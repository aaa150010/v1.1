var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
import { getCurrentInstance, shallowRef, reactive, watchEffect, isRef, onUnmounted, watch, ref, onMounted, nextTick, Comment, Fragment, openBlock, createBlock, createCommentVNode, isVNode, camelize as camelize$2, inject, computed, provide, defineComponent, onBeforeUnmount, createElementBlock, normalizeStyle, createElementVNode, normalizeClass, renderSlot, Transition, withCtx, withDirectives, createTextVNode, toDisplayString, vShow, onUpdated, mergeProps, withModifiers, resolveComponent, resolveDynamicComponent, createVNode, onActivated, onDeactivated, h, cloneVNode, Teleport, resolveDirective, withKeys, createSlots, renderList, toRef, normalizeProps, guardReactiveProps, toRefs, vModelCheckbox, vModelRadio, onBeforeUpdate, vModelText, toHandlers, onBeforeMount, unref, TransitionGroup, render as render$Z, pushScopeId, popScopeId } from "vue";
Object.freeze({});
Object.freeze([]);
const NOOP = () => {
};
const extend$2 = Object.assign;
const hasOwnProperty$c = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$c.call(val, key);
const isArray$9 = Array.isArray;
const isFunction$4 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isObject$b = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$b(val) && isFunction$4(val.then) && isFunction$4(val.catch);
};
const objectToString$2 = Object.prototype.toString;
const toTypeString = (value2) => objectToString$2.call(value2);
const toRawType = (value2) => {
  return toTypeString(value2).slice(8, -1);
};
const cacheStringFunction = (fn2) => {
  const cache = Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize$1 = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var eq_1 = eq$3;
var eq$2 = eq_1;
function assocIndexOf$4(array3, key) {
  var length = array3.length;
  while (length--) {
    if (eq$2(array3[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value2) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value2]);
  } else {
    data[index2][1] = value2;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries2) {
  var index2 = -1, length = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$6 = root$8.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value2) {
  var isOwn = hasOwnProperty$b.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString$1(value2) {
  return nativeObjectToString.call(value2);
}
var _objectToString = objectToString$1;
var Symbol$4 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$5(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
var _baseGetTag = baseGetTag$5;
function isObject$a(value2) {
  var type2 = typeof value2;
  return value2 != null && (type2 == "object" || type2 == "function");
}
var isObject_1 = isObject$a;
var baseGetTag$4 = _baseGetTag, isObject$9 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value2) {
  if (!isObject$9(value2)) {
    return false;
  }
  var tag = baseGetTag$4(value2);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$8 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$c = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value2) {
  if (!isObject$8(value2) || isMasked(value2)) {
    return false;
  }
  var pattern2 = isFunction$2(value2) ? reIsNative : reIsHostCtor;
  return pattern2.test(toSource$1(value2));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object3, key) {
  return object3 == null ? void 0 : object3[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object3, key) {
  var value2 = getValue(object3, key);
  return baseIsNative(value2) ? value2 : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$6 = _root;
var Map$4 = getNative$6(root$6, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value2) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED$1 : value2;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries2) {
  var index2 = -1, length = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value2) {
  var type2 = typeof value2;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value2) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value2);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries2) {
  var index2 = -1, length = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$1(key, value2) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value2]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key, value2);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries2) {
  var data = this.__data__ = new ListCache(entries2);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value2) {
  this.__data__.set(value2, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value2) {
  return this.__data__.has(value2);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$2(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
SetCache$2.prototype.has = setCacheHas;
var _SetCache = SetCache$2;
function arraySome$1(array3, predicate) {
  var index2 = -1, length = array3 == null ? 0 : array3.length;
  while (++index2 < length) {
    if (predicate(array3[index2], index2, array3)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$2(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(array3, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array3.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array3);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array3;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache$1() : void 0;
  stack.set(array3, other);
  stack.set(other, array3);
  while (++index2 < arrLength) {
    var arrValue = array3[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array3, stack) : customizer(arrValue, othValue, index2, array3, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array3);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$5 = _root;
var Uint8Array$3 = root$5.Uint8Array;
var _Uint8Array = Uint8Array$3;
function mapToArray$1(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value2, key) {
    result[++index2] = [key, value2];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$3(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value2) {
    result[++index2] = value2;
  });
  return result;
}
var _setToArray = setToArray$3;
var Symbol$3 = _Symbol, Uint8Array$2 = _Uint8Array, eq$1 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray;
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]";
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag$1(object3, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$4:
      if (object3.byteLength != other.byteLength || object3.byteOffset != other.byteOffset) {
        return false;
      }
      object3 = object3.buffer;
      other = other.buffer;
    case arrayBufferTag$3:
      if (object3.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object3), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag$3:
    case dateTag$3:
    case numberTag$3:
      return eq$1(+object3, +other);
    case errorTag$2:
      return object3.name == other.name && object3.message == other.message;
    case regexpTag$3:
    case stringTag$3:
      return object3 == other + "";
    case mapTag$5:
      var convert = mapToArray;
    case setTag$5:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray$2);
      if (object3.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object3);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object3, other);
      var result = equalArrays$1(convert(object3), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object3);
      return result;
    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object3) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$3(array3, values) {
  var index2 = -1, length = values.length, offset2 = array3.length;
  while (++index2 < length) {
    array3[offset2 + index2] = values[index2];
  }
  return array3;
}
var _arrayPush = arrayPush$3;
var isArray$8 = Array.isArray;
var isArray_1 = isArray$8;
var arrayPush$2 = _arrayPush, isArray$7 = isArray_1;
function baseGetAllKeys$2(object3, keysFunc, symbolsFunc) {
  var result = keysFunc(object3);
  return isArray$7(object3) ? result : arrayPush$2(result, symbolsFunc(object3));
}
var _baseGetAllKeys = baseGetAllKeys$2;
function arrayFilter$1(array3, predicate) {
  var index2 = -1, length = array3 == null ? 0 : array3.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value2 = array3[index2];
    if (predicate(value2, index2, array3)) {
      result[resIndex++] = value2;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$9 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object3) {
  if (object3 == null) {
    return [];
  }
  object3 = Object(object3);
  return arrayFilter(nativeGetSymbols$1(object3), function(symbol) {
    return propertyIsEnumerable$1.call(object3, symbol);
  });
};
var _getSymbols = getSymbols$3;
function baseTimes$1(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$8(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_1 = isObjectLike$8;
var baseGetTag$3 = _baseGetTag, isObjectLike$7 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value2) {
  return isObjectLike$7(value2) && baseGetTag$3(value2) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$6 = isObjectLike_1;
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike$6(value2) && hasOwnProperty$7.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
var isArguments_1 = isArguments$2;
var isBuffer$5 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer3 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer3;
})(isBuffer$5, isBuffer$5.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value2, length) {
  var type2 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$2 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$5 = isObjectLike_1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value2) {
  return isObjectLike$5(value2) && isLength$1(value2.length) && !!typedArrayTags[baseGetTag$2(value2)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value2) {
    return func(value2);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$6 = isArray_1, isBuffer$4 = isBuffer$5.exports, isIndex = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function arrayLikeKeys$2(value2, inherited) {
  var isArr = isArray$6(value2), isArg = !isArr && isArguments$1(value2), isBuff = !isArr && !isArg && isBuffer$4(value2), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty$6.call(value2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$6 = Object.prototype;
function isPrototype$3(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value2 === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseKeys$1(object3) {
  if (!isPrototype$2(object3)) {
    return nativeKeys(object3);
  }
  var result = [];
  for (var key in Object(object3)) {
    if (hasOwnProperty$5.call(object3, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$1 = isFunction_1, isLength = isLength_1;
function isArrayLike$3(value2) {
  return value2 != null && isLength(value2.length) && !isFunction$1(value2);
}
var isArrayLike_1 = isArrayLike$3;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$2 = isArrayLike_1;
function keys$3(object3) {
  return isArrayLike$2(object3) ? arrayLikeKeys$1(object3) : baseKeys(object3);
}
var keys_1 = keys$3;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols$2 = _getSymbols, keys$2 = keys_1;
function getAllKeys$2(object3) {
  return baseGetAllKeys$1(object3, keys$2, getSymbols$2);
}
var _getAllKeys = getAllKeys$2;
var getAllKeys$1 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function equalObjects$1(object3, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys$1(object3), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object3);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object3;
  }
  var result = true;
  stack.set(object3, other);
  stack.set(other, object3);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object3[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object3, stack) : customizer(objValue, othValue, key, object3, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object3.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object3 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object3);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$4 = _getNative, root$4 = _root;
var DataView$1 = getNative$4(root$4, "DataView");
var _DataView = DataView$1;
var getNative$3 = _getNative, root$3 = _root;
var Promise$2 = getNative$3(root$3, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$2 = _root;
var Set$3 = getNative$2(root$2, "Set");
var _Set = Set$3;
var getNative$1 = _getNative, root$1 = _root;
var WeakMap$2 = getNative$1(root$1, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$2 = _Set, WeakMap$1 = _WeakMap, baseGetTag$1 = _baseGetTag, toSource = _toSource;
var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag$4 = baseGetTag$1;
if (DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$4(new Map$1()) != mapTag$3 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$2 && getTag$4(new Set$2()) != setTag$3 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) {
  getTag$4 = function(value2) {
    var result = baseGetTag$1(value2), Ctor = result == objectTag$2 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$4;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$3 = _getTag, isArray$5 = isArray_1, isBuffer$3 = isBuffer$5.exports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseIsEqualDeep$1(object3, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$5(object3), othIsArr = isArray$5(other), objTag = objIsArr ? arrayTag$1 : getTag$3(object3), othTag = othIsArr ? arrayTag$1 : getTag$3(other);
  objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
  othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
  var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$3(object3)) {
    if (!isBuffer$3(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object3) ? equalArrays(object3, other, bitmask, customizer, equalFunc, stack) : equalByTag(object3, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object3, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object3.value() : object3, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object3, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$4 = isObjectLike_1;
function baseIsEqual$1(value2, other, bitmask, customizer, stack) {
  if (value2 === other) {
    return true;
  }
  if (value2 == null || other == null || !isObjectLike$4(value2) && !isObjectLike$4(other)) {
    return value2 !== value2 && other !== other;
  }
  return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual$1, stack);
}
var _baseIsEqual = baseIsEqual$1;
var isServer = typeof window === "undefined";
class ElementPlusError extends Error {
  constructor(m) {
    super(m);
    this.name = "ElementPlusError";
  }
}
var throwError = (scope, m) => {
  throw new ElementPlusError(`[${scope}] ${m}`);
};
function warn(scope, m) {
  console.warn(new ElementPlusError(`[${scope}] ${m}`));
}
function toObject(arr) {
  const res = {};
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2]) {
      extend$2(res, arr[i2]);
    }
  }
  return res;
}
const getValueByPath = (obj, paths = "") => {
  let ret = obj;
  paths.split(".").map((path) => {
    ret = ret === null || ret === void 0 ? void 0 : ret[path];
  });
  return ret;
};
function getPropByPath(obj, path, strict) {
  let tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, ".$1");
  path = path.replace(/^\./, "");
  const keyArr = path.split(".");
  let i2 = 0;
  for (i2; i2 < keyArr.length - 1; i2++) {
    if (!tempObj && !strict)
      break;
    const key = keyArr[i2];
    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error("please transfer a valid prop path to form item!");
      }
      break;
    }
  }
  return {
    o: tempObj,
    k: keyArr[i2],
    v: tempObj === null || tempObj === void 0 ? void 0 : tempObj[keyArr[i2]]
  };
}
const generateId = () => Math.floor(Math.random() * 1e4);
const escapeRegexpString = (value2 = "") => String(value2).replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
const coerceTruthyValueToArray = (arr) => {
  if (!arr && arr !== 0) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
};
const isIE = function() {
  return !isServer && !isNaN(Number(document.documentMode));
};
const isEdge = function() {
  return !isServer && navigator.userAgent.indexOf("Edge") > -1;
};
const isFirefox$1 = function() {
  return !isServer && !!window.navigator.userAgent.match(/firefox/i);
};
const autoprefixer = function(style) {
  const rules2 = ["transform", "transition", "animation"];
  const prefixes = ["ms-", "webkit-"];
  rules2.forEach((rule) => {
    const value2 = style[rule];
    if (rule && value2) {
      prefixes.forEach((prefix) => {
        style[prefix + rule] = value2;
      });
    }
  });
  return style;
};
const isBool = (val) => typeof val === "boolean";
const isNumber$1 = (val) => typeof val === "number";
const isHTMLElement$1 = (val) => toRawType(val).startsWith("HTML");
function rafThrottle(fn2) {
  let locked = false;
  return function(...args) {
    if (locked)
      return;
    locked = true;
    window.requestAnimationFrame(() => {
      fn2.apply(this, args);
      locked = false;
    });
  };
}
const clearTimer = (timer) => {
  clearTimeout(timer.value);
  timer.value = null;
};
function entries(obj) {
  return Object.keys(obj).map((key) => [key, obj[key]]);
}
function isUndefined$1(val) {
  return val === void 0;
}
function useGlobalConfig() {
  const vm = getCurrentInstance();
  if ("$ELEMENT" in vm.proxy) {
    return vm.proxy.$ELEMENT;
  }
  return {};
}
const arrayFindIndex = function(arr, pred) {
  return arr.findIndex(pred);
};
const arrayFind = function(arr, pred) {
  return arr.find(pred);
};
function isEmpty$1(val) {
  if (!val && val !== 0 || isArray$9(val) && !val.length || isObject$b(val) && !Object.keys(val).length)
    return true;
  return false;
}
function arrayFlat(arr) {
  return arr.reduce((acm, item) => {
    const val = Array.isArray(item) ? arrayFlat(item) : item;
    return acm.concat(val);
  }, []);
}
function deduplicate(arr) {
  return Array.from(new Set(arr));
}
function $(ref2) {
  return ref2.value;
}
function addUnit(value2) {
  if (isString$1(value2)) {
    return value2;
  } else if (isNumber$1(value2)) {
    return value2 + "px";
  }
  return "";
}
const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
const LISTENER_PREFIX = /^on[A-Z]/;
var useAttrs = (params = {}) => {
  const { excludeListeners = false, excludeKeys = [] } = params;
  const instance = getCurrentInstance();
  const attrs = shallowRef({});
  const allExcludeKeys = excludeKeys.concat(DEFAULT_EXCLUDE_KEYS);
  instance.attrs = reactive(instance.attrs);
  watchEffect(() => {
    const res = entries(instance.attrs).reduce((acm, [key, val]) => {
      if (!allExcludeKeys.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))) {
        acm[key] = val;
      }
      return acm;
    }, {});
    attrs.value = res;
  });
  return attrs;
};
const trim$1 = function(s) {
  return (s || "").replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, "");
};
const on$2 = function(element, event2, handler, useCapture = false) {
  if (element && event2 && handler) {
    element.addEventListener(event2, handler, useCapture);
  }
};
const off$2 = function(element, event2, handler, useCapture = false) {
  if (element && event2 && handler) {
    element.removeEventListener(event2, handler, useCapture);
  }
};
const once = function(el, event2, fn2) {
  const listener = function(...args) {
    if (fn2) {
      fn2.apply(this, args);
    }
    off$2(el, event2, listener);
  };
  on$2(el, event2, listener);
};
function hasClass(el, cls) {
  if (!el || !cls)
    return false;
  if (cls.indexOf(" ") !== -1)
    throw new Error("className should not contain space.");
  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (" " + el.className + " ").indexOf(" " + cls + " ") > -1;
  }
}
function addClass$1(el, cls) {
  if (!el)
    return;
  let curClass = el.className;
  const classes = (cls || "").split(" ");
  for (let i2 = 0, j = classes.length; i2 < j; i2++) {
    const clsName = classes[i2];
    if (!clsName)
      continue;
    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += " " + clsName;
    }
  }
  if (!el.classList) {
    el.className = curClass;
  }
}
function removeClass(el, cls) {
  if (!el || !cls)
    return;
  const classes = cls.split(" ");
  let curClass = " " + el.className + " ";
  for (let i2 = 0, j = classes.length; i2 < j; i2++) {
    const clsName = classes[i2];
    if (!clsName)
      continue;
    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(" " + clsName + " ", " ");
    }
  }
  if (!el.classList) {
    el.className = trim$1(curClass);
  }
}
const getStyle = function(element, styleName) {
  if (isServer)
    return;
  if (!element || !styleName)
    return null;
  styleName = camelize$1(styleName);
  if (styleName === "float") {
    styleName = "cssFloat";
  }
  try {
    const style = element.style[styleName];
    if (style)
      return style;
    const computed2 = document.defaultView.getComputedStyle(element, "");
    return computed2 ? computed2[styleName] : "";
  } catch (e) {
    return element.style[styleName];
  }
};
const isScroll = (el, isVertical) => {
  if (isServer)
    return;
  const determinedDirection = isVertical === null || isVertical === void 0;
  const overflow = determinedDirection ? getStyle(el, "overflow") : isVertical ? getStyle(el, "overflow-y") : getStyle(el, "overflow-x");
  return overflow.match(/(scroll|auto|overlay)/);
};
const getScrollContainer = (el, isVertical) => {
  if (isServer)
    return;
  let parent2 = el;
  while (parent2) {
    if ([window, document, document.documentElement].includes(parent2)) {
      return window;
    }
    if (isScroll(parent2, isVertical)) {
      return parent2;
    }
    parent2 = parent2.parentNode;
  }
  return parent2;
};
const isInContainer = (el, container) => {
  if (isServer || !el || !container)
    return false;
  const elRect = el.getBoundingClientRect();
  let containerRect;
  if ([window, document, document.documentElement, null, void 0].includes(container)) {
    containerRect = {
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      left: 0
    };
  } else {
    containerRect = container.getBoundingClientRect();
  }
  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
};
const getOffsetTop = (el) => {
  let offset2 = 0;
  let parent2 = el;
  while (parent2) {
    offset2 += parent2.offsetTop;
    parent2 = parent2.offsetParent;
  }
  return offset2;
};
const getOffsetTopDistance = (el, containerEl) => {
  return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl));
};
const stop = (e) => e.stopPropagation();
let scrollBarWidth;
function scrollbarWidth() {
  if (isServer)
    return 0;
  if (scrollBarWidth !== void 0)
    return scrollBarWidth;
  const outer = document.createElement("div");
  outer.className = "el-scrollbar__wrap";
  outer.style.visibility = "hidden";
  outer.style.width = "100px";
  outer.style.position = "absolute";
  outer.style.top = "-9999px";
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = "scroll";
  const inner = document.createElement("div");
  inner.style.width = "100%";
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
}
var useLockScreen = (trigger) => {
  if (!isRef(trigger)) {
    throwError("[useLockScreen]", "You need to pass a ref param to this function");
  }
  let scrollBarWidth2 = 0;
  let withoutHiddenClass = false;
  let bodyPaddingRight = "0";
  let computedBodyPaddingRight = 0;
  onUnmounted(() => {
    cleanup();
  });
  const cleanup = () => {
    removeClass(document.body, "el-popup-parent--hidden");
    if (withoutHiddenClass) {
      document.body.style.paddingRight = bodyPaddingRight;
    }
  };
  watch(trigger, (val) => {
    if (val) {
      withoutHiddenClass = !hasClass(document.body, "el-popup-parent--hidden");
      if (withoutHiddenClass) {
        bodyPaddingRight = document.body.style.paddingRight;
        computedBodyPaddingRight = parseInt(getStyle(document.body, "paddingRight"), 10);
      }
      scrollBarWidth2 = scrollbarWidth();
      const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
      const bodyOverflowY = getStyle(document.body, "overflowY");
      if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
        document.body.style.paddingRight = computedBodyPaddingRight + scrollBarWidth2 + "px";
      }
      addClass$1(document.body, "el-popup-parent--hidden");
    } else {
      cleanup();
    }
  });
};
var useRestoreActive = (toggle, initialFocus) => {
  let previousActive;
  watch(() => toggle.value, (val) => {
    var _a, _b;
    if (val) {
      previousActive = document.activeElement;
      if (isRef(initialFocus)) {
        (_b = (_a = initialFocus.value).focus) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    } else {
      {
        previousActive.focus();
      }
    }
  });
};
const EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace"
};
const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
const isVisible = (element) => {
  const computed2 = getComputedStyle(element);
  return computed2.position === "fixed" ? false : element.offsetParent !== null;
};
const obtainAllFocusableElements = (element) => {
  return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter(isFocusable).filter(isVisible);
};
const isFocusable = (element) => {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (element.disabled) {
    return false;
  }
  switch (element.nodeName) {
    case "A": {
      return !!element.href && element.rel !== "ignore";
    }
    case "INPUT": {
      return !(element.type === "hidden" || element.type === "file");
    }
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA": {
      return true;
    }
    default: {
      return false;
    }
  }
};
const triggerEvent = function(elm, name2, ...opts) {
  let eventName;
  if (name2.includes("mouse") || name2.includes("click")) {
    eventName = "MouseEvents";
  } else if (name2.includes("key")) {
    eventName = "KeyboardEvent";
  } else {
    eventName = "HTMLEvents";
  }
  const evt = document.createEvent(eventName);
  evt.initEvent(name2, ...opts);
  elm.dispatchEvent(evt);
  return elm;
};
const modalStack = [];
const closeModal = (e) => {
  if (modalStack.length === 0)
    return;
  if (e.code === EVENT_CODE.esc) {
    e.stopPropagation();
    const topModal = modalStack[modalStack.length - 1];
    topModal.handleClose();
  }
};
var useModal = (instance, visibleRef) => {
  watch(() => visibleRef.value, (val) => {
    if (val) {
      modalStack.push(instance);
    } else {
      modalStack.splice(modalStack.findIndex((modal) => modal === instance), 1);
    }
  });
};
if (!isServer) {
  on$2(document, "keydown", closeModal);
}
var useFocus = (el) => {
  return {
    focus: () => {
      var _a, _b;
      (_b = (_a = el.value) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
  };
};
function useThrottleRender(loading, throttle2 = 0) {
  if (throttle2 === 0)
    return loading;
  const throttled = ref(false);
  let timeoutHandle = 0;
  const dispatchThrottling = () => {
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
    }
    timeoutHandle = window.setTimeout(() => {
      throttled.value = loading.value;
    }, throttle2);
  };
  onMounted(dispatchThrottling);
  watch(() => loading.value, (val) => {
    if (val) {
      dispatchThrottling();
    } else {
      throttled.value = val;
    }
  });
  return throttled;
}
var usePreventGlobal = (indicator, evt, cb) => {
  const prevent = (e) => {
    if (cb(e)) {
      e.stopImmediatePropagation();
    }
  };
  watch(() => indicator.value, (val) => {
    if (val) {
      on$2(document, evt, prevent, true);
    } else {
      off$2(document, evt, prevent, true);
    }
  }, { immediate: true });
};
const UPDATE_MODEL_EVENT = "update:modelValue";
const CHANGE_EVENT = "change";
const INPUT_EVENT = "input";
const VALIDATE_STATE_MAP = {
  validating: "el-icon-loading",
  success: "el-icon-circle-check",
  error: "el-icon-circle-close"
};
var top$1 = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top$1, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style = state.styles[name2] || {};
    var attributes2 = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes2).forEach(function(name3) {
      var value2 = attributes2[name3];
      if (value2 === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value2 === true ? "" : value2);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes2 = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes2).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height
  };
}
function contains$1(parent2, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent2.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent2.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox2 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE2 = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE2 && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox2 && css.willChange === "filter" || isFirefox2 && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
var max$1 = Math.max;
var min$1 = Math.min;
var round = Math.round;
function within(min2, value2, max2) {
  return max$1(min2, min$1(value2, max2));
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value2, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value2;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name2 = _ref.name, options2 = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top$1 : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains$1(state.elements.popper, arrowElement)) {
    {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(round(x * dpr) / dpr) || 0,
    y: round(round(y * dpr) / dpr) || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y = _ref3$y === void 0 ? 0 : _ref3$y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top$1;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top$1) {
      sideY = bottom;
      y -= offsetParent[heightProp] - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left) {
      sideX = right;
      x -= offsetParent[widthProp] - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref4) {
  var state = _ref4.state, options2 = _ref4.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  {
    var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
  var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function getVariation(placement) {
  return placement.split("-")[1];
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top$1:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top$1, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
    {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options2 = _ref.options, name2 = _ref.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top$1, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top$1;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top$1, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name2 = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top$1].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options2 = _ref2.options, name2 = _ref2.name;
  var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name2] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options2 = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis || checkAltAxis) {
    var mainSide = mainAxis === "y" ? top$1 : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = popperOffsets2[mainAxis] + overflow[mainSide];
    var max2 = popperOffsets2[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
    if (checkMainAxis) {
      var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _mainSide = mainAxis === "x" ? top$1 : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var _preventedOffset = within(tether ? min$1(_min, tetherMin) : _min, _offset, tether ? max$1(_max, tetherMax) : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
  }
  state.modifiersData[name2] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function format$1(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    Object.keys(modifier).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format$1(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (typeof modifier.effect !== "function") {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (!Array.isArray(modifier.requires)) {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format$1(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
function uniqueBy(arr, fn2) {
  var identifiers = new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(options3) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options3);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name2 = _ref.name;
            return name2;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name2 = _ref2.name;
              return name2 === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle$1(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      update: debounce$2(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options2).then(function(state2) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name2 = _ref3.name, _ref3$options = _ref3.options, options3 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name2,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const nodeList = new Map();
let startClick;
if (!isServer) {
  on$2(document, "mousedown", (e) => startClick = e);
  on$2(document, "mouseup", (e) => {
    for (const handlers of nodeList.values()) {
      for (const { documentHandler } of handlers) {
        documentHandler(e, startClick);
      }
    }
  });
}
function createDocumentHandler(el, binding) {
  let excludes = [];
  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else if (binding.arg instanceof HTMLElement) {
    excludes.push(binding.arg);
  }
  return function(mouseup, mousedown) {
    const popperRef = binding.instance.popperRef;
    const mouseUpTarget = mouseup.target;
    const mouseDownTarget = mousedown === null || mousedown === void 0 ? void 0 : mousedown.target;
    const isBound = !binding || !binding.instance;
    const isTargetExists = !mouseUpTarget || !mouseDownTarget;
    const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
    const isSelf = el === mouseUpTarget;
    const isTargetExcluded = excludes.length && excludes.some((item) => item === null || item === void 0 ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
    const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }
    binding.value(mouseup, mousedown);
  };
}
const ClickOutside = {
  beforeMount(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    nodeList.get(el).push({
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },
  updated(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    const handlers = nodeList.get(el);
    const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
    const newHandler = {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    };
    if (oldHandlerIndex >= 0) {
      handlers.splice(oldHandlerIndex, 1, newHandler);
    } else {
      handlers.push(newHandler);
    }
  },
  unmounted(el) {
    nodeList.delete(el);
  }
};
var ClickOutside$1 = ClickOutside;
var RepeatClick = {
  beforeMount(el, binding) {
    let interval = null;
    let startTime;
    const handler = () => binding.value && binding.value();
    const clear = () => {
      if (Date.now() - startTime < 100) {
        handler();
      }
      clearInterval(interval);
      interval = null;
    };
    on$2(el, "mousedown", (e) => {
      if (e.button !== 0)
        return;
      startTime = Date.now();
      once(document, "mouseup", clear);
      clearInterval(interval);
      interval = setInterval(handler, 100);
    });
  }
};
const FOCUSABLE_CHILDREN = "_trap-focus-children";
const FOCUS_STACK = [];
const FOCUS_HANDLER = (e) => {
  if (FOCUS_STACK.length === 0)
    return;
  const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
  if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
    if (focusableElement.length === 1) {
      e.preventDefault();
      if (document.activeElement !== focusableElement[0]) {
        focusableElement[0].focus();
      }
      return;
    }
    const goingBackward = e.shiftKey;
    const isFirst = e.target === focusableElement[0];
    const isLast = e.target === focusableElement[focusableElement.length - 1];
    if (isFirst && goingBackward) {
      e.preventDefault();
      focusableElement[focusableElement.length - 1].focus();
    }
    if (isLast && !goingBackward) {
      e.preventDefault();
      focusableElement[0].focus();
    }
  }
};
const TrapFocus = {
  beforeMount(el) {
    el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el);
    FOCUS_STACK.push(el);
    if (FOCUS_STACK.length <= 1) {
      on$2(document, "keydown", FOCUS_HANDLER);
    }
  },
  updated(el) {
    nextTick(() => {
      el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el);
    });
  },
  unmounted() {
    FOCUS_STACK.shift();
    if (FOCUS_STACK.length === 0) {
      off$2(document, "keydown", FOCUS_HANDLER);
    }
  }
};
var TrapFocus$1 = TrapFocus;
var _populated = false;
var _ie, _firefox, _opera, _webkit, _chrome;
var _ie_real_version;
var _osx, _windows, _linux, _android;
var _win64;
var _iphone, _ipad, _native;
var _mobile;
function _populate() {
  if (_populated) {
    return;
  }
  _populated = true;
  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);
  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas);
  _win64 = !!/Win64/.exec(uas);
  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : agent[5] ? parseFloat(agent[5]) : NaN;
    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    }
    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;
    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit = agent[4] ? parseFloat(agent[4]) : NaN;
    if (_webkit) {
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }
  if (os) {
    if (os[1]) {
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);
      _osx = ver ? parseFloat(ver[1].replace("_", ".")) : true;
    } else {
      _osx = false;
    }
    _windows = !!os[2];
    _linux = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}
var UserAgent_DEPRECATED$1 = {
  ie: function() {
    return _populate() || _ie;
  },
  ieCompatibilityMode: function() {
    return _populate() || _ie_real_version > _ie;
  },
  ie64: function() {
    return UserAgent_DEPRECATED$1.ie() && _win64;
  },
  firefox: function() {
    return _populate() || _firefox;
  },
  opera: function() {
    return _populate() || _opera;
  },
  webkit: function() {
    return _populate() || _webkit;
  },
  safari: function() {
    return UserAgent_DEPRECATED$1.webkit();
  },
  chrome: function() {
    return _populate() || _chrome;
  },
  windows: function() {
    return _populate() || _windows;
  },
  osx: function() {
    return _populate() || _osx;
  },
  linux: function() {
    return _populate() || _linux;
  },
  iphone: function() {
    return _populate() || _iphone;
  },
  mobile: function() {
    return _populate() || (_iphone || _ipad || _android || _mobile);
  },
  nativeApp: function() {
    return _populate() || _native;
  },
  android: function() {
    return _populate() || _android;
  },
  ipad: function() {
    return _populate() || _ipad;
  }
};
var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED$1;
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var ExecutionEnvironment$1 = {
  canUseDOM,
  canUseWorkers: typeof Worker !== "undefined",
  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
  canUseViewport: canUseDOM && !!window.screen,
  isInWorker: !canUseDOM
};
var ExecutionEnvironment_1 = ExecutionEnvironment$1;
var ExecutionEnvironment = ExecutionEnvironment_1;
var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true;
}
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported$1(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !("addEventListener" in document)) {
    return false;
  }
  var eventName = "on" + eventNameSuffix;
  var isSupported = eventName in document;
  if (!isSupported) {
    var element = document.createElement("div");
    element.setAttribute(eventName, "return;");
    isSupported = typeof element[eventName] === "function";
  }
  if (!isSupported && useHasFeature && eventNameSuffix === "wheel") {
    isSupported = document.implementation.hasFeature("Events.wheel", "3.0");
  }
  return isSupported;
}
var isEventSupported_1 = isEventSupported$1;
var UserAgent_DEPRECATED = UserAgent_DEPRECATED_1;
var isEventSupported = isEventSupported_1;
var PIXEL_STEP = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function normalizeWheel$1(event2) {
  var sX = 0, sY = 0, pX = 0, pY = 0;
  if ("detail" in event2) {
    sY = event2.detail;
  }
  if ("wheelDelta" in event2) {
    sY = -event2.wheelDelta / 120;
  }
  if ("wheelDeltaY" in event2) {
    sY = -event2.wheelDeltaY / 120;
  }
  if ("wheelDeltaX" in event2) {
    sX = -event2.wheelDeltaX / 120;
  }
  if ("axis" in event2 && event2.axis === event2.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ("deltaY" in event2) {
    pY = event2.deltaY;
  }
  if ("deltaX" in event2) {
    pX = event2.deltaX;
  }
  if ((pX || pY) && event2.deltaMode) {
    if (event2.deltaMode == 1) {
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY
  };
}
normalizeWheel$1.getEventType = function() {
  return UserAgent_DEPRECATED.firefox() ? "DOMMouseScroll" : isEventSupported("wheel") ? "wheel" : "mousewheel";
};
var normalizeWheel_1 = normalizeWheel$1;
var normalizeWheel = normalizeWheel_1;
const isFirefox = typeof navigator !== "undefined" && navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
const mousewheel = function(element, callback) {
  if (element && element.addEventListener) {
    const fn2 = function(event2) {
      const normalized = normalizeWheel(event2);
      callback && callback.apply(this, [event2, normalized]);
    };
    if (isFirefox) {
      element.addEventListener("DOMMouseScroll", fn2);
    } else {
      element.onmousewheel = fn2;
    }
  }
};
const Mousewheel = {
  beforeMount(el, binding) {
    mousewheel(el, binding.value);
  }
};
var Mousewheel$1 = Mousewheel;
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key) {
      var index2 = getIndex(this.__entries__, key);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key, value2) {
      var index2 = getIndex(this.__entries__, key);
      if (~index2) {
        this.__entries__[index2][1] = value2;
      } else {
        this.__entries__.push([key, value2]);
      }
    };
    class_1.prototype.delete = function(key) {
      var entries2 = this.__entries__;
      var index2 = getIndex(entries2, key);
      if (~index2) {
        entries2.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx2) {
      if (ctx2 === void 0) {
        ctx2 = null;
      }
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx2, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle$2(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy2();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy2() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy2;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle$2(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
    var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props2) {
  for (var _i = 0, _a = Object.keys(props2); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props2[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value2) {
  return parseFloat(value2) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value2 = styles["border-" + position + "-width"];
    return size + toFloat(value2);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value2 = styles["padding-" + position];
    paddings[position] = toFloat(value2);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width2 = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width2 + horizPad) !== clientWidth) {
      width2 -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width2 + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width2 -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width2, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width2 = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width: width2,
    height,
    top: y,
    right: x + width2,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width2, height) {
  return { x, y, width: width2, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx2 = this.callbackCtx_;
    var entries2 = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx2, entries2, ctx2);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? new WeakMap() : new MapShim();
var ResizeObserver = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method3) {
  ResizeObserver.prototype[method3] = function() {
    var _a;
    return (_a = observers.get(this))[method3].apply(_a, arguments);
  };
});
var index$3 = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
const resizeHandler = function(entries2) {
  for (const entry of entries2) {
    const listeners = entry.target.__resizeListeners__ || [];
    if (listeners.length) {
      listeners.forEach((fn2) => {
        fn2();
      });
    }
  }
};
const addResizeListener = function(element, fn2) {
  if (isServer || !element)
    return;
  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new index$3(resizeHandler);
    element.__ro__.observe(element);
  }
  element.__resizeListeners__.push(fn2);
};
const removeResizeListener = function(element, fn2) {
  if (!element || !element.__resizeListeners__)
    return;
  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn2), 1);
  if (!element.__resizeListeners__.length) {
    element.__ro__.disconnect();
  }
};
const Resize = {
  beforeMount(el, binding) {
    el._handleResize = () => {
      var _a;
      el && ((_a = binding.value) === null || _a === void 0 ? void 0 : _a.call(binding));
    };
    addResizeListener(el, el._handleResize);
  },
  beforeUnmount(el) {
    removeResizeListener(el, el._handleResize);
  }
};
var Resize$1 = Resize;
const TEMPLATE = "template";
const SCOPE$3 = "VNode";
var PatchFlags;
(function(PatchFlags2) {
  PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
  PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
  PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
  PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
  PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
  PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
  PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
  PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
  PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
  PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
  PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
})(PatchFlags || (PatchFlags = {}));
const isFragment = (node) => node.type === Fragment;
const isComment = (node) => node.type === Comment;
const isTemplate = (node) => node.type === TEMPLATE;
function getChildren(node, depth) {
  if (isComment(node))
    return;
  if (isFragment(node) || isTemplate(node)) {
    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : void 0;
  }
  return node;
}
const isValidElementNode = (node) => !(isFragment(node) || isComment(node));
const getFirstValidNode = (nodes, maxDepth = 3) => {
  if (Array.isArray(nodes)) {
    return getChildren(nodes[0], maxDepth);
  } else {
    return getChildren(nodes, maxDepth);
  }
};
function renderIf(condition, node, props2, children, patchFlag, patchProps) {
  return condition ? renderBlock(node, props2, children, patchFlag, patchProps) : createCommentVNode("v-if", true);
}
function renderBlock(node, props2, children, patchFlag, patchProps) {
  return openBlock(), createBlock(node, props2, children, patchFlag, patchProps);
}
const getNormalizedProps = (node) => {
  if (!isVNode(node)) {
    warn(SCOPE$3, "value must be a VNode");
    return;
  }
  const raw = node.props || {};
  const type2 = node.type.props || {};
  const props2 = {};
  Object.keys(type2).forEach((key) => {
    if (hasOwn(type2[key], "default")) {
      props2[key] = type2[key].default;
    }
  });
  Object.keys(raw).forEach((key) => {
    props2[camelize$2(key)] = raw[key];
  });
  return props2;
};
let $ELEMENT = {};
const setConfig$1 = (option2) => {
  $ELEMENT = option2;
};
const getConfig = (key) => {
  return $ELEMENT[key];
};
const onTouchMove = (e) => {
  e.preventDefault();
  e.stopPropagation();
};
const onModalClick = () => {
  PopupManager === null || PopupManager === void 0 ? void 0 : PopupManager.doOnModalClick();
};
let hasModal = false;
let zIndex;
const getModal = function() {
  if (isServer)
    return;
  let modalDom = PopupManager.modalDom;
  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement("div");
    PopupManager.modalDom = modalDom;
    on$2(modalDom, "touchmove", onTouchMove);
    on$2(modalDom, "click", onModalClick);
  }
  return modalDom;
};
const instances$1 = {};
const PopupManager = {
  modalFade: true,
  modalDom: void 0,
  zIndex,
  getInstance: function(id2) {
    return instances$1[id2];
  },
  register: function(id2, instance) {
    if (id2 && instance) {
      instances$1[id2] = instance;
    }
  },
  deregister: function(id2) {
    if (id2) {
      instances$1[id2] = null;
      delete instances$1[id2];
    }
  },
  nextZIndex: function() {
    return ++PopupManager.zIndex;
  },
  modalStack: [],
  doOnModalClick: function() {
    const topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topItem)
      return;
    const instance = PopupManager.getInstance(topItem.id);
    if (instance && instance.closeOnClickModal.value) {
      instance.close();
    }
  },
  openModal: function(id2, zIndex2, dom, modalClass, modalFade) {
    if (isServer)
      return;
    if (!id2 || zIndex2 === void 0)
      return;
    this.modalFade = modalFade;
    const modalStack2 = this.modalStack;
    for (let i2 = 0, j = modalStack2.length; i2 < j; i2++) {
      const item = modalStack2[i2];
      if (item.id === id2) {
        return;
      }
    }
    const modalDom = getModal();
    addClass$1(modalDom, "v-modal");
    if (this.modalFade && !hasModal) {
      addClass$1(modalDom, "v-modal-enter");
    }
    if (modalClass) {
      const classArr = modalClass.trim().split(/\s+/);
      classArr.forEach((item) => addClass$1(modalDom, item));
    }
    setTimeout(() => {
      removeClass(modalDom, "v-modal-enter");
    }, 200);
    if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
      dom.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }
    if (zIndex2) {
      modalDom.style.zIndex = String(zIndex2);
    }
    modalDom.tabIndex = 0;
    modalDom.style.display = "";
    this.modalStack.push({ id: id2, zIndex: zIndex2, modalClass });
  },
  closeModal: function(id2) {
    const modalStack2 = this.modalStack;
    const modalDom = getModal();
    if (modalStack2.length > 0) {
      const topItem = modalStack2[modalStack2.length - 1];
      if (topItem.id === id2) {
        if (topItem.modalClass) {
          const classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach((item) => removeClass(modalDom, item));
        }
        modalStack2.pop();
        if (modalStack2.length > 0) {
          modalDom.style.zIndex = modalStack2[modalStack2.length - 1].zIndex;
        }
      } else {
        for (let i2 = modalStack2.length - 1; i2 >= 0; i2--) {
          if (modalStack2[i2].id === id2) {
            modalStack2.splice(i2, 1);
            break;
          }
        }
      }
    }
    if (modalStack2.length === 0) {
      if (this.modalFade) {
        addClass$1(modalDom, "v-modal-leave");
      }
      setTimeout(() => {
        if (modalStack2.length === 0) {
          if (modalDom.parentNode)
            modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = "none";
          PopupManager.modalDom = void 0;
        }
        removeClass(modalDom, "v-modal-leave");
      }, 200);
    }
  }
};
Object.defineProperty(PopupManager, "zIndex", {
  configurable: true,
  get() {
    if (zIndex === void 0) {
      zIndex = getConfig("zIndex") || 2e3;
    }
    return zIndex;
  },
  set(value2) {
    zIndex = value2;
  }
});
const getTopPopup = function() {
  if (isServer)
    return;
  if (PopupManager.modalStack.length > 0) {
    const topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup)
      return;
    const instance = PopupManager.getInstance(topPopup.id);
    return instance;
  }
};
if (!isServer) {
  on$2(window, "keydown", function(event2) {
    if (event2.code === EVENT_CODE.esc) {
      const topPopup = getTopPopup();
      if (topPopup && topPopup.closeOnPressEscape.value) {
        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction("cancel") : topPopup.close();
      }
    }
  });
}
var PopupManager$1 = PopupManager;
var English = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear"
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const useLocaleProps = {
  locale: {
    type: Object
  }
};
const LocaleInjectionKey = "ElLocaleInjection";
let localeObjCache;
function translate(path, option2, current) {
  const paths = path.split(".");
  let value2;
  for (let i2 = 0, j = paths.length; i2 < j; i2++) {
    const property = paths[i2];
    value2 = current[property];
    if (i2 === j - 1)
      return template(value2, option2);
    if (!value2)
      return "";
    current = value2;
  }
}
const useLocale = () => {
  const vm = getCurrentInstance();
  const props2 = vm.props;
  const locale = computed(() => props2.locale || English);
  const lang = computed(() => locale.value.name);
  const _translator = (...args) => {
    const [path, option2] = args;
    return translate(path, option2, locale.value);
  };
  const t = (...args) => {
    return _translator(...args);
  };
  const provides = {
    locale,
    lang,
    t
  };
  localeObjCache = provides;
  provide(LocaleInjectionKey, provides);
};
function template(str, option2) {
  if (!str || !option2)
    return str;
  return str.replace(/\{(\w+)\}/g, (_, key) => {
    return option2[key];
  });
}
const localeProviderMaker = (locale = English) => {
  const lang = ref(locale.name);
  const localeRef = ref(locale);
  return {
    lang,
    locale: localeRef,
    t: (...args) => {
      const [path, option2] = args;
      return translate(path, option2, localeRef.value);
    }
  };
};
const useLocaleInject = () => {
  return inject(LocaleInjectionKey, localeObjCache || {
    lang: ref(English.name),
    locale: ref(English),
    t: (...args) => {
      const [path, option2] = args;
      return translate(path, option2, English);
    }
  });
};
const version$1 = "1.1.0-beta.7";
const makeInstaller = (components2 = []) => {
  const apps = [];
  const install2 = (app, opts) => {
    const defaultInstallOpt2 = {
      size: "",
      zIndex: 2e3
    };
    const option2 = Object.assign(defaultInstallOpt2, opts);
    if (apps.includes(app))
      return;
    apps.push(app);
    components2.forEach((c) => {
      app.use(c);
    });
    if (option2.locale) {
      const localeProvides = localeProviderMaker(opts.locale);
      app.provide(LocaleInjectionKey, localeProvides);
    }
    app.config.globalProperties.$ELEMENT = option2;
    setConfig$1(option2);
  };
  return {
    version: version$1,
    install: install2
  };
};
var makeInstaller$1 = makeInstaller;
var script$$ = defineComponent({
  name: "ElAffix",
  props: {
    zIndex: {
      type: Number,
      default: 100
    },
    target: {
      type: String,
      default: ""
    },
    offset: {
      type: Number,
      default: 0
    },
    position: {
      type: String,
      default: "top"
    }
  },
  emits: ["scroll", "change"],
  setup(props2, { emit: emit2 }) {
    const target = ref(null);
    const root2 = ref(null);
    const scrollContainer = ref(null);
    const state = reactive({
      fixed: false,
      height: 0,
      width: 0,
      scrollTop: 0,
      clientHeight: 0,
      transform: 0
    });
    const rootStyle = computed(() => {
      return {
        height: state.fixed ? `${state.height}px` : "",
        width: state.fixed ? `${state.width}px` : ""
      };
    });
    const affixStyle = computed(() => {
      if (!state.fixed) {
        return;
      }
      const offset2 = props2.offset ? `${props2.offset}px` : 0;
      const transform = state.transform ? `translateY(${state.transform}px)` : "";
      return {
        height: `${state.height}px`,
        width: `${state.width}px`,
        top: props2.position === "top" ? offset2 : "",
        bottom: props2.position === "bottom" ? offset2 : "",
        transform,
        zIndex: props2.zIndex
      };
    });
    const update = () => {
      const rootRect = root2.value.getBoundingClientRect();
      const targetRect = target.value.getBoundingClientRect();
      state.height = rootRect.height;
      state.width = rootRect.width;
      state.scrollTop = scrollContainer.value === window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop;
      state.clientHeight = document.documentElement.clientHeight;
      if (props2.position === "top") {
        if (props2.target) {
          const difference = targetRect.bottom - props2.offset - state.height;
          state.fixed = props2.offset > rootRect.top && targetRect.bottom > 0;
          state.transform = difference < 0 ? difference : 0;
        } else {
          state.fixed = props2.offset > rootRect.top;
        }
      } else {
        if (props2.target) {
          const difference = state.clientHeight - targetRect.top - props2.offset - state.height;
          state.fixed = state.clientHeight - props2.offset < rootRect.bottom && state.clientHeight > targetRect.top;
          state.transform = difference < 0 ? -difference : 0;
        } else {
          state.fixed = state.clientHeight - props2.offset < rootRect.bottom;
        }
      }
    };
    const onScroll = () => {
      update();
      emit2("scroll", {
        scrollTop: state.scrollTop,
        fixed: state.fixed
      });
    };
    watch(() => state.fixed, () => {
      emit2("change", state.fixed);
    });
    onMounted(() => {
      if (props2.target) {
        target.value = document.querySelector(props2.target);
        if (!target.value) {
          throw new Error(`target is not existed: ${props2.target}`);
        }
      } else {
        target.value = document.documentElement;
      }
      scrollContainer.value = getScrollContainer(root2.value);
      on$2(scrollContainer.value, "scroll", onScroll);
      addResizeListener(root2.value, update);
    });
    onBeforeUnmount(() => {
      off$2(scrollContainer.value, "scroll", onScroll);
      removeResizeListener(root2.value, update);
    });
    return {
      root: root2,
      state,
      rootStyle,
      affixStyle,
      update
    };
  }
});
function render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "root",
    class: "el-affix",
    style: normalizeStyle(_ctx.rootStyle)
  }, [
    createElementVNode("div", {
      class: normalizeClass({ "el-affix--fixed": _ctx.state.fixed }),
      style: normalizeStyle(_ctx.affixStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6)
  ], 4);
}
script$$.render = render$Y;
script$$.__file = "packages/components/affix/src/workprogress.vue";
script$$.install = (app) => {
  app.component(script$$.name, script$$);
};
const _Affix = script$$;
const ElAffix = _Affix;
const TYPE_CLASSES_MAP = {
  "success": "el-icon-success",
  "warning": "el-icon-warning",
  "error": "el-icon-error"
};
var script$_ = defineComponent({
  name: "ElAlert",
  props: {
    title: {
      type: String,
      default: ""
    },
    description: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "info"
    },
    closable: {
      type: Boolean,
      default: true
    },
    closeText: {
      type: String,
      default: ""
    },
    showIcon: Boolean,
    center: Boolean,
    effect: {
      type: String,
      default: "light",
      validator: (value2) => ["light", "dark"].indexOf(value2) > -1
    }
  },
  emits: ["close"],
  setup(props2, ctx2) {
    const visible2 = ref(true);
    const typeClass = computed(() => `el-alert--${props2.type}`);
    const iconClass = computed(() => TYPE_CLASSES_MAP[props2.type] || "el-icon-info");
    const isBigIcon = computed(() => props2.description || ctx2.slots.default ? "is-big" : "");
    const isBoldTitle = computed(() => props2.description || ctx2.slots.default ? "is-bold" : "");
    const close2 = (evt) => {
      visible2.value = false;
      ctx2.emit("close", evt);
    };
    return {
      visible: visible2,
      typeClass,
      iconClass,
      isBigIcon,
      isBoldTitle,
      close: close2
    };
  }
});
const _hoisted_1$1e = { class: "el-alert__content" };
const _hoisted_2$10 = {
  key: 1,
  class: "el-alert__description"
};
function render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, { name: "el-alert-fade" }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        class: normalizeClass(["el-alert", [_ctx.typeClass, _ctx.center ? "is-center" : "", "is-" + _ctx.effect]]),
        role: "alert"
      }, [
        _ctx.showIcon ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass(["el-alert__icon", [_ctx.iconClass, _ctx.isBigIcon]])
        }, null, 2)) : createCommentVNode("v-if", true),
        createElementVNode("div", _hoisted_1$1e, [
          _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(["el-alert__title", [_ctx.isBoldTitle]])
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 2)) : createCommentVNode("v-if", true),
          _ctx.$slots.default || !!_ctx.description ? (openBlock(), createElementBlock("p", _hoisted_2$10, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.description), 1)
            ])
          ])) : createCommentVNode("v-if", true),
          _ctx.closable ? (openBlock(), createElementBlock("i", {
            key: 2,
            class: normalizeClass(["el-alert__closebtn", { "is-customed": _ctx.closeText !== "", "el-icon-close": _ctx.closeText === "" }]),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.close && _ctx.close(...args))
          }, toDisplayString(_ctx.closeText), 3)) : createCommentVNode("v-if", true)
        ])
      ], 2), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  });
}
script$_.render = render$X;
script$_.__file = "packages/components/alert/src/workprogress.vue";
script$_.install = (app) => {
  app.component(script$_.name, script$_);
};
const _Alert = script$_;
const ElAlert = _Alert;
var root = _root;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string2) {
  var index2 = string2.length;
  while (index2-- && reWhitespace.test(string2.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
}
var _baseTrim = baseTrim$1;
var baseGetTag = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var symbolTag$2 = "[object Symbol]";
function isSymbol$1(value2) {
  return typeof value2 == "symbol" || isObjectLike$3(value2) && baseGetTag(value2) == symbolTag$2;
}
var isSymbol_1 = isSymbol$1;
var baseTrim = _baseTrim, isObject$7 = isObject_1, isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol(value2)) {
    return NAN;
  }
  if (isObject$7(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject$7(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim(value2);
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
var toNumber_1 = toNumber$1;
var isObject$6 = isObject_1, now = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options2) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber(wait) || 0;
  if (isObject$6(options2)) {
    leading = !!options2.leading;
    maxing = "maxWait" in options2;
    maxWait = maxing ? nativeMax$1(toNumber(options2.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
const elFormKey = "elForm";
const elFormItemKey = "elFormItem";
const elFormEvents = {
  addField: "el.form.addField",
  removeField: "el.form.removeField"
};
function isKorean(text) {
  const reg = /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi;
  return reg.test(text);
}
const isValidWidthUnit = (val) => {
  if (isNumber$1(val)) {
    return true;
  } else {
    return ["px", "rem", "em", "vw", "%", "vmin", "vmax"].some((unit) => val.endsWith(unit));
  }
};
const isValidComponentSize = (val) => ["", "large", "medium", "small", "mini"].includes(val);
const isValidDatePickType = (val) => [
  "year",
  "month",
  "date",
  "dates",
  "week",
  "datetime",
  "datetimerange",
  "daterange",
  "monthrange"
].includes(val);
let hiddenTextarea$1;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue("box-sizing");
  const paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
  const contextStyle = CONTEXT_STYLE.map((name2) => `${name2}:${style.getPropertyValue(name2)}`).join(";");
  return { contextStyle, paddingSize, borderSize, boxSizing };
}
function calcTextareaHeight(targetElement, minRows = 1, maxRows = null) {
  var _a;
  if (!hiddenTextarea$1) {
    hiddenTextarea$1 = document.createElement("textarea");
    document.body.appendChild(hiddenTextarea$1);
  }
  const {
    paddingSize,
    borderSize,
    boxSizing,
    contextStyle
  } = calculateNodeStyling(targetElement);
  hiddenTextarea$1.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea$1.value = targetElement.value || targetElement.placeholder || "";
  let height = hiddenTextarea$1.scrollHeight;
  const result = {};
  if (boxSizing === "border-box") {
    height = height + borderSize;
  } else if (boxSizing === "content-box") {
    height = height - paddingSize;
  }
  hiddenTextarea$1.value = "";
  const singleRowHeight = hiddenTextarea$1.scrollHeight - paddingSize;
  if (minRows !== null) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result.minHeight = `${minHeight}px`;
  }
  if (maxRows !== null) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result.height = `${height}px`;
  (_a = hiddenTextarea$1.parentNode) == null ? void 0 : _a.removeChild(hiddenTextarea$1);
  hiddenTextarea$1 = null;
  return result;
}
var __defProp$r = Object.defineProperty;
var __defProps$o = Object.defineProperties;
var __getOwnPropDescs$o = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$r = Object.getOwnPropertySymbols;
var __hasOwnProp$r = Object.prototype.hasOwnProperty;
var __propIsEnum$r = Object.prototype.propertyIsEnumerable;
var __defNormalProp$r = (obj, key, value2) => key in obj ? __defProp$r(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$r = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$r.call(b, prop))
      __defNormalProp$r(a, prop, b[prop]);
  if (__getOwnPropSymbols$r)
    for (var prop of __getOwnPropSymbols$r(b)) {
      if (__propIsEnum$r.call(b, prop))
        __defNormalProp$r(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$o = (a, b) => __defProps$o(a, __getOwnPropDescs$o(b));
const PENDANT_MAP = {
  suffix: "append",
  prefix: "prepend"
};
var script$Z = defineComponent({
  name: "ElInput",
  inheritAttrs: false,
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    type: {
      type: String,
      default: "text"
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    resize: {
      type: String,
      validator: (val) => ["none", "both", "horizontal", "vertical"].includes(val)
    },
    autosize: {
      type: [Boolean, Object],
      default: false
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    placeholder: {
      type: String
    },
    form: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    clearable: {
      type: Boolean,
      default: false
    },
    showPassword: {
      type: Boolean,
      default: false
    },
    showWordLimit: {
      type: Boolean,
      default: false
    },
    suffixIcon: {
      type: String,
      default: ""
    },
    prefixIcon: {
      type: String,
      default: ""
    },
    label: {
      type: String
    },
    tabindex: {
      type: [Number, String]
    },
    validateEvent: {
      type: Boolean,
      default: true
    },
    inputStyle: {
      type: Object,
      default: () => ({})
    },
    maxlength: {
      type: [Number, String]
    }
  },
  emits: [
    UPDATE_MODEL_EVENT,
    "input",
    "change",
    "focus",
    "blur",
    "clear",
    "mouseleave",
    "mouseenter",
    "keydown"
  ],
  setup(props2, ctx2) {
    const instance = getCurrentInstance();
    const attrs = useAttrs();
    const $ELEMENT2 = useGlobalConfig();
    const elForm = inject(elFormKey, {});
    const elFormItem = inject(elFormItemKey, {});
    const input2 = ref(null);
    const textarea = ref(null);
    const focused = ref(false);
    const hovering = ref(false);
    const isComposing = ref(false);
    const passwordVisible = ref(false);
    const _textareaCalcStyle = shallowRef(props2.inputStyle);
    const inputOrTextarea = computed(() => input2.value || textarea.value);
    const inputSize = computed(() => props2.size || elFormItem.size || $ELEMENT2.size);
    const needStatusIcon = computed(() => elForm.statusIcon);
    const validateState = computed(() => elFormItem.validateState || "");
    const validateIcon = computed(() => VALIDATE_STATE_MAP[validateState.value]);
    const computedTextareaStyle = computed(() => __spreadProps$o(__spreadValues$r(__spreadValues$r({}, props2.inputStyle), _textareaCalcStyle.value), {
      resize: props2.resize
    }));
    const inputDisabled = computed(() => props2.disabled || elForm.disabled);
    const nativeInputValue = computed(() => props2.modelValue === null || props2.modelValue === void 0 ? "" : String(props2.modelValue));
    const showClear = computed(() => {
      return props2.clearable && !inputDisabled.value && !props2.readonly && nativeInputValue.value && (focused.value || hovering.value);
    });
    const showPwdVisible = computed(() => {
      return props2.showPassword && !inputDisabled.value && !props2.readonly && (!!nativeInputValue.value || focused.value);
    });
    const isWordLimitVisible = computed(() => {
      return props2.showWordLimit && props2.maxlength && (props2.type === "text" || props2.type === "textarea") && !inputDisabled.value && !props2.readonly && !props2.showPassword;
    });
    const textLength = computed(() => {
      return Array.from(nativeInputValue.value).length;
    });
    const inputExceed = computed(() => {
      return isWordLimitVisible.value && textLength.value > Number(props2.maxlength);
    });
    const resizeTextarea = () => {
      const { type: type2, autosize } = props2;
      if (isServer || type2 !== "textarea")
        return;
      if (autosize) {
        const minRows = isObject$b(autosize) ? autosize.minRows : void 0;
        const maxRows = isObject$b(autosize) ? autosize.maxRows : void 0;
        _textareaCalcStyle.value = __spreadValues$r({}, calcTextareaHeight(textarea.value, minRows, maxRows));
      } else {
        _textareaCalcStyle.value = {
          minHeight: calcTextareaHeight(textarea.value).minHeight
        };
      }
    };
    const setNativeInputValue = () => {
      const input22 = inputOrTextarea.value;
      if (!input22 || input22.value === nativeInputValue.value)
        return;
      input22.value = nativeInputValue.value;
    };
    const calcIconOffset = (place) => {
      const { el } = instance.vnode;
      const elList = Array.from(el.querySelectorAll(`.el-input__${place}`));
      const target = elList.find((item) => item.parentNode === el);
      if (!target)
        return;
      const pendant = PENDANT_MAP[place];
      if (ctx2.slots[pendant]) {
        target.style.transform = `translateX(${place === "suffix" ? "-" : ""}${el.querySelector(`.el-input-group__${pendant}`).offsetWidth}px)`;
      } else {
        target.removeAttribute("style");
      }
    };
    const updateIconOffset = () => {
      calcIconOffset("prefix");
      calcIconOffset("suffix");
    };
    const handleInput = (event2) => {
      let { value: value2 } = event2.target;
      if (isComposing.value)
        return;
      if (value2 === nativeInputValue.value)
        return;
      if (props2.maxlength) {
        const sliceIndex = inputExceed.value ? textLength.value : props2.maxlength;
        value2 = Array.from(value2).slice(0, Number(sliceIndex)).join("");
      }
      ctx2.emit(UPDATE_MODEL_EVENT, value2);
      ctx2.emit("input", value2);
      nextTick(setNativeInputValue);
    };
    const handleChange = (event2) => {
      ctx2.emit("change", event2.target.value);
    };
    const focus = () => {
      nextTick(() => {
        inputOrTextarea.value.focus();
      });
    };
    const blur = () => {
      inputOrTextarea.value.blur();
    };
    const handleFocus = (event2) => {
      focused.value = true;
      ctx2.emit("focus", event2);
    };
    const handleBlur = (event2) => {
      var _a;
      focused.value = false;
      ctx2.emit("blur", event2);
      if (props2.validateEvent) {
        (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.blur", [props2.modelValue]);
      }
    };
    const select = () => {
      inputOrTextarea.value.select();
    };
    const handleCompositionStart = () => {
      isComposing.value = true;
    };
    const handleCompositionUpdate = (event2) => {
      const text = event2.target.value;
      const lastCharacter = text[text.length - 1] || "";
      isComposing.value = !isKorean(lastCharacter);
    };
    const handleCompositionEnd = (event2) => {
      if (isComposing.value) {
        isComposing.value = false;
        handleInput(event2);
      }
    };
    const clear = () => {
      ctx2.emit(UPDATE_MODEL_EVENT, "");
      ctx2.emit("change", "");
      ctx2.emit("clear");
      ctx2.emit("input", "");
    };
    const handlePasswordVisible = () => {
      passwordVisible.value = !passwordVisible.value;
      focus();
    };
    const getSuffixVisible = () => {
      return ctx2.slots.suffix || props2.suffixIcon || showClear.value || props2.showPassword || isWordLimitVisible.value || validateState.value && needStatusIcon.value;
    };
    watch(() => props2.modelValue, (val) => {
      var _a;
      nextTick(resizeTextarea);
      if (props2.validateEvent) {
        (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", [val]);
      }
    });
    watch(nativeInputValue, () => {
      setNativeInputValue();
    });
    watch(() => props2.type, () => {
      nextTick(() => {
        setNativeInputValue();
        resizeTextarea();
        updateIconOffset();
      });
    });
    onMounted(() => {
      setNativeInputValue();
      updateIconOffset();
      nextTick(resizeTextarea);
    });
    onUpdated(() => {
      nextTick(updateIconOffset);
    });
    const onMouseLeave = (e) => {
      hovering.value = false;
      ctx2.emit("mouseleave", e);
    };
    const onMouseEnter = (e) => {
      hovering.value = true;
      ctx2.emit("mouseenter", e);
    };
    const handleKeydown = (e) => {
      ctx2.emit("keydown", e);
    };
    return {
      input: input2,
      textarea,
      attrs,
      inputSize,
      validateState,
      validateIcon,
      computedTextareaStyle,
      resizeTextarea,
      inputDisabled,
      showClear,
      showPwdVisible,
      isWordLimitVisible,
      textLength,
      hovering,
      inputExceed,
      passwordVisible,
      inputOrTextarea,
      handleInput,
      handleChange,
      handleFocus,
      handleBlur,
      handleCompositionStart,
      handleCompositionUpdate,
      handleCompositionEnd,
      handlePasswordVisible,
      clear,
      select,
      focus,
      blur,
      getSuffixVisible,
      onMouseLeave,
      onMouseEnter,
      handleKeydown
    };
  }
});
const _hoisted_1$1d = {
  key: 0,
  class: "el-input-group__prepend"
};
const _hoisted_2$$ = ["type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder"];
const _hoisted_3$W = {
  key: 2,
  class: "el-input__prefix"
};
const _hoisted_4$I = {
  key: 3,
  class: "el-input__suffix"
};
const _hoisted_5$B = { class: "el-input__suffix-inner" };
const _hoisted_6$u = {
  key: 3,
  class: "el-input__count"
};
const _hoisted_7$m = { class: "el-input__count-inner" };
const _hoisted_8$h = {
  key: 4,
  class: "el-input-group__append"
};
const _hoisted_9$g = ["tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder"];
const _hoisted_10$d = {
  key: 2,
  class: "el-input__count"
};
function render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      _ctx.type === "textarea" ? "el-textarea" : "el-input",
      _ctx.inputSize ? "el-input--" + _ctx.inputSize : "",
      {
        "is-disabled": _ctx.inputDisabled,
        "is-exceed": _ctx.inputExceed,
        "el-input-group": _ctx.$slots.prepend || _ctx.$slots.append,
        "el-input-group--append": _ctx.$slots.append,
        "el-input-group--prepend": _ctx.$slots.prepend,
        "el-input--prefix": _ctx.$slots.prefix || _ctx.prefixIcon,
        "el-input--suffix": _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,
        "el-input--suffix--password-clear": _ctx.clearable && _ctx.showPassword
      },
      _ctx.$attrs.class
    ]),
    style: normalizeStyle(_ctx.$attrs.style),
    onMouseenter: _cache[19] || (_cache[19] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onMouseleave: _cache[20] || (_cache[20] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createCommentVNode(" \u524D\u7F6E\u5143\u7D20 "),
      _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", _hoisted_1$1d, [
        renderSlot(_ctx.$slots, "prepend")
      ])) : createCommentVNode("v-if", true),
      _ctx.type !== "textarea" ? (openBlock(), createElementBlock("input", mergeProps({
        key: 1,
        ref: "input",
        class: "el-input__inner"
      }, _ctx.attrs, {
        type: _ctx.showPassword ? _ctx.passwordVisible ? "text" : "password" : _ctx.type,
        disabled: _ctx.inputDisabled,
        readonly: _ctx.readonly,
        autocomplete: _ctx.autocomplete,
        tabindex: _ctx.tabindex,
        "aria-label": _ctx.label,
        placeholder: _ctx.placeholder,
        style: _ctx.inputStyle,
        onCompositionstart: _cache[0] || (_cache[0] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
        onCompositionupdate: _cache[1] || (_cache[1] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
        onCompositionend: _cache[2] || (_cache[2] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
        onInput: _cache[3] || (_cache[3] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
        onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
        onChange: _cache[6] || (_cache[6] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onKeydown: _cache[7] || (_cache[7] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }), null, 16, _hoisted_2$$)) : createCommentVNode("v-if", true),
      createCommentVNode(" \u524D\u7F6E\u5185\u5BB9 "),
      _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", _hoisted_3$W, [
        renderSlot(_ctx.$slots, "prefix"),
        _ctx.prefixIcon ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass(["el-input__icon", _ctx.prefixIcon])
        }, null, 2)) : createCommentVNode("v-if", true)
      ])) : createCommentVNode("v-if", true),
      createCommentVNode(" \u540E\u7F6E\u5185\u5BB9 "),
      _ctx.getSuffixVisible() ? (openBlock(), createElementBlock("span", _hoisted_4$I, [
        createElementVNode("span", _hoisted_5$B, [
          !_ctx.showClear || !_ctx.showPwdVisible || !_ctx.isWordLimitVisible ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            renderSlot(_ctx.$slots, "suffix"),
            _ctx.suffixIcon ? (openBlock(), createElementBlock("i", {
              key: 0,
              class: normalizeClass(["el-input__icon", _ctx.suffixIcon])
            }, null, 2)) : createCommentVNode("v-if", true)
          ], 64)) : createCommentVNode("v-if", true),
          _ctx.showClear ? (openBlock(), createElementBlock("i", {
            key: 1,
            class: "el-input__icon el-icon-circle-close el-input__clear",
            onMousedown: _cache[8] || (_cache[8] = withModifiers(() => {
            }, ["prevent"])),
            onClick: _cache[9] || (_cache[9] = (...args) => _ctx.clear && _ctx.clear(...args))
          }, null, 32)) : createCommentVNode("v-if", true),
          _ctx.showPwdVisible ? (openBlock(), createElementBlock("i", {
            key: 2,
            class: "el-input__icon el-icon-view el-input__clear",
            onClick: _cache[10] || (_cache[10] = (...args) => _ctx.handlePasswordVisible && _ctx.handlePasswordVisible(...args))
          })) : createCommentVNode("v-if", true),
          _ctx.isWordLimitVisible ? (openBlock(), createElementBlock("span", _hoisted_6$u, [
            createElementVNode("span", _hoisted_7$m, toDisplayString(_ctx.textLength) + "/" + toDisplayString(_ctx.maxlength), 1)
          ])) : createCommentVNode("v-if", true)
        ]),
        _ctx.validateState ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass(["el-input__icon", "el-input__validateIcon", _ctx.validateIcon])
        }, null, 2)) : createCommentVNode("v-if", true)
      ])) : createCommentVNode("v-if", true),
      createCommentVNode(" \u540E\u7F6E\u5143\u7D20 "),
      _ctx.$slots.append ? (openBlock(), createElementBlock("div", _hoisted_8$h, [
        renderSlot(_ctx.$slots, "append")
      ])) : createCommentVNode("v-if", true)
    ], 64)) : (openBlock(), createElementBlock("textarea", mergeProps({
      key: 1,
      ref: "textarea",
      class: "el-textarea__inner"
    }, _ctx.attrs, {
      tabindex: _ctx.tabindex,
      disabled: _ctx.inputDisabled,
      readonly: _ctx.readonly,
      autocomplete: _ctx.autocomplete,
      style: _ctx.computedTextareaStyle,
      "aria-label": _ctx.label,
      placeholder: _ctx.placeholder,
      onCompositionstart: _cache[11] || (_cache[11] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
      onCompositionupdate: _cache[12] || (_cache[12] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
      onCompositionend: _cache[13] || (_cache[13] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
      onInput: _cache[14] || (_cache[14] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
      onFocus: _cache[15] || (_cache[15] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onBlur: _cache[16] || (_cache[16] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
      onChange: _cache[17] || (_cache[17] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onKeydown: _cache[18] || (_cache[18] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
    }), "\n    ", 16, _hoisted_9$g)),
    _ctx.isWordLimitVisible && _ctx.type === "textarea" ? (openBlock(), createElementBlock("span", _hoisted_10$d, toDisplayString(_ctx.textLength) + "/" + toDisplayString(_ctx.maxlength), 1)) : createCommentVNode("v-if", true)
  ], 38);
}
script$Z.render = render$W;
script$Z.__file = "packages/components/input/src/workprogress.vue";
script$Z.install = (app) => {
  app.component(script$Z.name, script$Z);
};
const _Input = script$Z;
const ElInput = _Input;
var ElInput$1 = _Input;
const BAR_MAP = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
};
function renderThumbStyle$1({ move, size, bar }) {
  const style = {};
  const translate2 = `translate${bar.axis}(${move}%)`;
  style[bar.size] = size;
  style.transform = translate2;
  style.msTransform = translate2;
  style.webkitTransform = translate2;
  return style;
}
var __pow = Math.pow;
var script$Y = defineComponent({
  name: "Bar",
  props: {
    vertical: Boolean,
    size: String,
    move: Number,
    ratio: Number,
    always: Boolean
  },
  setup(props2) {
    const instance = ref(null);
    const thumb = ref(null);
    const scrollbar = inject("scrollbar", {});
    const wrap = inject("scrollbar-wrap", {});
    const bar = computed(() => BAR_MAP[props2.vertical ? "vertical" : "horizontal"]);
    const barStore = ref({});
    const cursorDown = ref(null);
    const cursorLeave = ref(null);
    const visible2 = ref(false);
    let onselectstartStore = null;
    const offsetRatio = computed(() => {
      return __pow(instance.value[bar.value.offset], 2) / wrap.value[bar.value.scrollSize] / props2.ratio / thumb.value[bar.value.offset];
    });
    const clickThumbHandler = (e) => {
      e.stopPropagation();
      if (e.ctrlKey || [1, 2].includes(e.button)) {
        return;
      }
      window.getSelection().removeAllRanges();
      startDrag(e);
      barStore.value[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
    };
    const clickTrackHandler = (e) => {
      const offset2 = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
      const thumbHalf = thumb.value[bar.value.offset] / 2;
      const thumbPositionPercentage = (offset2 - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      wrap.value[bar.value.scroll] = thumbPositionPercentage * wrap.value[bar.value.scrollSize] / 100;
    };
    const startDrag = (e) => {
      e.stopImmediatePropagation();
      cursorDown.value = true;
      on$2(document, "mousemove", mouseMoveDocumentHandler);
      on$2(document, "mouseup", mouseUpDocumentHandler);
      onselectstartStore = document.onselectstart;
      document.onselectstart = () => false;
    };
    const mouseMoveDocumentHandler = (e) => {
      if (cursorDown.value === false)
        return;
      const prevPage = barStore.value[bar.value.axis];
      if (!prevPage)
        return;
      const offset2 = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
      const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
      const thumbPositionPercentage = (offset2 - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      wrap.value[bar.value.scroll] = thumbPositionPercentage * wrap.value[bar.value.scrollSize] / 100;
    };
    const mouseUpDocumentHandler = () => {
      cursorDown.value = false;
      barStore.value[bar.value.axis] = 0;
      off$2(document, "mousemove", mouseMoveDocumentHandler);
      document.onselectstart = onselectstartStore;
      if (cursorLeave.value) {
        visible2.value = false;
      }
    };
    const thumbStyle = computed(() => renderThumbStyle$1({
      size: props2.size,
      move: props2.move,
      bar: bar.value
    }));
    const mouseMoveScrollbarHandler = () => {
      cursorLeave.value = false;
      visible2.value = !!props2.size;
    };
    const mouseLeaveScrollbarHandler = () => {
      cursorLeave.value = true;
      visible2.value = cursorDown.value;
    };
    onMounted(() => {
      on$2(scrollbar.value, "mousemove", mouseMoveScrollbarHandler);
      on$2(scrollbar.value, "mouseleave", mouseLeaveScrollbarHandler);
    });
    onBeforeUnmount(() => {
      off$2(document, "mouseup", mouseUpDocumentHandler);
      off$2(scrollbar.value, "mousemove", mouseMoveScrollbarHandler);
      off$2(scrollbar.value, "mouseleave", mouseLeaveScrollbarHandler);
    });
    return {
      instance,
      thumb,
      bar,
      clickTrackHandler,
      clickThumbHandler,
      thumbStyle,
      visible: visible2
    };
  }
});
function render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, { name: "el-scrollbar-fade" }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        ref: "instance",
        class: normalizeClass(["el-scrollbar__bar", "is-" + _ctx.bar.key]),
        onMousedown: _cache[1] || (_cache[1] = (...args) => _ctx.clickTrackHandler && _ctx.clickTrackHandler(...args))
      }, [
        createElementVNode("div", {
          ref: "thumb",
          class: "el-scrollbar__thumb",
          style: normalizeStyle(_ctx.thumbStyle),
          onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.clickThumbHandler && _ctx.clickThumbHandler(...args))
        }, null, 36)
      ], 34), [
        [vShow, _ctx.always || _ctx.visible]
      ])
    ]),
    _: 1
  });
}
script$Y.render = render$V;
script$Y.__file = "packages/components/scrollbar/src/bar.vue";
var __pow$1 = Math.pow;
var script$1$v = defineComponent({
  name: "ElScrollbar",
  components: { Bar: script$Y },
  props: {
    height: {
      type: [String, Number],
      default: ""
    },
    maxHeight: {
      type: [String, Number],
      default: ""
    },
    native: {
      type: Boolean,
      default: false
    },
    wrapStyle: {
      type: [String, Array],
      default: ""
    },
    wrapClass: {
      type: [String, Array],
      default: ""
    },
    viewClass: {
      type: [String, Array],
      default: ""
    },
    viewStyle: {
      type: [String, Array],
      default: ""
    },
    noresize: Boolean,
    tag: {
      type: String,
      default: "div"
    },
    always: {
      type: Boolean,
      default: false
    },
    minSize: {
      type: Number,
      default: 20
    }
  },
  emits: ["scroll"],
  setup(props2, { emit: emit2 }) {
    const sizeWidth = ref("0");
    const sizeHeight = ref("0");
    const moveX = ref(0);
    const moveY = ref(0);
    const scrollbar = ref(null);
    const wrap = ref(null);
    const resize = ref(null);
    const ratioY = ref(1);
    const ratioX = ref(1);
    const SCOPE2 = "ElScrollbar";
    const GAP = 4;
    provide("scrollbar", scrollbar);
    provide("scrollbar-wrap", wrap);
    const handleScroll2 = () => {
      if (wrap.value) {
        const offsetHeight = wrap.value.offsetHeight - GAP;
        const offsetWidth = wrap.value.offsetWidth - GAP;
        moveY.value = wrap.value.scrollTop * 100 / offsetHeight * ratioY.value;
        moveX.value = wrap.value.scrollLeft * 100 / offsetWidth * ratioX.value;
        emit2("scroll", {
          scrollTop: wrap.value.scrollTop,
          scrollLeft: wrap.value.scrollLeft
        });
      }
    };
    const setScrollTop2 = (value2) => {
      if (!isNumber$1(value2)) {
        {
          warn(SCOPE2, "value must be a number");
        }
        return;
      }
      wrap.value.scrollTop = value2;
    };
    const setScrollLeft2 = (value2) => {
      if (!isNumber$1(value2)) {
        {
          warn(SCOPE2, "value must be a number");
        }
        return;
      }
      wrap.value.scrollLeft = value2;
    };
    const update = () => {
      if (!wrap.value)
        return;
      const offsetHeight = wrap.value.offsetHeight - GAP;
      const offsetWidth = wrap.value.offsetWidth - GAP;
      const originalHeight = __pow$1(offsetHeight, 2) / wrap.value.scrollHeight;
      const originalWidth = __pow$1(offsetWidth, 2) / wrap.value.scrollWidth;
      const height = Math.max(originalHeight, props2.minSize);
      const width2 = Math.max(originalWidth, props2.minSize);
      ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
      ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width2 / (offsetWidth - width2));
      sizeHeight.value = height + GAP < offsetHeight ? height + "px" : "";
      sizeWidth.value = width2 + GAP < offsetWidth ? width2 + "px" : "";
    };
    const style = computed(() => {
      let style2 = props2.wrapStyle;
      if (isArray$9(style2)) {
        style2 = toObject(style2);
        style2.height = addUnit(props2.height);
        style2.maxHeight = addUnit(props2.maxHeight);
      } else if (isString$1(style2)) {
        style2 += addUnit(props2.height) ? `height: ${addUnit(props2.height)};` : "";
        style2 += addUnit(props2.maxHeight) ? `max-height: ${addUnit(props2.maxHeight)};` : "";
      }
      return style2;
    });
    onMounted(() => {
      if (!props2.native) {
        nextTick(update);
      }
      if (!props2.noresize) {
        addResizeListener(resize.value, update);
        addEventListener("resize", update);
      }
    });
    onBeforeUnmount(() => {
      if (!props2.noresize) {
        removeResizeListener(resize.value, update);
        removeEventListener("resize", update);
      }
    });
    return {
      moveX,
      moveY,
      ratioX,
      ratioY,
      sizeWidth,
      sizeHeight,
      style,
      scrollbar,
      wrap,
      resize,
      update,
      handleScroll: handleScroll2,
      setScrollTop: setScrollTop2,
      setScrollLeft: setScrollLeft2
    };
  }
});
const _hoisted_1$1c = {
  ref: "scrollbar",
  class: "el-scrollbar"
};
function render$1$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_bar = resolveComponent("bar");
  return openBlock(), createElementBlock("div", _hoisted_1$1c, [
    createElementVNode("div", {
      ref: "wrap",
      class: normalizeClass([
        _ctx.wrapClass,
        "el-scrollbar__wrap",
        _ctx.native ? "" : "el-scrollbar__wrap--hidden-default"
      ]),
      style: normalizeStyle(_ctx.style),
      onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.handleScroll && _ctx.handleScroll(...args))
    }, [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
        ref: "resize",
        class: normalizeClass(["el-scrollbar__view", _ctx.viewClass]),
        style: normalizeStyle(_ctx.viewStyle)
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]))
    ], 38),
    !_ctx.native ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createVNode(_component_bar, {
        move: _ctx.moveX,
        ratio: _ctx.ratioX,
        size: _ctx.sizeWidth,
        always: _ctx.always
      }, null, 8, ["move", "ratio", "size", "always"]),
      createVNode(_component_bar, {
        move: _ctx.moveY,
        ratio: _ctx.ratioY,
        size: _ctx.sizeHeight,
        vertical: "",
        always: _ctx.always
      }, null, 8, ["move", "ratio", "size", "always"])
    ], 64)) : createCommentVNode("v-if", true)
  ], 512);
}
script$1$v.render = render$1$u;
script$1$v.__file = "packages/components/scrollbar/src/workprogress.vue";
script$1$v.install = (app) => {
  app.component(script$1$v.name, script$1$v);
};
const _Scrollbar = script$1$v;
const ElScrollbar = _Scrollbar;
function buildModifier(props2, externalModifiers = []) {
  const {
    arrow: arrow2,
    arrowOffset,
    offset: offset2,
    gpuAcceleration,
    fallbackPlacements
  } = props2;
  const modifiers = [
    {
      name: "offset",
      options: {
        offset: [0, offset2 != null ? offset2 : 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration,
        adaptive: gpuAcceleration
      }
    }
  ];
  if (arrow2) {
    modifiers.push({
      name: "arrow",
      options: {
        element: arrow2,
        padding: arrowOffset != null ? arrowOffset : 5
      }
    });
  }
  modifiers.push(...externalModifiers);
  return modifiers;
}
var __defProp$q = Object.defineProperty;
var __defProps$n = Object.defineProperties;
var __getOwnPropDescs$n = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$q = Object.getOwnPropertySymbols;
var __hasOwnProp$q = Object.prototype.hasOwnProperty;
var __propIsEnum$q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$q = (obj, key, value2) => key in obj ? __defProp$q(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$q.call(b, prop))
      __defNormalProp$q(a, prop, b[prop]);
  if (__getOwnPropSymbols$q)
    for (var prop of __getOwnPropSymbols$q(b)) {
      if (__propIsEnum$q.call(b, prop))
        __defNormalProp$q(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$n = (a, b) => __defProps$n(a, __getOwnPropDescs$n(b));
function usePopperOptions(props2, state) {
  return computed(() => {
    var _a;
    return __spreadProps$n(__spreadValues$q({
      placement: props2.placement
    }, props2.popperOptions), {
      modifiers: buildModifier({
        arrow: state.arrow.value,
        arrowOffset: props2.arrowOffset,
        offset: props2.offset,
        gpuAcceleration: props2.gpuAcceleration,
        fallbackPlacements: props2.fallbackPlacements
      }, (_a = props2.popperOptions) == null ? void 0 : _a.modifiers)
    });
  });
}
var Effect;
(function(Effect2) {
  Effect2["DARK"] = "dark";
  Effect2["LIGHT"] = "light";
})(Effect || (Effect = {}));
const DEFAULT_FALLBACK_PLACEMENTS = [];
var defaultProps$4 = {
  arrowOffset: {
    type: Number,
    default: 5
  },
  appendToBody: {
    type: Boolean,
    default: true
  },
  autoClose: {
    type: Number,
    default: 0
  },
  boundariesPadding: {
    type: Number,
    default: 0
  },
  content: {
    type: String,
    default: ""
  },
  class: {
    type: String,
    default: ""
  },
  style: Object,
  hideAfter: {
    type: Number,
    default: 200
  },
  cutoff: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  effect: {
    type: String,
    default: Effect.DARK
  },
  enterable: {
    type: Boolean,
    default: true
  },
  manualMode: {
    type: Boolean,
    default: false
  },
  showAfter: {
    type: Number,
    default: 0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    default: "bottom"
  },
  popperClass: {
    type: String,
    default: ""
  },
  pure: {
    type: Boolean,
    default: false
  },
  popperOptions: {
    type: Object,
    default: () => null
  },
  showArrow: {
    type: Boolean,
    default: true
  },
  strategy: {
    type: String,
    default: "fixed"
  },
  transition: {
    type: String,
    default: "el-fade-in-linear"
  },
  trigger: {
    type: [String, Array],
    default: "hover"
  },
  visible: {
    type: Boolean,
    default: void 0
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  },
  fallbackPlacements: {
    type: Array,
    default: DEFAULT_FALLBACK_PLACEMENTS
  }
};
const UPDATE_VISIBLE_EVENT = "update:visible";
function usePopper(props2, { emit: emit2 }) {
  const arrowRef = ref(null);
  const triggerRef = ref(null);
  const popperRef = ref(null);
  const popperId = `el-popper-${generateId()}`;
  let popperInstance = null;
  let showTimer = null;
  let hideTimer = null;
  let triggerFocused = false;
  const isManualMode = () => props2.manualMode || props2.trigger === "manual";
  const popperStyle = ref({ zIndex: PopupManager$1.nextZIndex() });
  const popperOptions2 = usePopperOptions(props2, {
    arrow: arrowRef
  });
  const state = reactive({
    visible: !!props2.visible
  });
  const visibility = computed({
    get() {
      if (props2.disabled) {
        return false;
      } else {
        return isBool(props2.visible) ? props2.visible : state.visible;
      }
    },
    set(val) {
      if (isManualMode())
        return;
      isBool(props2.visible) ? emit2(UPDATE_VISIBLE_EVENT, val) : state.visible = val;
    }
  });
  function _show() {
    if (props2.autoClose > 0) {
      hideTimer = window.setTimeout(() => {
        _hide();
      }, props2.autoClose);
    }
    visibility.value = true;
  }
  function _hide() {
    visibility.value = false;
  }
  function clearTimers() {
    clearTimeout(showTimer);
    clearTimeout(hideTimer);
  }
  const show = () => {
    if (isManualMode() || props2.disabled)
      return;
    clearTimers();
    if (props2.showAfter === 0) {
      _show();
    } else {
      showTimer = window.setTimeout(() => {
        _show();
      }, props2.showAfter);
    }
  };
  const hide2 = () => {
    if (isManualMode())
      return;
    clearTimers();
    if (props2.hideAfter > 0) {
      hideTimer = window.setTimeout(() => {
        close2();
      }, props2.hideAfter);
    } else {
      close2();
    }
  };
  const close2 = () => {
    _hide();
    if (props2.disabled) {
      doDestroy(true);
    }
  };
  function onPopperMouseEnter() {
    if (props2.enterable && props2.trigger !== "click") {
      clearTimeout(hideTimer);
    }
  }
  function onPopperMouseLeave() {
    const { trigger } = props2;
    const shouldPrevent = isString$1(trigger) && (trigger === "click" || trigger === "focus") || trigger.length === 1 && (trigger[0] === "click" || trigger[0] === "focus");
    if (shouldPrevent)
      return;
    hide2();
  }
  function initializePopper() {
    if (!$(visibility)) {
      return;
    }
    const unwrappedTrigger = $(triggerRef);
    const _trigger = isHTMLElement$1(unwrappedTrigger) ? unwrappedTrigger : unwrappedTrigger.$el;
    popperInstance = createPopper(_trigger, $(popperRef), $(popperOptions2));
    popperInstance.update();
  }
  function doDestroy(forceDestroy) {
    if (!popperInstance || $(visibility) && !forceDestroy)
      return;
    detachPopper();
  }
  function detachPopper() {
    var _a;
    (_a = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a.call(popperInstance);
    popperInstance = null;
  }
  const events2 = {};
  function update() {
    if (!$(visibility)) {
      return;
    }
    if (popperInstance) {
      popperInstance.update();
    } else {
      initializePopper();
    }
  }
  function onVisibilityChange(toState) {
    if (toState) {
      popperStyle.value.zIndex = PopupManager$1.nextZIndex();
      initializePopper();
    }
  }
  if (!isManualMode()) {
    const toggleState = () => {
      if ($(visibility)) {
        hide2();
      } else {
        show();
      }
    };
    const popperEventsHandler = (e) => {
      e.stopPropagation();
      switch (e.type) {
        case "click": {
          if (triggerFocused) {
            triggerFocused = false;
          } else {
            toggleState();
          }
          break;
        }
        case "mouseenter": {
          show();
          break;
        }
        case "mouseleave": {
          hide2();
          break;
        }
        case "focus": {
          triggerFocused = true;
          show();
          break;
        }
        case "blur": {
          triggerFocused = false;
          hide2();
          break;
        }
      }
    };
    const triggerEventsMap = {
      click: ["onClick"],
      hover: ["onMouseenter", "onMouseleave"],
      focus: ["onFocus", "onBlur"]
    };
    const mapEvents = (t) => {
      triggerEventsMap[t].forEach((event2) => {
        events2[event2] = popperEventsHandler;
      });
    };
    if (isArray$9(props2.trigger)) {
      Object.values(props2.trigger).forEach(mapEvents);
    } else {
      mapEvents(props2.trigger);
    }
  }
  watch(popperOptions2, (val) => {
    if (!popperInstance)
      return;
    popperInstance.setOptions(val);
    popperInstance.update();
  });
  watch(visibility, onVisibilityChange);
  return {
    update,
    doDestroy,
    show,
    hide: hide2,
    onPopperMouseEnter,
    onPopperMouseLeave,
    onAfterEnter: () => {
      emit2("after-enter");
    },
    onAfterLeave: () => {
      detachPopper();
      emit2("after-leave");
    },
    onBeforeEnter: () => {
      emit2("before-enter");
    },
    onBeforeLeave: () => {
      emit2("before-leave");
    },
    initializePopper,
    isManualMode,
    arrowRef,
    events: events2,
    popperId,
    popperInstance,
    popperRef,
    popperStyle,
    triggerRef,
    visibility
  };
}
function renderPopper(props2, children) {
  const {
    effect: effect2,
    name: name2,
    stopPopperMouseEvent,
    popperClass,
    popperStyle,
    popperRef,
    pure,
    popperId,
    visibility,
    onMouseenter,
    onMouseleave,
    onAfterEnter,
    onAfterLeave,
    onBeforeEnter,
    onBeforeLeave
  } = props2;
  const kls = [
    popperClass,
    "el-popper",
    "is-" + effect2,
    pure ? "is-pure" : ""
  ];
  const mouseUpAndDown = stopPopperMouseEvent ? stop : NOOP;
  return h(Transition, {
    name: name2,
    "onAfterEnter": onAfterEnter,
    "onAfterLeave": onAfterLeave,
    "onBeforeEnter": onBeforeEnter,
    "onBeforeLeave": onBeforeLeave
  }, {
    default: withCtx(() => [withDirectives(h("div", {
      "aria-hidden": String(!visibility),
      class: kls,
      style: popperStyle != null ? popperStyle : {},
      id: popperId,
      ref: popperRef != null ? popperRef : "popperRef",
      role: "tooltip",
      onMouseenter,
      onMouseleave,
      onClick: stop,
      onMousedown: mouseUpAndDown,
      onMouseup: mouseUpAndDown
    }, children), [[vShow, visibility]])])
  });
}
function renderTrigger(trigger, extraProps) {
  const firstElement = getFirstValidNode(trigger, 1);
  if (!firstElement)
    throwError("renderTrigger", "trigger expects single rooted node");
  return cloneVNode(firstElement, extraProps, true);
}
function renderArrow(showArrow) {
  return showArrow ? h("div", {
    ref: "arrowRef",
    class: "el-popper__arrow",
    "data-popper-arrow": ""
  }, null) : h(Comment, null, "");
}
var __defProp$1$8 = Object.defineProperty;
var __getOwnPropSymbols$1$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$8 = (obj, key, value2) => key in obj ? __defProp$1$8(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$8.call(b, prop))
      __defNormalProp$1$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$8)
    for (var prop of __getOwnPropSymbols$1$8(b)) {
      if (__propIsEnum$1$8.call(b, prop))
        __defNormalProp$1$8(a, prop, b[prop]);
    }
  return a;
};
const compName = "ElPopper";
const UPDATE_VISIBLE_EVENT$1 = "update:visible";
var script$X = defineComponent({
  name: compName,
  props: defaultProps$4,
  emits: [UPDATE_VISIBLE_EVENT$1, "after-enter", "after-leave", "before-enter", "before-leave"],
  setup(props2, ctx2) {
    if (!ctx2.slots.trigger) {
      throwError(compName, "Trigger must be provided");
    }
    const popperStates = usePopper(props2, ctx2);
    const forceDestroy = () => popperStates.doDestroy(true);
    onMounted(popperStates.initializePopper);
    onBeforeUnmount(forceDestroy);
    onActivated(popperStates.initializePopper);
    onDeactivated(forceDestroy);
    return popperStates;
  },
  render() {
    var _a;
    const {
      $slots,
      appendToBody,
      class: kls,
      style,
      effect: effect2,
      hide: hide2,
      onPopperMouseEnter,
      onPopperMouseLeave,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave,
      popperClass,
      popperId,
      popperStyle,
      pure,
      showArrow,
      transition,
      visibility,
      stopPopperMouseEvent
    } = this;
    const isManual = this.isManualMode();
    const arrow2 = renderArrow(showArrow);
    const popper2 = renderPopper({
      effect: effect2,
      name: transition,
      popperClass,
      popperId,
      popperStyle,
      pure,
      stopPopperMouseEvent,
      onMouseenter: onPopperMouseEnter,
      onMouseleave: onPopperMouseLeave,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave,
      visibility
    }, [
      renderSlot($slots, "default", {}, () => {
        return [toDisplayString(this.content)];
      }),
      arrow2
    ]);
    const _t = (_a = $slots.trigger) == null ? void 0 : _a.call($slots);
    const triggerProps = __spreadValues$1$8({
      "aria-describedby": popperId,
      class: kls,
      style,
      ref: "triggerRef"
    }, this.events);
    const trigger = isManual ? renderTrigger(_t, triggerProps) : withDirectives(renderTrigger(_t, triggerProps), [[ClickOutside$1, hide2]]);
    return h(Fragment, null, [
      trigger,
      h(Teleport, {
        to: "body",
        disabled: !appendToBody
      }, [popper2])
    ]);
  }
});
script$X.__file = "packages/components/popper/src/workprogress.vue";
script$X.install = (app) => {
  app.component(script$X.name, script$X);
};
const _Popper = script$X;
const ElPopper = _Popper;
var ElPopper$1 = _Popper;
var script$W = defineComponent({
  name: "ElAutocomplete",
  components: {
    ElPopper: ElPopper$1,
    ElInput: ElInput$1,
    ElScrollbar: _Scrollbar
  },
  directives: {
    clickoutside: ClickOutside$1
  },
  inheritAttrs: false,
  props: {
    valueKey: {
      type: String,
      default: "value"
    },
    modelValue: {
      type: [String, Number],
      default: ""
    },
    debounce: {
      type: Number,
      default: 300
    },
    placement: {
      type: String,
      validator: (val) => {
        return ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end"].includes(val);
      },
      default: "bottom-start"
    },
    fetchSuggestions: {
      type: Function,
      default: NOOP
    },
    popperClass: {
      type: String,
      default: ""
    },
    triggerOnFocus: {
      type: Boolean,
      default: true
    },
    selectWhenUnmatched: {
      type: Boolean,
      default: false
    },
    hideLoading: {
      type: Boolean,
      default: false
    },
    popperAppendToBody: {
      type: Boolean,
      default: true
    },
    highlightFirstItem: {
      type: Boolean,
      default: false
    }
  },
  emits: [UPDATE_MODEL_EVENT, "input", "change", "focus", "blur", "clear", "select"],
  setup(props2, ctx2) {
    const attrs = useAttrs();
    const suggestions = ref([]);
    const highlightedIndex = ref(-1);
    const dropdownWidth = ref("");
    const activated = ref(false);
    const suggestionDisabled = ref(false);
    const loading = ref(false);
    const inputRef = ref(null);
    const regionRef = ref(null);
    const popper2 = ref(null);
    const id2 = computed(() => {
      return `el-autocomplete-${generateId()}`;
    });
    const suggestionVisible = computed(() => {
      const isValidData = isArray$9(suggestions.value) && suggestions.value.length > 0;
      return (isValidData || loading.value) && activated.value;
    });
    const suggestionLoading = computed(() => {
      return !props2.hideLoading && loading.value;
    });
    const updatePopperPosition = () => {
      nextTick(popper2.value.update);
    };
    watch(suggestionVisible, () => {
      dropdownWidth.value = `${inputRef.value.$el.offsetWidth}px`;
    });
    onMounted(() => {
      inputRef.value.inputOrTextarea.setAttribute("role", "textbox");
      inputRef.value.inputOrTextarea.setAttribute("aria-autocomplete", "list");
      inputRef.value.inputOrTextarea.setAttribute("aria-controls", "id");
      inputRef.value.inputOrTextarea.setAttribute("aria-activedescendant", `${id2.value}-item-${highlightedIndex.value}`);
      const $ul = regionRef.value.querySelector(".el-autocomplete-suggestion__list");
      $ul.setAttribute("role", "listbox");
      $ul.setAttribute("id", id2.value);
    });
    onUpdated(updatePopperPosition);
    const getData = (queryString) => {
      if (suggestionDisabled.value) {
        return;
      }
      loading.value = true;
      updatePopperPosition();
      props2.fetchSuggestions(queryString, (suggestionsArg) => {
        loading.value = false;
        if (suggestionDisabled.value) {
          return;
        }
        if (isArray$9(suggestionsArg)) {
          suggestions.value = suggestionsArg;
          highlightedIndex.value = props2.highlightFirstItem ? 0 : -1;
        } else {
          throwError("ElAutocomplete", "autocomplete suggestions must be an array");
        }
      });
    };
    const debouncedGetData = debounce_1(getData, props2.debounce);
    const handleInput = (value2) => {
      ctx2.emit("input", value2);
      ctx2.emit(UPDATE_MODEL_EVENT, value2);
      suggestionDisabled.value = false;
      if (!props2.triggerOnFocus && !value2) {
        suggestionDisabled.value = true;
        suggestions.value = [];
        return;
      }
      debouncedGetData(value2);
    };
    const handleChange = (value2) => {
      ctx2.emit("change", value2);
    };
    const handleFocus = (e) => {
      activated.value = true;
      ctx2.emit("focus", e);
      if (props2.triggerOnFocus) {
        debouncedGetData(props2.modelValue);
      }
    };
    const handleBlur = (e) => {
      ctx2.emit("blur", e);
    };
    const handleClear = () => {
      activated.value = false;
      ctx2.emit(UPDATE_MODEL_EVENT, "");
      ctx2.emit("clear");
    };
    const handleKeyEnter = () => {
      if (suggestionVisible.value && highlightedIndex.value >= 0 && highlightedIndex.value < suggestions.value.length) {
        select(suggestions.value[highlightedIndex.value]);
      } else if (props2.selectWhenUnmatched) {
        ctx2.emit("select", { value: props2.modelValue });
        nextTick(() => {
          suggestions.value = [];
          highlightedIndex.value = -1;
        });
      }
    };
    const close2 = () => {
      activated.value = false;
    };
    const focus = () => {
      inputRef.value.focus();
    };
    const select = (item) => {
      ctx2.emit("input", item[props2.valueKey]);
      ctx2.emit(UPDATE_MODEL_EVENT, item[props2.valueKey]);
      ctx2.emit("select", item);
      nextTick(() => {
        suggestions.value = [];
        highlightedIndex.value = -1;
      });
    };
    const highlight = (index2) => {
      if (!suggestionVisible.value || loading.value) {
        return;
      }
      if (index2 < 0) {
        highlightedIndex.value = -1;
        return;
      }
      if (index2 >= suggestions.value.length) {
        index2 = suggestions.value.length - 1;
      }
      const suggestion = regionRef.value.querySelector(".el-autocomplete-suggestion__wrap");
      const suggestionList = suggestion.querySelectorAll(".el-autocomplete-suggestion__list li");
      const highlightItem = suggestionList[index2];
      const scrollTop = suggestion.scrollTop;
      const { offsetTop, scrollHeight } = highlightItem;
      if (offsetTop + scrollHeight > scrollTop + suggestion.clientHeight) {
        suggestion.scrollTop += scrollHeight;
      }
      if (offsetTop < scrollTop) {
        suggestion.scrollTop -= scrollHeight;
      }
      highlightedIndex.value = index2;
      inputRef.value.inputOrTextarea.setAttribute("aria-activedescendant", `${id2.value}-item-${highlightedIndex.value}`);
    };
    return {
      attrs,
      suggestions,
      highlightedIndex,
      dropdownWidth,
      activated,
      suggestionDisabled,
      loading,
      inputRef,
      regionRef,
      popper: popper2,
      id: id2,
      suggestionVisible,
      suggestionLoading,
      getData,
      handleInput,
      handleChange,
      handleFocus,
      handleBlur,
      handleClear,
      handleKeyEnter,
      close: close2,
      focus,
      select,
      highlight
    };
  }
});
const _hoisted_1$1b = ["aria-expanded", "aria-owns"];
const _hoisted_2$_ = { key: 0 };
const _hoisted_3$V = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-loading" }, null, -1);
const _hoisted_4$H = [
  _hoisted_3$V
];
const _hoisted_5$A = ["id", "aria-selected", "onClick"];
function render$U(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "popper",
    visible: _ctx.suggestionVisible,
    "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => _ctx.suggestionVisible = $event),
    placement: _ctx.placement,
    "popper-class": `el-autocomplete__popper ${_ctx.popperClass}`,
    "append-to-body": _ctx.popperAppendToBody,
    pure: "",
    "manual-mode": "",
    effect: "light",
    trigger: "click",
    transition: "el-zoom-in-top",
    "gpu-acceleration": false
  }, {
    trigger: withCtx(() => [
      withDirectives(createElementVNode("div", {
        class: normalizeClass(["el-autocomplete", _ctx.$attrs.class]),
        style: normalizeStyle(_ctx.$attrs.style),
        role: "combobox",
        "aria-haspopup": "listbox",
        "aria-expanded": _ctx.suggestionVisible,
        "aria-owns": _ctx.id
      }, [
        createVNode(_component_el_input, mergeProps({ ref: "inputRef" }, _ctx.attrs, {
          "model-value": _ctx.modelValue,
          onInput: _ctx.handleInput,
          onChange: _ctx.handleChange,
          onFocus: _ctx.handleFocus,
          onBlur: _ctx.handleBlur,
          onClear: _ctx.handleClear,
          onKeydown: [
            _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.highlight(_ctx.highlightedIndex - 1), ["prevent"]), ["up"])),
            _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.highlight(_ctx.highlightedIndex + 1), ["prevent"]), ["down"])),
            withKeys(_ctx.handleKeyEnter, ["enter"]),
            withKeys(_ctx.close, ["tab"])
          ]
        }), createSlots({ _: 2 }, [
          _ctx.$slots.prepend ? {
            name: "prepend",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prepend")
            ])
          } : void 0,
          _ctx.$slots.append ? {
            name: "append",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "append")
            ])
          } : void 0,
          _ctx.$slots.prefix ? {
            name: "prefix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prefix")
            ])
          } : void 0,
          _ctx.$slots.suffix ? {
            name: "suffix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "suffix")
            ])
          } : void 0
        ]), 1040, ["model-value", "onInput", "onChange", "onFocus", "onBlur", "onClear", "onKeydown"])
      ], 14, _hoisted_1$1b), [
        [_directive_clickoutside, _ctx.close]
      ])
    ]),
    default: withCtx(() => [
      createElementVNode("div", {
        ref: "regionRef",
        class: normalizeClass(["el-autocomplete-suggestion", _ctx.suggestionLoading && "is-loading"]),
        style: normalizeStyle({ width: _ctx.dropdownWidth, outline: "none" }),
        role: "region"
      }, [
        createVNode(_component_el_scrollbar, {
          tag: "ul",
          "wrap-class": "el-autocomplete-suggestion__wrap",
          "view-class": "el-autocomplete-suggestion__list"
        }, {
          default: withCtx(() => [
            _ctx.suggestionLoading ? (openBlock(), createElementBlock("li", _hoisted_2$_, _hoisted_4$H)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.suggestions, (item, index2) => {
              return openBlock(), createElementBlock("li", {
                id: `${_ctx.id}-item-${index2}`,
                key: index2,
                class: normalizeClass({ "highlighted": _ctx.highlightedIndex === index2 }),
                role: "option",
                "aria-selected": _ctx.highlightedIndex === index2,
                onClick: ($event) => _ctx.select(item)
              }, [
                renderSlot(_ctx.$slots, "default", { item }, () => [
                  createTextVNode(toDisplayString(item[_ctx.valueKey]), 1)
                ])
              ], 10, _hoisted_5$A);
            }), 128))
          ]),
          _: 3
        })
      ], 6)
    ]),
    _: 3
  }, 8, ["visible", "placement", "popper-class", "append-to-body"]);
}
script$W.render = render$U;
script$W.__file = "packages/components/autocomplete/src/workprogress.vue";
script$W.install = (app) => {
  app.component(script$W.name, script$W);
};
const _Autocomplete = script$W;
const ElAutocomplete = _Autocomplete;
const ERROR_EVENT = "error";
var script$V = defineComponent({
  name: "ElAvatar",
  props: {
    size: {
      type: [Number, String],
      validator(val) {
        if (typeof val === "string") {
          return ["large", "medium", "small"].includes(val);
        }
        return typeof val === "number";
      },
      default: "large"
    },
    shape: {
      type: String,
      default: "circle",
      validator(val) {
        return ["circle", "square"].includes(val);
      }
    },
    icon: String,
    src: {
      type: String,
      default: ""
    },
    alt: String,
    srcSet: String,
    fit: {
      type: String,
      default: "cover"
    }
  },
  emits: [ERROR_EVENT],
  setup(props2, { emit: emit2 }) {
    const hasLoadError = ref(false);
    const src = toRef(props2, "src");
    watch(src, () => {
      hasLoadError.value = false;
    });
    const avatarClass = computed(() => {
      const { size, icon, shape } = props2;
      const classList = ["el-avatar"];
      if (size && typeof size === "string") {
        classList.push(`el-avatar--${size}`);
      }
      if (icon) {
        classList.push("el-avatar--icon");
      }
      if (shape) {
        classList.push(`el-avatar--${shape}`);
      }
      return classList;
    });
    const sizeStyle = computed(() => {
      const { size } = props2;
      return typeof size === "number" ? {
        height: `${size}px`,
        width: `${size}px`,
        lineHeight: `${size}px`
      } : {};
    });
    const fitStyle = computed(() => ({
      objectFit: props2.fit
    }));
    function handleError(e) {
      hasLoadError.value = true;
      emit2(ERROR_EVENT, e);
    }
    return {
      hasLoadError,
      avatarClass,
      sizeStyle,
      handleError,
      fitStyle
    };
  }
});
const _hoisted_1$1a = ["src", "alt", "srcset"];
function render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(_ctx.avatarClass),
    style: normalizeStyle(_ctx.sizeStyle)
  }, [
    (_ctx.src || _ctx.srcSet) && !_ctx.hasLoadError ? (openBlock(), createElementBlock("img", {
      key: 0,
      src: _ctx.src,
      alt: _ctx.alt,
      srcset: _ctx.srcSet,
      style: normalizeStyle(_ctx.fitStyle),
      onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args))
    }, null, 44, _hoisted_1$1a)) : _ctx.icon ? (openBlock(), createElementBlock("i", {
      key: 1,
      class: normalizeClass(_ctx.icon)
    }, null, 2)) : renderSlot(_ctx.$slots, "default", { key: 2 })
  ], 6);
}
script$V.render = render$T;
script$V.__file = "packages/components/avatar/src/workprogress.vue";
script$V.install = (app) => {
  app.component(script$V.name, script$V);
};
const _Avatar = script$V;
const ElAvatar = _Avatar;
var debounce = debounce_1, isObject$5 = isObject_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function throttle$1(func, wait, options2) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  if (isObject$5(options2)) {
    leading = "leading" in options2 ? !!options2.leading : leading;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle$1;
const cubic = (value2) => Math.pow(value2, 3);
const easeInOutCubic = (value2) => value2 < 0.5 ? cubic(value2 * 2) / 2 : 1 - cubic((1 - value2) * 2) / 2;
var script$U = defineComponent({
  name: "ElBacktop",
  props: {
    visibilityHeight: {
      type: Number,
      default: 200
    },
    target: {
      type: String,
      default: ""
    },
    right: {
      type: Number,
      default: 40
    },
    bottom: {
      type: Number,
      default: 40
    }
  },
  emits: ["click"],
  setup(props2, ctx2) {
    const el = ref(null);
    const container = ref(null);
    const visible2 = ref(false);
    const styleBottom = computed(() => `${props2.bottom}px`);
    const styleRight = computed(() => `${props2.right}px`);
    const scope = "ElBackTop";
    const scrollToTop = () => {
      const beginTime = Date.now();
      const beginValue = el.value.scrollTop;
      const rAF2 = window.requestAnimationFrame || ((func) => setTimeout(func, 16));
      const frameFunc = () => {
        const progress = (Date.now() - beginTime) / 500;
        if (progress < 1) {
          el.value.scrollTop = beginValue * (1 - easeInOutCubic(progress));
          rAF2(frameFunc);
        } else {
          el.value.scrollTop = 0;
        }
      };
      rAF2(frameFunc);
    };
    const onScroll = () => {
      visible2.value = el.value.scrollTop >= props2.visibilityHeight;
    };
    const handleClick = (event2) => {
      scrollToTop();
      ctx2.emit("click", event2);
    };
    const throttledScrollHandler = throttle_1(onScroll, 300);
    onMounted(() => {
      container.value = document;
      el.value = document.documentElement;
      if (props2.target) {
        el.value = document.querySelector(props2.target);
        if (!el.value) {
          throwError(scope, `target is not existed: ${props2.target}`);
        }
        container.value = el.value;
      }
      on$2(container.value, "scroll", throttledScrollHandler);
    });
    onBeforeUnmount(() => {
      off$2(container.value, "scroll", throttledScrollHandler);
    });
    return {
      el,
      container,
      visible: visible2,
      styleBottom,
      styleRight,
      handleClick
    };
  }
});
const _hoisted_1$19 = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-caret-top" }, null, -1);
function render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, { name: "el-fade-in" }, {
    default: withCtx(() => [
      _ctx.visible ? (openBlock(), createElementBlock("div", {
        key: 0,
        style: normalizeStyle({
          "right": _ctx.styleRight,
          "bottom": _ctx.styleBottom
        }),
        class: "el-backtop",
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          _hoisted_1$19
        ])
      ], 4)) : createCommentVNode("v-if", true)
    ]),
    _: 3
  });
}
script$U.render = render$S;
script$U.__file = "packages/components/backtop/src/workprogress.vue";
script$U.install = (app) => {
  app.component(script$U.name, script$U);
};
const _Backtop = script$U;
const ElBacktop = _Backtop;
var script$T = defineComponent({
  name: "ElBadge",
  props: {
    value: {
      type: [String, Number],
      default: ""
    },
    max: {
      type: Number,
      default: 99
    },
    isDot: Boolean,
    hidden: Boolean,
    type: {
      type: String,
      default: "primary",
      validator: (val) => {
        return ["primary", "success", "warning", "info", "danger"].includes(val);
      }
    }
  },
  setup(props2) {
    const content = computed(() => {
      if (props2.isDot) {
        return;
      }
      if (typeof props2.value === "number" && typeof props2.max === "number") {
        return props2.max < props2.value ? `${props2.max}+` : props2.value;
      }
      return props2.value;
    });
    return {
      content
    };
  }
});
const _hoisted_1$18 = { class: "el-badge" };
const _hoisted_2$Z = ["textContent"];
function render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$18, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(Transition, { name: "el-zoom-in-center" }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("sup", {
          class: normalizeClass(["el-badge__content", [
            _ctx.isDot ? "is-dot" : "el-badge__content--" + _ctx.type,
            {
              "is-fixed": _ctx.$slots.default
            }
          ]]),
          textContent: toDisplayString(_ctx.content)
        }, null, 10, _hoisted_2$Z), [
          [vShow, !_ctx.hidden && (_ctx.content || _ctx.content === 0 || _ctx.isDot)]
        ])
      ]),
      _: 1
    })
  ]);
}
script$T.render = render$R;
script$T.__file = "packages/components/badge/src/workprogress.vue";
script$T.install = (app) => {
  app.component(script$T.name, script$T);
};
const _Badge = script$T;
const ElBadge = _Badge;
var script$S = defineComponent({
  name: "ElBreadcrumb",
  props: {
    separator: {
      type: String,
      default: "/"
    },
    separatorClass: {
      type: String,
      default: ""
    }
  },
  setup(props2) {
    const breadcrumb = ref(null);
    provide("breadcrumb", props2);
    onMounted(() => {
      const items = breadcrumb.value.querySelectorAll(".el-breadcrumb__item");
      if (items.length) {
        items[items.length - 1].setAttribute("aria-current", "page");
      }
    });
    return {
      breadcrumb
    };
  }
});
const _hoisted_1$17 = {
  ref: "breadcrumb",
  class: "el-breadcrumb",
  "aria-label": "Breadcrumb",
  role: "navigation"
};
function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$17, [
    renderSlot(_ctx.$slots, "default")
  ], 512);
}
script$S.render = render$Q;
script$S.__file = "packages/components/breadcrumb/src/workprogress.vue";
var script$1$u = defineComponent({
  name: "ElBreadcrumbItem",
  props: {
    to: {
      type: [String, Object],
      default: ""
    },
    replace: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const link = ref(null);
    const parent2 = inject("breadcrumb");
    const instance = getCurrentInstance();
    const router = instance.appContext.config.globalProperties.$router;
    onMounted(() => {
      link.value.setAttribute("role", "link");
      link.value.addEventListener("click", () => {
        if (!props2.to || !router)
          return;
        props2.replace ? router.replace(props2.to) : router.push(props2.to);
      });
    });
    return {
      link,
      separator: parent2 == null ? void 0 : parent2.separator,
      separatorClass: parent2 == null ? void 0 : parent2.separatorClass
    };
  }
});
const _hoisted_1$1$n = { class: "el-breadcrumb__item" };
const _hoisted_2$Y = {
  key: 1,
  class: "el-breadcrumb__separator",
  role: "presentation"
};
function render$1$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", _hoisted_1$1$n, [
    createElementVNode("span", {
      ref: "link",
      class: normalizeClass(["el-breadcrumb__inner", _ctx.to ? "is-link" : ""]),
      role: "link"
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2),
    _ctx.separatorClass ? (openBlock(), createElementBlock("i", {
      key: 0,
      class: normalizeClass(["el-breadcrumb__separator", _ctx.separatorClass])
    }, null, 2)) : (openBlock(), createElementBlock("span", _hoisted_2$Y, toDisplayString(_ctx.separator), 1))
  ]);
}
script$1$u.render = render$1$t;
script$1$u.__file = "packages/components/breadcrumb/src/item.vue";
script$S.install = (app) => {
  app.component(script$S.name, script$S);
  app.component(script$1$u.name, script$1$u);
};
script$S.BreadcrumbItem = script$1$u;
const _Breadcrumb = script$S;
const ElBreadcrumb = _Breadcrumb;
var script$R = defineComponent({
  name: "ElButton",
  props: {
    type: {
      type: String,
      default: "default",
      validator: (val) => {
        return [
          "default",
          "primary",
          "success",
          "warning",
          "info",
          "danger",
          "text"
        ].includes(val);
      }
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    icon: {
      type: String,
      default: ""
    },
    nativeType: {
      type: String,
      default: "button",
      validator: (val) => {
        return ["button", "submit", "reset"].includes(val);
      }
    },
    loading: Boolean,
    disabled: Boolean,
    plain: Boolean,
    autofocus: Boolean,
    round: Boolean,
    circle: Boolean
  },
  emits: ["click"],
  setup(props2, { emit: emit2 }) {
    const $ELEMENT2 = useGlobalConfig();
    const elForm = inject(elFormKey, {});
    const elFormItem = inject(elFormItemKey, {});
    const buttonSize = computed(() => {
      return props2.size || elFormItem.size || $ELEMENT2.size;
    });
    const buttonDisabled = computed(() => {
      return props2.disabled || elForm.disabled;
    });
    const handleClick = (evt) => {
      emit2("click", evt);
    };
    return {
      buttonSize,
      buttonDisabled,
      handleClick
    };
  }
});
const _hoisted_1$16 = ["disabled", "autofocus", "type"];
const _hoisted_2$X = {
  key: 0,
  class: "el-icon-loading"
};
const _hoisted_3$U = { key: 2 };
function render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: normalizeClass([
      "el-button",
      _ctx.type ? "el-button--" + _ctx.type : "",
      _ctx.buttonSize ? "el-button--" + _ctx.buttonSize : "",
      {
        "is-disabled": _ctx.buttonDisabled,
        "is-loading": _ctx.loading,
        "is-plain": _ctx.plain,
        "is-round": _ctx.round,
        "is-circle": _ctx.circle
      }
    ]),
    disabled: _ctx.buttonDisabled || _ctx.loading,
    autofocus: _ctx.autofocus,
    type: _ctx.nativeType,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.loading ? (openBlock(), createElementBlock("i", _hoisted_2$X)) : createCommentVNode("v-if", true),
    _ctx.icon && !_ctx.loading ? (openBlock(), createElementBlock("i", {
      key: 1,
      class: normalizeClass(_ctx.icon)
    }, null, 2)) : createCommentVNode("v-if", true),
    _ctx.$slots.default ? (openBlock(), createElementBlock("span", _hoisted_3$U, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$16);
}
script$R.render = render$P;
script$R.__file = "packages/components/button/src/button.vue";
var script$1$t = defineComponent({
  name: "ElButtonGroup"
});
const _hoisted_1$1$m = { class: "el-button-group" };
function render$1$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1$m, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$1$t.render = render$1$s;
script$1$t.__file = "packages/components/button/src/button-group.vue";
script$R.install = (app) => {
  app.component(script$R.name, script$R);
  app.component(script$1$t.name, script$1$t);
};
script$R.ButtonGroup = script$1$t;
const _Button = script$R;
const ElButton = _Button;
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i2 = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h2 = "quarter", c = "year", d = "date", $2 = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, g = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i3 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i3, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date())
        return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i3 = e2.clone().add(r2, f), s2 = n2 - i3 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
      return +(-(r2 + (n2 - i3) / (s2 ? i3 - u2 : u2 - i3)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i2, ms: r, Q: h2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === void 0;
    } }, D = "en", v = {};
    v[D] = M;
    var p = function(t2) {
      return t2 instanceof _;
    }, S = function(t2, e2, n2) {
      var r2;
      if (!t2)
        return D;
      if (typeof t2 == "string")
        v[t2] && (r2 = t2), e2 && (v[t2] = e2, r2 = t2);
      else {
        var i3 = t2.name;
        v[i3] = t2, r2 = i3;
      }
      return !n2 && r2 && (D = r2), r2 || !n2 && D;
    }, w = function(t2, e2) {
      if (p(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _(n2);
    }, O = g;
    O.l = S, O.i = p, O.w = function(t2, e2) {
      return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = S(t2.locale, null, true), this.parse(t2);
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (e2 === null)
            return new Date(NaN);
          if (O.u(e2))
            return new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match(l);
            if (r2) {
              var i3 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return O;
      }, m2.isValid = function() {
        return !(this.$d.toString() === $2);
      }, m2.isSame = function(t2, e2) {
        var n2 = w(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return w(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < w(t2);
      }, m2.$g = function(t2, e2, n2) {
        return O.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!O.u(e2) || e2, h3 = O.p(t2), $3 = function(t3, e3) {
          var i3 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i3 : i3.endOf(a);
        }, l2 = function(t3, e3) {
          return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c:
            return r2 ? $3(1, 0) : $3(31, 11);
          case f:
            return r2 ? $3(1, M3) : $3(0, M3 + 1);
          case o:
            var D2 = this.$locale().weekStart || 0, v2 = (y2 < D2 ? y2 + 7 : y2) - D2;
            return $3(r2 ? m3 - v2 : m3 + (6 - v2), M3);
          case a:
          case d:
            return l2(g2 + "Hours", 0);
          case u:
            return l2(g2 + "Minutes", 1);
          case s:
            return l2(g2 + "Seconds", 2);
          case i2:
            return l2(g2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = O.p(t2), h3 = "set" + (this.$u ? "UTC" : ""), $3 = (n2 = {}, n2[a] = h3 + "Date", n2[d] = h3 + "Date", n2[f] = h3 + "Month", n2[c] = h3 + "FullYear", n2[u] = h3 + "Hours", n2[s] = h3 + "Minutes", n2[i2] = h3 + "Seconds", n2[r] = h3 + "Milliseconds", n2)[o2], l2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === f || o2 === c) {
          var y2 = this.clone().set(d, 1);
          y2.$d[$3](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          $3 && this.$d[$3](l2);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[O.p(t2)]();
      }, m2.add = function(r2, h3) {
        var d2, $3 = this;
        r2 = Number(r2);
        var l2 = O.p(h3), y2 = function(t2) {
          var e2 = w($3);
          return O.w(e2.date(e2.date() + Math.round(t2 * r2)), $3);
        };
        if (l2 === f)
          return this.set(f, this.$M + r2);
        if (l2 === c)
          return this.set(c, this.$y + r2);
        if (l2 === a)
          return y2(1);
        if (l2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i2] = t, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return O.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || $2;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h3 = function(t3, n3, i4, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i4[n3].substr(0, s3);
        }, c2 = function(t3) {
          return O.s(s2 % 12 || 12, t3, "0");
        }, d2 = n2.meridiem || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h3(n2.monthsShort, a2, f2, 3), MMMM: h3(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n2.weekdaysMin, this.$W, o2, 2), ddd: h3(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i3 };
        return r2.replace(y, function(t3, e3) {
          return e3 || l2[t3] || i3.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, $3) {
        var l2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, D2 = O.m(this, M3);
        return D2 = (l2 = {}, l2[c] = D2 / 12, l2[f] = D2, l2[h2] = D2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n, l2[s] = g2 / e, l2[i2] = g2 / t, l2)[y2] || g2, $3 ? D2 : O.a(D2);
      }, m2.daysInMonth = function() {
        return this.endOf(f).$D;
      }, m2.$locale = function() {
        return v[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return O.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), b = _.prototype;
    return w.prototype = b, [["$ms", r], ["$s", i2], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
      b[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), w.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _, w), t2.$i = true), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
      return w(1e3 * t2);
    }, w.en = v[D], w.Ls = v, w.p = {}, w;
  });
})(dayjs_min);
var dayjs = dayjs_min.exports;
var localeData$1 = { exports: {} };
(function(module, exports) {
  !function(n, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    return function(n, e, t) {
      var r = e.prototype, o = function(n2) {
        return n2 && (n2.indexOf ? n2 : n2.s);
      }, u = function(n2, e2, t2, r2, u2) {
        var i3 = n2.name ? n2 : n2.$locale(), a2 = o(i3[e2]), s2 = o(i3[t2]), f = a2 || s2.map(function(n3) {
          return n3.substr(0, r2);
        });
        if (!u2)
          return f;
        var d = i3.weekStart;
        return f.map(function(n3, e3) {
          return f[(e3 + (d || 0)) % 7];
        });
      }, i2 = function() {
        return t.Ls[t.locale()];
      }, a = function(n2, e2) {
        return n2.formats[e2] || function(n3) {
          return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
            return e3 || t2.slice(1);
          });
        }(n2.formats[e2.toUpperCase()]);
      }, s = function() {
        var n2 = this;
        return { months: function(e2) {
          return e2 ? e2.format("MMMM") : u(n2, "months");
        }, monthsShort: function(e2) {
          return e2 ? e2.format("MMM") : u(n2, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return n2.$locale().weekStart || 0;
        }, weekdays: function(e2) {
          return e2 ? e2.format("dddd") : u(n2, "weekdays");
        }, weekdaysMin: function(e2) {
          return e2 ? e2.format("dd") : u(n2, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(e2) {
          return e2 ? e2.format("ddd") : u(n2, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(e2) {
          return a(n2.$locale(), e2);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      r.localeData = function() {
        return s.bind(this)();
      }, t.localeData = function() {
        var n2 = i2();
        return { firstDayOfWeek: function() {
          return n2.weekStart || 0;
        }, weekdays: function() {
          return t.weekdays();
        }, weekdaysShort: function() {
          return t.weekdaysShort();
        }, weekdaysMin: function() {
          return t.weekdaysMin();
        }, months: function() {
          return t.months();
        }, monthsShort: function() {
          return t.monthsShort();
        }, longDateFormat: function(e2) {
          return a(n2, e2);
        }, meridiem: n2.meridiem, ordinal: n2.ordinal };
      }, t.months = function() {
        return u(i2(), "months");
      }, t.monthsShort = function() {
        return u(i2(), "monthsShort", "months", 3);
      }, t.weekdays = function(n2) {
        return u(i2(), "weekdays", null, null, n2);
      }, t.weekdaysShort = function(n2) {
        return u(i2(), "weekdaysShort", "weekdays", 3, n2);
      }, t.weekdaysMin = function(n2) {
        return u(i2(), "weekdaysMin", "weekdays", 2, n2);
      };
    };
  });
})(localeData$1);
var localeData = localeData$1.exports;
var customParseFormat$1 = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, e = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i2 = /\d*[^\s\d-_:/()]+/, o = {}, s = function(t2) {
      return (t2 = +t2) + (t2 > 68 ? 1900 : 2e3);
    };
    var a = function(t2) {
      return function(e2) {
        this[t2] = +e2;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(t2) {
      (this.zone || (this.zone = {})).offset = function(t3) {
        if (!t3)
          return 0;
        if (t3 === "Z")
          return 0;
        var e2 = t3.match(/([+-]|\d\d)/g), n2 = 60 * e2[1] + (+e2[2] || 0);
        return n2 === 0 ? 0 : e2[0] === "+" ? -n2 : n2;
      }(t2);
    }], u = function(t2) {
      var e2 = o[t2];
      return e2 && (e2.indexOf ? e2 : e2.s.concat(e2.f));
    }, h2 = function(t2, e2) {
      var n2, r2 = o.meridiem;
      if (r2) {
        for (var i3 = 1; i3 <= 24; i3 += 1)
          if (t2.indexOf(r2(i3, 0, e2)) > -1) {
            n2 = i3 > 12;
            break;
          }
      } else
        n2 = t2 === (e2 ? "pm" : "PM");
      return n2;
    }, d = { A: [i2, function(t2) {
      this.afternoon = h2(t2, false);
    }], a: [i2, function(t2) {
      this.afternoon = h2(t2, true);
    }], S: [/\d/, function(t2) {
      this.milliseconds = 100 * +t2;
    }], SS: [n, function(t2) {
      this.milliseconds = 10 * +t2;
    }], SSS: [/\d{3}/, function(t2) {
      this.milliseconds = +t2;
    }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i2, function(t2) {
      var e2 = o.ordinal, n2 = t2.match(/\d+/);
      if (this.day = n2[0], e2)
        for (var r2 = 1; r2 <= 31; r2 += 1)
          e2(r2).replace(/\[|\]/g, "") === t2 && (this.day = r2);
    }], M: [r, a("month")], MM: [n, a("month")], MMM: [i2, function(t2) {
      var e2 = u("months"), n2 = (u("monthsShort") || e2.map(function(t3) {
        return t3.substr(0, 3);
      })).indexOf(t2) + 1;
      if (n2 < 1)
        throw new Error();
      this.month = n2 % 12 || n2;
    }], MMMM: [i2, function(t2) {
      var e2 = u("months").indexOf(t2) + 1;
      if (e2 < 1)
        throw new Error();
      this.month = e2 % 12 || e2;
    }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(t2) {
      this.year = s(t2);
    }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
    function c(n2) {
      var r2, i3;
      r2 = n2, i3 = o && o.formats;
      for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(e2, n3, r3) {
        var o2 = r3 && r3.toUpperCase();
        return n3 || i3[r3] || t[r3] || i3[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(t2, e3, n4) {
          return e3 || n4.slice(1);
        });
      })).match(e), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
        var u2 = s2[f2], h3 = d[u2], c2 = h3 && h3[0], l = h3 && h3[1];
        s2[f2] = l ? { regex: c2, parser: l } : u2.replace(/^\[|\]$/g, "");
      }
      return function(t2) {
        for (var e2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
          var i4 = s2[n3];
          if (typeof i4 == "string")
            r3 += i4.length;
          else {
            var o2 = i4.regex, f3 = i4.parser, u3 = t2.substr(r3), h4 = o2.exec(u3)[0];
            f3.call(e2, h4), t2 = t2.replace(h4, "");
          }
        }
        return function(t3) {
          var e3 = t3.afternoon;
          if (e3 !== void 0) {
            var n4 = t3.hours;
            e3 ? n4 < 12 && (t3.hours += 12) : n4 === 12 && (t3.hours = 0), delete t3.afternoon;
          }
        }(e2), e2;
      };
    }
    return function(t2, e2, n2) {
      n2.p.customParseFormat = true, t2 && t2.parseTwoDigitYear && (s = t2.parseTwoDigitYear);
      var r2 = e2.prototype, i3 = r2.parse;
      r2.parse = function(t3) {
        var e3 = t3.date, r3 = t3.utc, s2 = t3.args;
        this.$u = r3;
        var a2 = s2[1];
        if (typeof a2 == "string") {
          var f2 = s2[2] === true, u2 = s2[3] === true, h3 = f2 || u2, d2 = s2[2];
          u2 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(t4, e4, n3) {
            try {
              if (["x", "X"].indexOf(e4) > -1)
                return new Date((e4 === "X" ? 1e3 : 1) * t4);
              var r4 = c(e4)(t4), i4 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, u3 = r4.seconds, h4 = r4.milliseconds, d3 = r4.zone, l2 = new Date(), m2 = s3 || (i4 || o2 ? 1 : l2.getDate()), M2 = i4 || l2.getFullYear(), Y = 0;
              i4 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
              var p = a3 || 0, v = f3 || 0, D = u3 || 0, g = h4 || 0;
              return d3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g + 60 * d3.offset * 1e3)) : n3 ? new Date(Date.UTC(M2, Y, m2, p, v, D, g)) : new Date(M2, Y, m2, p, v, D, g);
            } catch (t5) {
              return new Date("");
            }
          }(e3, a2, r3), this.init(), d2 && d2 !== true && (this.$L = this.locale(d2).$L), h3 && e3 !== this.format(a2) && (this.$d = new Date("")), o = {};
        } else if (a2 instanceof Array)
          for (var l = a2.length, m = 1; m <= l; m += 1) {
            s2[1] = a2[m - 1];
            var M = n2.apply(this, s2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === l && (this.$d = new Date(""));
          }
        else
          i3.call(this, t3);
      };
    };
  });
})(customParseFormat$1);
var customParseFormat = customParseFormat$1.exports;
var baseIsEqual = _baseIsEqual;
function isEqual(value2, other) {
  return baseIsEqual(value2, other);
}
var isEqual_1 = isEqual;
var Symbol$2 = _Symbol, isArguments = isArguments_1, isArray$4 = isArray_1;
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable$1(value2) {
  return isArray$4(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush$1 = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array3, depth, predicate, isStrict, result) {
  var index2 = -1, length = array3.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value2 = array3[index2];
    if (depth > 0 && predicate(value2)) {
      if (depth > 1) {
        baseFlatten$1(value2, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush$1(result, value2);
      }
    } else if (!isStrict) {
      result[result.length] = value2;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
function identity$2(value2) {
  return value2;
}
var identity_1 = identity$2;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$1(func, start2, transform) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array3 = Array(length);
    while (++index2 < length) {
      array3[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array3);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$1(value2) {
  return function() {
    return value2;
  };
}
var constant_1 = constant$1;
var getNative = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty$1 = defineProperty$2;
var constant = constant_1, defineProperty$1 = _defineProperty$1, identity$1 = identity_1;
var baseSetToString$1 = !defineProperty$1 ? identity$1 : function(func, string2) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string2),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;
var identity = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func, start2) {
  return setToString(overRest(func, start2, identity), func + "");
}
var _baseRest = baseRest$1;
function baseFindIndex$1(array3, predicate, fromIndex, fromRight) {
  var length = array3.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array3[index2], index2, array3)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$1;
function baseIsNaN$1(value2) {
  return value2 !== value2;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array3, value2, fromIndex) {
  var index2 = fromIndex - 1, length = array3.length;
  while (++index2 < length) {
    if (array3[index2] === value2) {
      return index2;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(array3, value2, fromIndex) {
  return value2 === value2 ? strictIndexOf(array3, value2, fromIndex) : baseFindIndex(array3, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$1;
var baseIndexOf = _baseIndexOf;
function arrayIncludes$1(array3, value2) {
  var length = array3 == null ? 0 : array3.length;
  return !!length && baseIndexOf(array3, value2, 0) > -1;
}
var _arrayIncludes = arrayIncludes$1;
function arrayIncludesWith$1(array3, value2, comparator) {
  var index2 = -1, length = array3 == null ? 0 : array3.length;
  while (++index2 < length) {
    if (comparator(value2, array3[index2])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$1;
function noop$1() {
}
var noop_1 = noop$1;
var Set$1 = _Set, noop = noop_1, setToArray$1 = _setToArray;
var INFINITY = 1 / 0;
var createSet$1 = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY) ? noop : function(values) {
  return new Set$1(values);
};
var _createSet = createSet$1;
var SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray;
var LARGE_ARRAY_SIZE = 200;
function baseUniq$1(array3, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length = array3.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set2 = iteratee ? null : createSet(array3);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value2 = array3[index2], computed2 = iteratee ? iteratee(value2) : value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed2 === computed2) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed2) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed2);
        }
        result.push(value2);
      } else if (!includes(seen, computed2, comparator)) {
        if (seen !== result) {
          seen.push(computed2);
        }
        result.push(value2);
      }
    }
  return result;
}
var _baseUniq = baseUniq$1;
var isArrayLike$1 = isArrayLike_1, isObjectLike$2 = isObjectLike_1;
function isArrayLikeObject$1(value2) {
  return isObjectLike$2(value2) && isArrayLike$1(value2);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var baseFlatten = _baseFlatten, baseRest = _baseRest, baseUniq = _baseUniq, isArrayLikeObject = isArrayLikeObject_1;
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
var union_1 = union;
const DEFAULT_FORMATS_TIME = "HH:mm:ss";
const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
const DEFAULT_FORMATS_DATEPICKER = {
  date: DEFAULT_FORMATS_DATE,
  week: "gggg[w]ww",
  year: "YYYY",
  month: "YYYY-MM",
  datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
  monthrange: "YYYY-MM",
  daterange: DEFAULT_FORMATS_DATE,
  datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
};
const timePickerDefaultProps = {
  name: {
    type: [Array, String],
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: {
    type: String
  },
  valueFormat: {
    type: String
  },
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: String,
    default: "el-icon-circle-close"
  },
  editable: {
    type: Boolean,
    default: true
  },
  prefixIcon: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    validator: isValidComponentSize
  },
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: () => ({})
  },
  modelValue: {
    type: [Date, Array, String],
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: [Date, Array]
  },
  defaultTime: {
    type: [Date, Array]
  },
  isRange: {
    type: Boolean,
    default: false
  },
  disabledHours: {
    type: Function
  },
  disabledMinutes: {
    type: Function
  },
  disabledSeconds: {
    type: Function
  },
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: {
    type: Boolean,
    default: false
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  unlinkPanels: Boolean
};
const dateEquals = function(a, b) {
  const aIsDate = a instanceof Date;
  const bIsDate = b instanceof Date;
  if (aIsDate && bIsDate) {
    return a.getTime() === b.getTime();
  }
  if (!aIsDate && !bIsDate) {
    return a === b;
  }
  return false;
};
const valueEquals = function(a, b) {
  const aIsArray = a instanceof Array;
  const bIsArray = b instanceof Array;
  if (aIsArray && bIsArray) {
    if (a.length !== b.length) {
      return false;
    }
    return a.every((item, index2) => dateEquals(item, b[index2]));
  }
  if (!aIsArray && !bIsArray) {
    return dateEquals(a, b);
  }
  return false;
};
const parser = function(date3, format2, lang) {
  const day = isEmpty$1(format2) ? dayjs(date3).locale(lang) : dayjs(date3, format2).locale(lang);
  return day.isValid() ? day : void 0;
};
const formatter = function(date3, format2, lang) {
  return isEmpty$1(format2) ? date3 : dayjs(date3).locale(lang).format(format2);
};
var script$Q = defineComponent({
  name: "Picker",
  components: {
    ElInput: ElInput$1,
    ElPopper: ElPopper$1
  },
  directives: { clickoutside: ClickOutside$1 },
  props: timePickerDefaultProps,
  emits: ["update:modelValue", "change", "focus", "blur", "calendar-change"],
  setup(props2, ctx2) {
    const ELEMENT = useGlobalConfig();
    const { lang } = useLocaleInject();
    const elForm = inject(elFormKey, {});
    const elFormItem = inject(elFormItemKey, {});
    const elPopperOptions = inject("ElPopperOptions", {});
    const refPopper = ref(null);
    const pickerVisible = ref(false);
    const pickerActualVisible = ref(false);
    const valueOnOpen = ref(null);
    watch(pickerVisible, (val) => {
      var _a;
      if (!val) {
        userInput.value = null;
        nextTick(() => {
          emitChange(props2.modelValue);
        });
        ctx2.emit("blur");
        blurInput();
        props2.validateEvent && ((_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.blur"));
      } else {
        valueOnOpen.value = props2.modelValue;
      }
    });
    const emitChange = (val, isClear) => {
      var _a;
      if (isClear || !valueEquals(val, valueOnOpen.value)) {
        ctx2.emit("change", val);
        props2.validateEvent && ((_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", val));
      }
    };
    const emitInput = (val) => {
      if (!valueEquals(props2.modelValue, val)) {
        let formatValue;
        if (Array.isArray(val)) {
          formatValue = val.map((_) => formatter(_, props2.valueFormat, lang.value));
        } else if (val) {
          formatValue = formatter(val, props2.valueFormat, lang.value);
        }
        ctx2.emit("update:modelValue", val ? formatValue : val, lang.value);
      }
    };
    const refInput = computed(() => {
      if (refPopper.value.triggerRef) {
        const _r = isRangeInput.value ? refPopper.value.triggerRef : refPopper.value.triggerRef.$el;
        return [].slice.call(_r.querySelectorAll("input"));
      }
      return [];
    });
    const setSelectionRange = (start2, end2, pos) => {
      const _inputs = refInput.value;
      if (!_inputs.length)
        return;
      if (!pos || pos === "min") {
        _inputs[0].setSelectionRange(start2, end2);
        _inputs[0].focus();
      } else if (pos === "max") {
        _inputs[1].setSelectionRange(start2, end2);
        _inputs[1].focus();
      }
    };
    const onPick = (date3 = "", visible2 = false) => {
      pickerVisible.value = visible2;
      let result;
      if (Array.isArray(date3)) {
        result = date3.map((_) => _.toDate());
      } else {
        result = date3 ? date3.toDate() : date3;
      }
      userInput.value = null;
      emitInput(result);
    };
    const handleFocus = (e) => {
      if (props2.readonly || pickerDisabled.value || pickerVisible.value)
        return;
      pickerVisible.value = true;
      ctx2.emit("focus", e);
    };
    const handleBlur = () => {
      pickerVisible.value = false;
      blurInput();
    };
    const pickerDisabled = computed(() => {
      return props2.disabled || elForm.disabled;
    });
    const parsedValue = computed(() => {
      let result;
      if (valueIsEmpty.value) {
        if (pickerOptions.value.getDefaultValue) {
          result = pickerOptions.value.getDefaultValue();
        }
      } else {
        if (Array.isArray(props2.modelValue)) {
          result = props2.modelValue.map((_) => parser(_, props2.valueFormat, lang.value));
        } else {
          result = parser(props2.modelValue, props2.valueFormat, lang.value);
        }
      }
      if (pickerOptions.value.getRangeAvailableTime) {
        const availableResult = pickerOptions.value.getRangeAvailableTime(result);
        if (!isEqual_1(availableResult, result)) {
          result = availableResult;
          emitInput(Array.isArray(result) ? result.map((_) => _.toDate()) : result.toDate());
        }
      }
      if (Array.isArray(result) && result.some((_) => !_)) {
        result = [];
      }
      return result;
    });
    const displayValue = computed(() => {
      if (!pickerOptions.value.panelReady)
        return;
      const formattedValue = formatDayjsToString(parsedValue.value);
      if (Array.isArray(userInput.value)) {
        return [
          userInput.value[0] || formattedValue && formattedValue[0] || "",
          userInput.value[1] || formattedValue && formattedValue[1] || ""
        ];
      } else if (userInput.value !== null) {
        return userInput.value;
      }
      if (!isTimePicker.value && valueIsEmpty.value)
        return;
      if (!pickerVisible.value && valueIsEmpty.value)
        return;
      if (formattedValue) {
        return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
      }
      return "";
    });
    const isTimeLikePicker = computed(() => {
      return props2.type.indexOf("time") !== -1;
    });
    const isTimePicker = computed(() => {
      return props2.type.indexOf("time") === 0;
    });
    const isDatesPicker = computed(() => {
      return props2.type === "dates";
    });
    const triggerClass = computed(() => {
      return props2.prefixIcon || (isTimeLikePicker.value ? "el-icon-time" : "el-icon-date");
    });
    const showClose = ref(false);
    const onClearIconClick = (event2) => {
      if (props2.readonly || pickerDisabled.value)
        return;
      if (showClose.value) {
        event2.stopPropagation();
        emitInput(null);
        emitChange(null, true);
        showClose.value = false;
        pickerVisible.value = false;
        pickerOptions.value.handleClear && pickerOptions.value.handleClear();
      }
    };
    const valueIsEmpty = computed(() => {
      return !props2.modelValue || Array.isArray(props2.modelValue) && !props2.modelValue.length;
    });
    const onMouseEnter = () => {
      if (props2.readonly || pickerDisabled.value)
        return;
      if (!valueIsEmpty.value && props2.clearable) {
        showClose.value = true;
      }
    };
    const onMouseLeave = () => {
      showClose.value = false;
    };
    const isRangeInput = computed(() => {
      return props2.type.indexOf("range") > -1;
    });
    const pickerSize = computed(() => {
      return props2.size || elFormItem.size || ELEMENT.size;
    });
    const popperPaneRef = computed(() => {
      var _a;
      return (_a = refPopper.value) == null ? void 0 : _a.popperRef;
    });
    const onClickOutside = () => {
      if (!pickerVisible.value)
        return;
      pickerVisible.value = false;
    };
    const userInput = ref(null);
    const handleChange = () => {
      if (userInput.value) {
        const value2 = parseUserInputToDayjs(displayValue.value);
        if (value2) {
          if (isValidValue(value2)) {
            emitInput(Array.isArray(value2) ? value2.map((_) => _.toDate()) : value2.toDate());
            userInput.value = null;
          }
        }
      }
      if (userInput.value === "") {
        emitInput(null);
        emitChange(null);
        userInput.value = null;
      }
    };
    const blurInput = () => {
      refInput.value.forEach((input2) => input2.blur());
    };
    const parseUserInputToDayjs = (value2) => {
      if (!value2)
        return null;
      return pickerOptions.value.parseUserInput(value2);
    };
    const formatDayjsToString = (value2) => {
      if (!value2)
        return null;
      return pickerOptions.value.formatToString(value2);
    };
    const isValidValue = (value2) => {
      return pickerOptions.value.isValidValue(value2);
    };
    const handleKeydown = (event2) => {
      const code = event2.code;
      if (code === EVENT_CODE.esc) {
        pickerVisible.value = false;
        event2.stopPropagation();
        return;
      }
      if (code === EVENT_CODE.tab) {
        if (!isRangeInput.value) {
          handleChange();
          pickerVisible.value = false;
          event2.stopPropagation();
        } else {
          setTimeout(() => {
            if (refInput.value.indexOf(document.activeElement) === -1) {
              pickerVisible.value = false;
              blurInput();
            }
          }, 0);
        }
        return;
      }
      if (code === EVENT_CODE.enter) {
        if (userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
          handleChange();
          pickerVisible.value = false;
        }
        event2.stopPropagation();
        return;
      }
      if (userInput.value) {
        event2.stopPropagation();
        return;
      }
      if (pickerOptions.value.handleKeydown) {
        pickerOptions.value.handleKeydown(event2);
      }
    };
    const onUserInput = (e) => {
      userInput.value = e;
    };
    const handleStartInput = (event2) => {
      if (userInput.value) {
        userInput.value = [event2.target.value, userInput.value[1]];
      } else {
        userInput.value = [event2.target.value, null];
      }
    };
    const handleEndInput = (event2) => {
      if (userInput.value) {
        userInput.value = [userInput.value[0], event2.target.value];
      } else {
        userInput.value = [null, event2.target.value];
      }
    };
    const handleStartChange = () => {
      const value2 = parseUserInputToDayjs(userInput.value && userInput.value[0]);
      if (value2 && value2.isValid()) {
        userInput.value = [formatDayjsToString(value2), displayValue.value[1]];
        const newValue = [value2, parsedValue.value && parsedValue.value[1]];
        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const handleEndChange = () => {
      const value2 = parseUserInputToDayjs(userInput.value && userInput.value[1]);
      if (value2 && value2.isValid()) {
        userInput.value = [displayValue.value[0], formatDayjsToString(value2)];
        const newValue = [parsedValue.value && parsedValue.value[0], value2];
        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const pickerOptions = ref({});
    const onSetPickerOption = (e) => {
      pickerOptions.value[e[0]] = e[1];
      pickerOptions.value.panelReady = true;
    };
    const onCalendarChange = (e) => {
      ctx2.emit("calendar-change", e);
    };
    provide("EP_PICKER_BASE", {
      props: props2
    });
    return {
      elPopperOptions,
      isDatesPicker,
      handleEndChange,
      handleStartChange,
      handleStartInput,
      handleEndInput,
      onUserInput,
      handleChange,
      handleKeydown,
      popperPaneRef,
      onClickOutside,
      pickerSize,
      isRangeInput,
      onMouseLeave,
      onMouseEnter,
      onClearIconClick,
      showClose,
      triggerClass,
      onPick,
      handleFocus,
      handleBlur,
      pickerVisible,
      pickerActualVisible,
      displayValue,
      parsedValue,
      setSelectionRange,
      refPopper,
      pickerDisabled,
      onSetPickerOption,
      onCalendarChange
    };
  }
});
const _hoisted_1$15 = ["name", "placeholder", "value", "disabled", "readonly"];
const _hoisted_2$W = { class: "el-range-separator" };
const _hoisted_3$T = ["name", "placeholder", "value", "disabled", "readonly"];
function render$O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createBlock(_component_el_popper, mergeProps({
    ref: "refPopper",
    visible: _ctx.pickerVisible,
    "onUpdate:visible": _cache[18] || (_cache[18] = ($event) => _ctx.pickerVisible = $event),
    "manual-mode": "",
    effect: "light",
    pure: "",
    trigger: "click"
  }, _ctx.$attrs, {
    "popper-class": `el-picker__popper ${_ctx.popperClass}`,
    "popper-options": _ctx.elPopperOptions,
    "fallback-placements": ["bottom", "top", "right", "left"],
    transition: "el-zoom-in-top",
    "gpu-acceleration": false,
    "stop-popper-mouse-event": false,
    "append-to-body": "",
    onBeforeEnter: _cache[19] || (_cache[19] = ($event) => _ctx.pickerActualVisible = true),
    onAfterLeave: _cache[20] || (_cache[20] = ($event) => _ctx.pickerActualVisible = false)
  }), {
    trigger: withCtx(() => [
      !_ctx.isRangeInput ? withDirectives((openBlock(), createBlock(_component_el_input, {
        key: 0,
        "model-value": _ctx.displayValue,
        name: _ctx.name,
        size: _ctx.pickerSize,
        disabled: _ctx.pickerDisabled,
        placeholder: _ctx.placeholder,
        class: normalizeClass(["el-date-editor", "el-date-editor--" + _ctx.type]),
        readonly: !_ctx.editable || _ctx.readonly || _ctx.isDatesPicker || _ctx.type === "week",
        onInput: _ctx.onUserInput,
        onFocus: _ctx.handleFocus,
        onKeydown: _ctx.handleKeydown,
        onChange: _ctx.handleChange,
        onMouseenter: _ctx.onMouseEnter,
        onMouseleave: _ctx.onMouseLeave
      }, {
        prefix: withCtx(() => [
          createElementVNode("i", {
            class: normalizeClass(["el-input__icon", _ctx.triggerClass]),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args))
          }, null, 2)
        ]),
        suffix: withCtx(() => [
          createElementVNode("i", {
            class: normalizeClass(["el-input__icon", [_ctx.showClose ? "" + _ctx.clearIcon : ""]]),
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClearIconClick && _ctx.onClearIconClick(...args))
          }, null, 2)
        ]),
        _: 1
      }, 8, ["model-value", "name", "size", "disabled", "placeholder", "class", "readonly", "onInput", "onFocus", "onKeydown", "onChange", "onMouseenter", "onMouseleave"])), [
        [_directive_clickoutside, _ctx.onClickOutside, _ctx.popperPaneRef]
      ]) : withDirectives((openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["el-date-editor el-range-editor el-input__inner", [
          "el-date-editor--" + _ctx.type,
          _ctx.pickerSize ? `el-range-editor--${_ctx.pickerSize}` : "",
          _ctx.pickerDisabled ? "is-disabled" : "",
          _ctx.pickerVisible ? "is-active" : ""
        ]]),
        onClick: _cache[9] || (_cache[9] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onMouseenter: _cache[10] || (_cache[10] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
        onMouseleave: _cache[11] || (_cache[11] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
        onKeydown: _cache[12] || (_cache[12] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }, [
        createElementVNode("i", {
          class: normalizeClass(["el-input__icon", "el-range__icon", _ctx.triggerClass])
        }, null, 2),
        createElementVNode("input", {
          autocomplete: "off",
          name: _ctx.name && _ctx.name[0],
          placeholder: _ctx.startPlaceholder,
          value: _ctx.displayValue && _ctx.displayValue[0],
          disabled: _ctx.pickerDisabled,
          readonly: !_ctx.editable || _ctx.readonly,
          class: "el-range-input",
          onInput: _cache[2] || (_cache[2] = (...args) => _ctx.handleStartInput && _ctx.handleStartInput(...args)),
          onChange: _cache[3] || (_cache[3] = (...args) => _ctx.handleStartChange && _ctx.handleStartChange(...args)),
          onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args))
        }, null, 40, _hoisted_1$15),
        renderSlot(_ctx.$slots, "range-separator", {}, () => [
          createElementVNode("span", _hoisted_2$W, toDisplayString(_ctx.rangeSeparator), 1)
        ]),
        createElementVNode("input", {
          autocomplete: "off",
          name: _ctx.name && _ctx.name[1],
          placeholder: _ctx.endPlaceholder,
          value: _ctx.displayValue && _ctx.displayValue[1],
          disabled: _ctx.pickerDisabled,
          readonly: !_ctx.editable || _ctx.readonly,
          class: "el-range-input",
          onFocus: _cache[5] || (_cache[5] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
          onInput: _cache[6] || (_cache[6] = (...args) => _ctx.handleEndInput && _ctx.handleEndInput(...args)),
          onChange: _cache[7] || (_cache[7] = (...args) => _ctx.handleEndChange && _ctx.handleEndChange(...args))
        }, null, 40, _hoisted_3$T),
        createElementVNode("i", {
          class: normalizeClass([[_ctx.showClose ? "" + _ctx.clearIcon : ""], "el-input__icon el-range__close-icon"]),
          onClick: _cache[8] || (_cache[8] = (...args) => _ctx.onClearIconClick && _ctx.onClearIconClick(...args))
        }, null, 2)
      ], 34)), [
        [_directive_clickoutside, _ctx.onClickOutside, _ctx.popperPaneRef]
      ])
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {
        visible: _ctx.pickerVisible,
        actualVisible: _ctx.pickerActualVisible,
        parsedValue: _ctx.parsedValue,
        format: _ctx.format,
        unlinkPanels: _ctx.unlinkPanels,
        type: _ctx.type,
        defaultValue: _ctx.defaultValue,
        onPick: _cache[13] || (_cache[13] = (...args) => _ctx.onPick && _ctx.onPick(...args)),
        onSelectRange: _cache[14] || (_cache[14] = (...args) => _ctx.setSelectionRange && _ctx.setSelectionRange(...args)),
        onSetPickerOption: _cache[15] || (_cache[15] = (...args) => _ctx.onSetPickerOption && _ctx.onSetPickerOption(...args)),
        onCalendarChange: _cache[16] || (_cache[16] = (...args) => _ctx.onCalendarChange && _ctx.onCalendarChange(...args)),
        onMousedown: _cache[17] || (_cache[17] = withModifiers(() => {
        }, ["stop"]))
      })
    ]),
    _: 3
  }, 16, ["visible", "popper-class", "popper-options"]);
}
script$Q.render = render$O;
script$Q.__file = "packages/components/time-picker/src/common/picker.vue";
const makeList = (total, method3, methodFunc) => {
  const arr = [];
  const disabledArr = method3 && methodFunc();
  for (let i2 = 0; i2 < total; i2++) {
    arr[i2] = disabledArr ? disabledArr.includes(i2) : false;
  }
  return arr;
};
const makeAvailableArr = (list) => {
  return list.map((_, index2) => !_ ? index2 : _).filter((_) => _ !== true);
};
const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
  const getHoursList = (role, compare) => {
    return makeList(24, disabledHours, () => disabledHours(role, compare));
  };
  const getMinutesList = (hour, role, compare) => {
    return makeList(60, disabledMinutes, () => disabledMinutes(hour, role, compare));
  };
  const getSecondsList = (hour, minute, role, compare) => {
    return makeList(60, disabledSeconds, () => disabledSeconds(hour, minute, role, compare));
  };
  return {
    getHoursList,
    getMinutesList,
    getSecondsList
  };
};
const getAvailableArrs = (disabledHours, disabledMinutes, disabledSeconds) => {
  const {
    getHoursList,
    getMinutesList,
    getSecondsList
  } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
  const getAvailableHours = (role, compare) => {
    return makeAvailableArr(getHoursList(role, compare));
  };
  const getAvailableMinutes = (hour, role, compare) => {
    return makeAvailableArr(getMinutesList(hour, role, compare));
  };
  const getAvailableSeconds = (hour, minute, role, compare) => {
    return makeAvailableArr(getSecondsList(hour, minute, role, compare));
  };
  return {
    getAvailableHours,
    getAvailableMinutes,
    getAvailableSeconds
  };
};
const useOldValue = (props2) => {
  const oldValue = ref(props2.parsedValue);
  watch(() => props2.visible, (val) => {
    if (!val) {
      oldValue.value = props2.parsedValue;
    }
  });
  return oldValue;
};
var script$1$s = defineComponent({
  directives: {
    repeatClick: RepeatClick
  },
  components: {
    ElScrollbar: _Scrollbar
  },
  props: {
    role: {
      type: String,
      required: true
    },
    spinnerDate: {
      type: Object,
      required: true
    },
    showSeconds: {
      type: Boolean,
      default: true
    },
    arrowControl: Boolean,
    amPmMode: {
      type: String,
      default: ""
    },
    disabledHours: {
      type: Function
    },
    disabledMinutes: {
      type: Function
    },
    disabledSeconds: {
      type: Function
    }
  },
  emits: ["change", "select-range", "set-option"],
  setup(props2, ctx2) {
    let isScrolling = false;
    const debouncedResetScroll = debounce_1((type2) => {
      isScrolling = false;
      adjustCurrentSpinner(type2);
    }, 200);
    const currentScrollbar = ref(null);
    const listHoursRef = ref(null);
    const listMinutesRef = ref(null);
    const listSecondsRef = ref(null);
    const listRefsMap = {
      hours: listHoursRef,
      minutes: listMinutesRef,
      seconds: listSecondsRef
    };
    const spinnerItems = computed(() => {
      const arr = ["hours", "minutes", "seconds"];
      return props2.showSeconds ? arr : arr.slice(0, 2);
    });
    const hours = computed(() => {
      return props2.spinnerDate.hour();
    });
    const minutes = computed(() => {
      return props2.spinnerDate.minute();
    });
    const seconds = computed(() => {
      return props2.spinnerDate.second();
    });
    const timePartsMap = computed(() => ({
      hours,
      minutes,
      seconds
    }));
    const hoursList = computed(() => {
      return getHoursList(props2.role);
    });
    const minutesList = computed(() => {
      return getMinutesList(hours.value, props2.role);
    });
    const secondsList = computed(() => {
      return getSecondsList(hours.value, minutes.value, props2.role);
    });
    const listMap = computed(() => ({
      hours: hoursList,
      minutes: minutesList,
      seconds: secondsList
    }));
    const arrowHourList = computed(() => {
      const hour = hours.value;
      return [
        hour > 0 ? hour - 1 : void 0,
        hour,
        hour < 23 ? hour + 1 : void 0
      ];
    });
    const arrowMinuteList = computed(() => {
      const minute = minutes.value;
      return [
        minute > 0 ? minute - 1 : void 0,
        minute,
        minute < 59 ? minute + 1 : void 0
      ];
    });
    const arrowSecondList = computed(() => {
      const second = seconds.value;
      return [
        second > 0 ? second - 1 : void 0,
        second,
        second < 59 ? second + 1 : void 0
      ];
    });
    const arrowListMap = computed(() => ({
      hours: arrowHourList,
      minutes: arrowMinuteList,
      seconds: arrowSecondList
    }));
    const getAmPmFlag = (hour) => {
      let shouldShowAmPm = !!props2.amPmMode;
      if (!shouldShowAmPm)
        return "";
      let isCapital = props2.amPmMode === "A";
      let content = hour < 12 ? " am" : " pm";
      if (isCapital)
        content = content.toUpperCase();
      return content;
    };
    const emitSelectRange = (type2) => {
      if (type2 === "hours") {
        ctx2.emit("select-range", 0, 2);
      } else if (type2 === "minutes") {
        ctx2.emit("select-range", 3, 5);
      } else if (type2 === "seconds") {
        ctx2.emit("select-range", 6, 8);
      }
      currentScrollbar.value = type2;
    };
    const adjustCurrentSpinner = (type2) => {
      adjustSpinner(type2, timePartsMap.value[type2].value);
    };
    const adjustSpinners = () => {
      adjustCurrentSpinner("hours");
      adjustCurrentSpinner("minutes");
      adjustCurrentSpinner("seconds");
    };
    const adjustSpinner = (type2, value2) => {
      if (props2.arrowControl)
        return;
      const el = listRefsMap[type2];
      if (el.value) {
        el.value.$el.querySelector(".el-scrollbar__wrap").scrollTop = Math.max(0, value2 * typeItemHeight(type2));
      }
    };
    const typeItemHeight = (type2) => {
      const el = listRefsMap[type2];
      return el.value.$el.querySelector("li").offsetHeight;
    };
    const onIncreaseClick = () => {
      scrollDown(1);
    };
    const onDecreaseClick = () => {
      scrollDown(-1);
    };
    const scrollDown = (step) => {
      if (!currentScrollbar.value) {
        emitSelectRange("hours");
      }
      const label = currentScrollbar.value;
      let now2 = timePartsMap.value[label].value;
      const total = currentScrollbar.value === "hours" ? 24 : 60;
      now2 = (now2 + step + total) % total;
      modifyDateField(label, now2);
      adjustSpinner(label, now2);
      nextTick(() => emitSelectRange(currentScrollbar.value));
    };
    const modifyDateField = (type2, value2) => {
      const list = listMap.value[type2].value;
      const isDisabled = list[value2];
      if (isDisabled)
        return;
      switch (type2) {
        case "hours":
          ctx2.emit("change", props2.spinnerDate.hour(value2).minute(minutes.value).second(seconds.value));
          break;
        case "minutes":
          ctx2.emit("change", props2.spinnerDate.hour(hours.value).minute(value2).second(seconds.value));
          break;
        case "seconds":
          ctx2.emit("change", props2.spinnerDate.hour(hours.value).minute(minutes.value).second(value2));
          break;
      }
    };
    const handleClick = (type2, { value: value2, disabled }) => {
      if (!disabled) {
        modifyDateField(type2, value2);
        emitSelectRange(type2);
        adjustSpinner(type2, value2);
      }
    };
    const handleScroll2 = (type2) => {
      isScrolling = true;
      debouncedResetScroll(type2);
      const value2 = Math.min(Math.round((listRefsMap[type2].value.$el.querySelector(".el-scrollbar__wrap").scrollTop - (scrollBarHeight(type2) * 0.5 - 10) / typeItemHeight(type2) + 3) / typeItemHeight(type2)), type2 === "hours" ? 23 : 59);
      modifyDateField(type2, value2);
    };
    const scrollBarHeight = (type2) => {
      return listRefsMap[type2].value.$el.offsetHeight;
    };
    const bindScrollEvent = () => {
      const bindFuntion = (type2) => {
        if (listRefsMap[type2].value) {
          listRefsMap[type2].value.$el.querySelector(".el-scrollbar__wrap").onscroll = () => {
            handleScroll2(type2);
          };
        }
      };
      bindFuntion("hours");
      bindFuntion("minutes");
      bindFuntion("seconds");
    };
    onMounted(() => {
      nextTick(() => {
        !props2.arrowControl && bindScrollEvent();
        adjustSpinners();
        if (props2.role === "start")
          emitSelectRange("hours");
      });
    });
    const getRefId = (item) => {
      return `list${item.charAt(0).toUpperCase() + item.slice(1)}Ref`;
    };
    ctx2.emit("set-option", [`${props2.role}_scrollDown`, scrollDown]);
    ctx2.emit("set-option", [`${props2.role}_emitSelectRange`, emitSelectRange]);
    const {
      getHoursList,
      getMinutesList,
      getSecondsList
    } = getTimeLists(props2.disabledHours, props2.disabledMinutes, props2.disabledSeconds);
    watch(() => props2.spinnerDate, () => {
      if (isScrolling)
        return;
      adjustSpinners();
    });
    return {
      getRefId,
      spinnerItems,
      currentScrollbar,
      hours,
      minutes,
      seconds,
      hoursList,
      minutesList,
      arrowHourList,
      arrowMinuteList,
      arrowSecondList,
      getAmPmFlag,
      emitSelectRange,
      adjustCurrentSpinner,
      typeItemHeight,
      listHoursRef,
      listMinutesRef,
      listSecondsRef,
      onIncreaseClick,
      onDecreaseClick,
      handleClick,
      secondsList,
      timePartsMap,
      arrowListMap,
      listMap
    };
  }
});
const _hoisted_1$1$l = ["onClick"];
const _hoisted_2$1$e = ["onMouseenter"];
const _hoisted_3$1$c = { class: "el-time-spinner__arrow el-icon-arrow-up" };
const _hoisted_4$G = { class: "el-time-spinner__arrow el-icon-arrow-down" };
const _hoisted_5$z = { class: "el-time-spinner__list" };
function render$1$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _directive_repeat_click = resolveDirective("repeat-click");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-time-spinner", { "has-seconds": _ctx.showSeconds }])
  }, [
    !_ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.spinnerItems, (item) => {
      return openBlock(), createBlock(_component_el_scrollbar, {
        key: item,
        ref: _ctx.getRefId(item),
        class: "el-time-spinner__wrapper",
        "wrap-style": "max-height: inherit;",
        "view-class": "el-time-spinner__list",
        noresize: "",
        tag: "ul",
        onMouseenter: ($event) => _ctx.emitSelectRange(item),
        onMousemove: ($event) => _ctx.adjustCurrentSpinner(item)
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.listMap[item].value, (disabled, key) => {
            return openBlock(), createElementBlock("li", {
              key,
              class: normalizeClass(["el-time-spinner__item", { "active": key === _ctx.timePartsMap[item].value, disabled }]),
              onClick: ($event) => _ctx.handleClick(item, { value: key, disabled })
            }, [
              item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + toDisplayString(_ctx.getAmPmFlag(key)), 1)
              ], 2112)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(("0" + key).slice(-2)), 1)
              ], 2112))
            ], 10, _hoisted_1$1$l);
          }), 128))
        ]),
        _: 2
      }, 1032, ["onMouseenter", "onMousemove"]);
    }), 128)) : createCommentVNode("v-if", true),
    _ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.spinnerItems, (item) => {
      return openBlock(), createElementBlock("div", {
        key: item,
        class: "el-time-spinner__wrapper is-arrow",
        onMouseenter: ($event) => _ctx.emitSelectRange(item)
      }, [
        withDirectives(createElementVNode("i", _hoisted_3$1$c, null, 512), [
          [_directive_repeat_click, _ctx.onDecreaseClick]
        ]),
        withDirectives(createElementVNode("i", _hoisted_4$G, null, 512), [
          [_directive_repeat_click, _ctx.onIncreaseClick]
        ]),
        createElementVNode("ul", _hoisted_5$z, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.arrowListMap[item].value, (time, key) => {
            return openBlock(), createElementBlock("li", {
              key,
              class: normalizeClass(["el-time-spinner__item", { "active": time === _ctx.timePartsMap[item].value, "disabled": _ctx.listMap[item].value[time] }])
            }, toDisplayString(time === void 0 ? "" : ("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2) + _ctx.getAmPmFlag(time)), 3);
          }), 128))
        ])
      ], 40, _hoisted_2$1$e);
    }), 128)) : createCommentVNode("v-if", true)
  ], 2);
}
script$1$s.render = render$1$r;
script$1$s.__file = "packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue";
var script$2$i = defineComponent({
  components: {
    TimeSpinner: script$1$s
  },
  props: {
    visible: Boolean,
    actualVisible: {
      type: Boolean,
      default: void 0
    },
    datetimeRole: {
      type: String
    },
    parsedValue: {
      type: [Object, String]
    },
    format: {
      type: String,
      default: ""
    }
  },
  emits: ["pick", "select-range", "set-picker-option"],
  setup(props2, ctx2) {
    const { t, lang } = useLocaleInject();
    const selectionRange = ref([0, 2]);
    const oldValue = useOldValue(props2);
    const transitionName = computed(() => {
      return props2.actualVisible === void 0 ? "el-zoom-in-top" : "";
    });
    const showSeconds = computed(() => {
      return props2.format.includes("ss");
    });
    const amPmMode = computed(() => {
      if (props2.format.includes("A"))
        return "A";
      if (props2.format.includes("a"))
        return "a";
      return "";
    });
    const isValidValue = (_date) => {
      const parsedDate = dayjs(_date).locale(lang.value);
      const result = getRangeAvailableTime(parsedDate);
      return parsedDate.isSame(result);
    };
    const handleCancel = () => {
      ctx2.emit("pick", oldValue.value, false);
    };
    const handleConfirm = (visible2 = false, first) => {
      if (first)
        return;
      ctx2.emit("pick", props2.parsedValue, visible2);
    };
    const handleChange = (_date) => {
      if (!props2.visible) {
        return;
      }
      const result = getRangeAvailableTime(_date).millisecond(0);
      ctx2.emit("pick", result, true);
    };
    const setSelectionRange = (start2, end2) => {
      ctx2.emit("select-range", start2, end2);
      selectionRange.value = [start2, end2];
    };
    const changeSelectionRange = (step) => {
      const list = [0, 3].concat(showSeconds.value ? [6] : []);
      const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
      const index2 = list.indexOf(selectionRange.value[0]);
      const next = (index2 + step + list.length) % list.length;
      timePickerOptions["start_emitSelectRange"](mapping[next]);
    };
    const handleKeydown = (event2) => {
      const code = event2.code;
      if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
        const step = code === EVENT_CODE.left ? -1 : 1;
        changeSelectionRange(step);
        event2.preventDefault();
        return;
      }
      if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
        const step = code === EVENT_CODE.up ? -1 : 1;
        timePickerOptions["start_scrollDown"](step);
        event2.preventDefault();
        return;
      }
    };
    const getRangeAvailableTime = (date3) => {
      const availableMap = {
        hour: getAvailableHours,
        minute: getAvailableMinutes,
        second: getAvailableSeconds
      };
      let result = date3;
      ["hour", "minute", "second"].forEach((_) => {
        if (availableMap[_]) {
          let availableArr;
          const method3 = availableMap[_];
          if (_ === "minute") {
            availableArr = method3(result.hour(), props2.datetimeRole);
          } else if (_ === "second") {
            availableArr = method3(result.hour(), result.minute(), props2.datetimeRole);
          } else {
            availableArr = method3(props2.datetimeRole);
          }
          if (availableArr && availableArr.length && !availableArr.includes(result[_]())) {
            result = result[_](availableArr[0]);
          }
        }
      });
      return result;
    };
    const parseUserInput = (value2) => {
      if (!value2)
        return null;
      return dayjs(value2, props2.format).locale(lang.value);
    };
    const formatToString = (value2) => {
      if (!value2)
        return null;
      return value2.format(props2.format);
    };
    const getDefaultValue = () => {
      return dayjs(defaultValue2).locale(lang.value);
    };
    ctx2.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx2.emit("set-picker-option", ["formatToString", formatToString]);
    ctx2.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx2.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    ctx2.emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
    ctx2.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
    const timePickerOptions = {};
    const onSetOption = (e) => {
      timePickerOptions[e[0]] = e[1];
    };
    const pickerBase = inject("EP_PICKER_BASE");
    const { arrowControl, disabledHours, disabledMinutes, disabledSeconds, defaultValue: defaultValue2 } = pickerBase.props;
    const {
      getAvailableHours,
      getAvailableMinutes,
      getAvailableSeconds
    } = getAvailableArrs(disabledHours, disabledMinutes, disabledSeconds);
    return {
      transitionName,
      arrowControl,
      onSetOption,
      t,
      handleConfirm,
      handleChange,
      setSelectionRange,
      amPmMode,
      showSeconds,
      handleCancel,
      disabledHours,
      disabledMinutes,
      disabledSeconds
    };
  }
});
const _hoisted_1$2$6 = {
  key: 0,
  class: "el-time-panel"
};
const _hoisted_2$2$5 = { class: "el-time-panel__footer" };
function render$2$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_time_spinner = resolveComponent("time-spinner");
  return openBlock(), createBlock(Transition, { name: _ctx.transitionName }, {
    default: withCtx(() => [
      _ctx.actualVisible || _ctx.visible ? (openBlock(), createElementBlock("div", _hoisted_1$2$6, [
        createElementVNode("div", {
          class: normalizeClass(["el-time-panel__content", { "has-seconds": _ctx.showSeconds }])
        }, [
          createVNode(_component_time_spinner, {
            ref: "spinner",
            role: _ctx.datetimeRole || "start",
            "arrow-control": _ctx.arrowControl,
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "spinner-date": _ctx.parsedValue,
            "disabled-hours": _ctx.disabledHours,
            "disabled-minutes": _ctx.disabledMinutes,
            "disabled-seconds": _ctx.disabledSeconds,
            onChange: _ctx.handleChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setSelectionRange
          }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2),
        createElementVNode("div", _hoisted_2$2$5, [
          createElementVNode("button", {
            type: "button",
            class: "el-time-panel__btn cancel",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
          }, toDisplayString(_ctx.t("el.datepicker.cancel")), 1),
          createElementVNode("button", {
            type: "button",
            class: "el-time-panel__btn confirm",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleConfirm())
          }, toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ])
      ])) : createCommentVNode("v-if", true)
    ]),
    _: 1
  }, 8, ["name"]);
}
script$2$i.render = render$2$f;
script$2$i.__file = "packages/components/time-picker/src/time-picker-com/panel-time-pick.vue";
const makeSelectRange = (start2, end2) => {
  const result = [];
  for (let i2 = start2; i2 <= end2; i2++) {
    result.push(i2);
  }
  return result;
};
var script$3$a = defineComponent({
  components: { TimeSpinner: script$1$s },
  props: {
    visible: Boolean,
    actualVisible: Boolean,
    parsedValue: {
      type: [Array, String]
    },
    format: {
      type: String,
      default: ""
    }
  },
  emits: ["pick", "select-range", "set-picker-option"],
  setup(props2, ctx2) {
    const { t, lang } = useLocaleInject();
    const minDate = computed(() => props2.parsedValue[0]);
    const maxDate = computed(() => props2.parsedValue[1]);
    const oldValue = useOldValue(props2);
    const handleCancel = () => {
      ctx2.emit("pick", oldValue.value, null);
    };
    const showSeconds = computed(() => {
      return props2.format.includes("ss");
    });
    const amPmMode = computed(() => {
      if (props2.format.includes("A"))
        return "A";
      if (props2.format.includes("a"))
        return "a";
      return "";
    });
    const minSelectableRange = ref([]);
    const maxSelectableRange = ref([]);
    const handleConfirm = (visible2 = false) => {
      ctx2.emit("pick", [minDate.value, maxDate.value], visible2);
    };
    const handleMinChange = (date3) => {
      handleChange(date3.millisecond(0), maxDate.value);
    };
    const handleMaxChange = (date3) => {
      handleChange(minDate.value, date3.millisecond(0));
    };
    const isValidValue = (_date) => {
      const parsedDate = _date.map((_) => dayjs(_).locale(lang.value));
      const result = getRangeAvailableTime(parsedDate);
      return parsedDate[0].isSame(result[0]) && parsedDate[1].isSame(result[1]);
    };
    const handleChange = (_minDate, _maxDate) => {
      ctx2.emit("pick", [_minDate, _maxDate], true);
    };
    const btnConfirmDisabled = computed(() => {
      return minDate.value > maxDate.value;
    });
    const selectionRange = ref([0, 2]);
    const setMinSelectionRange = (start2, end2) => {
      ctx2.emit("select-range", start2, end2, "min");
      selectionRange.value = [start2, end2];
    };
    const offset2 = computed(() => showSeconds.value ? 11 : 8);
    const setMaxSelectionRange = (start2, end2) => {
      ctx2.emit("select-range", start2, end2, "max");
      selectionRange.value = [start2 + offset2.value, end2 + offset2.value];
    };
    const changeSelectionRange = (step) => {
      const list = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
      const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
      const index2 = list.indexOf(selectionRange.value[0]);
      const next = (index2 + step + list.length) % list.length;
      const half = list.length / 2;
      if (next < half) {
        timePickerOptions["start_emitSelectRange"](mapping[next]);
      } else {
        timePickerOptions["end_emitSelectRange"](mapping[next - half]);
      }
    };
    const handleKeydown = (event2) => {
      const code = event2.code;
      if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
        const step = code === EVENT_CODE.left ? -1 : 1;
        changeSelectionRange(step);
        event2.preventDefault();
        return;
      }
      if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
        const step = code === EVENT_CODE.up ? -1 : 1;
        const role = selectionRange.value[0] < offset2.value ? "start" : "end";
        timePickerOptions[`${role}_scrollDown`](step);
        event2.preventDefault();
        return;
      }
    };
    const disabledHours_ = (role, compare) => {
      const defaultDisable = disabledHours ? disabledHours(role) : [];
      const isStart = role === "start";
      const compareDate = compare || (isStart ? maxDate.value : minDate.value);
      const compareHour = compareDate.hour();
      const nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
      return union_1(defaultDisable, nextDisable);
    };
    const disabledMinutes_ = (hour, role, compare) => {
      const defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
      const isStart = role === "start";
      const compareDate = compare || (isStart ? maxDate.value : minDate.value);
      const compareHour = compareDate.hour();
      if (hour !== compareHour) {
        return defaultDisable;
      }
      const compareMinute = compareDate.minute();
      const nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
      return union_1(defaultDisable, nextDisable);
    };
    const disabledSeconds_ = (hour, minute, role, compare) => {
      const defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
      const isStart = role === "start";
      const compareDate = compare || (isStart ? maxDate.value : minDate.value);
      const compareHour = compareDate.hour();
      const compareMinute = compareDate.minute();
      if (hour !== compareHour || minute !== compareMinute) {
        return defaultDisable;
      }
      const compareSecond = compareDate.second();
      const nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
      return union_1(defaultDisable, nextDisable);
    };
    const getRangeAvailableTime = (dates) => {
      return dates.map((_, index2) => getRangeAvailableTimeEach(dates[0], dates[1], index2 === 0 ? "start" : "end"));
    };
    const {
      getAvailableHours,
      getAvailableMinutes,
      getAvailableSeconds
    } = getAvailableArrs(disabledHours_, disabledMinutes_, disabledSeconds_);
    const getRangeAvailableTimeEach = (startDate, endDate, role) => {
      const availableMap = {
        hour: getAvailableHours,
        minute: getAvailableMinutes,
        second: getAvailableSeconds
      };
      const isStart = role === "start";
      let result = isStart ? startDate : endDate;
      const compareDate = isStart ? endDate : startDate;
      ["hour", "minute", "second"].forEach((_) => {
        if (availableMap[_]) {
          let availableArr;
          const method3 = availableMap[_];
          if (_ === "minute") {
            availableArr = method3(result.hour(), role, compareDate);
          } else if (_ === "second") {
            availableArr = method3(result.hour(), result.minute(), role, compareDate);
          } else {
            availableArr = method3(role, compareDate);
          }
          if (availableArr && availableArr.length && !availableArr.includes(result[_]())) {
            const pos = isStart ? 0 : availableArr.length - 1;
            result = result[_](availableArr[pos]);
          }
        }
      });
      return result;
    };
    const parseUserInput = (value2) => {
      if (!value2)
        return null;
      if (Array.isArray(value2)) {
        return value2.map((_) => dayjs(_, props2.format).locale(lang.value));
      }
      return dayjs(value2, props2.format).locale(lang.value);
    };
    const formatToString = (value2) => {
      if (!value2)
        return null;
      if (Array.isArray(value2)) {
        return value2.map((_) => _.format(props2.format));
      }
      return value2.format(props2.format);
    };
    const getDefaultValue = () => {
      if (Array.isArray(defaultValue2)) {
        return defaultValue2.map((_) => dayjs(_).locale(lang.value));
      }
      const defaultDay = dayjs(defaultValue2).locale(lang.value);
      return [
        defaultDay,
        defaultDay.add(60, "m")
      ];
    };
    ctx2.emit("set-picker-option", ["formatToString", formatToString]);
    ctx2.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx2.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx2.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    ctx2.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
    ctx2.emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
    const timePickerOptions = {};
    const onSetOption = (e) => {
      timePickerOptions[e[0]] = e[1];
    };
    const pickerBase = inject("EP_PICKER_BASE");
    const { arrowControl, disabledHours, disabledMinutes, disabledSeconds, defaultValue: defaultValue2 } = pickerBase.props;
    return {
      arrowControl,
      onSetOption,
      setMaxSelectionRange,
      setMinSelectionRange,
      btnConfirmDisabled,
      handleCancel,
      handleConfirm,
      t,
      showSeconds,
      minDate,
      maxDate,
      amPmMode,
      handleMinChange,
      handleMaxChange,
      minSelectableRange,
      maxSelectableRange,
      disabledHours_,
      disabledMinutes_,
      disabledSeconds_
    };
  }
});
const _hoisted_1$3$4 = {
  key: 0,
  class: "el-time-range-picker el-picker-panel"
};
const _hoisted_2$3$3 = { class: "el-time-range-picker__content" };
const _hoisted_3$2$5 = { class: "el-time-range-picker__cell" };
const _hoisted_4$1$5 = { class: "el-time-range-picker__header" };
const _hoisted_5$1$4 = { class: "el-time-range-picker__cell" };
const _hoisted_6$t = { class: "el-time-range-picker__header" };
const _hoisted_7$l = { class: "el-time-panel__footer" };
const _hoisted_8$g = ["disabled"];
function render$3$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_time_spinner = resolveComponent("time-spinner");
  return _ctx.actualVisible ? (openBlock(), createElementBlock("div", _hoisted_1$3$4, [
    createElementVNode("div", _hoisted_2$3$3, [
      createElementVNode("div", _hoisted_3$2$5, [
        createElementVNode("div", _hoisted_4$1$5, toDisplayString(_ctx.t("el.datepicker.startTime")), 1),
        createElementVNode("div", {
          class: normalizeClass([{ "has-seconds": _ctx.showSeconds, "is-arrow": _ctx.arrowControl }, "el-time-range-picker__body el-time-panel__content"])
        }, [
          createVNode(_component_time_spinner, {
            ref: "minSpinner",
            role: "start",
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "arrow-control": _ctx.arrowControl,
            "spinner-date": _ctx.minDate,
            "disabled-hours": _ctx.disabledHours_,
            "disabled-minutes": _ctx.disabledMinutes_,
            "disabled-seconds": _ctx.disabledSeconds_,
            onChange: _ctx.handleMinChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setMinSelectionRange
          }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2)
      ]),
      createElementVNode("div", _hoisted_5$1$4, [
        createElementVNode("div", _hoisted_6$t, toDisplayString(_ctx.t("el.datepicker.endTime")), 1),
        createElementVNode("div", {
          class: normalizeClass([{ "has-seconds": _ctx.showSeconds, "is-arrow": _ctx.arrowControl }, "el-time-range-picker__body el-time-panel__content"])
        }, [
          createVNode(_component_time_spinner, {
            ref: "maxSpinner",
            role: "end",
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "arrow-control": _ctx.arrowControl,
            "spinner-date": _ctx.maxDate,
            "disabled-hours": _ctx.disabledHours_,
            "disabled-minutes": _ctx.disabledMinutes_,
            "disabled-seconds": _ctx.disabledSeconds_,
            onChange: _ctx.handleMaxChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setMaxSelectionRange
          }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2)
      ])
    ]),
    createElementVNode("div", _hoisted_7$l, [
      createElementVNode("button", {
        type: "button",
        class: "el-time-panel__btn cancel",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleCancel())
      }, toDisplayString(_ctx.t("el.datepicker.cancel")), 1),
      createElementVNode("button", {
        type: "button",
        class: "el-time-panel__btn confirm",
        disabled: _ctx.btnConfirmDisabled,
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleConfirm())
      }, toDisplayString(_ctx.t("el.datepicker.confirm")), 9, _hoisted_8$g)
    ])
  ])) : createCommentVNode("v-if", true);
}
script$3$a.render = render$3$8;
script$3$a.__file = "packages/components/time-picker/src/time-picker-com/panel-time-range.vue";
var __defProp$p = Object.defineProperty;
var __defProps$m = Object.defineProperties;
var __getOwnPropDescs$m = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$p = Object.getOwnPropertySymbols;
var __hasOwnProp$p = Object.prototype.hasOwnProperty;
var __propIsEnum$p = Object.prototype.propertyIsEnumerable;
var __defNormalProp$p = (obj, key, value2) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$p = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$p.call(b, prop))
      __defNormalProp$p(a, prop, b[prop]);
  if (__getOwnPropSymbols$p)
    for (var prop of __getOwnPropSymbols$p(b)) {
      if (__propIsEnum$p.call(b, prop))
        __defNormalProp$p(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$m = (a, b) => __defProps$m(a, __getOwnPropDescs$m(b));
dayjs.extend(customParseFormat);
var TimePicker = defineComponent({
  name: "ElTimePicker",
  install: null,
  props: __spreadProps$m(__spreadValues$p({}, timePickerDefaultProps), {
    isRange: {
      type: Boolean,
      default: false
    }
  }),
  emits: ["update:modelValue"],
  setup(props2, ctx2) {
    const commonPicker = ref(null);
    const type2 = props2.isRange ? "timerange" : "time";
    const panel = props2.isRange ? script$3$a : script$2$i;
    const refProps = __spreadProps$m(__spreadValues$p({}, props2), {
      focus: () => {
        var _a;
        (_a = commonPicker.value) == null ? void 0 : _a.handleFocus();
      },
      blur: () => {
        var _a;
        (_a = commonPicker.value) == null ? void 0 : _a.handleBlur();
      }
    });
    provide("ElPopperOptions", props2.popperOptions);
    ctx2.expose(refProps);
    return () => {
      var _a;
      const format2 = (_a = props2.format) != null ? _a : DEFAULT_FORMATS_TIME;
      return h(script$Q, __spreadProps$m(__spreadValues$p({}, props2), {
        format: format2,
        type: type2,
        ref: commonPicker,
        "onUpdate:modelValue": (value2) => ctx2.emit("update:modelValue", value2)
      }), {
        default: (scopedProps) => h(panel, scopedProps)
      });
    };
  }
});
const rangeArr = (n) => {
  return Array.from(Array(n).keys());
};
const extractDateFormat = (format2) => {
  return format2.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
};
const extractTimeFormat = (format2) => {
  return format2.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
};
const _TimePicker = TimePicker;
_TimePicker.install = (app) => {
  app.component(_TimePicker.name, _TimePicker);
};
const ElTimePicker = _TimePicker;
dayjs.extend(localeData);
const getPrevMonthLastDays = (date3, amount) => {
  const lastDay = date3.subtract(1, "month").endOf("month").date();
  return rangeArr(amount).map((_, index2) => lastDay - (amount - index2 - 1));
};
const getMonthDays = (date3) => {
  const days = date3.daysInMonth();
  return rangeArr(days).map((_, index2) => index2 + 1);
};
var script$P = defineComponent({
  props: {
    selectedDay: {
      type: Object
    },
    range: {
      type: Array
    },
    date: {
      type: Object
    },
    hideHeader: {
      type: Boolean
    }
  },
  emits: ["pick"],
  setup(props2, ctx2) {
    const { lang } = useLocaleInject();
    const WEEK_DAYS = ref(dayjs().locale(lang.value).localeData().weekdaysShort());
    const now2 = dayjs().locale(lang.value);
    const firstDayOfWeek = now2.$locale().weekStart || 0;
    const toNestedArr = (days) => {
      return rangeArr(days.length / 7).map((_, index2) => {
        const start2 = index2 * 7;
        return days.slice(start2, start2 + 7);
      });
    };
    const getFormattedDate = (day, type2) => {
      let result;
      if (type2 === "prev") {
        result = props2.date.startOf("month").subtract(1, "month").date(day);
      } else if (type2 === "next") {
        result = props2.date.startOf("month").add(1, "month").date(day);
      } else {
        result = props2.date.date(day);
      }
      return result;
    };
    const getCellClass = ({ text, type: type2 }) => {
      const classes = [type2];
      if (type2 === "current") {
        const date_ = getFormattedDate(text, type2);
        if (date_.isSame(props2.selectedDay, "day")) {
          classes.push("is-selected");
        }
        if (date_.isSame(now2, "day")) {
          classes.push("is-today");
        }
      }
      return classes;
    };
    const pickDay = ({ text, type: type2 }) => {
      const date3 = getFormattedDate(text, type2);
      ctx2.emit("pick", date3);
    };
    const getSlotData = ({ text, type: type2 }) => {
      const day = getFormattedDate(text, type2);
      return {
        isSelected: day.isSame(props2.selectedDay),
        type: `${type2}-month`,
        day: day.format("YYYY-MM-DD"),
        date: day.toDate()
      };
    };
    const isInRange = computed(() => {
      return props2.range && props2.range.length;
    });
    const rows = computed(() => {
      let days = [];
      if (isInRange.value) {
        const [start2, end2] = props2.range;
        const currentMonthRange = rangeArr(end2.date() - start2.date() + 1).map((_, index2) => ({
          text: start2.date() + index2,
          type: "current"
        }));
        let remaining = currentMonthRange.length % 7;
        remaining = remaining === 0 ? 0 : 7 - remaining;
        const nextMonthRange = rangeArr(remaining).map((_, index2) => ({
          text: index2 + 1,
          type: "next"
        }));
        days = currentMonthRange.concat(nextMonthRange);
      } else {
        const firstDay = props2.date.startOf("month").day() || 7;
        const prevMonthDays = getPrevMonthLastDays(props2.date, firstDay - firstDayOfWeek).map((day) => ({
          text: day,
          type: "prev"
        }));
        const currentMonthDays = getMonthDays(props2.date).map((day) => ({
          text: day,
          type: "current"
        }));
        days = [...prevMonthDays, ...currentMonthDays];
        const nextMonthDays = rangeArr(42 - days.length).map((_, index2) => ({
          text: index2 + 1,
          type: "next"
        }));
        days = days.concat(nextMonthDays);
      }
      return toNestedArr(days);
    });
    const weekDays = computed(() => {
      const start2 = firstDayOfWeek;
      if (start2 === 0) {
        return WEEK_DAYS.value;
      } else {
        return WEEK_DAYS.value.slice(start2).concat(WEEK_DAYS.value.slice(0, start2));
      }
    });
    return {
      isInRange,
      weekDays,
      rows,
      getCellClass,
      pickDay,
      getSlotData
    };
  }
});
const _hoisted_1$14 = { key: 0 };
const _hoisted_2$V = ["onClick"];
const _hoisted_3$S = { class: "el-calendar-day" };
function render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", {
    class: normalizeClass({
      "el-calendar-table": true,
      "is-range": _ctx.isInRange
    }),
    cellspacing: "0",
    cellpadding: "0"
  }, [
    !_ctx.hideHeader ? (openBlock(), createElementBlock("thead", _hoisted_1$14, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.weekDays, (day) => {
        return openBlock(), createElementBlock("th", { key: day }, toDisplayString(day), 1);
      }), 128))
    ])) : createCommentVNode("v-if", true),
    createElementVNode("tbody", null, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row, index2) => {
        return openBlock(), createElementBlock("tr", {
          key: index2,
          class: normalizeClass({
            "el-calendar-table__row": true,
            "el-calendar-table__row--hide-border": index2 === 0 && _ctx.hideHeader
          })
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key) => {
            return openBlock(), createElementBlock("td", {
              key,
              class: normalizeClass(_ctx.getCellClass(cell)),
              onClick: ($event) => _ctx.pickDay(cell)
            }, [
              createElementVNode("div", _hoisted_3$S, [
                renderSlot(_ctx.$slots, "dateCell", {
                  data: _ctx.getSlotData(cell)
                }, () => [
                  createElementVNode("span", null, toDisplayString(cell.text), 1)
                ])
              ])
            ], 10, _hoisted_2$V);
          }), 128))
        ], 2);
      }), 128))
    ])
  ], 2);
}
script$P.render = render$N;
script$P.__file = "packages/components/calendar/src/date-table.vue";
const { ButtonGroup: ElButtonGroup$1 } = _Button;
var script$1$r = defineComponent({
  name: "ElCalendar",
  components: {
    DateTable: script$P,
    ElButton: _Button,
    ElButtonGroup: ElButtonGroup$1
  },
  props: {
    modelValue: {
      type: Date
    },
    range: {
      type: Array,
      validator: (range2) => {
        if (Array.isArray(range2)) {
          return range2.length === 2 && range2.every((item) => item instanceof Date);
        }
        return false;
      }
    }
  },
  emits: ["input", "update:modelValue"],
  setup(props2, ctx2) {
    const { t, lang } = useLocaleInject();
    const selectedDay = ref(null);
    const now2 = dayjs().locale(lang.value);
    const prevMonthDayjs = computed(() => {
      return date3.value.subtract(1, "month");
    });
    const curMonthDatePrefix = computed(() => {
      return dayjs(date3.value).locale(lang.value).format("YYYY-MM");
    });
    const nextMonthDayjs = computed(() => {
      return date3.value.add(1, "month");
    });
    const i18nDate = computed(() => {
      const pickedMonth = `el.datepicker.month${date3.value.format("M")}`;
      return `${date3.value.year()} ${t("el.datepicker.year")} ${t(pickedMonth)}`;
    });
    const realSelectedDay = computed({
      get() {
        if (!props2.modelValue)
          return selectedDay.value;
        return date3.value;
      },
      set(val) {
        selectedDay.value = val;
        const result = val.toDate();
        ctx2.emit("input", result);
        ctx2.emit("update:modelValue", result);
      }
    });
    const date3 = computed(() => {
      if (!props2.modelValue) {
        if (realSelectedDay.value) {
          return realSelectedDay.value;
        } else if (validatedRange.value.length) {
          return validatedRange.value[0][0];
        }
        return now2;
      } else {
        return dayjs(props2.modelValue).locale(lang.value);
      }
    });
    const validatedRange = computed(() => {
      if (!props2.range)
        return [];
      const rangeArrDayjs = props2.range.map((_) => dayjs(_).locale(lang.value));
      const [startDayjs, endDayjs] = rangeArrDayjs;
      if (startDayjs.isAfter(endDayjs)) {
        console.warn("[ElementCalendar]end time should be greater than start time");
        return [];
      }
      if (startDayjs.isSame(endDayjs, "month")) {
        return [[
          startDayjs.startOf("week"),
          endDayjs.endOf("week")
        ]];
      } else {
        if (startDayjs.add(1, "month").month() !== endDayjs.month()) {
          console.warn("[ElementCalendar]start time and end time interval must not exceed two months");
          return [];
        }
        const endMonthFirstDay = endDayjs.startOf("month");
        const endMonthFirstWeekDay = endMonthFirstDay.startOf("week");
        let endMonthStart = endMonthFirstDay;
        if (!endMonthFirstDay.isSame(endMonthFirstWeekDay, "month")) {
          endMonthStart = endMonthFirstDay.endOf("week").add(1, "day");
        }
        return [
          [
            startDayjs.startOf("week"),
            startDayjs.endOf("month")
          ],
          [
            endMonthStart,
            endDayjs.endOf("week")
          ]
        ];
      }
    });
    const pickDay = (day) => {
      realSelectedDay.value = day;
    };
    const selectDate = (type2) => {
      let day;
      if (type2 === "prev-month") {
        day = prevMonthDayjs.value;
      } else if (type2 === "next-month") {
        day = nextMonthDayjs.value;
      } else {
        day = now2;
      }
      if (day.isSame(date3.value, "day"))
        return;
      pickDay(day);
    };
    return {
      selectedDay,
      curMonthDatePrefix,
      i18nDate,
      realSelectedDay,
      date: date3,
      validatedRange,
      pickDay,
      selectDate,
      t
    };
  }
});
const _hoisted_1$1$k = { class: "el-calendar" };
const _hoisted_2$1$d = { class: "el-calendar__header" };
const _hoisted_3$1$b = { class: "el-calendar__title" };
const _hoisted_4$F = {
  key: 0,
  class: "el-calendar__button-group"
};
const _hoisted_5$y = {
  key: 0,
  class: "el-calendar__body"
};
const _hoisted_6$s = {
  key: 1,
  class: "el-calendar__body"
};
function render$1$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_el_button_group = resolveComponent("el-button-group");
  const _component_date_table = resolveComponent("date-table");
  return openBlock(), createElementBlock("div", _hoisted_1$1$k, [
    createElementVNode("div", _hoisted_2$1$d, [
      createElementVNode("div", _hoisted_3$1$b, toDisplayString(_ctx.i18nDate), 1),
      _ctx.validatedRange.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_4$F, [
        createVNode(_component_el_button_group, null, {
          default: withCtx(() => [
            createVNode(_component_el_button, {
              size: "mini",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.selectDate("prev-month"))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.t("el.datepicker.prevMonth")), 1)
              ]),
              _: 1
            }),
            createVNode(_component_el_button, {
              size: "mini",
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.selectDate("today"))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.t("el.datepicker.today")), 1)
              ]),
              _: 1
            }),
            createVNode(_component_el_button, {
              size: "mini",
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.selectDate("next-month"))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.t("el.datepicker.nextMonth")), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ])) : createCommentVNode("v-if", true)
    ]),
    _ctx.validatedRange.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_5$y, [
      createVNode(_component_date_table, {
        date: _ctx.date,
        "selected-day": _ctx.realSelectedDay,
        onPick: _ctx.pickDay
      }, createSlots({ _: 2 }, [
        _ctx.$slots.dateCell ? {
          name: "dateCell",
          fn: withCtx((data) => [
            renderSlot(_ctx.$slots, "dateCell", normalizeProps(guardReactiveProps(data)))
          ])
        } : void 0
      ]), 1032, ["date", "selected-day", "onPick"])
    ])) : (openBlock(), createElementBlock("div", _hoisted_6$s, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.validatedRange, (range_, index2) => {
        return openBlock(), createBlock(_component_date_table, {
          key: index2,
          date: range_[0],
          "selected-day": _ctx.realSelectedDay,
          range: range_,
          "hide-header": index2 !== 0,
          onPick: _ctx.pickDay
        }, createSlots({ _: 2 }, [
          _ctx.$slots.dateCell ? {
            name: "dateCell",
            fn: withCtx((data) => [
              renderSlot(_ctx.$slots, "dateCell", normalizeProps(guardReactiveProps(data)))
            ])
          } : void 0
        ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]);
      }), 128))
    ]))
  ]);
}
script$1$r.render = render$1$q;
script$1$r.__file = "packages/components/calendar/src/workprogress.vue";
script$1$r.install = (app) => {
  app.component(script$1$r.name, script$1$r);
};
const _Calendar = script$1$r;
const ElCalendar = _Calendar;
var script$O = defineComponent({
  name: "ElCard",
  props: {
    header: {
      type: String,
      default: ""
    },
    bodyStyle: {
      type: [String, Object, Array],
      default: ""
    },
    shadow: {
      type: String,
      default: ""
    }
  }
});
const _hoisted_1$13 = {
  key: 0,
  class: "el-card__header"
};
function render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-card", _ctx.shadow ? "is-" + _ctx.shadow + "-shadow" : "is-always-shadow"])
  }, [
    _ctx.$slots.header || _ctx.header ? (openBlock(), createElementBlock("div", _hoisted_1$13, [
      renderSlot(_ctx.$slots, "header", {}, () => [
        createTextVNode(toDisplayString(_ctx.header), 1)
      ])
    ])) : createCommentVNode("v-if", true),
    createElementVNode("div", {
      class: "el-card__body",
      style: normalizeStyle(_ctx.bodyStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)
  ], 2);
}
script$O.render = render$M;
script$O.__file = "packages/components/card/src/workprogress.vue";
script$O.install = (app) => {
  app.component(script$O.name, script$O);
};
const _Card = script$O;
const ElCard = _Card;
var script$N = defineComponent({
  name: "ElCarousel",
  props: {
    initialIndex: {
      type: Number,
      default: 0
    },
    height: { type: String, default: "" },
    trigger: {
      type: String,
      default: "hover"
    },
    autoplay: {
      type: Boolean,
      default: true
    },
    interval: {
      type: Number,
      default: 3e3
    },
    indicatorPosition: { type: String, default: "" },
    indicator: {
      type: Boolean,
      default: true
    },
    arrow: {
      type: String,
      default: "hover"
    },
    type: { type: String, default: "" },
    loop: {
      type: Boolean,
      default: true
    },
    direction: {
      type: String,
      default: "horizontal",
      validator(val) {
        return ["horizontal", "vertical"].includes(val);
      }
    },
    pauseOnHover: {
      type: Boolean,
      default: true
    }
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    const data = reactive({
      activeIndex: -1,
      containerWidth: 0,
      timer: null,
      hover: false
    });
    const root2 = ref(null);
    const items = ref([]);
    const arrowDisplay = computed(() => props2.arrow !== "never" && props2.direction !== "vertical");
    const hasLabel = computed(() => {
      return items.value.some((item) => item.label.toString().length > 0);
    });
    const carouselClasses = computed(() => {
      const classes = ["el-carousel", "el-carousel--" + props2.direction];
      if (props2.type === "card") {
        classes.push("el-carousel--card");
      }
      return classes;
    });
    const indicatorsClasses = computed(() => {
      const classes = [
        "el-carousel__indicators",
        "el-carousel__indicators--" + props2.direction
      ];
      if (hasLabel.value) {
        classes.push("el-carousel__indicators--labels");
      }
      if (props2.indicatorPosition === "outside" || props2.type === "card") {
        classes.push("el-carousel__indicators--outside");
      }
      return classes;
    });
    const throttledArrowClick = throttle_1((index2) => {
      setActiveItem(index2);
    }, 300, { trailing: true });
    const throttledIndicatorHover = throttle_1((index2) => {
      handleIndicatorHover(index2);
    }, 300);
    function pauseTimer() {
      if (data.timer) {
        clearInterval(data.timer);
        data.timer = null;
      }
    }
    function startTimer() {
      if (props2.interval <= 0 || !props2.autoplay || data.timer)
        return;
      data.timer = setInterval(() => playSlides(), props2.interval);
    }
    const playSlides = () => {
      if (data.activeIndex < items.value.length - 1) {
        data.activeIndex = data.activeIndex + 1;
      } else if (props2.loop) {
        data.activeIndex = 0;
      }
    };
    function setActiveItem(index2) {
      if (typeof index2 === "string") {
        const filteredItems = items.value.filter((item) => item.name === index2);
        if (filteredItems.length > 0) {
          index2 = items.value.indexOf(filteredItems[0]);
        }
      }
      index2 = Number(index2);
      if (isNaN(index2) || index2 !== Math.floor(index2)) {
        console.warn("[Element Warn][Carousel]index must be an integer.");
        return;
      }
      let length = items.value.length;
      const oldIndex2 = data.activeIndex;
      if (index2 < 0) {
        data.activeIndex = props2.loop ? length - 1 : 0;
      } else if (index2 >= length) {
        data.activeIndex = props2.loop ? 0 : length - 1;
      } else {
        data.activeIndex = index2;
      }
      if (oldIndex2 === data.activeIndex) {
        resetItemPosition(oldIndex2);
      }
    }
    function resetItemPosition(oldIndex2) {
      items.value.forEach((item, index2) => {
        item.translateItem(index2, data.activeIndex, oldIndex2);
      });
    }
    function addItem(item) {
      items.value.push(item);
    }
    function removeItem(uid2) {
      const index2 = items.value.findIndex((item) => item.uid === uid2);
      if (index2 !== -1) {
        items.value.splice(index2, 1);
        if (data.activeIndex === index2)
          next();
      }
    }
    function itemInStage(item, index2) {
      const length = items.value.length;
      if (index2 === length - 1 && item.inStage && items.value[0].active || item.inStage && items.value[index2 + 1] && items.value[index2 + 1].active) {
        return "left";
      } else if (index2 === 0 && item.inStage && items.value[length - 1].active || item.inStage && items.value[index2 - 1] && items.value[index2 - 1].active) {
        return "right";
      }
      return false;
    }
    function handleMouseEnter() {
      data.hover = true;
      if (props2.pauseOnHover) {
        pauseTimer();
      }
    }
    function handleMouseLeave() {
      data.hover = false;
      startTimer();
    }
    function handleButtonEnter(arrow2) {
      if (props2.direction === "vertical")
        return;
      items.value.forEach((item, index2) => {
        if (arrow2 === itemInStage(item, index2)) {
          item.hover = true;
        }
      });
    }
    function handleButtonLeave() {
      if (props2.direction === "vertical")
        return;
      items.value.forEach((item) => {
        item.hover = false;
      });
    }
    function handleIndicatorClick(index2) {
      data.activeIndex = index2;
    }
    function handleIndicatorHover(index2) {
      if (props2.trigger === "hover" && index2 !== data.activeIndex) {
        data.activeIndex = index2;
      }
    }
    function prev() {
      setActiveItem(data.activeIndex - 1);
    }
    function next() {
      setActiveItem(data.activeIndex + 1);
    }
    watch(() => data.activeIndex, (current, prev2) => {
      resetItemPosition(prev2);
      if (prev2 > -1) {
        emit2("change", current, prev2);
      }
    });
    watch(() => props2.autoplay, (current) => {
      current ? startTimer() : pauseTimer();
    });
    watch(() => props2.loop, () => {
      setActiveItem(data.activeIndex);
    });
    onMounted(() => {
      nextTick(() => {
        addResizeListener(root2.value, resetItemPosition);
        if (props2.initialIndex < items.value.length && props2.initialIndex >= 0) {
          data.activeIndex = props2.initialIndex;
        }
        startTimer();
      });
    });
    onBeforeUnmount(() => {
      if (root2.value)
        removeResizeListener(root2.value, resetItemPosition);
      pauseTimer();
    });
    provide("injectCarouselScope", {
      root: root2,
      direction: props2.direction,
      type: props2.type,
      items,
      loop: props2.loop,
      addItem,
      removeItem,
      setActiveItem
    });
    return {
      data,
      props: props2,
      items,
      arrowDisplay,
      carouselClasses,
      indicatorsClasses,
      hasLabel,
      handleMouseEnter,
      handleMouseLeave,
      handleIndicatorClick,
      throttledArrowClick,
      throttledIndicatorHover,
      handleButtonEnter,
      handleButtonLeave,
      prev,
      next,
      setActiveItem,
      root: root2
    };
  }
});
const _hoisted_1$12 = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-arrow-left" }, null, -1);
const _hoisted_2$U = [
  _hoisted_1$12
];
const _hoisted_3$R = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-arrow-right" }, null, -1);
const _hoisted_4$E = [
  _hoisted_3$R
];
const _hoisted_5$x = ["onMouseenter", "onClick"];
const _hoisted_6$r = { class: "el-carousel__button" };
const _hoisted_7$k = { key: 0 };
function render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "root",
    class: normalizeClass(_ctx.carouselClasses),
    onMouseenter: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args), ["stop"])),
    onMouseleave: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args), ["stop"]))
  }, [
    createElementVNode("div", {
      class: "el-carousel__container",
      style: normalizeStyle({ height: _ctx.height })
    }, [
      _ctx.arrowDisplay ? (openBlock(), createBlock(Transition, {
        key: 0,
        name: "carousel-arrow-left"
      }, {
        default: withCtx(() => [
          withDirectives(createElementVNode("button", {
            type: "button",
            class: "el-carousel__arrow el-carousel__arrow--left",
            onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.handleButtonEnter("left")),
            onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.handleButtonLeave && _ctx.handleButtonLeave(...args)),
            onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.throttledArrowClick(_ctx.data.activeIndex - 1), ["stop"]))
          }, _hoisted_2$U, 544), [
            [
              vShow,
              (_ctx.arrow === "always" || _ctx.data.hover) && (_ctx.props.loop || _ctx.data.activeIndex > 0)
            ]
          ])
        ]),
        _: 1
      })) : createCommentVNode("v-if", true),
      _ctx.arrowDisplay ? (openBlock(), createBlock(Transition, {
        key: 1,
        name: "carousel-arrow-right"
      }, {
        default: withCtx(() => [
          withDirectives(createElementVNode("button", {
            type: "button",
            class: "el-carousel__arrow el-carousel__arrow--right",
            onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.handleButtonEnter("right")),
            onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.handleButtonLeave && _ctx.handleButtonLeave(...args)),
            onClick: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.throttledArrowClick(_ctx.data.activeIndex + 1), ["stop"]))
          }, _hoisted_4$E, 544), [
            [
              vShow,
              (_ctx.arrow === "always" || _ctx.data.hover) && (_ctx.props.loop || _ctx.data.activeIndex < _ctx.items.length - 1)
            ]
          ])
        ]),
        _: 1
      })) : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default")
    ], 4),
    _ctx.indicatorPosition !== "none" ? (openBlock(), createElementBlock("ul", {
      key: 0,
      class: normalizeClass(_ctx.indicatorsClasses)
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item, index2) => {
        return openBlock(), createElementBlock("li", {
          key: index2,
          class: normalizeClass([
            "el-carousel__indicator",
            "el-carousel__indicator--" + _ctx.direction,
            { "is-active": index2 === _ctx.data.activeIndex }
          ]),
          onMouseenter: ($event) => _ctx.throttledIndicatorHover(index2),
          onClick: withModifiers(($event) => _ctx.handleIndicatorClick(index2), ["stop"])
        }, [
          createElementVNode("button", _hoisted_6$r, [
            _ctx.hasLabel ? (openBlock(), createElementBlock("span", _hoisted_7$k, toDisplayString(item.label), 1)) : createCommentVNode("v-if", true)
          ])
        ], 42, _hoisted_5$x);
      }), 128))
    ], 2)) : createCommentVNode("v-if", true)
  ], 34);
}
script$N.render = render$L;
script$N.__file = "packages/components/carousel/src/main.vue";
var __defProp$o = Object.defineProperty;
var __defProps$l = Object.defineProperties;
var __getOwnPropDescs$l = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$o = Object.getOwnPropertySymbols;
var __hasOwnProp$o = Object.prototype.hasOwnProperty;
var __propIsEnum$o = Object.prototype.propertyIsEnumerable;
var __defNormalProp$o = (obj, key, value2) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$o = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$o.call(b, prop))
      __defNormalProp$o(a, prop, b[prop]);
  if (__getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(b)) {
      if (__propIsEnum$o.call(b, prop))
        __defNormalProp$o(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$l = (a, b) => __defProps$l(a, __getOwnPropDescs$l(b));
const CARD_SCALE = 0.83;
var script$1$q = defineComponent({
  name: "ElCarouselItem",
  props: {
    name: { type: String, default: "" },
    label: {
      type: [String, Number],
      default: ""
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    instance.uid;
    const data = reactive({
      hover: false,
      translate: 0,
      scale: 1,
      active: false,
      ready: false,
      inStage: false,
      animating: false
    });
    const injectCarouselScope = inject("injectCarouselScope");
    const parentDirection = computed(() => {
      return injectCarouselScope.direction;
    });
    const itemStyle = computed(() => {
      const translateType = parentDirection.value === "vertical" ? "translateY" : "translateX";
      const value2 = `${translateType}(${data.translate}px) scale(${data.scale})`;
      const style = {
        transform: value2
      };
      return autoprefixer(style);
    });
    function processIndex(index2, activeIndex, length) {
      if (activeIndex === 0 && index2 === length - 1) {
        return -1;
      } else if (activeIndex === length - 1 && index2 === 0) {
        return length;
      } else if (index2 < activeIndex - 1 && activeIndex - index2 >= length / 2) {
        return length + 1;
      } else if (index2 > activeIndex + 1 && index2 - activeIndex >= length / 2) {
        return -2;
      }
      return index2;
    }
    function calcCardTranslate(index2, activeIndex) {
      var _a;
      const parentWidth = ((_a = injectCarouselScope.root.value) == null ? void 0 : _a.offsetWidth) || 0;
      if (data.inStage) {
        return parentWidth * ((2 - CARD_SCALE) * (index2 - activeIndex) + 1) / 4;
      } else if (index2 < activeIndex) {
        return -(1 + CARD_SCALE) * parentWidth / 4;
      } else {
        return (3 + CARD_SCALE) * parentWidth / 4;
      }
    }
    function calcTranslate(index2, activeIndex, isVertical) {
      var _a, _b;
      const distance = (isVertical ? (_a = injectCarouselScope.root.value) == null ? void 0 : _a.offsetHeight : (_b = injectCarouselScope.root.value) == null ? void 0 : _b.offsetWidth) || 0;
      return distance * (index2 - activeIndex);
    }
    const translateItem = (index2, activeIndex, oldIndex2) => {
      const parentType = injectCarouselScope.type;
      const length = injectCarouselScope.items.value.length;
      if (parentType !== "card" && oldIndex2 !== void 0) {
        data.animating = index2 === activeIndex || index2 === oldIndex2;
      }
      if (index2 !== activeIndex && length > 2 && injectCarouselScope.loop) {
        index2 = processIndex(index2, activeIndex, length);
      }
      if (parentType === "card") {
        if (parentDirection.value === "vertical") {
          console.warn("[Element Warn][Carousel]vertical direction is not supported in card mode");
        }
        data.inStage = Math.round(Math.abs(index2 - activeIndex)) <= 1;
        data.active = index2 === activeIndex;
        data.translate = calcCardTranslate(index2, activeIndex);
        data.scale = data.active ? 1 : CARD_SCALE;
      } else {
        data.active = index2 === activeIndex;
        const isVertical = parentDirection.value === "vertical";
        data.translate = calcTranslate(index2, activeIndex, isVertical);
      }
      data.ready = true;
    };
    function handleItemClick() {
      if (injectCarouselScope && injectCarouselScope.type === "card") {
        const index2 = injectCarouselScope.items.value.map((d) => d.uid).indexOf(instance.uid);
        injectCarouselScope.setActiveItem(index2);
      }
    }
    onMounted(() => {
      if (injectCarouselScope.addItem) {
        injectCarouselScope.addItem(__spreadProps$l(__spreadValues$o(__spreadValues$o({
          uid: instance.uid
        }, props2), toRefs(data)), {
          translateItem
        }));
      }
    });
    onUnmounted(() => {
      if (injectCarouselScope.removeItem) {
        injectCarouselScope.removeItem(instance.uid);
      }
    });
    return {
      data,
      itemStyle,
      translateItem,
      type: injectCarouselScope.type,
      handleItemClick
    };
  }
});
const _hoisted_1$1$j = {
  key: 0,
  class: "el-carousel__mask"
};
function render$1$p(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-carousel__item", {
      "is-active": _ctx.data.active,
      "el-carousel__item--card": _ctx.type === "card",
      "is-in-stage": _ctx.data.inStage,
      "is-hover": _ctx.data.hover,
      "is-animating": _ctx.data.animating
    }]),
    style: normalizeStyle(_ctx.itemStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleItemClick && _ctx.handleItemClick(...args))
  }, [
    _ctx.type === "card" ? withDirectives((openBlock(), createElementBlock("div", _hoisted_1$1$j, null, 512)), [
      [vShow, !_ctx.data.active]
    ]) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "default")
  ], 6)), [
    [vShow, _ctx.data.ready]
  ]);
}
script$1$q.render = render$1$p;
script$1$q.__file = "packages/components/carousel/src/item.vue";
script$N.install = (app) => {
  app.component(script$N.name, script$N);
  app.component(script$1$q.name, script$1$q);
};
script$N.CarouselItem = script$1$q;
const _Carousel = script$N;
const ElCarousel = _Carousel;
function scrollIntoView$1(container, selected) {
  if (isServer)
    return;
  if (!selected) {
    container.scrollTop = 0;
    return;
  }
  const offsetParents = [];
  let pointer = selected.offsetParent;
  while (pointer !== null && container !== pointer && container.contains(pointer)) {
    offsetParents.push(pointer);
    pointer = pointer.offsetParent;
  }
  const top2 = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
  const bottom2 = top2 + selected.offsetHeight;
  const viewRectTop = container.scrollTop;
  const viewRectBottom = viewRectTop + container.clientHeight;
  if (top2 < viewRectTop) {
    container.scrollTop = top2;
  } else if (bottom2 > viewRectBottom) {
    container.scrollTop = bottom2 - container.clientHeight;
  }
}
const useCheckboxProps = {
  modelValue: {
    type: [Boolean, Number, String],
    default: () => void 0
  },
  label: {
    type: [String, Boolean, Number, Object]
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  size: String
};
const useCheckboxGroup = () => {
  const ELEMENT = useGlobalConfig();
  const elForm = inject(elFormKey, {});
  const elFormItem = inject(elFormItemKey, {});
  const checkboxGroup = inject("CheckboxGroup", {});
  const isGroup = computed(() => checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === "ElCheckboxGroup");
  const elFormItemSize = computed(() => {
    return elFormItem.size;
  });
  return {
    isGroup,
    checkboxGroup,
    elForm,
    ELEMENT,
    elFormItemSize,
    elFormItem
  };
};
const useModel = (props2) => {
  const selfModel = ref(false);
  const { emit: emit2 } = getCurrentInstance();
  const { isGroup, checkboxGroup } = useCheckboxGroup();
  const isLimitExceeded = ref(false);
  const store = computed(() => {
    var _a;
    return checkboxGroup ? (_a = checkboxGroup.modelValue) == null ? void 0 : _a.value : props2.modelValue;
  });
  const model = computed({
    get() {
      var _a;
      return isGroup.value ? store.value : (_a = props2.modelValue) != null ? _a : selfModel.value;
    },
    set(val) {
      var _a;
      if (isGroup.value && Array.isArray(val)) {
        isLimitExceeded.value = false;
        if (checkboxGroup.min !== void 0 && val.length < checkboxGroup.min.value) {
          isLimitExceeded.value = true;
        }
        if (checkboxGroup.max !== void 0 && val.length > checkboxGroup.max.value) {
          isLimitExceeded.value = true;
        }
        isLimitExceeded.value === false && ((_a = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _a.call(checkboxGroup, val));
      } else {
        emit2(UPDATE_MODEL_EVENT, val);
        selfModel.value = val;
      }
    }
  });
  return {
    model,
    isLimitExceeded
  };
};
const useCheckboxStatus = (props2, { model }) => {
  const { isGroup, checkboxGroup, elFormItemSize, ELEMENT } = useCheckboxGroup();
  const focus = ref(false);
  const size = computed(() => {
    var _a;
    return ((_a = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a.value) || elFormItemSize.value || ELEMENT.size;
  });
  const isChecked = computed(() => {
    const value2 = model.value;
    if (toTypeString(value2) === "[object Boolean]") {
      return value2;
    } else if (Array.isArray(value2)) {
      return value2.includes(props2.label);
    } else if (value2 !== null && value2 !== void 0) {
      return value2 === props2.trueLabel;
    }
  });
  const checkboxSize = computed(() => {
    var _a;
    const temCheckboxSize = props2.size || elFormItemSize.value || ELEMENT.size;
    return isGroup.value ? ((_a = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a.value) || temCheckboxSize : temCheckboxSize;
  });
  return {
    isChecked,
    focus,
    size,
    checkboxSize
  };
};
const useDisabled = (props2, { model, isChecked }) => {
  const { elForm, isGroup, checkboxGroup } = useCheckboxGroup();
  const isLimitDisabled = computed(() => {
    var _a, _b;
    const max2 = (_a = checkboxGroup.max) == null ? void 0 : _a.value;
    const min2 = (_b = checkboxGroup.min) == null ? void 0 : _b.value;
    return !!(max2 || min2) && (model.value.length >= max2 && !isChecked.value) || model.value.length <= min2 && isChecked.value;
  });
  const isDisabled = computed(() => {
    var _a;
    const disabled = props2.disabled || elForm.disabled;
    return isGroup.value ? ((_a = checkboxGroup.disabled) == null ? void 0 : _a.value) || disabled || isLimitDisabled.value : props2.disabled || elForm.disabled;
  });
  return {
    isDisabled,
    isLimitDisabled
  };
};
const setStoreValue = (props2, { model }) => {
  function addToStore() {
    if (Array.isArray(model.value) && !model.value.includes(props2.label)) {
      model.value.push(props2.label);
    } else {
      model.value = props2.trueLabel || true;
    }
  }
  props2.checked && addToStore();
};
const useEvent$1 = (props2, { isLimitExceeded }) => {
  const { elFormItem } = useCheckboxGroup();
  const { emit: emit2 } = getCurrentInstance();
  function handleChange(e) {
    var _a, _b;
    if (isLimitExceeded.value)
      return;
    const target = e.target;
    const value2 = target.checked ? (_a = props2.trueLabel) != null ? _a : true : (_b = props2.falseLabel) != null ? _b : false;
    emit2("change", value2, e);
  }
  watch(() => props2.modelValue, (val) => {
    var _a;
    (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", [val]);
  });
  return {
    handleChange
  };
};
const useCheckbox = (props2) => {
  const { model, isLimitExceeded } = useModel(props2);
  const { focus, size, isChecked, checkboxSize } = useCheckboxStatus(props2, { model });
  const { isDisabled } = useDisabled(props2, { model, isChecked });
  const { handleChange } = useEvent$1(props2, { isLimitExceeded });
  setStoreValue(props2, { model });
  return {
    isChecked,
    isDisabled,
    checkboxSize,
    model,
    handleChange,
    focus,
    size
  };
};
var script$M = defineComponent({
  name: "ElCheckbox",
  props: {
    modelValue: {
      type: [Boolean, Number, String],
      default: () => void 0
    },
    label: {
      type: [String, Boolean, Number, Object]
    },
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: {
      type: String,
      default: void 0
    },
    trueLabel: {
      type: [String, Number],
      default: void 0
    },
    falseLabel: {
      type: [String, Number],
      default: void 0
    },
    id: {
      type: String,
      default: void 0
    },
    controls: {
      type: String,
      default: void 0
    },
    border: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    }
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2) {
    return useCheckbox(props2);
  }
});
const _hoisted_1$11 = ["id", "aria-controls"];
const _hoisted_2$T = ["tabindex", "role", "aria-checked"];
const _hoisted_3$Q = /* @__PURE__ */ createElementVNode("span", { class: "el-checkbox__inner" }, null, -1);
const _hoisted_4$D = ["checked", "aria-hidden", "name", "disabled", "true-value", "false-value"];
const _hoisted_5$w = ["aria-hidden", "disabled", "value", "name"];
const _hoisted_6$q = {
  key: 0,
  class: "el-checkbox__label"
};
function render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    id: _ctx.id,
    class: normalizeClass(["el-checkbox", [
      _ctx.border && _ctx.checkboxSize ? "el-checkbox--" + _ctx.checkboxSize : "",
      { "is-disabled": _ctx.isDisabled },
      { "is-bordered": _ctx.border },
      { "is-checked": _ctx.isChecked }
    ]]),
    "aria-controls": _ctx.indeterminate ? _ctx.controls : null
  }, [
    createElementVNode("span", {
      class: normalizeClass(["el-checkbox__input", {
        "is-disabled": _ctx.isDisabled,
        "is-checked": _ctx.isChecked,
        "is-indeterminate": _ctx.indeterminate,
        "is-focus": _ctx.focus
      }]),
      tabindex: _ctx.indeterminate ? 0 : false,
      role: _ctx.indeterminate ? "checkbox" : false,
      "aria-checked": _ctx.indeterminate ? "mixed" : false
    }, [
      _hoisted_3$Q,
      _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
        key: 0,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
        checked: _ctx.isChecked,
        class: "el-checkbox__original",
        type: "checkbox",
        "aria-hidden": _ctx.indeterminate ? "true" : "false",
        name: _ctx.name,
        disabled: _ctx.isDisabled,
        "true-value": _ctx.trueLabel,
        "false-value": _ctx.falseLabel,
        onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.focus = true),
        onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focus = false)
      }, null, 40, _hoisted_4$D)), [
        [vModelCheckbox, _ctx.model]
      ]) : withDirectives((openBlock(), createElementBlock("input", {
        key: 1,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.model = $event),
        class: "el-checkbox__original",
        type: "checkbox",
        "aria-hidden": _ctx.indeterminate ? "true" : "false",
        disabled: _ctx.isDisabled,
        value: _ctx.label,
        name: _ctx.name,
        onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onFocus: _cache[6] || (_cache[6] = ($event) => _ctx.focus = true),
        onBlur: _cache[7] || (_cache[7] = ($event) => _ctx.focus = false)
      }, null, 40, _hoisted_5$w)), [
        [vModelCheckbox, _ctx.model]
      ])
    ], 10, _hoisted_2$T),
    _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", _hoisted_6$q, [
      renderSlot(_ctx.$slots, "default"),
      !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ], 2112)) : createCommentVNode("v-if", true)
    ])) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$11);
}
script$M.render = render$K;
script$M.__file = "packages/components/checkbox/src/checkbox.vue";
var script$1$p = defineComponent({
  name: "ElCheckboxButton",
  props: useCheckboxProps,
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2) {
    const { focus, isChecked, isDisabled, size, model, handleChange } = useCheckbox(props2);
    const { checkboxGroup } = useCheckboxGroup();
    const activeStyle = computed(() => {
      var _a, _b, _c, _d;
      const fillValue = (_b = (_a = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a.value) != null ? _b : "";
      return {
        backgroundColor: fillValue,
        borderColor: fillValue,
        color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
        boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : null
      };
    });
    return {
      focus,
      isChecked,
      isDisabled,
      model,
      handleChange,
      activeStyle,
      size
    };
  }
});
const _hoisted_1$1$i = ["aria-checked", "aria-disabled"];
const _hoisted_2$1$c = ["checked", "name", "disabled", "true-value", "false-value"];
const _hoisted_3$1$a = ["name", "disabled", "value"];
function render$1$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["el-checkbox-button", [
      _ctx.size ? "el-checkbox-button--" + _ctx.size : "",
      { "is-disabled": _ctx.isDisabled },
      { "is-checked": _ctx.isChecked },
      { "is-focus": _ctx.focus }
    ]]),
    role: "checkbox",
    "aria-checked": _ctx.isChecked,
    "aria-disabled": _ctx.isDisabled
  }, [
    _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
      key: 0,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
      checked: _ctx.isChecked,
      class: "el-checkbox-button__original",
      type: "checkbox",
      name: _ctx.name,
      disabled: _ctx.isDisabled,
      "true-value": _ctx.trueLabel,
      "false-value": _ctx.falseLabel,
      onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.focus = true),
      onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focus = false)
    }, null, 40, _hoisted_2$1$c)), [
      [vModelCheckbox, _ctx.model]
    ]) : withDirectives((openBlock(), createElementBlock("input", {
      key: 1,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.model = $event),
      class: "el-checkbox-button__original",
      type: "checkbox",
      name: _ctx.name,
      disabled: _ctx.isDisabled,
      value: _ctx.label,
      onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[6] || (_cache[6] = ($event) => _ctx.focus = true),
      onBlur: _cache[7] || (_cache[7] = ($event) => _ctx.focus = false)
    }, null, 40, _hoisted_3$1$a)), [
      [vModelCheckbox, _ctx.model]
    ]),
    _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
      key: 2,
      class: "el-checkbox-button__inner",
      style: normalizeStyle(_ctx.isChecked ? _ctx.activeStyle : null)
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 4)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$1$i);
}
script$1$p.render = render$1$o;
script$1$p.__file = "packages/components/checkbox/src/checkbox-button.vue";
var __defProp$n = Object.defineProperty;
var __defProps$k = Object.defineProperties;
var __getOwnPropDescs$k = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
var __hasOwnProp$n = Object.prototype.hasOwnProperty;
var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$n = (obj, key, value2) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$n = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$n.call(b, prop))
      __defNormalProp$n(a, prop, b[prop]);
  if (__getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(b)) {
      if (__propIsEnum$n.call(b, prop))
        __defNormalProp$n(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$k = (a, b) => __defProps$k(a, __getOwnPropDescs$k(b));
var script$2$h = defineComponent({
  name: "ElCheckboxGroup",
  props: {
    modelValue: {
      type: [Object, Boolean, Array],
      default: () => void 0
    },
    disabled: Boolean,
    min: {
      type: Number,
      default: void 0
    },
    max: {
      type: Number,
      default: void 0
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    fill: {
      type: String,
      default: void 0
    },
    textColor: {
      type: String,
      default: void 0
    }
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2, ctx2) {
    const { elFormItem, elFormItemSize, ELEMENT } = useCheckboxGroup();
    const checkboxGroupSize = computed(() => props2.size || elFormItemSize.value || ELEMENT.size);
    const changeEvent = (value2) => {
      ctx2.emit(UPDATE_MODEL_EVENT, value2);
      nextTick(() => {
        ctx2.emit("change", value2);
      });
    };
    const modelValue = computed({
      get() {
        return props2.modelValue;
      },
      set(val) {
        changeEvent(val);
      }
    });
    provide("CheckboxGroup", __spreadProps$k(__spreadValues$n({
      name: "ElCheckboxGroup",
      modelValue
    }, toRefs(props2)), {
      checkboxGroupSize,
      changeEvent
    }));
    watch(() => props2.modelValue, (val) => {
      var _a;
      (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", [val]);
    });
  }
});
const _hoisted_1$2$5 = {
  class: "el-checkbox-group",
  role: "group",
  "aria-label": "checkbox-group"
};
function render$2$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$2$5, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$2$h.render = render$2$e;
script$2$h.__file = "packages/components/checkbox/src/checkbox-group.vue";
script$M.install = (app) => {
  app.component(script$M.name, script$M);
  app.component(script$1$p.name, script$1$p);
  app.component(script$2$h.name, script$2$h);
};
script$M.CheckboxButton = script$1$p;
script$M.CheckboxGroup = script$2$h;
const _Checkbox = script$M;
const ElCheckbox = _Checkbox;
const ElCheckboxGroup$1 = script$2$h;
const radioGroupKey = "RadioGroup";
const useRadio = () => {
  const ELEMENT = useGlobalConfig();
  const elForm = inject(elFormKey, {});
  const elFormItem = inject(elFormItemKey, {});
  const radioGroup = inject(radioGroupKey, {});
  const focus = ref(false);
  const isGroup = computed(() => (radioGroup == null ? void 0 : radioGroup.name) === "ElRadioGroup");
  const elFormItemSize = computed(() => elFormItem.size || ELEMENT.size);
  return {
    isGroup,
    focus,
    radioGroup,
    elForm,
    ELEMENT,
    elFormItemSize
  };
};
const useRadioAttrs = (props2, {
  isGroup,
  radioGroup,
  elForm,
  model
}) => {
  const isDisabled = computed(() => {
    return isGroup.value ? radioGroup.disabled || props2.disabled || elForm.disabled : props2.disabled || elForm.disabled;
  });
  const tabIndex = computed(() => {
    return isDisabled.value || isGroup.value && model.value !== props2.label ? -1 : 0;
  });
  return {
    isDisabled,
    tabIndex
  };
};
var script$L = defineComponent({
  name: "ElRadio",
  componentName: "ElRadio",
  props: {
    modelValue: {
      type: [String, Number, Boolean],
      default: ""
    },
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    disabled: Boolean,
    name: {
      type: String,
      default: ""
    },
    border: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    }
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2, ctx2) {
    const {
      isGroup,
      radioGroup,
      elFormItemSize,
      ELEMENT,
      focus,
      elForm
    } = useRadio();
    const radioRef = ref();
    const model = computed({
      get() {
        return isGroup.value ? radioGroup.modelValue : props2.modelValue;
      },
      set(val) {
        if (isGroup.value) {
          radioGroup.changeEvent(val);
        } else {
          ctx2.emit(UPDATE_MODEL_EVENT, val);
        }
        radioRef.value.checked = props2.modelValue === props2.label;
      }
    });
    const {
      tabIndex,
      isDisabled
    } = useRadioAttrs(props2, {
      isGroup,
      radioGroup,
      elForm,
      model
    });
    const radioSize = computed(() => {
      const temRadioSize = props2.size || elFormItemSize.value || ELEMENT.size;
      return isGroup.value ? radioGroup.radioGroupSize || temRadioSize : temRadioSize;
    });
    function handleChange() {
      nextTick(() => {
        ctx2.emit("change", model.value);
      });
    }
    return {
      focus,
      isGroup,
      isDisabled,
      model,
      tabIndex,
      radioSize,
      handleChange,
      radioRef
    };
  }
});
const _hoisted_1$10 = ["aria-checked", "aria-disabled", "tabindex"];
const _hoisted_2$S = /* @__PURE__ */ createElementVNode("span", { class: "el-radio__inner" }, null, -1);
const _hoisted_3$P = ["value", "name", "disabled"];
function render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["el-radio", {
      [`el-radio--${_ctx.radioSize || ""}`]: _ctx.border && _ctx.radioSize,
      "is-disabled": _ctx.isDisabled,
      "is-focus": _ctx.focus,
      "is-bordered": _ctx.border,
      "is-checked": _ctx.model === _ctx.label
    }]),
    role: "radio",
    "aria-checked": _ctx.model === _ctx.label,
    "aria-disabled": _ctx.isDisabled,
    tabindex: _ctx.tabIndex,
    onKeydown: _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.model = _ctx.isDisabled ? _ctx.model : _ctx.label, ["stop", "prevent"]), ["space"]))
  }, [
    createElementVNode("span", {
      class: normalizeClass(["el-radio__input", {
        "is-disabled": _ctx.isDisabled,
        "is-checked": _ctx.model === _ctx.label
      }])
    }, [
      _hoisted_2$S,
      withDirectives(createElementVNode("input", {
        ref: "radioRef",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
        class: "el-radio__original",
        value: _ctx.label,
        type: "radio",
        "aria-hidden": "true",
        name: _ctx.name,
        disabled: _ctx.isDisabled,
        tabindex: "-1",
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.focus = true),
        onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.focus = false),
        onChange: _cache[3] || (_cache[3] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
      }, null, 40, _hoisted_3$P), [
        [vModelRadio, _ctx.model]
      ])
    ], 2),
    createElementVNode("span", {
      class: "el-radio__label",
      onKeydown: _cache[4] || (_cache[4] = withModifiers(() => {
      }, ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 32)
  ], 42, _hoisted_1$10);
}
script$L.render = render$J;
script$L.__file = "packages/components/radio/src/radio.vue";
var script$1$o = defineComponent({
  name: "ElRadioButton",
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    disabled: Boolean,
    name: {
      type: String,
      default: ""
    }
  },
  setup(props2) {
    const {
      isGroup,
      radioGroup,
      elFormItemSize,
      ELEMENT,
      focus,
      elForm
    } = useRadio();
    const size = computed(() => {
      return radioGroup.radioGroupSize || elFormItemSize.value || ELEMENT.size;
    });
    const radioRef = ref();
    const value2 = computed({
      get() {
        return radioGroup.modelValue;
      },
      set(value22) {
        radioGroup.changeEvent(value22);
        radioRef.value.checked = radioGroup.modelValue === props2.label;
      }
    });
    const {
      isDisabled,
      tabIndex
    } = useRadioAttrs(props2, {
      model: value2,
      elForm,
      radioGroup,
      isGroup
    });
    const activeStyle = computed(() => {
      return {
        backgroundColor: radioGroup.fill || "",
        borderColor: radioGroup.fill || "",
        boxShadow: radioGroup.fill ? `-1px 0 0 0 ${radioGroup.fill}` : "",
        color: radioGroup.textColor || ""
      };
    });
    return {
      isGroup,
      size,
      isDisabled,
      tabIndex,
      value: value2,
      focus,
      activeStyle,
      radioRef
    };
  }
});
const _hoisted_1$1$h = ["aria-checked", "aria-disabled", "tabindex"];
const _hoisted_2$1$b = ["value", "name", "disabled"];
function render$1$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["el-radio-button", [
      _ctx.size ? "el-radio-button--" + _ctx.size : "",
      {
        "is-active": _ctx.value === _ctx.label,
        "is-disabled": _ctx.isDisabled,
        "is-focus": _ctx.focus
      }
    ]]),
    role: "radio",
    "aria-checked": _ctx.value === _ctx.label,
    "aria-disabled": _ctx.isDisabled,
    tabindex: _ctx.tabIndex,
    onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.value = _ctx.isDisabled ? _ctx.value : _ctx.label, ["stop", "prevent"]), ["space"]))
  }, [
    withDirectives(createElementVNode("input", {
      ref: "radioRef",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event),
      class: "el-radio-button__original-radio",
      value: _ctx.label,
      type: "radio",
      name: _ctx.name,
      disabled: _ctx.isDisabled,
      tabindex: "-1",
      onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.focus = true),
      onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.focus = false)
    }, null, 40, _hoisted_2$1$b), [
      [vModelRadio, _ctx.value]
    ]),
    createElementVNode("span", {
      class: "el-radio-button__inner",
      style: normalizeStyle(_ctx.value === _ctx.label ? _ctx.activeStyle : null),
      onKeydown: _cache[3] || (_cache[3] = withModifiers(() => {
      }, ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 36)
  ], 42, _hoisted_1$1$h);
}
script$1$o.render = render$1$n;
script$1$o.__file = "packages/components/radio/src/radio-button.vue";
var __defProp$m = Object.defineProperty;
var __defProps$j = Object.defineProperties;
var __getOwnPropDescs$j = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$m = Object.getOwnPropertySymbols;
var __hasOwnProp$m = Object.prototype.hasOwnProperty;
var __propIsEnum$m = Object.prototype.propertyIsEnumerable;
var __defNormalProp$m = (obj, key, value2) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$m = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$m.call(b, prop))
      __defNormalProp$m(a, prop, b[prop]);
  if (__getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(b)) {
      if (__propIsEnum$m.call(b, prop))
        __defNormalProp$m(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$j = (a, b) => __defProps$j(a, __getOwnPropDescs$j(b));
var script$2$g = defineComponent({
  name: "ElRadioGroup",
  componentName: "ElRadioGroup",
  props: {
    modelValue: {
      type: [String, Number, Boolean],
      default: ""
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    fill: {
      type: String,
      default: ""
    },
    textColor: {
      type: String,
      default: ""
    },
    disabled: Boolean
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2, ctx2) {
    const radioGroup = ref(null);
    const elFormItem = inject(elFormItemKey, {});
    const radioGroupSize = computed(() => {
      return props2.size || elFormItem.size;
    });
    const changeEvent = (value2) => {
      ctx2.emit(UPDATE_MODEL_EVENT, value2);
      nextTick(() => {
        ctx2.emit("change", value2);
      });
    };
    provide(radioGroupKey, reactive(__spreadProps$j(__spreadValues$m({
      name: "ElRadioGroup"
    }, toRefs(props2)), {
      radioGroupSize,
      changeEvent
    })));
    watch(() => props2.modelValue, (val) => {
      var _a;
      (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", [val]);
    });
    const handleKeydown = (e) => {
      const target = e.target;
      const className = target.nodeName === "INPUT" ? "[type=radio]" : "[role=radio]";
      const radios = radioGroup.value.querySelectorAll(className);
      const length = radios.length;
      const index2 = Array.from(radios).indexOf(target);
      const roleRadios = radioGroup.value.querySelectorAll("[role=radio]");
      let nextIndex = null;
      switch (e.code) {
        case EVENT_CODE.left:
        case EVENT_CODE.up:
          e.stopPropagation();
          e.preventDefault();
          nextIndex = index2 === 0 ? length - 1 : index2 - 1;
          break;
        case EVENT_CODE.right:
        case EVENT_CODE.down:
          e.stopPropagation();
          e.preventDefault();
          nextIndex = index2 === length - 1 ? 0 : index2 + 1;
          break;
      }
      if (nextIndex === null)
        return;
      roleRadios[nextIndex].click();
      roleRadios[nextIndex].focus();
    };
    onMounted(() => {
      const radios = radioGroup.value.querySelectorAll("[type=radio]");
      const firstLabel = radios[0];
      if (!Array.from(radios).some((radio) => radio.checked) && firstLabel) {
        firstLabel.tabIndex = 0;
      }
    });
    return {
      handleKeydown,
      radioGroupSize,
      radioGroup
    };
  }
});
function render$2$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "radioGroup",
    class: "el-radio-group",
    role: "radiogroup",
    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 544);
}
script$2$g.render = render$2$d;
script$2$g.__file = "packages/components/radio/src/radio-group.vue";
script$L.install = (app) => {
  app.component(script$L.name, script$L);
  app.component(script$1$o.name, script$1$o);
  app.component(script$2$g.name, script$2$g);
};
script$L.RadioButton = script$1$o;
script$L.RadioGroup = script$2$g;
const _Radio = script$L;
const ElRadio = _Radio;
var ElRadio$1 = _Radio;
var NodeContent = defineComponent({
  name: "NodeContent",
  render() {
    const { node, panel } = this.$parent;
    const { data, label } = node;
    const { renderLabelFn } = panel;
    return h("span", { class: "el-cascader-node__label" }, renderLabelFn ? renderLabelFn({ node, data }) : label);
  }
});
var ExpandTrigger;
(function(ExpandTrigger2) {
  ExpandTrigger2["CLICK"] = "click";
  ExpandTrigger2["HOVER"] = "hover";
})(ExpandTrigger || (ExpandTrigger = {}));
const CASCADER_PANEL_INJECTION_KEY = Symbol();
var script$K = defineComponent({
  name: "ElCascaderNode",
  components: {
    ElCheckbox: _Checkbox,
    ElRadio: ElRadio$1,
    NodeContent
  },
  props: {
    node: {
      type: Object,
      required: true
    },
    menuId: String
  },
  emits: ["expand"],
  setup(props2, { emit: emit2 }) {
    const panel = inject(CASCADER_PANEL_INJECTION_KEY);
    const isHoverMenu = computed(() => panel.isHoverMenu);
    const multiple = computed(() => panel.config.multiple);
    const checkStrictly = computed(() => panel.config.checkStrictly);
    const checkedNodeId = computed(() => {
      var _a;
      return (_a = panel.checkedNodes[0]) == null ? void 0 : _a.uid;
    });
    const isDisabled = computed(() => props2.node.isDisabled);
    const isLeaf2 = computed(() => props2.node.isLeaf);
    const expandable = computed(() => checkStrictly.value && !isLeaf2.value || !isDisabled.value);
    const inExpandingPath = computed(() => isInPath(panel.expandingNode));
    const inCheckedPath = computed(() => checkStrictly.value && panel.checkedNodes.some(isInPath));
    const isInPath = (node) => {
      var _a;
      const { level, uid: uid2 } = props2.node;
      return ((_a = node == null ? void 0 : node.pathNodes[level - 1]) == null ? void 0 : _a.uid) === uid2;
    };
    const doExpand = () => {
      if (inExpandingPath.value)
        return;
      panel.expandNode(props2.node);
    };
    const doCheck = (checked) => {
      const { node } = props2;
      if (checked === node.checked)
        return;
      panel.handleCheckChange(node, checked);
    };
    const doLoad = () => {
      panel.lazyLoad(props2.node, () => {
        if (!isLeaf2.value)
          doExpand();
      });
    };
    const handleHoverExpand = (e) => {
      if (!isHoverMenu.value)
        return;
      handleExpand();
      !isLeaf2.value && emit2("expand", e);
    };
    const handleExpand = () => {
      const { node } = props2;
      if (!expandable.value || node.loading)
        return;
      node.loaded ? doExpand() : doLoad();
    };
    const handleClick = () => {
      if (isHoverMenu.value && !isLeaf2.value)
        return;
      if (isLeaf2.value && !isDisabled.value && !checkStrictly.value && !multiple.value) {
        handleCheck(true);
      } else {
        handleExpand();
      }
    };
    const handleCheck = (checked) => {
      if (!props2.node.loaded) {
        doLoad();
      } else {
        doCheck(checked);
        !checkStrictly.value && doExpand();
      }
    };
    return {
      panel,
      isHoverMenu,
      multiple,
      checkStrictly,
      checkedNodeId,
      isDisabled,
      isLeaf: isLeaf2,
      expandable,
      inExpandingPath,
      inCheckedPath,
      handleHoverExpand,
      handleExpand,
      handleClick,
      handleCheck
    };
  }
});
const _hoisted_1$$ = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"];
const _hoisted_2$R = /* @__PURE__ */ createElementVNode("span", null, null, -1);
const _hoisted_3$O = {
  key: 2,
  class: "el-icon-check el-cascader-node__prefix"
};
const _hoisted_4$C = {
  key: 0,
  class: "el-icon-loading el-cascader-node__postfix"
};
const _hoisted_5$v = {
  key: 1,
  class: "el-icon-arrow-right el-cascader-node__postfix"
};
function render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_radio = resolveComponent("el-radio");
  const _component_node_content = resolveComponent("node-content");
  return openBlock(), createElementBlock("li", {
    id: `${_ctx.menuId}-${_ctx.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !_ctx.isLeaf,
    "aria-owns": _ctx.isLeaf ? null : _ctx.menuId,
    "aria-expanded": _ctx.inExpandingPath,
    tabindex: _ctx.expandable ? -1 : null,
    class: normalizeClass([
      "el-cascader-node",
      _ctx.checkStrictly && "is-selectable",
      _ctx.inExpandingPath && "in-active-path",
      _ctx.inCheckedPath && "in-checked-path",
      _ctx.node.checked && "is-active",
      !_ctx.expandable && "is-disabled"
    ]),
    onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    createCommentVNode(" prefix "),
    _ctx.multiple ? (openBlock(), createBlock(_component_el_checkbox, {
      key: 0,
      "model-value": _ctx.node.checked,
      indeterminate: _ctx.node.indeterminate,
      disabled: _ctx.isDisabled,
      onClick: _cache[0] || (_cache[0] = withModifiers(() => {
      }, ["stop"])),
      "onUpdate:modelValue": _ctx.handleCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : _ctx.checkStrictly ? (openBlock(), createBlock(_component_el_radio, {
      key: 1,
      "model-value": _ctx.checkedNodeId,
      label: _ctx.node.uid,
      disabled: _ctx.isDisabled,
      "onUpdate:modelValue": _ctx.handleCheck,
      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
      }, ["stop"]))
    }, {
      default: withCtx(() => [
        createCommentVNode("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "),
        _hoisted_2$R
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : _ctx.isLeaf && _ctx.node.checked ? (openBlock(), createElementBlock("i", _hoisted_3$O)) : createCommentVNode("v-if", true),
    createCommentVNode(" content "),
    createVNode(_component_node_content),
    createCommentVNode(" postfix "),
    !_ctx.isLeaf ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
      _ctx.node.loading ? (openBlock(), createElementBlock("i", _hoisted_4$C)) : (openBlock(), createElementBlock("i", _hoisted_5$v))
    ], 2112)) : createCommentVNode("v-if", true)
  ], 42, _hoisted_1$$);
}
script$K.render = render$I;
script$K.__file = "packages/components/cascader-panel/src/node.vue";
var script$1$n = defineComponent({
  name: "ElCascaderMenu",
  components: {
    ElScrollbar: _Scrollbar,
    ElCascaderNode: script$K
  },
  props: {
    nodes: {
      type: Array,
      required: true
    },
    index: {
      type: Number,
      required: true
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const { t } = useLocaleInject();
    const id2 = generateId();
    let activeNode = null;
    let hoverTimer = null;
    const panel = inject(CASCADER_PANEL_INJECTION_KEY);
    const hoverZone = ref(null);
    const isEmpty2 = computed(() => !props2.nodes.length);
    const menuId = computed(() => `cascader-menu-${id2}-${props2.index}`);
    const handleExpand = (e) => {
      activeNode = e.target;
    };
    const handleMouseMove = (e) => {
      if (!panel.isHoverMenu || !activeNode || !hoverZone.value)
        return;
      if (activeNode.contains(e.target)) {
        clearHoverTimer();
        const el = instance.vnode.el;
        const { left: left2 } = el.getBoundingClientRect();
        const { offsetWidth, offsetHeight } = el;
        const startX = e.clientX - left2;
        const top2 = activeNode.offsetTop;
        const bottom2 = top2 + activeNode.offsetHeight;
        hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top2} L${offsetWidth} 0 V${top2} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom2} L${offsetWidth} ${offsetHeight} V${bottom2} Z" />
        `;
      } else if (!hoverTimer) {
        hoverTimer = window.setTimeout(clearHoverZone, panel.config.hoverThreshold);
      }
    };
    const clearHoverTimer = () => {
      if (!hoverTimer)
        return;
      clearTimeout(hoverTimer);
      hoverTimer = null;
    };
    const clearHoverZone = () => {
      if (!hoverZone.value)
        return;
      hoverZone.value.innerHTML = "";
      clearHoverTimer();
    };
    return {
      panel,
      hoverZone,
      isEmpty: isEmpty2,
      menuId,
      t,
      handleExpand,
      handleMouseMove,
      clearHoverZone
    };
  }
});
const _hoisted_1$1$g = {
  key: 0,
  class: "el-cascader-menu__empty-text"
};
const _hoisted_2$1$a = {
  key: 1,
  ref: "hoverZone",
  class: "el-cascader-menu__hover-zone"
};
function render$1$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_node = resolveComponent("el-cascader-node");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  return openBlock(), createBlock(_component_el_scrollbar, {
    id: _ctx.menuId,
    tag: "ul",
    role: "menu",
    class: "el-cascader-menu",
    "wrap-class": "el-cascader-menu__wrap",
    "view-class": [
      "el-cascader-menu__list",
      _ctx.isEmpty && "is-empty"
    ],
    onMousemove: _ctx.handleMouseMove,
    onMouseleave: _ctx.clearHoverZone
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.nodes, (node) => {
        return openBlock(), createBlock(_component_el_cascader_node, {
          key: node.uid,
          node,
          "menu-id": _ctx.menuId,
          onExpand: _ctx.handleExpand
        }, null, 8, ["node", "menu-id", "onExpand"]);
      }), 128)),
      _ctx.isEmpty ? (openBlock(), createElementBlock("div", _hoisted_1$1$g, toDisplayString(_ctx.t("el.cascader.noData")), 1)) : _ctx.panel.isHoverMenu ? (openBlock(), createElementBlock("svg", _hoisted_2$1$a, null, 512)) : createCommentVNode("v-if", true)
    ]),
    _: 1
  }, 8, ["id", "view-class", "onMousemove", "onMouseleave"]);
}
script$1$n.render = render$1$m;
script$1$n.__file = "packages/components/cascader-panel/src/menu.vue";
var ExpandTrigger$1;
(function(ExpandTrigger2) {
  ExpandTrigger2["CLICK"] = "click";
  ExpandTrigger2["HOVER"] = "hover";
})(ExpandTrigger$1 || (ExpandTrigger$1 = {}));
let uid = 0;
const calculatePathNodes = (node) => {
  const nodes = [node];
  let { parent: parent2 } = node;
  while (parent2) {
    nodes.unshift(parent2);
    parent2 = parent2.parent;
  }
  return nodes;
};
class Node$1 {
  constructor(data, config2, parent2, root2 = false) {
    this.data = data;
    this.config = config2;
    this.parent = parent2;
    this.root = root2;
    this.uid = uid++;
    this.checked = false;
    this.indeterminate = false;
    this.loading = false;
    const { value: valueKey, label: labelKey, children: childrenKey } = config2;
    const childrenData = data[childrenKey];
    const pathNodes = calculatePathNodes(this);
    this.level = root2 ? 0 : parent2 ? parent2.level + 1 : 1;
    this.value = data[valueKey];
    this.label = data[labelKey];
    this.pathNodes = pathNodes;
    this.pathValues = pathNodes.map((node) => node.value);
    this.pathLabels = pathNodes.map((node) => node.label);
    this.childrenData = childrenData;
    this.children = (childrenData || []).map((child) => new Node$1(child, config2, this));
    this.loaded = !config2.lazy || this.isLeaf || !isEmpty$1(childrenData);
  }
  get isDisabled() {
    const { data, parent: parent2, config: config2 } = this;
    const { disabled, checkStrictly } = config2;
    const isDisabled = isFunction$4(disabled) ? disabled(data, this) : !!data[disabled];
    return isDisabled || !checkStrictly && (parent2 == null ? void 0 : parent2.isDisabled);
  }
  get isLeaf() {
    const { data, config: config2, childrenData, loaded } = this;
    const { lazy, leaf } = config2;
    const isLeaf2 = isFunction$4(leaf) ? leaf(data, this) : data[leaf];
    return isUndefined$1(isLeaf2) ? lazy && !loaded ? false : !Array.isArray(childrenData) : !!isLeaf2;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(childData) {
    const { childrenData, children } = this;
    const node = new Node$1(childData, this.config, this);
    if (Array.isArray(childrenData)) {
      childrenData.push(childData);
    } else {
      this.childrenData = [childData];
    }
    children.push(node);
    return node;
  }
  calcText(allLevels, separator) {
    const text = allLevels ? this.pathLabels.join(separator) : this.label;
    this.text = text;
    return text;
  }
  broadcast(event2, ...args) {
    const handlerName = `onParent${capitalize(event2)}`;
    this.children.forEach((child) => {
      if (child) {
        child.broadcast(event2, ...args);
        child[handlerName] && child[handlerName](...args);
      }
    });
  }
  emit(event2, ...args) {
    const { parent: parent2 } = this;
    const handlerName = `onChild${capitalize(event2)}`;
    if (parent2) {
      parent2[handlerName] && parent2[handlerName](...args);
      parent2.emit(event2, ...args);
    }
  }
  onParentCheck(checked) {
    if (!this.isDisabled) {
      this.setCheckState(checked);
    }
  }
  onChildCheck() {
    const { children } = this;
    const validChildren = children.filter((child) => !child.isDisabled);
    const checked = validChildren.length ? validChildren.every((child) => child.checked) : false;
    this.setCheckState(checked);
  }
  setCheckState(checked) {
    const totalNum = this.children.length;
    const checkedNum = this.children.reduce((c, p) => {
      const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;
      return c + num;
    }, 0);
    this.checked = this.loaded && this.children.every((child) => child.loaded && child.checked) && checked;
    this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
  }
  doCheck(checked) {
    if (this.checked === checked)
      return;
    const { checkStrictly, multiple } = this.config;
    if (checkStrictly || !multiple) {
      this.checked = checked;
    } else {
      this.broadcast("check", checked);
      this.setCheckState(checked);
      this.emit("check");
    }
  }
}
const flatNodes = (nodes, leafOnly) => {
  return nodes.reduce((res, node) => {
    if (node.isLeaf) {
      res.push(node);
    } else {
      !leafOnly && res.push(node);
      res = res.concat(flatNodes(node.children, leafOnly));
    }
    return res;
  }, []);
};
class Store {
  constructor(data, config2) {
    this.config = config2;
    const nodes = (data || []).map((nodeData) => new Node$1(nodeData, this.config));
    this.nodes = nodes;
    this.allNodes = flatNodes(nodes, false);
    this.leafNodes = flatNodes(nodes, true);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(leafOnly) {
    return leafOnly ? this.leafNodes : this.allNodes;
  }
  appendNode(nodeData, parentNode) {
    const node = parentNode ? parentNode.appendChild(nodeData) : new Node$1(nodeData, this.config);
    if (!parentNode)
      this.nodes.push(node);
    this.allNodes.push(node);
    node.isLeaf && this.leafNodes.push(node);
  }
  appendNodes(nodeDataList, parentNode) {
    nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode));
  }
  getNodeByValue(value2, leafOnly = false) {
    if (!value2 && value2 !== 0)
      return null;
    const nodes = this.getFlattedNodes(leafOnly).filter((node) => isEqual_1(node.value, value2) || isEqual_1(node.pathValues, value2));
    return nodes[0] || null;
  }
  getSameNode(node) {
    if (!node)
      return null;
    const nodes = this.getFlattedNodes(false).filter(({ value: value2, level }) => isEqual_1(node.value, value2) && node.level === level);
    return nodes[0] || null;
  }
}
var __defProp$l = Object.defineProperty;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$l = (obj, key, value2) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$l = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$l.call(b, prop))
      __defNormalProp$l(a, prop, b[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b)) {
      if (__propIsEnum$l.call(b, prop))
        __defNormalProp$l(a, prop, b[prop]);
    }
  return a;
};
const CommonProps = {
  modelValue: [Number, String, Array],
  options: {
    type: Array,
    default: () => []
  },
  props: {
    type: Object,
    default: () => ({})
  }
};
const DefaultProps = {
  expandTrigger: ExpandTrigger$1.CLICK,
  multiple: false,
  checkStrictly: false,
  emitPath: true,
  lazy: false,
  lazyLoad: NOOP,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
};
const useCascaderConfig = (props2) => {
  return computed(() => __spreadValues$l(__spreadValues$l({}, DefaultProps), props2.props));
};
const isLeaf = (el) => !el.getAttribute("aria-owns");
const getSibling = (el, distance) => {
  const { parentNode } = el;
  if (!parentNode)
    return null;
  const siblings = parentNode.querySelectorAll('.el-cascader-node[tabindex="-1"]');
  const index2 = Array.prototype.indexOf.call(siblings, el);
  return siblings[index2 + distance] || null;
};
const getMenuIndex = (el) => {
  if (!el)
    return 0;
  const pieces = el.id.split("-");
  return Number(pieces[pieces.length - 2]);
};
const focusNode = (el) => {
  if (!el)
    return;
  el.focus();
  !isLeaf(el) && el.click();
};
const checkNode = (el) => {
  if (!el)
    return;
  const input2 = el.querySelector("input");
  if (input2) {
    input2.click();
  } else if (isLeaf(el)) {
    el.click();
  }
};
const sortByOriginalOrder = (oldNodes, newNodes) => {
  const newNodesCopy = newNodes.slice(0);
  const newIds = newNodesCopy.map((node) => node.uid);
  const res = oldNodes.reduce((acc, item) => {
    const index2 = newIds.indexOf(item.uid);
    if (index2 > -1) {
      acc.push(item);
      newNodesCopy.splice(index2, 1);
      newIds.splice(index2, 1);
    }
    return acc;
  }, []);
  res.push(...newNodesCopy);
  return res;
};
var __defProp$1$7 = Object.defineProperty;
var __defProps$i = Object.defineProperties;
var __getOwnPropDescs$i = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$7 = (obj, key, value2) => key in obj ? __defProp$1$7(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$7.call(b, prop))
      __defNormalProp$1$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$7)
    for (var prop of __getOwnPropSymbols$1$7(b)) {
      if (__propIsEnum$1$7.call(b, prop))
        __defNormalProp$1$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$i = (a, b) => __defProps$i(a, __getOwnPropDescs$i(b));
var script$2$f = defineComponent({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu: script$1$n
  },
  props: __spreadProps$i(__spreadValues$1$7({}, CommonProps), {
    border: {
      type: Boolean,
      default: true
    },
    renderLabel: Function
  }),
  emits: [
    UPDATE_MODEL_EVENT,
    CHANGE_EVENT,
    "close",
    "expand-change"
  ],
  setup(props2, { emit: emit2, slots }) {
    let initialLoaded = true;
    let manualChecked = false;
    const config2 = useCascaderConfig(props2);
    const store = ref(null);
    const menuList = ref([]);
    const checkedValue = ref(null);
    const menus = ref([]);
    const expandingNode = ref(null);
    const checkedNodes = ref([]);
    const isHoverMenu = computed(() => config2.value.expandTrigger === ExpandTrigger$1.HOVER);
    const renderLabelFn = computed(() => props2.renderLabel || slots.default);
    const initStore = () => {
      const { options: options2 } = props2;
      const cfg = config2.value;
      manualChecked = false;
      store.value = new Store(options2, cfg);
      menus.value = [store.value.getNodes()];
      if (cfg.lazy && isEmpty$1(props2.options)) {
        initialLoaded = false;
        lazyLoad(null, () => {
          initialLoaded = true;
          syncCheckedValue(false, true);
        });
      } else {
        syncCheckedValue(false, true);
      }
    };
    const lazyLoad = (node, cb) => {
      const cfg = config2.value;
      node = node || new Node$1({}, cfg, null, true);
      node.loading = true;
      const resolve = (dataList) => {
        const parent2 = node.root ? null : node;
        dataList && store.value.appendNodes(dataList, parent2);
        node.loading = false;
        node.loaded = true;
        cb && cb(dataList);
      };
      cfg.lazyLoad(node, resolve);
    };
    const expandNode = (node, silent) => {
      var _a;
      const { level } = node;
      const newMenus = menus.value.slice(0, level);
      let newExpandingNode;
      if (node.isLeaf) {
        newExpandingNode = node.pathNodes[level - 2];
      } else {
        newExpandingNode = node;
        newMenus.push(node.children);
      }
      if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {
        expandingNode.value = node;
        menus.value = newMenus;
        !silent && emit2("expand-change", (node == null ? void 0 : node.pathValues) || []);
      }
    };
    const handleCheckChange = (node, checked, emitClose = true) => {
      const { checkStrictly, multiple } = config2.value;
      const oldNode = checkedNodes.value[0];
      manualChecked = true;
      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));
      node.doCheck(checked);
      calculateCheckedValue();
      emitClose && !multiple && !checkStrictly && emit2("close");
    };
    const getFlattedNodes = (leafOnly) => {
      return store.value.getFlattedNodes(leafOnly);
    };
    const getCheckedNodes = (leafOnly) => {
      return getFlattedNodes(leafOnly).filter((node) => node.checked !== false);
    };
    const clearCheckedNodes = () => {
      checkedNodes.value.forEach((node) => node.doCheck(false));
      calculateCheckedValue();
    };
    const calculateCheckedValue = () => {
      var _a;
      const { checkStrictly, multiple } = config2.value;
      const oldNodes = checkedNodes.value;
      const newNodes = getCheckedNodes(!checkStrictly);
      const nodes = sortByOriginalOrder(oldNodes, newNodes);
      const values = nodes.map((node) => node.valueByOption);
      checkedNodes.value = nodes;
      checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;
    };
    const syncCheckedValue = (loaded = false, forced = false) => {
      const { modelValue } = props2;
      const { lazy, multiple, checkStrictly } = config2.value;
      const leafOnly = !checkStrictly;
      if (!initialLoaded || manualChecked || !forced && isEqual_1(modelValue, checkedValue.value))
        return;
      if (lazy && !loaded) {
        const values = deduplicate(arrayFlat(coerceTruthyValueToArray(modelValue)));
        const nodes = values.map((val) => store.value.getNodeByValue(val)).filter((node) => !!node && !node.loaded && !node.loading);
        if (nodes.length) {
          nodes.forEach((node) => {
            lazyLoad(node, () => syncCheckedValue(false, forced));
          });
        } else {
          syncCheckedValue(true, forced);
        }
      } else {
        const values = multiple ? coerceTruthyValueToArray(modelValue) : [modelValue];
        const nodes = deduplicate(values.map((val) => store.value.getNodeByValue(val, leafOnly)));
        syncMenuState(nodes, false);
        checkedValue.value = modelValue;
      }
    };
    const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {
      const { checkStrictly } = config2.value;
      const oldNodes = checkedNodes.value;
      const newNodes = newCheckedNodes.filter((node) => !!node && (checkStrictly || node.isLeaf));
      const oldExpandingNode = store.value.getSameNode(expandingNode.value);
      const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];
      if (newExpandingNode) {
        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true));
      } else {
        expandingNode.value = null;
      }
      oldNodes.forEach((node) => node.doCheck(false));
      newNodes.forEach((node) => node.doCheck(true));
      checkedNodes.value = newNodes;
      nextTick(scrollToExpandingNode);
    };
    const scrollToExpandingNode = () => {
      if (isServer)
        return;
      menuList.value.forEach((menu) => {
        const menuElement = menu == null ? void 0 : menu.$el;
        if (menuElement) {
          const container = menuElement.querySelector(".el-scrollbar__wrap");
          const activeNode = menuElement.querySelector(".el-cascader-node.is-active") || menuElement.querySelector(".el-cascader-node.in-active-path");
          scrollIntoView$1(container, activeNode);
        }
      });
    };
    const handleKeyDown = (e) => {
      const target = e.target;
      const { code } = e;
      switch (code) {
        case EVENT_CODE.up:
        case EVENT_CODE.down:
          const distance = code === EVENT_CODE.up ? -1 : 1;
          focusNode(getSibling(target, distance));
          break;
        case EVENT_CODE.left:
          const preMenu = menuList.value[getMenuIndex(target) - 1];
          const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector('.el-cascader-node[aria-expanded="true"]');
          focusNode(expandedNode);
          break;
        case EVENT_CODE.right:
          const nextMenu = menuList.value[getMenuIndex(target) + 1];
          const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector('.el-cascader-node[tabindex="-1"]');
          focusNode(firstNode);
          break;
        case EVENT_CODE.enter:
          checkNode(target);
          break;
        case EVENT_CODE.esc:
        case EVENT_CODE.tab:
          emit2("close");
          break;
      }
    };
    provide(CASCADER_PANEL_INJECTION_KEY, reactive({
      config: config2,
      expandingNode,
      checkedNodes,
      isHoverMenu,
      renderLabelFn,
      lazyLoad,
      expandNode,
      handleCheckChange
    }));
    watch([config2, () => props2.options], initStore, { deep: true, immediate: true });
    watch(() => props2.modelValue, () => {
      manualChecked = false;
      syncCheckedValue();
    });
    watch(checkedValue, (val) => {
      if (!isEqual_1(val, props2.modelValue)) {
        emit2(UPDATE_MODEL_EVENT, val);
        emit2(CHANGE_EVENT, val);
      }
    });
    onBeforeUpdate(() => menuList.value = []);
    onMounted(() => !isEmpty$1(props2.modelValue) && syncCheckedValue());
    return {
      menuList,
      menus,
      checkedNodes,
      handleKeyDown,
      handleCheckChange,
      getFlattedNodes,
      getCheckedNodes,
      clearCheckedNodes,
      calculateCheckedValue,
      scrollToExpandingNode
    };
  }
});
function render$2$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_menu = resolveComponent("el-cascader-menu");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      "el-cascader-panel",
      _ctx.border && "is-bordered"
    ]),
    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menus, (menu, index2) => {
      return openBlock(), createBlock(_component_el_cascader_menu, {
        key: index2,
        ref: (item) => _ctx.menuList[index2] = item,
        index: index2,
        nodes: menu
      }, null, 8, ["index", "nodes"]);
    }), 128))
  ], 34);
}
script$2$f.render = render$2$c;
script$2$f.__file = "packages/components/cascader-panel/src/workprogress.vue";
script$2$f.install = (app) => {
  app.component(script$2$f.name, script$2$f);
};
const _CascaderPanel = script$2$f;
const ElCascaderPanel = _CascaderPanel;
var script$J = defineComponent({
  name: "ElTag",
  props: {
    closable: Boolean,
    type: {
      type: String,
      default: ""
    },
    hit: Boolean,
    disableTransitions: Boolean,
    color: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    effect: {
      type: String,
      default: "light",
      validator: (val) => {
        return ["dark", "light", "plain"].indexOf(val) !== -1;
      }
    }
  },
  emits: ["close", "click"],
  setup(props2, ctx2) {
    const ELEMENT = useGlobalConfig();
    const tagSize = computed(() => {
      return props2.size || ELEMENT.size;
    });
    const classes = computed(() => {
      const { type: type2, hit, effect: effect2 } = props2;
      return [
        "el-tag",
        type2 ? `el-tag--${type2}` : "",
        tagSize.value ? `el-tag--${tagSize.value}` : "",
        effect2 ? `el-tag--${effect2}` : "",
        hit && "is-hit"
      ];
    });
    const handleClose = (event2) => {
      event2.stopPropagation();
      ctx2.emit("close", event2);
    };
    const handleClick = (event2) => {
      ctx2.emit("click", event2);
    };
    return {
      tagSize,
      classes,
      handleClose,
      handleClick
    };
  }
});
function render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return !_ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
    key: 0,
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle({ backgroundColor: _ctx.color }),
    onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default"),
    _ctx.closable ? (openBlock(), createElementBlock("i", {
      key: 0,
      class: "el-tag__close el-icon-close",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
    })) : createCommentVNode("v-if", true)
  ], 6)) : (openBlock(), createBlock(Transition, {
    key: 1,
    name: "el-zoom-in-center"
  }, {
    default: withCtx(() => [
      createElementVNode("span", {
        class: normalizeClass(_ctx.classes),
        style: normalizeStyle({ backgroundColor: _ctx.color }),
        onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, [
        renderSlot(_ctx.$slots, "default"),
        _ctx.closable ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: "el-tag__close el-icon-close",
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
        })) : createCommentVNode("v-if", true)
      ], 6)
    ]),
    _: 3
  }));
}
script$J.render = render$H;
script$J.__file = "packages/components/tag/src/workprogress.vue";
script$J.install = (app) => {
  app.component(script$J.name, script$J);
};
const _Tag = script$J;
const ElTag = _Tag;
var ElTag$1 = _Tag;
var __defProp$k = Object.defineProperty;
var __defProps$h = Object.defineProperties;
var __getOwnPropDescs$h = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$k = (obj, key, value2) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$k = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$k.call(b, prop))
      __defNormalProp$k(a, prop, b[prop]);
  if (__getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(b)) {
      if (__propIsEnum$k.call(b, prop))
        __defNormalProp$k(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$h = (a, b) => __defProps$h(a, __getOwnPropDescs$h(b));
const DEFAULT_INPUT_HEIGHT = 40;
const INPUT_HEIGHT_MAP = {
  medium: 36,
  small: 32,
  mini: 28
};
const popperOptions = {
  modifiers: [
    {
      name: "arrowPosition",
      enabled: true,
      phase: "main",
      fn: ({ state }) => {
        const { modifiersData, placement } = state;
        if (["right", "left"].includes(placement))
          return;
        modifiersData.arrow.x = 35;
      },
      requires: ["arrow"]
    }
  ]
};
var script$I = defineComponent({
  name: "ElCascader",
  components: {
    ElCascaderPanel: _CascaderPanel,
    ElInput: ElInput$1,
    ElPopper: ElPopper$1,
    ElScrollbar: _Scrollbar,
    ElTag: ElTag$1
  },
  directives: {
    Clickoutside: ClickOutside$1
  },
  props: __spreadProps$h(__spreadValues$k({}, CommonProps), {
    size: {
      type: String,
      validator: isValidComponentSize
    },
    placeholder: {
      type: String
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    filterMethod: {
      type: Function,
      default: (node, keyword) => node.text.includes(keyword)
    },
    separator: {
      type: String,
      default: " / "
    },
    showAllLevels: {
      type: Boolean,
      default: true
    },
    collapseTags: Boolean,
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: Function,
      default: () => true
    },
    popperClass: {
      type: String,
      default: ""
    },
    popperAppendToBody: {
      type: Boolean,
      default: true
    }
  }),
  emits: [
    UPDATE_MODEL_EVENT,
    CHANGE_EVENT,
    "focus",
    "blur",
    "visible-change",
    "expand-change",
    "remove-tag"
  ],
  setup(props2, { emit: emit2 }) {
    let inputInitialHeight = 0;
    let pressDeleteCount = 0;
    const { t } = useLocaleInject();
    const $ELEMENT2 = useGlobalConfig();
    const elForm = inject(elFormKey, {});
    const elFormItem = inject(elFormItemKey, {});
    const popper2 = ref(null);
    const input2 = ref(null);
    const tagWrapper = ref(null);
    const panel = ref(null);
    const suggestionPanel = ref(null);
    const popperVisible = ref(false);
    const inputHover = ref(false);
    const filtering = ref(false);
    const inputValue = ref("");
    const searchInputValue = ref("");
    const presentTags = ref([]);
    const suggestions = ref([]);
    const isDisabled = computed(() => props2.disabled || elForm.disabled);
    const inputPlaceholder = computed(() => props2.placeholder || t("el.cascader.placeholder"));
    const realSize = computed(() => props2.size || elFormItem.size || $ELEMENT2.size);
    const tagSize = computed(() => ["small", "mini"].includes(realSize.value) ? "mini" : "small");
    const multiple = computed(() => !!props2.props.multiple);
    const readonly = computed(() => !props2.filterable || multiple.value);
    const searchKeyword = computed(() => multiple.value ? searchInputValue.value : inputValue.value);
    const checkedNodes = computed(() => {
      var _a;
      return ((_a = panel.value) == null ? void 0 : _a.checkedNodes) || [];
    });
    const clearBtnVisible = computed(() => {
      if (!props2.clearable || isDisabled.value || filtering.value || !inputHover.value)
        return false;
      return !!checkedNodes.value.length;
    });
    const presentText = computed(() => {
      const { showAllLevels, separator } = props2;
      const nodes = checkedNodes.value;
      return nodes.length ? multiple.value ? " " : nodes[0].calcText(showAllLevels, separator) : "";
    });
    const checkedValue = computed({
      get() {
        return props2.modelValue;
      },
      set(val) {
        var _a;
        emit2(UPDATE_MODEL_EVENT, val);
        emit2(CHANGE_EVENT, val);
        (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", [val]);
      }
    });
    const popperPaneRef = computed(() => {
      var _a;
      return (_a = popper2.value) == null ? void 0 : _a.popperRef;
    });
    const togglePopperVisible = (visible2) => {
      if (isDisabled.value)
        return;
      visible2 = visible2 != null ? visible2 : !popperVisible.value;
      if (visible2 !== popperVisible.value) {
        popperVisible.value = visible2;
        input2.value.input.setAttribute("aria-expanded", visible2);
        if (visible2) {
          updatePopperPosition();
          nextTick(panel.value.scrollToExpandingNode);
        } else if (props2.filterable) {
          const { value: value2 } = presentText;
          inputValue.value = value2;
          searchInputValue.value = value2;
        }
        emit2("visible-change", visible2);
      }
    };
    const updatePopperPosition = () => {
      nextTick(popper2.value.update);
    };
    const hideSuggestionPanel = () => {
      filtering.value = false;
    };
    const genTag2 = (node) => {
      const { showAllLevels, separator } = props2;
      return {
        node,
        key: node.uid,
        text: node.calcText(showAllLevels, separator),
        hitState: false,
        closable: !isDisabled.value && !node.isDisabled
      };
    };
    const deleteTag = (tag) => {
      const { node } = tag;
      node.doCheck(false);
      panel.value.calculateCheckedValue();
      emit2("remove-tag", node.valueByOption);
    };
    const calculatePresentTags = () => {
      if (!multiple.value)
        return;
      const nodes = checkedNodes.value;
      const tags2 = [];
      if (nodes.length) {
        const [first, ...rest] = nodes;
        const restCount = rest.length;
        tags2.push(genTag2(first));
        if (restCount) {
          if (props2.collapseTags) {
            tags2.push({
              key: -1,
              text: `+ ${restCount}`,
              closable: false
            });
          } else {
            rest.forEach((node) => tags2.push(genTag2(node)));
          }
        }
      }
      presentTags.value = tags2;
    };
    const calculateSuggestions = () => {
      const { filterMethod, showAllLevels, separator } = props2;
      const res = panel.value.getFlattedNodes(!props2.props.checkStrictly).filter((node) => {
        if (node.isDisabled)
          return false;
        node.calcText(showAllLevels, separator);
        return filterMethod(node, searchKeyword.value);
      });
      if (multiple.value) {
        presentTags.value.forEach((tag) => {
          tag.hitState = false;
        });
      }
      filtering.value = true;
      suggestions.value = res;
      updatePopperPosition();
    };
    const focusFirstNode = () => {
      var _a;
      let firstNode = null;
      if (filtering.value && suggestionPanel.value) {
        firstNode = suggestionPanel.value.$el.querySelector(".el-cascader__suggestion-item");
      } else {
        firstNode = (_a = panel.value) == null ? void 0 : _a.$el.querySelector('.el-cascader-node[tabindex="-1"]');
      }
      if (firstNode) {
        firstNode.focus();
        !filtering.value && firstNode.click();
      }
    };
    const updateStyle = () => {
      var _a;
      const inputInner = input2.value.input;
      const tagWrapperEl = tagWrapper.value;
      const suggestionPanelEl = (_a = suggestionPanel.value) == null ? void 0 : _a.$el;
      if (isServer || !inputInner)
        return;
      if (suggestionPanelEl) {
        const suggestionList = suggestionPanelEl.querySelector(".el-cascader__suggestion-list");
        suggestionList.style.minWidth = inputInner.offsetWidth + "px";
      }
      if (tagWrapperEl) {
        const { offsetHeight } = tagWrapperEl;
        const height = presentTags.value.length > 0 ? Math.max(offsetHeight + 6, inputInitialHeight) + "px" : `${inputInitialHeight}px`;
        inputInner.style.height = height;
        updatePopperPosition();
      }
    };
    const getCheckedNodes = (leafOnly) => {
      return panel.value.getCheckedNodes(leafOnly);
    };
    const handleExpandChange = (value2) => {
      updatePopperPosition();
      emit2("expand-change", value2);
    };
    const handleKeyDown = (e) => {
      switch (e.code) {
        case EVENT_CODE.enter:
          togglePopperVisible();
          break;
        case EVENT_CODE.down:
          togglePopperVisible(true);
          nextTick(focusFirstNode);
          event.preventDefault();
          break;
        case EVENT_CODE.esc:
        case EVENT_CODE.tab:
          togglePopperVisible(false);
          break;
      }
    };
    const handleClear = () => {
      panel.value.clearCheckedNodes();
      togglePopperVisible(false);
    };
    const handleSuggestionClick = (node) => {
      const { checked } = node;
      if (multiple.value) {
        panel.value.handleCheckChange(node, !checked, false);
      } else {
        !checked && panel.value.handleCheckChange(node, true, false);
        togglePopperVisible(false);
      }
    };
    const handleDelete = () => {
      const tags2 = presentTags.value;
      const lastTag = tags2[tags2.length - 1];
      pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
      if (!lastTag || !pressDeleteCount)
        return;
      if (lastTag.hitState) {
        deleteTag(lastTag);
      } else {
        lastTag.hitState = true;
      }
    };
    const handleFilter = debounce_1(() => {
      const { value: value2 } = searchKeyword;
      if (!value2)
        return;
      const passed = props2.beforeFilter(value2);
      if (isPromise(passed)) {
        passed.then(calculateSuggestions).catch(() => {
        });
      } else if (passed !== false) {
        calculateSuggestions();
      } else {
        hideSuggestionPanel();
      }
    }, props2.debounce);
    const handleInput = (val, e) => {
      !popperVisible.value && togglePopperVisible(true);
      if (e == null ? void 0 : e.isComposing)
        return;
      val ? handleFilter() : hideSuggestionPanel();
    };
    watch(filtering, updatePopperPosition);
    watch([checkedNodes, isDisabled], calculatePresentTags);
    watch(presentTags, () => nextTick(updateStyle));
    watch(presentText, (val) => inputValue.value = val, { immediate: true });
    onMounted(() => {
      const inputEl = input2.value.$el;
      inputInitialHeight = (inputEl == null ? void 0 : inputEl.offsetHeight) || INPUT_HEIGHT_MAP[realSize.value] || DEFAULT_INPUT_HEIGHT;
      addResizeListener(inputEl, updateStyle);
    });
    onBeforeUnmount(() => {
      removeResizeListener(input2.value.$el, updateStyle);
    });
    return {
      popperOptions,
      popper: popper2,
      popperPaneRef,
      input: input2,
      tagWrapper,
      panel,
      suggestionPanel,
      popperVisible,
      inputHover,
      inputPlaceholder,
      filtering,
      presentText,
      checkedValue,
      inputValue,
      searchInputValue,
      presentTags,
      suggestions,
      isDisabled,
      realSize,
      tagSize,
      multiple,
      readonly,
      clearBtnVisible,
      t,
      togglePopperVisible,
      hideSuggestionPanel,
      deleteTag,
      focusFirstNode,
      getCheckedNodes,
      handleExpandChange,
      handleKeyDown,
      handleClear,
      handleSuggestionClick,
      handleDelete,
      handleInput
    };
  }
});
const _hoisted_1$_ = {
  key: 0,
  ref: "tagWrapper",
  class: "el-cascader__tags"
};
const _hoisted_2$Q = ["placeholder"];
const _hoisted_3$N = ["onClick"];
const _hoisted_4$B = {
  key: 0,
  class: "el-icon-check"
};
const _hoisted_5$u = { class: "el-cascader__empty-text" };
function render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_cascader_panel = resolveComponent("el-cascader-panel");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "popper",
    visible: _ctx.popperVisible,
    "onUpdate:visible": _cache[15] || (_cache[15] = ($event) => _ctx.popperVisible = $event),
    "manual-mode": "",
    "append-to-body": _ctx.popperAppendToBody,
    placement: "bottom-start",
    "popper-class": `el-cascader__dropdown ${_ctx.popperClass}`,
    "popper-options": _ctx.popperOptions,
    "fallback-placements": ["bottom-start", "top-start", "right", "left"],
    "stop-popper-mouse-event": false,
    transition: "el-zoom-in-top",
    "gpu-acceleration": false,
    effect: "light",
    pure: "",
    onAfterLeave: _ctx.hideSuggestionPanel
  }, {
    trigger: withCtx(() => [
      withDirectives(createElementVNode("div", {
        class: normalizeClass([
          "el-cascader",
          _ctx.realSize && `el-cascader--${_ctx.realSize}`,
          { "is-disabled": _ctx.isDisabled }
        ]),
        onClick: _cache[9] || (_cache[9] = () => _ctx.togglePopperVisible(_ctx.readonly ? void 0 : true)),
        onKeydown: _cache[10] || (_cache[10] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args)),
        onMouseenter: _cache[11] || (_cache[11] = ($event) => _ctx.inputHover = true),
        onMouseleave: _cache[12] || (_cache[12] = ($event) => _ctx.inputHover = false)
      }, [
        createVNode(_component_el_input, {
          ref: "input",
          modelValue: _ctx.inputValue,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
          modelModifiers: { trim: true },
          placeholder: _ctx.inputPlaceholder,
          readonly: _ctx.readonly,
          disabled: _ctx.isDisabled,
          "validate-event": false,
          size: _ctx.realSize,
          class: normalizeClass({ "is-focus": _ctx.popperVisible }),
          onFocus: _cache[3] || (_cache[3] = (e) => _ctx.$emit("focus", e)),
          onBlur: _cache[4] || (_cache[4] = (e) => _ctx.$emit("blur", e)),
          onInput: _ctx.handleInput
        }, {
          suffix: withCtx(() => [
            _ctx.clearBtnVisible ? (openBlock(), createElementBlock("i", {
              key: "clear",
              class: "el-input__icon el-icon-circle-close",
              onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
            })) : (openBlock(), createElementBlock("i", {
              key: "arrow-down",
              class: normalizeClass([
                "el-input__icon",
                "el-icon-arrow-down",
                _ctx.popperVisible && "is-reverse"
              ]),
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.togglePopperVisible(), ["stop"]))
            }, null, 2))
          ]),
          _: 1
        }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "onInput"]),
        _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$_, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.presentTags, (tag) => {
            return openBlock(), createBlock(_component_el_tag, {
              key: tag.key,
              type: "info",
              size: _ctx.tagSize,
              hit: tag.hitState,
              closable: tag.closable,
              "disable-transitions": "",
              onClose: ($event) => _ctx.deleteTag(tag)
            }, {
              default: withCtx(() => [
                createElementVNode("span", null, toDisplayString(tag.text), 1)
              ]),
              _: 2
            }, 1032, ["size", "hit", "closable", "onClose"]);
          }), 128)),
          _ctx.filterable && !_ctx.isDisabled ? withDirectives((openBlock(), createElementBlock("input", {
            key: 0,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.searchInputValue = $event),
            type: "text",
            class: "el-cascader__search-input",
            placeholder: _ctx.presentText ? "" : _ctx.inputPlaceholder,
            onInput: _cache[6] || (_cache[6] = (e) => _ctx.handleInput(_ctx.searchInputValue, e)),
            onClick: _cache[7] || (_cache[7] = withModifiers(($event) => _ctx.togglePopperVisible(true), ["stop"])),
            onKeydown: _cache[8] || (_cache[8] = withKeys((...args) => _ctx.handleDelete && _ctx.handleDelete(...args), ["delete"]))
          }, null, 40, _hoisted_2$Q)), [
            [
              vModelText,
              _ctx.searchInputValue,
              void 0,
              { trim: true }
            ]
          ]) : createCommentVNode("v-if", true)
        ], 512)) : createCommentVNode("v-if", true)
      ], 34), [
        [_directive_clickoutside, () => _ctx.togglePopperVisible(false), _ctx.popperPaneRef]
      ])
    ]),
    default: withCtx(() => [
      withDirectives(createVNode(_component_el_cascader_panel, {
        ref: "panel",
        modelValue: _ctx.checkedValue,
        "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => _ctx.checkedValue = $event),
        options: _ctx.options,
        props: _ctx.props,
        border: false,
        "render-label": _ctx.$slots.default,
        onExpandChange: _ctx.handleExpandChange,
        onClose: _cache[14] || (_cache[14] = ($event) => _ctx.togglePopperVisible(false))
      }, null, 8, ["modelValue", "options", "props", "render-label", "onExpandChange"]), [
        [vShow, !_ctx.filtering]
      ]),
      _ctx.filterable ? withDirectives((openBlock(), createBlock(_component_el_scrollbar, {
        key: 0,
        ref: "suggestionPanel",
        tag: "ul",
        class: "el-cascader__suggestion-panel",
        "view-class": "el-cascader__suggestion-list"
      }, {
        default: withCtx(() => [
          _ctx.suggestions.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.suggestions, (item) => {
            return openBlock(), createElementBlock("li", {
              key: item.uid,
              class: normalizeClass([
                "el-cascader__suggestion-item",
                item.checked && "is-checked"
              ]),
              tabindex: -1,
              onClick: ($event) => _ctx.handleSuggestionClick(item)
            }, [
              createElementVNode("span", null, toDisplayString(item.text), 1),
              item.checked ? (openBlock(), createElementBlock("i", _hoisted_4$B)) : createCommentVNode("v-if", true)
            ], 10, _hoisted_3$N);
          }), 128)) : renderSlot(_ctx.$slots, "empty", { key: 1 }, () => [
            createElementVNode("li", _hoisted_5$u, toDisplayString(_ctx.t("el.cascader.noMatch")), 1)
          ])
        ]),
        _: 3
      }, 512)), [
        [vShow, _ctx.filtering]
      ]) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 8, ["visible", "append-to-body", "popper-class", "popper-options", "onAfterLeave"]);
}
script$I.render = render$G;
script$I.__file = "packages/components/cascader/src/workprogress.vue";
script$I.install = (app) => {
  app.component(script$I.name, script$I);
};
const _Cascader = script$I;
const ElCascader = _Cascader;
var script$H = defineComponent({
  name: "ElCheckTag",
  props: {
    checked: Boolean
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    const onChange = () => {
      emit2("change", !props2.checked);
    };
    return {
      onChange
    };
  }
});
function render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    class: normalizeClass({
      "el-check-tag": true,
      "is-checked": _ctx.checked
    }),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onChange && _ctx.onChange(...args))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
script$H.render = render$F;
script$H.__file = "packages/components/check-tag/src/workprogress.vue";
script$H.install = (app) => {
  app.component(script$H.name, script$H);
};
const _CheckTag = script$H;
const ElCheckTag = _CheckTag;
const ElCol = defineComponent({
  name: "ElCol",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    span: {
      type: Number,
      default: 24
    },
    offset: {
      type: Number,
      default: 0
    },
    pull: {
      type: Number,
      default: 0
    },
    push: {
      type: Number,
      default: 0
    },
    xs: {
      type: [Number, Object],
      default: () => ({})
    },
    sm: {
      type: [Number, Object],
      default: () => ({})
    },
    md: {
      type: [Number, Object],
      default: () => ({})
    },
    lg: {
      type: [Number, Object],
      default: () => ({})
    },
    xl: {
      type: [Number, Object],
      default: () => ({})
    }
  },
  setup(props2, { slots }) {
    const { gutter } = inject("ElRow", { gutter: { value: 0 } });
    const style = computed(() => {
      if (gutter.value) {
        return {
          paddingLeft: gutter.value / 2 + "px",
          paddingRight: gutter.value / 2 + "px"
        };
      }
      return {};
    });
    const classList = computed(() => {
      const ret = [];
      const pos = ["span", "offset", "pull", "push"];
      pos.forEach((prop) => {
        const size = props2[prop];
        if (typeof size === "number") {
          if (prop === "span")
            ret.push(`el-col-${props2[prop]}`);
          else if (size > 0)
            ret.push(`el-col-${prop}-${props2[prop]}`);
        }
      });
      const sizes = ["xs", "sm", "md", "lg", "xl"];
      sizes.forEach((size) => {
        if (typeof props2[size] === "number") {
          ret.push(`el-col-${size}-${props2[size]}`);
        } else if (typeof props2[size] === "object") {
          const sizeProps = props2[size];
          Object.keys(sizeProps).forEach((prop) => {
            ret.push(prop !== "span" ? `el-col-${size}-${prop}-${sizeProps[prop]}` : `el-col-${size}-${sizeProps[prop]}`);
          });
        }
      });
      if (gutter.value) {
        ret.push("is-guttered");
      }
      return ret;
    });
    return () => {
      var _a;
      return h(props2.tag, {
        class: ["el-col", classList.value],
        style: style.value
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
const _Col = ElCol;
_Col.install = (app) => {
  app.component(_Col.name, _Col);
};
const ElCol$1 = _Col;
function mitt(n) {
  return { all: n = n || new Map(), on: function(t, e) {
    var i2 = n.get(t);
    i2 && i2.push(e) || n.set(t, [e]);
  }, off: function(t, e) {
    var i2 = n.get(t);
    i2 && i2.splice(i2.indexOf(e) >>> 0, 1);
  }, emit: function(t, e) {
    (n.get(t) || []).slice().map(function(n2) {
      n2(e);
    }), (n.get("*") || []).slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
var script$G = defineComponent({
  name: "ElCollapseTransition",
  setup() {
    return {
      on: {
        beforeEnter(el) {
          addClass$1(el, "collapse-transition");
          if (!el.dataset)
            el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.style.height = "0";
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        },
        enter(el) {
          el.dataset.oldOverflow = el.style.overflow;
          if (el.scrollHeight !== 0) {
            el.style.height = el.scrollHeight + "px";
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          } else {
            el.style.height = "";
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          }
          el.style.overflow = "hidden";
        },
        afterEnter(el) {
          removeClass(el, "collapse-transition");
          el.style.height = "";
          el.style.overflow = el.dataset.oldOverflow;
        },
        beforeLeave(el) {
          if (!el.dataset)
            el.dataset = {};
          el.dataset.oldPaddingTop = el.style.paddingTop;
          el.dataset.oldPaddingBottom = el.style.paddingBottom;
          el.dataset.oldOverflow = el.style.overflow;
          el.style.height = el.scrollHeight + "px";
          el.style.overflow = "hidden";
        },
        leave(el) {
          if (el.scrollHeight !== 0) {
            addClass$1(el, "collapse-transition");
            el.style.transitionProperty = "height";
            el.style.height = 0;
            el.style.paddingTop = 0;
            el.style.paddingBottom = 0;
          }
        },
        afterLeave(el) {
          removeClass(el, "collapse-transition");
          el.style.height = "";
          el.style.overflow = el.dataset.oldOverflow;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
      }
    };
  }
});
function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, toHandlers(_ctx.on), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
script$G.render = render$E;
script$G.__file = "packages/components/collapse-transition/src/collapse-transition.vue";
script$G.install = (app) => {
  app.component(script$G.name, script$G);
};
const _CollapseTransition = script$G;
const ElCollapseTransition = _CollapseTransition;
var ElCollapseTransition$1 = _CollapseTransition;
var script$F = defineComponent({
  name: "ElCollapse",
  props: {
    accordion: Boolean,
    modelValue: {
      type: [Array, String, Number],
      default: () => []
    }
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT],
  setup(props2, { emit: emit2 }) {
    const activeNames = ref([].concat(props2.modelValue));
    const collapseMitt = mitt();
    const setActiveNames = (_activeNames) => {
      activeNames.value = [].concat(_activeNames);
      const value2 = props2.accordion ? activeNames.value[0] : activeNames.value;
      emit2(UPDATE_MODEL_EVENT, value2);
      emit2(CHANGE_EVENT, value2);
    };
    const handleItemClick = (name2) => {
      if (props2.accordion) {
        setActiveNames((activeNames.value[0] || activeNames.value[0] === 0) && activeNames.value[0] === name2 ? "" : name2);
      } else {
        const _activeNames = activeNames.value.slice(0);
        const index2 = _activeNames.indexOf(name2);
        if (index2 > -1) {
          _activeNames.splice(index2, 1);
        } else {
          _activeNames.push(name2);
        }
        setActiveNames(_activeNames);
      }
    };
    watch(() => props2.modelValue, () => {
      activeNames.value = [].concat(props2.modelValue);
    });
    collapseMitt.on("item-click", handleItemClick);
    onUnmounted(() => {
      collapseMitt.all.clear();
    });
    provide("collapse", {
      activeNames,
      collapseMitt
    });
    return {
      activeNames,
      setActiveNames,
      handleItemClick
    };
  }
});
const _hoisted_1$Z = {
  class: "el-collapse",
  role: "tablist",
  "aria-multiselectable": "true"
};
function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$Z, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$F.render = render$D;
script$F.__file = "packages/components/collapse/src/collapse.vue";
var script$1$m = defineComponent({
  name: "ElCollapseItem",
  components: { ElCollapseTransition: ElCollapseTransition$1 },
  props: {
    title: {
      type: String,
      default: ""
    },
    name: {
      type: [String, Number],
      default: () => {
        return generateId();
      }
    },
    disabled: Boolean
  },
  setup(props2) {
    const collapse = inject("collapse");
    const collapseMitt = collapse == null ? void 0 : collapse.collapseMitt;
    const contentWrapStyle = ref({
      height: "auto",
      display: "block"
    });
    const contentHeight = ref(0);
    const focusing = ref(false);
    const isClick = ref(false);
    const id2 = ref(generateId());
    const isActive = computed(() => {
      return (collapse == null ? void 0 : collapse.activeNames.value.indexOf(props2.name)) > -1;
    });
    const handleFocus = () => {
      setTimeout(() => {
        if (!isClick.value) {
          focusing.value = true;
        } else {
          isClick.value = false;
        }
      }, 50);
    };
    const handleHeaderClick = () => {
      if (props2.disabled)
        return;
      collapseMitt == null ? void 0 : collapseMitt.emit("item-click", props2.name);
      focusing.value = false;
      isClick.value = true;
    };
    const handleEnterClick = () => {
      collapseMitt == null ? void 0 : collapseMitt.emit("item-click", props2.name);
    };
    return {
      isActive,
      contentWrapStyle,
      contentHeight,
      focusing,
      isClick,
      id: id2,
      handleFocus,
      handleHeaderClick,
      handleEnterClick,
      collapse
    };
  }
});
const _hoisted_1$1$f = ["aria-expanded", "aria-controls", "aria-describedby"];
const _hoisted_2$P = ["id", "tabindex"];
const _hoisted_3$M = ["id", "aria-hidden", "aria-labelledby"];
const _hoisted_4$A = { class: "el-collapse-item__content" };
function render$1$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_collapse_transition = resolveComponent("el-collapse-transition");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-collapse-item", { "is-active": _ctx.isActive, "is-disabled": _ctx.disabled }])
  }, [
    createElementVNode("div", {
      role: "tab",
      "aria-expanded": _ctx.isActive,
      "aria-controls": `el-collapse-content-${_ctx.id}`,
      "aria-describedby": `el-collapse-content-${_ctx.id}`
    }, [
      createElementVNode("div", {
        id: `el-collapse-head-${_ctx.id}`,
        class: normalizeClass(["el-collapse-item__header", {
          "focusing": _ctx.focusing,
          "is-active": _ctx.isActive
        }]),
        role: "button",
        tabindex: _ctx.disabled ? -1 : 0,
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleHeaderClick && _ctx.handleHeaderClick(...args)),
        onKeyup: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.handleEnterClick && _ctx.handleEnterClick(...args), ["stop"]), ["space", "enter"])),
        onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focusing = false)
      }, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ]),
        createElementVNode("i", {
          class: normalizeClass(["el-collapse-item__arrow el-icon-arrow-right", { "is-active": _ctx.isActive }])
        }, null, 2)
      ], 42, _hoisted_2$P)
    ], 8, _hoisted_1$1$f),
    createVNode(_component_el_collapse_transition, null, {
      default: withCtx(() => [
        withDirectives(createElementVNode("div", {
          id: `el-collapse-content-${_ctx.id}`,
          class: "el-collapse-item__wrap",
          role: "tabpanel",
          "aria-hidden": !_ctx.isActive,
          "aria-labelledby": `el-collapse-head-${_ctx.id}`
        }, [
          createElementVNode("div", _hoisted_4$A, [
            renderSlot(_ctx.$slots, "default")
          ])
        ], 8, _hoisted_3$M), [
          [vShow, _ctx.isActive]
        ])
      ]),
      _: 3
    })
  ], 2);
}
script$1$m.render = render$1$l;
script$1$m.__file = "packages/components/collapse/src/collapse-item.vue";
script$F.install = (app) => {
  app.component(script$F.name, script$F);
  app.component(script$1$m.name, script$1$m);
};
script$1$m.CollapseItem = script$1$m;
const _Collapse = script$F;
const ElCollapse = _Collapse;
let isDragging = false;
function draggable(element, options2) {
  if (isServer)
    return;
  const moveFn = function(event2) {
    var _a;
    (_a = options2.drag) == null ? void 0 : _a.call(options2, event2);
  };
  const upFn = function(event2) {
    var _a;
    off$2(document, "mousemove", moveFn);
    off$2(document, "mouseup", upFn);
    document.onselectstart = null;
    document.ondragstart = null;
    isDragging = false;
    (_a = options2.end) == null ? void 0 : _a.call(options2, event2);
  };
  on$2(element, "mousedown", function(event2) {
    var _a;
    if (isDragging)
      return;
    document.onselectstart = () => false;
    document.ondragstart = () => false;
    on$2(document, "mousemove", moveFn);
    on$2(document, "mouseup", upFn);
    isDragging = true;
    (_a = options2.start) == null ? void 0 : _a.call(options2, event2);
  });
}
var script$E = defineComponent({
  name: "ElColorAlphaSlider",
  props: {
    color: {
      type: Object,
      required: true
    },
    vertical: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const thumb = ref(null);
    const bar = ref(null);
    const thumbLeft = ref(0);
    const thumbTop = ref(0);
    const background = ref(null);
    watch(() => props2.color.get("alpha"), () => {
      update();
    });
    watch(() => props2.color.value, () => {
      update();
    });
    function getThumbLeft() {
      if (props2.vertical)
        return 0;
      const el = instance.vnode.el;
      const alpha = props2.color.get("alpha");
      if (!el)
        return 0;
      return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
    }
    function getThumbTop() {
      const el = instance.vnode.el;
      if (!props2.vertical)
        return 0;
      const alpha = props2.color.get("alpha");
      if (!el)
        return 0;
      return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
    }
    function getBackground() {
      if (props2.color && props2.color.value) {
        const { r, g, b } = props2.color.toRgb();
        return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;
      }
      return null;
    }
    function handleClick(event2) {
      const target = event2.target;
      if (target !== thumb.value) {
        handleDrag(event2);
      }
    }
    function handleDrag(event2) {
      const el = instance.vnode.el;
      const rect = el.getBoundingClientRect();
      if (!props2.vertical) {
        let left2 = event2.clientX - rect.left;
        left2 = Math.max(thumb.value.offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
        props2.color.set("alpha", Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
      } else {
        let top2 = event2.clientY - rect.top;
        top2 = Math.max(thumb.value.offsetHeight / 2, top2);
        top2 = Math.min(top2, rect.height - thumb.value.offsetHeight / 2);
        props2.color.set("alpha", Math.round((top2 - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
      }
    }
    function update() {
      thumbLeft.value = getThumbLeft();
      thumbTop.value = getThumbTop();
      background.value = getBackground();
    }
    onMounted(() => {
      const dragConfig = {
        drag: (event2) => {
          handleDrag(event2);
        },
        end: (event2) => {
          handleDrag(event2);
        }
      };
      draggable(bar.value, dragConfig);
      draggable(thumb.value, dragConfig);
      update();
    });
    return {
      thumb,
      bar,
      thumbLeft,
      thumbTop,
      background,
      handleClick,
      update
    };
  }
});
function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-color-alpha-slider", { "is-vertical": _ctx.vertical }])
  }, [
    createElementVNode("div", {
      ref: "bar",
      class: "el-color-alpha-slider__bar",
      style: normalizeStyle({
        background: _ctx.background
      }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, null, 4),
    createElementVNode("div", {
      ref: "thumb",
      class: "el-color-alpha-slider__thumb",
      style: normalizeStyle({
        left: _ctx.thumbLeft + "px",
        top: _ctx.thumbTop + "px"
      })
    }, null, 4)
  ], 2);
}
script$E.render = render$C;
script$E.__file = "packages/components/color-picker/src/components/alpha-slider.vue";
var script$1$l = defineComponent({
  name: "ElColorHueSlider",
  props: {
    color: {
      type: Object,
      required: true
    },
    vertical: Boolean
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const thumb = ref(null);
    const bar = ref(null);
    const thumbLeft = ref(0);
    const thumbTop = ref(0);
    const hueValue = computed(() => {
      return props2.color.get("hue");
    });
    watch(() => hueValue.value, () => {
      update();
    });
    function handleClick(event2) {
      const target = event2.target;
      if (target !== thumb.value) {
        handleDrag(event2);
      }
    }
    function handleDrag(event2) {
      const el = instance.vnode.el;
      const rect = el.getBoundingClientRect();
      let hue;
      if (!props2.vertical) {
        let left2 = event2.clientX - rect.left;
        left2 = Math.min(left2, rect.width - thumb.value.offsetWidth / 2);
        left2 = Math.max(thumb.value.offsetWidth / 2, left2);
        hue = Math.round((left2 - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
      } else {
        let top2 = event2.clientY - rect.top;
        top2 = Math.min(top2, rect.height - thumb.value.offsetHeight / 2);
        top2 = Math.max(thumb.value.offsetHeight / 2, top2);
        hue = Math.round((top2 - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
      }
      props2.color.set("hue", hue);
    }
    function getThumbLeft() {
      const el = instance.vnode.el;
      if (props2.vertical)
        return 0;
      const hue = props2.color.get("hue");
      if (!el)
        return 0;
      return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
    }
    function getThumbTop() {
      const el = instance.vnode.el;
      if (!props2.vertical)
        return 0;
      const hue = props2.color.get("hue");
      if (!el)
        return 0;
      return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
    }
    function update() {
      thumbLeft.value = getThumbLeft();
      thumbTop.value = getThumbTop();
    }
    onMounted(() => {
      const dragConfig = {
        drag: (event2) => {
          handleDrag(event2);
        },
        end: (event2) => {
          handleDrag(event2);
        }
      };
      draggable(bar.value, dragConfig);
      draggable(thumb.value, dragConfig);
      update();
    });
    return {
      bar,
      thumb,
      thumbLeft,
      thumbTop,
      hueValue,
      handleClick,
      update
    };
  }
});
function render$1$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-color-hue-slider", { "is-vertical": _ctx.vertical }])
  }, [
    createElementVNode("div", {
      ref: "bar",
      class: "el-color-hue-slider__bar",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, null, 512),
    createElementVNode("div", {
      ref: "thumb",
      class: "el-color-hue-slider__thumb",
      style: normalizeStyle({
        left: _ctx.thumbLeft + "px",
        top: _ctx.thumbTop + "px"
      })
    }, null, 4)
  ], 2);
}
script$1$l.render = render$1$k;
script$1$l.__file = "packages/components/color-picker/src/components/hue-slider.vue";
const OPTIONS_KEY = Symbol();
const useOptions = () => {
  return inject(OPTIONS_KEY);
};
const hsv2hsl = function(hue, sat, val) {
  return [
    hue,
    sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
    hue / 2
  ];
};
const isOnePointZero = function(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
};
const isPercentage = function(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
};
const bound01 = function(value2, max2) {
  if (isOnePointZero(value2))
    value2 = "100%";
  const processPercent = isPercentage(value2);
  value2 = Math.min(max2, Math.max(0, parseFloat(value2 + "")));
  if (processPercent) {
    value2 = parseInt(value2 * max2 + "", 10) / 100;
  }
  if (Math.abs(value2 - max2) < 1e-6) {
    return 1;
  }
  return value2 % max2 / parseFloat(max2);
};
const INT_HEX_MAP = { 10: "A", 11: "B", 12: "C", 13: "D", 14: "E", 15: "F" };
const toHex = function({ r, g, b }) {
  const hexOne = function(value2) {
    value2 = Math.min(Math.round(value2), 255);
    const high = Math.floor(value2 / 16);
    const low = value2 % 16;
    return "" + (INT_HEX_MAP[high] || high) + (INT_HEX_MAP[low] || low);
  };
  if (isNaN(r) || isNaN(g) || isNaN(b))
    return "";
  return "#" + hexOne(r) + hexOne(g) + hexOne(b);
};
const HEX_INT_MAP = { A: 10, B: 11, C: 12, D: 13, E: 14, F: 15 };
const parseHexChannel = function(hex2) {
  if (hex2.length === 2) {
    return (HEX_INT_MAP[hex2[0].toUpperCase()] || +hex2[0]) * 16 + (HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1]);
  }
  return HEX_INT_MAP[hex2[1].toUpperCase()] || +hex2[1];
};
const hsl2hsv = function(hue, sat, light) {
  sat = sat / 100;
  light = light / 100;
  let smin = sat;
  const lmin = Math.max(light, 0.01);
  light *= 2;
  sat *= light <= 1 ? light : 2 - light;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v = (light + sat) / 2;
  const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
  return {
    h: hue,
    s: sv * 100,
    v: v * 100
  };
};
const rgb2hsv = function(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  const max2 = Math.max(r, g, b);
  const min2 = Math.min(r, g, b);
  let h2;
  const v = max2;
  const d = max2 - min2;
  const s = max2 === 0 ? 0 : d / max2;
  if (max2 === min2) {
    h2 = 0;
  } else {
    switch (max2) {
      case r: {
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      }
      case g: {
        h2 = (b - r) / d + 2;
        break;
      }
      case b: {
        h2 = (r - g) / d + 4;
        break;
      }
    }
    h2 /= 6;
  }
  return { h: h2 * 360, s: s * 100, v: v * 100 };
};
const hsv2rgb = function(h2, s, v) {
  h2 = bound01(h2, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  const i2 = Math.floor(h2);
  const f = h2 - i2;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  const mod = i2 % 6;
  const r = [v, q, p, p, t, v][mod];
  const g = [t, v, v, q, p, p][mod];
  const b = [p, p, t, v, v, q][mod];
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
};
class Color {
  constructor(options2) {
    this._hue = 0;
    this._saturation = 100;
    this._value = 100;
    this._alpha = 100;
    this.enableAlpha = false;
    this.format = "hex";
    this.value = "";
    options2 = options2 || {};
    for (const option2 in options2) {
      if (hasOwn(options2, option2)) {
        this[option2] = options2[option2];
      }
    }
    this.doOnChange();
  }
  set(prop, value2) {
    if (arguments.length === 1 && typeof prop === "object") {
      for (const p in prop) {
        if (hasOwn(prop, p)) {
          this.set(p, prop[p]);
        }
      }
      return;
    }
    this["_" + prop] = value2;
    this.doOnChange();
  }
  get(prop) {
    return this["_" + prop];
  }
  toRgb() {
    return hsv2rgb(this._hue, this._saturation, this._value);
  }
  fromString(value2) {
    if (!value2) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;
      this.doOnChange();
      return;
    }
    const fromHSV = (h2, s, v) => {
      this._hue = Math.max(0, Math.min(360, h2));
      this._saturation = Math.max(0, Math.min(100, s));
      this._value = Math.max(0, Math.min(100, v));
      this.doOnChange();
    };
    if (value2.indexOf("hsl") !== -1) {
      const parts = value2.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? parseFloat(val) : parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }
      if (parts.length >= 3) {
        const { h: h2, s, v } = hsl2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h2, s, v);
      }
    } else if (value2.indexOf("hsv") !== -1) {
      const parts = value2.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? parseFloat(val) : parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }
      if (parts.length >= 3) {
        fromHSV(parts[0], parts[1], parts[2]);
      }
    } else if (value2.indexOf("rgb") !== -1) {
      const parts = value2.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? parseFloat(val) : parseInt(val, 10));
      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }
      if (parts.length >= 3) {
        const { h: h2, s, v } = rgb2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h2, s, v);
      }
    } else if (value2.indexOf("#") !== -1) {
      const hex2 = value2.replace("#", "").trim();
      if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex2))
        return;
      let r, g, b;
      if (hex2.length === 3) {
        r = parseHexChannel(hex2[0] + hex2[0]);
        g = parseHexChannel(hex2[1] + hex2[1]);
        b = parseHexChannel(hex2[2] + hex2[2]);
      } else if (hex2.length === 6 || hex2.length === 8) {
        r = parseHexChannel(hex2.substring(0, 2));
        g = parseHexChannel(hex2.substring(2, 4));
        b = parseHexChannel(hex2.substring(4, 6));
      }
      if (hex2.length === 8) {
        this._alpha = Math.floor(parseHexChannel(hex2.substring(6)) / 255 * 100);
      } else if (hex2.length === 3 || hex2.length === 6) {
        this._alpha = 100;
      }
      const { h: h2, s, v } = rgb2hsv(r, g, b);
      fromHSV(h2, s, v);
    }
  }
  compare(color) {
    return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
  }
  doOnChange() {
    const { _hue, _saturation, _value, _alpha, format: format2 } = this;
    if (this.enableAlpha) {
      switch (format2) {
        case "hsl": {
          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${_alpha / 100})`;
          break;
        }
        case "hsv": {
          this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${_alpha / 100})`;
          break;
        }
        default: {
          const { r, g, b } = hsv2rgb(_hue, _saturation, _value);
          this.value = `rgba(${r}, ${g}, ${b}, ${_alpha / 100})`;
        }
      }
    } else {
      switch (format2) {
        case "hsl": {
          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
          break;
        }
        case "hsv": {
          this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
          break;
        }
        case "rgb": {
          const { r, g, b } = hsv2rgb(_hue, _saturation, _value);
          this.value = `rgb(${r}, ${g}, ${b})`;
          break;
        }
        default: {
          this.value = toHex(hsv2rgb(_hue, _saturation, _value));
        }
      }
    }
  }
}
var script$2$e = defineComponent({
  props: {
    colors: { type: Array, required: true },
    color: {
      type: Object,
      required: true
    }
  },
  setup(props2) {
    const { currentColor } = useOptions();
    const rgbaColors = ref(parseColors(props2.colors, props2.color));
    watch(() => currentColor.value, (val) => {
      const color = new Color();
      color.fromString(val);
      rgbaColors.value.forEach((item) => {
        item.selected = color.compare(item);
      });
    });
    watchEffect(() => {
      rgbaColors.value = parseColors(props2.colors, props2.color);
    });
    function handleSelect(index2) {
      props2.color.fromString(props2.colors[index2]);
    }
    function parseColors(colors, color) {
      return colors.map((value2) => {
        const c = new Color();
        c.enableAlpha = true;
        c.format = "rgba";
        c.fromString(value2);
        c.selected = c.value === color.value;
        return c;
      });
    }
    return {
      rgbaColors,
      handleSelect
    };
  }
});
const _hoisted_1$Y = { class: "el-color-predefine" };
const _hoisted_2$O = { class: "el-color-predefine__colors" };
const _hoisted_3$L = ["onClick"];
function render$2$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$Y, [
    createElementVNode("div", _hoisted_2$O, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rgbaColors, (item, index2) => {
        return openBlock(), createElementBlock("div", {
          key: _ctx.colors[index2],
          class: normalizeClass(["el-color-predefine__color-selector", { selected: item.selected, "is-alpha": item._alpha < 100 }]),
          onClick: ($event) => _ctx.handleSelect(index2)
        }, [
          createElementVNode("div", {
            style: normalizeStyle({ backgroundColor: item.value })
          }, null, 4)
        ], 10, _hoisted_3$L);
      }), 128))
    ])
  ]);
}
script$2$e.render = render$2$b;
script$2$e.__file = "packages/components/color-picker/src/components/predefine.vue";
var script$3$9 = defineComponent({
  name: "ElSlPanel",
  props: {
    color: {
      type: Object,
      required: true
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const cursorTop = ref(0);
    const cursorLeft = ref(0);
    const background = ref("hsl(0, 100%, 50%)");
    const colorValue = computed(() => {
      const hue = props2.color.get("hue");
      const value2 = props2.color.get("value");
      return { hue, value: value2 };
    });
    function update() {
      const saturation = props2.color.get("saturation");
      const value2 = props2.color.get("value");
      const el = instance.vnode.el;
      let { clientWidth: width2, clientHeight: height } = el;
      cursorLeft.value = saturation * width2 / 100;
      cursorTop.value = (100 - value2) * height / 100;
      background.value = "hsl(" + props2.color.get("hue") + ", 100%, 50%)";
    }
    function handleDrag(event2) {
      const el = instance.vnode.el;
      const rect = el.getBoundingClientRect();
      let left2 = event2.clientX - rect.left;
      let top2 = event2.clientY - rect.top;
      left2 = Math.max(0, left2);
      left2 = Math.min(left2, rect.width);
      top2 = Math.max(0, top2);
      top2 = Math.min(top2, rect.height);
      cursorLeft.value = left2;
      cursorTop.value = top2;
      props2.color.set({
        saturation: left2 / rect.width * 100,
        value: 100 - top2 / rect.height * 100
      });
    }
    watch(() => colorValue.value, () => {
      update();
    });
    onMounted(() => {
      draggable(instance.vnode.el, {
        drag: (event2) => {
          handleDrag(event2);
        },
        end: (event2) => {
          handleDrag(event2);
        }
      });
      update();
    });
    return {
      cursorTop,
      cursorLeft,
      background,
      colorValue,
      handleDrag,
      update
    };
  }
});
const _hoisted_1$1$e = /* @__PURE__ */ createElementVNode("div", { class: "el-color-svpanel__white" }, null, -1);
const _hoisted_2$1$9 = /* @__PURE__ */ createElementVNode("div", { class: "el-color-svpanel__black" }, null, -1);
const _hoisted_3$1$9 = /* @__PURE__ */ createElementVNode("div", null, null, -1);
const _hoisted_4$z = [
  _hoisted_3$1$9
];
function render$3$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "el-color-svpanel",
    style: normalizeStyle({
      backgroundColor: _ctx.background
    })
  }, [
    _hoisted_1$1$e,
    _hoisted_2$1$9,
    createElementVNode("div", {
      class: "el-color-svpanel__cursor",
      style: normalizeStyle({
        top: _ctx.cursorTop + "px",
        left: _ctx.cursorLeft + "px"
      })
    }, _hoisted_4$z, 4)
  ], 4);
}
script$3$9.render = render$3$7;
script$3$9.__file = "packages/components/color-picker/src/components/sv-panel.vue";
var script$4$6 = defineComponent({
  name: "ElColorPicker",
  components: {
    ElButton: _Button,
    ElPopper: ElPopper$1,
    ElInput: ElInput$1,
    SvPanel: script$3$9,
    HueSlider: script$1$l,
    AlphaSlider: script$E,
    Predefine: script$2$e
  },
  directives: {
    ClickOutside: ClickOutside$1
  },
  props: {
    modelValue: String,
    showAlpha: Boolean,
    colorFormat: String,
    disabled: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    },
    popperClass: String,
    predefine: Array
  },
  emits: ["change", "active-change", UPDATE_MODEL_EVENT],
  setup(props2, { emit: emit2 }) {
    const ELEMENT = useGlobalConfig();
    const { t } = useLocaleInject();
    const elForm = inject(elFormKey, {});
    const elFormItem = inject(elFormItemKey, {});
    const hue = ref(null);
    const svPanel = ref(null);
    const alpha = ref(null);
    const popper2 = ref(null);
    const color = reactive(new Color({
      enableAlpha: props2.showAlpha,
      format: props2.colorFormat
    }));
    const showPicker = ref(false);
    const showPanelColor = ref(false);
    const customInput = ref("");
    const displayedColor = computed(() => {
      if (!props2.modelValue && !showPanelColor.value) {
        return "transparent";
      }
      return displayedRgb(color, props2.showAlpha);
    });
    const colorSize = computed(() => {
      return props2.size || elFormItem.size || ELEMENT.size;
    });
    const colorDisabled = computed(() => {
      return props2.disabled || elForm.disabled;
    });
    const currentColor = computed(() => {
      return !props2.modelValue && !showPanelColor.value ? "" : color.value;
    });
    watch(() => props2.modelValue, (newVal) => {
      if (!newVal) {
        showPanelColor.value = false;
      } else if (newVal && newVal !== color.value) {
        color.fromString(newVal);
      }
    });
    watch(() => currentColor.value, (val) => {
      customInput.value = val;
      emit2("active-change", val);
    });
    watch(() => color.value, () => {
      if (!props2.modelValue && !showPanelColor.value) {
        showPanelColor.value = true;
      }
    });
    function displayedRgb(color2, showAlpha) {
      if (!(color2 instanceof Color)) {
        throw Error("color should be instance of _color Class");
      }
      const { r, g, b } = color2.toRgb();
      return showAlpha ? `rgba(${r}, ${g}, ${b}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g}, ${b})`;
    }
    function setShowPicker(value2) {
      showPicker.value = value2;
    }
    const debounceSetShowPicker = debounce_1(setShowPicker, 100);
    function hide2() {
      debounceSetShowPicker(false);
      resetColor();
    }
    function resetColor() {
      nextTick(() => {
        if (props2.modelValue) {
          color.fromString(props2.modelValue);
        } else {
          showPanelColor.value = false;
        }
      });
    }
    function handleTrigger() {
      if (colorDisabled.value)
        return;
      debounceSetShowPicker(!showPicker.value);
    }
    function handleConfirm() {
      color.fromString(customInput.value);
    }
    function confirmValue() {
      var _a;
      const value2 = color.value;
      emit2(UPDATE_MODEL_EVENT, value2);
      emit2("change", value2);
      (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", value2);
      debounceSetShowPicker(false);
      nextTick(() => {
        const newColor = new Color({
          enableAlpha: props2.showAlpha,
          format: props2.colorFormat
        });
        newColor.fromString(props2.modelValue);
        if (!color.compare(newColor)) {
          resetColor();
        }
      });
    }
    function clear() {
      var _a;
      debounceSetShowPicker(false);
      emit2(UPDATE_MODEL_EVENT, null);
      emit2("change", null);
      if (props2.modelValue !== null) {
        (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", null);
      }
      resetColor();
    }
    onMounted(() => {
      if (props2.modelValue) {
        color.fromString(props2.modelValue);
        customInput.value = currentColor.value;
      }
    });
    watch(() => showPicker.value, () => {
      nextTick(() => {
        var _a, _b, _c;
        (_a = hue.value) == null ? void 0 : _a.update();
        (_b = svPanel.value) == null ? void 0 : _b.update();
        (_c = alpha.value) == null ? void 0 : _c.update();
      });
    });
    provide(OPTIONS_KEY, {
      currentColor
    });
    return {
      color,
      colorDisabled,
      colorSize,
      displayedColor,
      showPanelColor,
      showPicker,
      customInput,
      handleConfirm,
      hide: hide2,
      handleTrigger,
      clear,
      confirmValue,
      t,
      hue,
      svPanel,
      alpha,
      popper: popper2
    };
  }
});
const _hoisted_1$2$4 = { class: "el-color-dropdown__main-wrapper" };
const _hoisted_2$2$4 = { class: "el-color-dropdown__btns" };
const _hoisted_3$2$4 = { class: "el-color-dropdown__value" };
const _hoisted_4$1$4 = {
  key: 0,
  class: "el-color-picker__mask"
};
const _hoisted_5$t = {
  key: 0,
  class: "el-color-picker__empty el-icon-close"
};
const _hoisted_6$p = { class: "el-color-picker__icon el-icon-arrow-down" };
function render$4$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_hue_slider = resolveComponent("hue-slider");
  const _component_sv_panel = resolveComponent("sv-panel");
  const _component_alpha_slider = resolveComponent("alpha-slider");
  const _component_predefine = resolveComponent("predefine");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "popper",
    visible: _ctx.showPicker,
    "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => _ctx.showPicker = $event),
    effect: "light",
    "manual-mode": "",
    trigger: "click",
    "show-arrow": false,
    "fallback-placements": ["bottom", "top", "right", "left"],
    offset: 0,
    transition: "el-zoom-in-top",
    "gpu-acceleration": false,
    "popper-class": `el-color-picker__panel el-color-dropdown ${_ctx.popperClass}`,
    "stop-popper-mouse-event": false
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", null, [
        createElementVNode("div", _hoisted_1$2$4, [
          createVNode(_component_hue_slider, {
            ref: "hue",
            class: "hue-slider",
            color: _ctx.color,
            vertical: ""
          }, null, 8, ["color"]),
          createVNode(_component_sv_panel, {
            ref: "svPanel",
            color: _ctx.color
          }, null, 8, ["color"])
        ]),
        _ctx.showAlpha ? (openBlock(), createBlock(_component_alpha_slider, {
          key: 0,
          ref: "alpha",
          color: _ctx.color
        }, null, 8, ["color"])) : createCommentVNode("v-if", true),
        _ctx.predefine ? (openBlock(), createBlock(_component_predefine, {
          key: 1,
          ref: "predefine",
          color: _ctx.color,
          colors: _ctx.predefine
        }, null, 8, ["color", "colors"])) : createCommentVNode("v-if", true),
        createElementVNode("div", _hoisted_2$2$4, [
          createElementVNode("span", _hoisted_3$2$4, [
            createVNode(_component_el_input, {
              modelValue: _ctx.customInput,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.customInput = $event),
              "validate-event": false,
              size: "mini",
              onKeyup: withKeys(_ctx.handleConfirm, ["enter"]),
              onBlur: _ctx.handleConfirm
            }, null, 8, ["modelValue", "onKeyup", "onBlur"])
          ]),
          createVNode(_component_el_button, {
            size: "mini",
            type: "text",
            class: "el-color-dropdown__link-btn",
            onClick: _ctx.clear
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.t("el.colorpicker.clear")), 1)
            ]),
            _: 1
          }, 8, ["onClick"]),
          createVNode(_component_el_button, {
            plain: "",
            size: "mini",
            class: "el-color-dropdown__btn",
            onClick: _ctx.confirmValue
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.t("el.colorpicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ], 512), [
        [_directive_click_outside, _ctx.hide]
      ])
    ]),
    trigger: withCtx(() => [
      createElementVNode("div", {
        class: normalizeClass([
          "el-color-picker",
          _ctx.colorDisabled ? "is-disabled" : "",
          _ctx.colorSize ? `el-color-picker--${_ctx.colorSize}` : ""
        ])
      }, [
        _ctx.colorDisabled ? (openBlock(), createElementBlock("div", _hoisted_4$1$4)) : createCommentVNode("v-if", true),
        createElementVNode("div", {
          class: "el-color-picker__trigger",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleTrigger && _ctx.handleTrigger(...args))
        }, [
          createElementVNode("span", {
            class: normalizeClass(["el-color-picker__color", { "is-alpha": _ctx.showAlpha }])
          }, [
            createElementVNode("span", {
              class: "el-color-picker__color-inner",
              style: normalizeStyle({
                backgroundColor: _ctx.displayedColor
              })
            }, null, 4),
            !_ctx.modelValue && !_ctx.showPanelColor ? (openBlock(), createElementBlock("span", _hoisted_5$t)) : createCommentVNode("v-if", true)
          ], 2),
          withDirectives(createElementVNode("span", _hoisted_6$p, null, 512), [
            [vShow, _ctx.modelValue || _ctx.showPanelColor]
          ])
        ])
      ], 2)
    ]),
    _: 1
  }, 8, ["visible", "popper-class"]);
}
script$4$6.render = render$4$5;
script$4$6.__file = "packages/components/color-picker/src/workprogress.vue";
script$4$6.install = (app) => {
  app.component(script$4$6.name, script$4$6);
};
const _ColorPicker = script$4$6;
const ElColorPicker = _ColorPicker;
var withInstall = (component2) => {
  component2.install = (app) => {
    app.component(component2.name, component2);
  };
  return component2;
};
var __defProp$j = Object.defineProperty;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value2) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$j = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$j.call(b, prop))
      __defNormalProp$j(a, prop, b[prop]);
  if (__getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(b)) {
      if (__propIsEnum$j.call(b, prop))
        __defNormalProp$j(a, prop, b[prop]);
    }
  return a;
};
const ConfigProvider = defineComponent({
  name: "ElConfigProvider",
  props: __spreadValues$j({}, useLocaleProps),
  setup(_, { slots }) {
    useLocale();
    return () => slots.default();
  }
});
const ElConfigProvider = withInstall(ConfigProvider);
var script$D = defineComponent({
  name: "ElContainer",
  props: {
    direction: {
      type: String,
      default: ""
    }
  },
  setup(props2, { slots }) {
    const isVertical = computed(() => {
      if (props2.direction === "vertical") {
        return true;
      } else if (props2.direction === "horizontal") {
        return false;
      }
      if (slots && slots.default) {
        const vNodes = slots.default();
        return vNodes.some((vNode) => {
          const tag = vNode.type.name;
          return tag === "ElHeader" || tag === "ElFooter";
        });
      } else {
        return false;
      }
    });
    return {
      isVertical
    };
  }
});
function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("section", {
    class: normalizeClass(["el-container", { "is-vertical": _ctx.isVertical }])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
script$D.render = render$B;
script$D.__file = "packages/components/container/src/container.vue";
var script$1$k = defineComponent({
  name: "ElAside",
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(props2) {
    return {
      style: computed(() => {
        return props2.width ? { "--el-aside-width": props2.width } : {};
      })
    };
  }
});
function render$1$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("aside", {
    class: "el-aside",
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
script$1$k.render = render$1$j;
script$1$k.__file = "packages/components/container/src/aside.vue";
var script$2$d = defineComponent({
  name: "ElFooter",
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(props2) {
    return {
      style: computed(() => props2.height ? {
        "--el-footer-height": props2.height
      } : {})
    };
  }
});
function render$2$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("footer", {
    class: "el-footer",
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
script$2$d.render = render$2$a;
script$2$d.__file = "packages/components/container/src/footer.vue";
var script$3$8 = defineComponent({
  name: "ElHeader",
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(props2) {
    return {
      style: computed(() => props2.height ? {
        "--el-header-height": props2.height
      } : {})
    };
  }
});
function render$3$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    class: "el-header",
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
script$3$8.render = render$3$6;
script$3$8.__file = "packages/components/container/src/header.vue";
var script$4$5 = defineComponent({
  name: "ElMain"
});
const _hoisted_1$X = { class: "el-main" };
function render$4$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("main", _hoisted_1$X, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
script$4$5.render = render$4$4;
script$4$5.__file = "packages/components/container/src/main.vue";
script$D.install = (app) => {
  app.component(script$D.name, script$D);
  app.component(script$1$k.name, script$1$k);
  app.component(script$2$d.name, script$2$d);
  app.component(script$3$8.name, script$3$8);
  app.component(script$4$5.name, script$4$5);
};
script$D.Aside = script$1$k;
script$D.Footer = script$2$d;
script$D.Header = script$3$8;
script$D.Main = script$4$5;
const _Container = script$D;
const ElContainer = _Container;
var advancedFormat$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t, r) {
      var n = t.prototype, s = n.format;
      r.en.ordinal = function(e2) {
        var t2 = ["th", "st", "nd", "rd"], r2 = e2 % 100;
        return "[" + e2 + (t2[(r2 - 20) % 10] || t2[r2] || t2[0]) + "]";
      }, n.format = function(e2) {
        var t2 = this, r2 = this.$locale(), n2 = this.$utils(), a = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
          switch (e3) {
            case "Q":
              return Math.ceil((t2.$M + 1) / 3);
            case "Do":
              return r2.ordinal(t2.$D);
            case "gggg":
              return t2.weekYear();
            case "GGGG":
              return t2.isoWeekYear();
            case "wo":
              return r2.ordinal(t2.week(), "W");
            case "w":
            case "ww":
              return n2.s(t2.week(), e3 === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return n2.s(t2.isoWeek(), e3 === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return n2.s(String(t2.$H === 0 ? 24 : t2.$H), e3 === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(t2.$d.getTime() / 1e3);
            case "x":
              return t2.$d.getTime();
            case "z":
              return "[" + t2.offsetName() + "]";
            case "zzz":
              return "[" + t2.offsetName("long") + "]";
            default:
              return e3;
          }
        });
        return s.bind(this)(a);
      };
    };
  });
})(advancedFormat$1);
var advancedFormat = advancedFormat$1.exports;
var weekOfYear$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    var e = "week", t = "year";
    return function(i2, n, r) {
      var f = n.prototype;
      f.week = function(i3) {
        if (i3 === void 0 && (i3 = null), i3 !== null)
          return this.add(7 * (i3 - this.week()), "day");
        var n2 = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var f2 = r(this).startOf(t).add(1, t).date(n2), s = r(this).endOf(e);
          if (f2.isBefore(s))
            return 1;
        }
        var a = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o = this.diff(a, e, true);
        return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
      }, f.weeks = function(e2) {
        return e2 === void 0 && (e2 = null), this.week(e2);
      };
    };
  });
})(weekOfYear$1);
var weekOfYear = weekOfYear$1.exports;
var weekYear$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.weekYear = function() {
        var e2 = this.month(), t2 = this.week(), n = this.year();
        return t2 === 1 && e2 === 11 ? n + 1 : e2 === 0 && t2 >= 52 ? n - 1 : n;
      };
    };
  });
})(weekYear$1);
var weekYear = weekYear$1.exports;
var dayOfYear$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t, n) {
      t.prototype.dayOfYear = function(e2) {
        var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
        return e2 == null ? t2 : this.add(e2 - t2, "day");
      };
    };
  });
})(dayOfYear$1);
var dayOfYear = dayOfYear$1.exports;
var isSameOrAfter$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.isSameOrAfter = function(e2, t2) {
        return this.isSame(e2, t2) || this.isAfter(e2, t2);
      };
    };
  });
})(isSameOrAfter$1);
var isSameOrAfter = isSameOrAfter$1.exports;
var isSameOrBefore$1 = { exports: {} };
(function(module, exports) {
  !function(e, i2) {
    module.exports = i2();
  }(commonjsGlobal, function() {
    return function(e, i2) {
      i2.prototype.isSameOrBefore = function(e2, i3) {
        return this.isSame(e2, i3) || this.isBefore(e2, i3);
      };
    };
  });
})(isSameOrBefore$1);
var isSameOrBefore = isSameOrBefore$1.exports;
var script$C = defineComponent({
  props: {
    date: {
      type: Object
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    parsedValue: {
      type: [Object, Array]
    },
    selectionMode: {
      type: String,
      default: "day"
    },
    showWeekNumber: {
      type: Boolean,
      default: false
    },
    disabledDate: {
      type: Function
    },
    cellClassName: {
      type: Function
    },
    rangeState: {
      type: Object,
      default: () => ({
        endDate: null,
        selecting: false
      })
    }
  },
  emits: ["changerange", "pick", "select"],
  setup(props2, ctx2) {
    const { t, lang } = useLocaleInject();
    const lastRow = ref(null);
    const lastColumn = ref(null);
    const tableRows = ref([[], [], [], [], [], []]);
    const firstDayOfWeek = props2.date.$locale().weekStart || 7;
    const WEEKS_CONSTANT = props2.date.locale("en").localeData().weekdaysShort().map((_) => _.toLowerCase());
    const offsetDay = computed(() => {
      return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
    });
    const startDate = computed(() => {
      const startDayOfMonth = props2.date.startOf("month");
      return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
    });
    const WEEKS = computed(() => {
      return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
    });
    const rows = computed(() => {
      var _a;
      const startOfMonth = props2.date.startOf("month");
      const startOfMonthDay = startOfMonth.day() || 7;
      const dateCountOfMonth = startOfMonth.daysInMonth();
      const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
      const offset2 = offsetDay.value;
      const rows_ = tableRows.value;
      let count = 1;
      const selectedDate = props2.selectionMode === "dates" ? coerceTruthyValueToArray(props2.parsedValue) : [];
      const calNow = dayjs().locale(lang.value).startOf("day");
      for (let i2 = 0; i2 < 6; i2++) {
        const row = rows_[i2];
        if (props2.showWeekNumber) {
          if (!row[0]) {
            row[0] = {
              type: "week",
              text: startDate.value.add(i2 * 7 + 1, "day").week()
            };
          }
        }
        for (let j = 0; j < 7; j++) {
          let cell = row[props2.showWeekNumber ? j + 1 : j];
          if (!cell) {
            cell = {
              row: i2,
              column: j,
              type: "normal",
              inRange: false,
              start: false,
              end: false
            };
          }
          const index2 = i2 * 7 + j;
          const calTime = startDate.value.add(index2 - offset2, "day");
          cell.type = "normal";
          const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate;
          cell.inRange = props2.minDate && calTime.isSameOrAfter(props2.minDate, "day") && (calEndDate && calTime.isSameOrBefore(calEndDate, "day")) || props2.minDate && calTime.isSameOrBefore(props2.minDate, "day") && (calEndDate && calTime.isSameOrAfter(calEndDate, "day"));
          if ((_a = props2.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, "day");
            cell.end = props2.minDate && calTime.isSame(props2.minDate, "day");
          } else {
            cell.start = props2.minDate && calTime.isSame(props2.minDate, "day");
            cell.end = calEndDate && calTime.isSame(calEndDate, "day");
          }
          const isToday = calTime.isSame(calNow, "day");
          if (isToday) {
            cell.type = "today";
          }
          if (i2 >= 0 && i2 <= 1) {
            const numberOfDaysFromPreviousMonth = startOfMonthDay + offset2 < 0 ? 7 + startOfMonthDay + offset2 : startOfMonthDay + offset2;
            if (j + i2 * 7 >= numberOfDaysFromPreviousMonth) {
              cell.text = count++;
            } else {
              cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i2 * 7;
              cell.type = "prev-month";
            }
          } else {
            if (count <= dateCountOfMonth) {
              cell.text = count++;
            } else {
              cell.text = count++ - dateCountOfMonth;
              cell.type = "next-month";
            }
          }
          const cellDate = calTime.toDate();
          cell.selected = selectedDate.find((_) => _.valueOf() === calTime.valueOf());
          cell.disabled = props2.disabledDate && props2.disabledDate(cellDate);
          cell.customClass = props2.cellClassName && props2.cellClassName(cellDate);
          row[props2.showWeekNumber ? j + 1 : j] = cell;
        }
        if (props2.selectionMode === "week") {
          const start2 = props2.showWeekNumber ? 1 : 0;
          const end2 = props2.showWeekNumber ? 7 : 6;
          const isActive = isWeekActive(row[start2 + 1]);
          row[start2].inRange = isActive;
          row[start2].start = isActive;
          row[end2].inRange = isActive;
          row[end2].end = isActive;
        }
      }
      return rows_;
    });
    const cellMatchesDate = (cell, date3) => {
      if (!date3)
        return false;
      return dayjs(date3).locale(lang.value).isSame(props2.date.date(Number(cell.text)), "day");
    };
    const getCellClasses = (cell) => {
      let classes = [];
      if ((cell.type === "normal" || cell.type === "today") && !cell.disabled) {
        classes.push("available");
        if (cell.type === "today") {
          classes.push("today");
        }
      } else {
        classes.push(cell.type);
      }
      if (props2.selectionMode === "day" && (cell.type === "normal" || cell.type === "today") && cellMatchesDate(cell, props2.parsedValue)) {
        classes.push("current");
      }
      if (cell.inRange && (cell.type === "normal" || cell.type === "today" || props2.selectionMode === "week")) {
        classes.push("in-range");
        if (cell.start) {
          classes.push("start-date");
        }
        if (cell.end) {
          classes.push("end-date");
        }
      }
      if (cell.disabled) {
        classes.push("disabled");
      }
      if (cell.selected) {
        classes.push("selected");
      }
      if (cell.customClass) {
        classes.push(cell.customClass);
      }
      return classes.join(" ");
    };
    const getDateOfCell = (row, column) => {
      const offsetFromStart = row * 7 + (column - (props2.showWeekNumber ? 1 : 0)) - offsetDay.value;
      return startDate.value.add(offsetFromStart, "day");
    };
    const handleMouseMove = (event2) => {
      if (!props2.rangeState.selecting)
        return;
      let target = event2.target;
      if (target.tagName === "SPAN") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      if (rows.value[row][column].disabled)
        return;
      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx2.emit("changerange", {
          selecting: true,
          endDate: getDateOfCell(row, column)
        });
      }
    };
    const handleClick = (event2) => {
      let target = event2.target;
      if (target.tagName === "SPAN") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      const cell = rows.value[row][column];
      if (cell.disabled || cell.type === "week")
        return;
      const newDate = getDateOfCell(row, column);
      if (props2.selectionMode === "range") {
        if (!props2.rangeState.selecting) {
          ctx2.emit("pick", { minDate: newDate, maxDate: null });
          ctx2.emit("select", true);
        } else {
          if (newDate >= props2.minDate) {
            ctx2.emit("pick", { minDate: props2.minDate, maxDate: newDate });
          } else {
            ctx2.emit("pick", { minDate: newDate, maxDate: props2.minDate });
          }
          ctx2.emit("select", false);
        }
      } else if (props2.selectionMode === "day") {
        ctx2.emit("pick", newDate);
      } else if (props2.selectionMode === "week") {
        const weekNumber = newDate.week();
        const value2 = newDate.year() + "w" + weekNumber;
        ctx2.emit("pick", {
          year: newDate.year(),
          week: weekNumber,
          value: value2,
          date: newDate.startOf("week")
        });
      } else if (props2.selectionMode === "dates") {
        const newValue = cell.selected ? coerceTruthyValueToArray(props2.parsedValue).filter((_) => _.valueOf() !== newDate.valueOf()) : coerceTruthyValueToArray(props2.parsedValue).concat([newDate]);
        ctx2.emit("pick", newValue);
      }
    };
    const isWeekActive = (cell) => {
      if (props2.selectionMode !== "week")
        return false;
      let newDate = props2.date.startOf("day");
      if (cell.type === "prev-month") {
        newDate = newDate.subtract(1, "month");
      }
      if (cell.type === "next-month") {
        newDate = newDate.add(1, "month");
      }
      newDate = newDate.date(parseInt(cell.text, 10));
      if (props2.parsedValue && !Array.isArray(props2.parsedValue)) {
        const dayOffset = (props2.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
        const weekDate = props2.parsedValue.subtract(dayOffset, "day");
        return weekDate.isSame(newDate, "day");
      }
      return false;
    };
    return {
      handleMouseMove,
      t,
      rows,
      isWeekActive,
      getCellClasses,
      WEEKS,
      handleClick
    };
  }
});
const _hoisted_1$W = { key: 0 };
function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", {
    cellspacing: "0",
    cellpadding: "0",
    class: normalizeClass(["el-date-table", { "is-week-mode": _ctx.selectionMode === "week" }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [
    createElementVNode("tbody", null, [
      createElementVNode("tr", null, [
        _ctx.showWeekNumber ? (openBlock(), createElementBlock("th", _hoisted_1$W, toDisplayString(_ctx.t("el.datepicker.week")), 1)) : createCommentVNode("v-if", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.WEEKS, (week, key) => {
          return openBlock(), createElementBlock("th", { key }, toDisplayString(_ctx.t("el.datepicker.weeks." + week)), 1);
        }), 128))
      ]),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row, key) => {
        return openBlock(), createElementBlock("tr", {
          key,
          class: normalizeClass(["el-date-table__row", { current: _ctx.isWeekActive(row[1]) }])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
            return openBlock(), createElementBlock("td", {
              key: key_,
              class: normalizeClass(_ctx.getCellClasses(cell))
            }, [
              createElementVNode("div", null, [
                createElementVNode("span", null, toDisplayString(cell.text), 1)
              ])
            ], 2);
          }), 128))
        ], 2);
      }), 128))
    ])
  ], 34);
}
script$C.render = render$A;
script$C.__file = "packages/components/date-picker/src/date-picker-com/basic-date-table.vue";
const datesInMonth = (year, month, lang) => {
  const firstDay = dayjs().locale(lang).startOf("month").month(month).year(year);
  const numOfDays = firstDay.daysInMonth();
  return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
};
var script$1$j = defineComponent({
  props: {
    disabledDate: {
      type: Function
    },
    selectionMode: {
      type: String,
      default: "month"
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    date: {
      type: Object
    },
    parsedValue: {
      type: Object
    },
    rangeState: {
      type: Object,
      default: () => ({
        endDate: null,
        selecting: false
      })
    }
  },
  emits: ["changerange", "pick", "select"],
  setup(props2, ctx2) {
    const { t, lang } = useLocaleInject();
    const months = ref(props2.date.locale("en").localeData().monthsShort().map((_) => _.toLowerCase()));
    const tableRows = ref([[], [], []]);
    const lastRow = ref(null);
    const lastColumn = ref(null);
    const rows = computed(() => {
      var _a;
      const rows2 = tableRows.value;
      const now2 = dayjs().locale(lang.value).startOf("month");
      for (let i2 = 0; i2 < 3; i2++) {
        const row = rows2[i2];
        for (let j = 0; j < 4; j++) {
          let cell = row[j];
          if (!cell) {
            cell = {
              row: i2,
              column: j,
              type: "normal",
              inRange: false,
              start: false,
              end: false
            };
          }
          cell.type = "normal";
          const index2 = i2 * 4 + j;
          const calTime = props2.date.startOf("year").month(index2);
          const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate;
          cell.inRange = props2.minDate && calTime.isSameOrAfter(props2.minDate, "month") && (calEndDate && calTime.isSameOrBefore(calEndDate, "month")) || props2.minDate && calTime.isSameOrBefore(props2.minDate, "month") && (calEndDate && calTime.isSameOrAfter(calEndDate, "month"));
          if ((_a = props2.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, "month");
            cell.end = props2.minDate && calTime.isSame(props2.minDate, "month");
          } else {
            cell.start = props2.minDate && calTime.isSame(props2.minDate, "month");
            cell.end = calEndDate && calTime.isSame(calEndDate, "month");
          }
          const isToday = now2.isSame(calTime);
          if (isToday) {
            cell.type = "today";
          }
          cell.text = index2;
          let cellDate = calTime.toDate();
          cell.disabled = props2.disabledDate && props2.disabledDate(cellDate);
          row[j] = cell;
        }
      }
      return rows2;
    });
    const getCellStyle = (cell) => {
      const style = {};
      const year = props2.date.year();
      const today = new Date();
      const month = cell.text;
      style.disabled = props2.disabledDate ? datesInMonth(year, month, lang.value).every(props2.disabledDate) : false;
      style.current = coerceTruthyValueToArray(props2.parsedValue).findIndex((date3) => date3.year() === year && date3.month() === month) >= 0;
      style.today = today.getFullYear() === year && today.getMonth() === month;
      if (cell.inRange) {
        style["in-range"] = true;
        if (cell.start) {
          style["start-date"] = true;
        }
        if (cell.end) {
          style["end-date"] = true;
        }
      }
      return style;
    };
    const handleMouseMove = (event2) => {
      if (!props2.rangeState.selecting)
        return;
      let target = event2.target;
      if (target.tagName === "A") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex;
      const column = target.cellIndex;
      if (rows.value[row][column].disabled)
        return;
      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx2.emit("changerange", {
          selecting: true,
          endDate: props2.date.startOf("year").month(row * 4 + column)
        });
      }
    };
    const handleMonthTableClick = (event2) => {
      let target = event2.target;
      if (target.tagName === "A") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      if (hasClass(target, "disabled"))
        return;
      const column = target.cellIndex;
      const row = target.parentNode.rowIndex;
      const month = row * 4 + column;
      const newDate = props2.date.startOf("year").month(month);
      if (props2.selectionMode === "range") {
        if (!props2.rangeState.selecting) {
          ctx2.emit("pick", { minDate: newDate, maxDate: null });
          ctx2.emit("select", true);
        } else {
          if (newDate >= props2.minDate) {
            ctx2.emit("pick", { minDate: props2.minDate, maxDate: newDate });
          } else {
            ctx2.emit("pick", { minDate: newDate, maxDate: props2.minDate });
          }
          ctx2.emit("select", false);
        }
      } else {
        ctx2.emit("pick", month);
      }
    };
    return {
      handleMouseMove,
      handleMonthTableClick,
      rows,
      getCellStyle,
      t,
      months
    };
  }
});
const _hoisted_1$1$d = { class: "cell" };
function render$1$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", {
    class: "el-month-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMonthTableClick && _ctx.handleMonthTableClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [
    createElementVNode("tbody", null, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row, key) => {
        return openBlock(), createElementBlock("tr", { key }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
            return openBlock(), createElementBlock("td", {
              key: key_,
              class: normalizeClass(_ctx.getCellStyle(cell))
            }, [
              createElementVNode("div", null, [
                createElementVNode("a", _hoisted_1$1$d, toDisplayString(_ctx.t("el.datepicker.months." + _ctx.months[cell.text])), 1)
              ])
            ], 2);
          }), 128))
        ]);
      }), 128))
    ])
  ], 32);
}
script$1$j.render = render$1$i;
script$1$j.__file = "packages/components/date-picker/src/date-picker-com/basic-month-table.vue";
const datesInYear = (year, lang) => {
  const firstDay = dayjs(String(year)).locale(lang).startOf("year");
  const lastDay = firstDay.endOf("year");
  const numOfDays = lastDay.dayOfYear();
  return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
};
var script$2$c = defineComponent({
  props: {
    disabledDate: {
      type: Function
    },
    parsedValue: {
      type: Object
    },
    date: {
      type: Object
    }
  },
  emits: ["pick"],
  setup(props2, ctx2) {
    const { lang } = useLocaleInject();
    const startYear = computed(() => {
      return Math.floor(props2.date.year() / 10) * 10;
    });
    const getCellStyle = (year) => {
      const style = {};
      const today = dayjs().locale(lang.value);
      style.disabled = props2.disabledDate ? datesInYear(year, lang.value).every(props2.disabledDate) : false;
      style.current = coerceTruthyValueToArray(props2.parsedValue).findIndex((_) => _.year() === year) >= 0;
      style.today = today.year() === year;
      return style;
    };
    const handleYearTableClick = (event2) => {
      const target = event2.target;
      if (target.tagName === "A") {
        if (hasClass(target.parentNode, "disabled"))
          return;
        const year = target.textContent || target.innerText;
        ctx2.emit("pick", Number(year));
      }
    };
    return {
      startYear,
      getCellStyle,
      handleYearTableClick
    };
  }
});
const _hoisted_1$2$3 = { class: "cell" };
const _hoisted_2$N = { class: "cell" };
const _hoisted_3$K = { class: "cell" };
const _hoisted_4$y = { class: "cell" };
const _hoisted_5$s = { class: "cell" };
const _hoisted_6$o = { class: "cell" };
const _hoisted_7$j = { class: "cell" };
const _hoisted_8$f = { class: "cell" };
const _hoisted_9$f = { class: "cell" };
const _hoisted_10$c = { class: "cell" };
const _hoisted_11$a = /* @__PURE__ */ createElementVNode("td", null, null, -1);
const _hoisted_12$9 = /* @__PURE__ */ createElementVNode("td", null, null, -1);
function render$2$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", {
    class: "el-year-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleYearTableClick && _ctx.handleYearTableClick(...args))
  }, [
    createElementVNode("tbody", null, [
      createElementVNode("tr", null, [
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 0)])
        }, [
          createElementVNode("a", _hoisted_1$2$3, toDisplayString(_ctx.startYear), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 1)])
        }, [
          createElementVNode("a", _hoisted_2$N, toDisplayString(_ctx.startYear + 1), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 2)])
        }, [
          createElementVNode("a", _hoisted_3$K, toDisplayString(_ctx.startYear + 2), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 3)])
        }, [
          createElementVNode("a", _hoisted_4$y, toDisplayString(_ctx.startYear + 3), 1)
        ], 2)
      ]),
      createElementVNode("tr", null, [
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 4)])
        }, [
          createElementVNode("a", _hoisted_5$s, toDisplayString(_ctx.startYear + 4), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 5)])
        }, [
          createElementVNode("a", _hoisted_6$o, toDisplayString(_ctx.startYear + 5), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 6)])
        }, [
          createElementVNode("a", _hoisted_7$j, toDisplayString(_ctx.startYear + 6), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 7)])
        }, [
          createElementVNode("a", _hoisted_8$f, toDisplayString(_ctx.startYear + 7), 1)
        ], 2)
      ]),
      createElementVNode("tr", null, [
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 8)])
        }, [
          createElementVNode("a", _hoisted_9$f, toDisplayString(_ctx.startYear + 8), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 9)])
        }, [
          createElementVNode("a", _hoisted_10$c, toDisplayString(_ctx.startYear + 9), 1)
        ], 2),
        _hoisted_11$a,
        _hoisted_12$9
      ])
    ])
  ]);
}
script$2$c.render = render$2$9;
script$2$c.__file = "packages/components/date-picker/src/date-picker-com/basic-year-table.vue";
const timeWithinRange = (_, __, ___) => true;
var script$3$7 = defineComponent({
  components: {
    DateTable: script$C,
    ElInput: ElInput$1,
    ElButton: _Button,
    TimePickPanel: script$2$i,
    MonthTable: script$1$j,
    YearTable: script$2$c
  },
  directives: { clickoutside: ClickOutside$1 },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    parsedValue: {
      type: [Object, Array]
    },
    format: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      required: true,
      validator: isValidDatePickType
    }
  },
  emits: ["pick", "set-picker-option"],
  setup(props2, ctx2) {
    const { t, lang } = useLocaleInject();
    const innerDate = ref(dayjs().locale(lang.value));
    const month = computed(() => {
      return innerDate.value.month();
    });
    const year = computed(() => {
      return innerDate.value.year();
    });
    const selectableRange = ref([]);
    const userInputDate = ref(null);
    const userInputTime = ref(null);
    const checkDateWithinRange = (date3) => {
      return selectableRange.value.length > 0 ? timeWithinRange(date3, selectableRange.value, props2.format || "HH:mm:ss") : true;
    };
    const formatEmit = (emitDayjs) => {
      if (defaultTime) {
        const defaultTimeD = dayjs(defaultTime).locale(lang.value);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      if (showTime.value)
        return emitDayjs.millisecond(0);
      return emitDayjs.startOf("day");
    };
    const emit2 = (value2, ...args) => {
      if (!value2) {
        ctx2.emit("pick", value2, ...args);
      } else if (Array.isArray(value2)) {
        const dates = value2.map(formatEmit);
        ctx2.emit("pick", dates, ...args);
      } else {
        ctx2.emit("pick", formatEmit(value2), ...args);
      }
      userInputDate.value = null;
      userInputTime.value = null;
    };
    const handleDatePick = (value2) => {
      if (selectionMode.value === "day") {
        let newDate = props2.parsedValue ? props2.parsedValue.year(value2.year()).month(value2.month()).date(value2.date()) : value2;
        if (!checkDateWithinRange(newDate)) {
          newDate = selectableRange.value[0][0].year(value2.year()).month(value2.month()).date(value2.date());
        }
        innerDate.value = newDate;
        emit2(newDate, showTime.value);
      } else if (selectionMode.value === "week") {
        emit2(value2.date);
      } else if (selectionMode.value === "dates") {
        emit2(value2, true);
      }
    };
    const prevMonth_ = () => {
      innerDate.value = innerDate.value.subtract(1, "month");
    };
    const nextMonth_ = () => {
      innerDate.value = innerDate.value.add(1, "month");
    };
    const prevYear_ = () => {
      if (currentView.value === "year") {
        innerDate.value = innerDate.value.subtract(10, "year");
      } else {
        innerDate.value = innerDate.value.subtract(1, "year");
      }
    };
    const nextYear_ = () => {
      if (currentView.value === "year") {
        innerDate.value = innerDate.value.add(10, "year");
      } else {
        innerDate.value = innerDate.value.add(1, "year");
      }
    };
    const currentView = ref("date");
    const yearLabel = computed(() => {
      const yearTranslation = t("el.datepicker.year");
      if (currentView.value === "year") {
        const startYear = Math.floor(year.value / 10) * 10;
        if (yearTranslation) {
          return startYear + " " + yearTranslation + " - " + (startYear + 9) + " " + yearTranslation;
        }
        return startYear + " - " + (startYear + 9);
      }
      return year.value + " " + yearTranslation;
    });
    const handleShortcutClick = (shortcut) => {
      const shortcutValue = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      if (shortcutValue) {
        emit2(dayjs(shortcutValue).locale(lang.value));
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick(ctx2);
      }
    };
    const selectionMode = computed(() => {
      if (["week", "month", "year", "dates"].includes(props2.type)) {
        return props2.type;
      }
      return "day";
    });
    watch(() => selectionMode.value, (val) => {
      if (["month", "year"].includes(val)) {
        currentView.value = val;
        return;
      }
      currentView.value = "date";
    }, { immediate: true });
    const hasShortcuts = computed(() => !!shortcuts.length);
    const handleMonthPick = (month2) => {
      innerDate.value = innerDate.value.startOf("month").month(month2);
      if (selectionMode.value === "month") {
        emit2(innerDate.value);
      } else {
        currentView.value = "date";
      }
    };
    const handleYearPick = (year2) => {
      if (selectionMode.value === "year") {
        innerDate.value = innerDate.value.startOf("year").year(year2);
        emit2(innerDate.value);
      } else {
        innerDate.value = innerDate.value.year(year2);
        currentView.value = "month";
      }
    };
    const showMonthPicker = () => {
      currentView.value = "month";
    };
    const showYearPicker = () => {
      currentView.value = "year";
    };
    const showTime = computed(() => props2.type === "datetime" || props2.type === "datetimerange");
    const footerVisible = computed(() => {
      return showTime.value || selectionMode.value === "dates";
    });
    const onConfirm = () => {
      if (selectionMode.value === "dates") {
        emit2(props2.parsedValue);
      } else {
        let result = props2.parsedValue;
        if (!result) {
          const defaultTimeD = dayjs(defaultTime).locale(lang.value);
          const defaultValueD = getDefaultValue();
          result = defaultTimeD.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
        }
        innerDate.value = result;
        emit2(result);
      }
    };
    const changeToNow = () => {
      const now2 = dayjs().locale(lang.value);
      const nowDate = now2.toDate();
      if ((!disabledDate || !disabledDate(nowDate)) && checkDateWithinRange(nowDate)) {
        innerDate.value = dayjs().locale(lang.value);
        emit2(innerDate.value);
      }
    };
    const timeFormat = computed(() => {
      return extractTimeFormat(props2.format);
    });
    const dateFormat = computed(() => {
      return extractDateFormat(props2.format);
    });
    const visibleTime = computed(() => {
      if (userInputTime.value)
        return userInputTime.value;
      if (!props2.parsedValue && !defaultValue2)
        return;
      return (props2.parsedValue || innerDate.value).format(timeFormat.value);
    });
    const visibleDate = computed(() => {
      if (userInputDate.value)
        return userInputDate.value;
      if (!props2.parsedValue && !defaultValue2)
        return;
      return (props2.parsedValue || innerDate.value).format(dateFormat.value);
    });
    const timePickerVisible = ref(false);
    const onTimePickerInputFocus = () => {
      timePickerVisible.value = true;
    };
    const handleTimePickClose = () => {
      timePickerVisible.value = false;
    };
    const handleTimePick = (value2, visible2, first) => {
      const newDate = props2.parsedValue ? props2.parsedValue.hour(value2.hour()).minute(value2.minute()).second(value2.second()) : value2;
      innerDate.value = newDate;
      emit2(innerDate.value, true);
      if (!first) {
        timePickerVisible.value = visible2;
      }
    };
    const handleVisibleTimeChange = (value2) => {
      const newDate = dayjs(value2, timeFormat.value).locale(lang.value);
      if (newDate.isValid() && checkDateWithinRange(newDate)) {
        innerDate.value = newDate.year(innerDate.value.year()).month(innerDate.value.month()).date(innerDate.value.date());
        userInputTime.value = null;
        timePickerVisible.value = false;
        emit2(innerDate.value, true);
      }
    };
    const handleVisibleDateChange = (value2) => {
      const newDate = dayjs(value2, dateFormat.value).locale(lang.value);
      if (newDate.isValid()) {
        if (disabledDate && disabledDate(newDate.toDate())) {
          return;
        }
        innerDate.value = newDate.hour(innerDate.value.hour()).minute(innerDate.value.minute()).second(innerDate.value.second());
        userInputDate.value = null;
        emit2(innerDate.value, true);
      }
    };
    const isValidValue = (date_) => {
      return date_.isValid() && (disabledDate ? !disabledDate(date_.toDate()) : true);
    };
    const formatToString = (value2) => {
      if (selectionMode.value === "dates") {
        return value2.map((_) => _.format(props2.format));
      }
      return value2.format(props2.format);
    };
    const parseUserInput = (value2) => {
      return dayjs(value2, props2.format).locale(lang.value);
    };
    const getDefaultValue = () => {
      return dayjs(defaultValue2).locale(lang.value);
    };
    const handleKeydown = (event2) => {
      const { code, keyCode } = event2;
      const list = [EVENT_CODE.up, EVENT_CODE.down, EVENT_CODE.left, EVENT_CODE.right];
      if (props2.visible && !timePickerVisible.value) {
        if (list.includes(code)) {
          handleKeyControl(keyCode);
          event2.stopPropagation();
          event2.preventDefault();
        }
        if (code === EVENT_CODE.enter && userInputDate.value === null && userInputTime.value === null) {
          emit2(innerDate, false);
        }
      }
    };
    const handleKeyControl = (keyCode) => {
      const mapping = {
        "year": {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: (date3, step) => date3.setFullYear(date3.getFullYear() + step)
        },
        "month": {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: (date3, step) => date3.setMonth(date3.getMonth() + step)
        },
        "week": {
          38: -1,
          40: 1,
          37: -1,
          39: 1,
          offset: (date3, step) => date3.setDate(date3.getDate() + step * 7)
        },
        "day": {
          38: -7,
          40: 7,
          37: -1,
          39: 1,
          offset: (date3, step) => date3.setDate(date3.getDate() + step)
        }
      };
      const newDate = innerDate.value.toDate();
      while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
        const map2 = mapping[selectionMode.value];
        map2.offset(newDate, map2[keyCode]);
        if (disabledDate && disabledDate(newDate)) {
          continue;
        }
        const result = dayjs(newDate).locale(lang.value);
        innerDate.value = result;
        ctx2.emit("pick", result, true);
        break;
      }
    };
    ctx2.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx2.emit("set-picker-option", ["formatToString", formatToString]);
    ctx2.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx2.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    const pickerBase = inject("EP_PICKER_BASE");
    const { shortcuts, disabledDate, cellClassName, defaultTime, defaultValue: defaultValue2, arrowControl } = pickerBase.props;
    watch(() => props2.parsedValue, (val) => {
      if (val) {
        if (selectionMode.value === "dates")
          return;
        if (Array.isArray(val))
          return;
        innerDate.value = val;
      } else {
        innerDate.value = getDefaultValue();
      }
    }, { immediate: true });
    return {
      handleTimePick,
      handleTimePickClose,
      onTimePickerInputFocus,
      timePickerVisible,
      visibleTime,
      visibleDate,
      showTime,
      changeToNow,
      onConfirm,
      footerVisible,
      handleYearPick,
      showMonthPicker,
      showYearPicker,
      handleMonthPick,
      hasShortcuts,
      shortcuts,
      arrowControl,
      disabledDate,
      cellClassName,
      selectionMode,
      handleShortcutClick,
      prevYear_,
      nextYear_,
      prevMonth_,
      nextMonth_,
      innerDate,
      t,
      yearLabel,
      currentView,
      month,
      handleDatePick,
      handleVisibleTimeChange,
      handleVisibleDateChange,
      timeFormat,
      userInputTime,
      userInputDate
    };
  }
});
const _hoisted_1$3$3 = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$1$8 = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$1$8 = ["onClick"];
const _hoisted_4$1$3 = { class: "el-picker-panel__body" };
const _hoisted_5$1$3 = {
  key: 0,
  class: "el-date-picker__time-header"
};
const _hoisted_6$1$2 = { class: "el-date-picker__editor-wrap" };
const _hoisted_7$1$1 = { class: "el-date-picker__editor-wrap" };
const _hoisted_8$1$1 = ["aria-label"];
const _hoisted_9$1$1 = ["aria-label"];
const _hoisted_10$1$1 = ["aria-label"];
const _hoisted_11$1$1 = ["aria-label"];
const _hoisted_12$1$1 = { class: "el-picker-panel__content" };
const _hoisted_13$7 = { class: "el-picker-panel__footer" };
function render$3$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_time_pick_panel = resolveComponent("time-pick-panel");
  const _component_date_table = resolveComponent("date-table");
  const _component_year_table = resolveComponent("year-table");
  const _component_month_table = resolveComponent("month-table");
  const _component_el_button = resolveComponent("el-button");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-picker-panel el-date-picker", [{
      "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
      "has-time": _ctx.showTime
    }]])
  }, [
    createElementVNode("div", _hoisted_1$3$3, [
      renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (openBlock(), createElementBlock("div", _hoisted_2$1$8, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (shortcut, key) => {
          return openBlock(), createElementBlock("button", {
            key,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, toDisplayString(shortcut.text), 9, _hoisted_3$1$8);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_4$1$3, [
        _ctx.showTime ? (openBlock(), createElementBlock("div", _hoisted_5$1$3, [
          createElementVNode("span", _hoisted_6$1$2, [
            createVNode(_component_el_input, {
              placeholder: _ctx.t("el.datepicker.selectDate"),
              "model-value": _ctx.visibleDate,
              size: "small",
              onInput: _cache[0] || (_cache[0] = (val) => _ctx.userInputDate = val),
              onChange: _ctx.handleVisibleDateChange
            }, null, 8, ["placeholder", "model-value", "onChange"])
          ]),
          withDirectives(createElementVNode("span", _hoisted_7$1$1, [
            createVNode(_component_el_input, {
              placeholder: _ctx.t("el.datepicker.selectTime"),
              "model-value": _ctx.visibleTime,
              size: "small",
              onFocus: _ctx.onTimePickerInputFocus,
              onInput: _cache[1] || (_cache[1] = (val) => _ctx.userInputTime = val),
              onChange: _ctx.handleVisibleTimeChange
            }, null, 8, ["placeholder", "model-value", "onFocus", "onChange"]),
            createVNode(_component_time_pick_panel, {
              visible: _ctx.timePickerVisible,
              format: _ctx.timeFormat,
              "time-arrow-control": _ctx.arrowControl,
              "parsed-value": _ctx.innerDate,
              onPick: _ctx.handleTimePick
            }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
          ], 512), [
            [_directive_clickoutside, _ctx.handleTimePickClose]
          ])
        ])) : createCommentVNode("v-if", true),
        withDirectives(createElementVNode("div", {
          class: normalizeClass(["el-date-picker__header", { "el-date-picker__header--bordered": _ctx.currentView === "year" || _ctx.currentView === "month" }])
        }, [
          createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.prevYear`),
            class: "el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-d-arrow-left",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.prevYear_ && _ctx.prevYear_(...args))
          }, null, 8, _hoisted_8$1$1),
          withDirectives(createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.prevMonth`),
            class: "el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-arrow-left",
            onClick: _cache[3] || (_cache[3] = (...args) => _ctx.prevMonth_ && _ctx.prevMonth_(...args))
          }, null, 8, _hoisted_9$1$1), [
            [vShow, _ctx.currentView === "date"]
          ]),
          createElementVNode("span", {
            role: "button",
            class: "el-date-picker__header-label",
            onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showYearPicker && _ctx.showYearPicker(...args))
          }, toDisplayString(_ctx.yearLabel), 1),
          withDirectives(createElementVNode("span", {
            role: "button",
            class: normalizeClass(["el-date-picker__header-label", { active: _ctx.currentView === "month" }]),
            onClick: _cache[5] || (_cache[5] = (...args) => _ctx.showMonthPicker && _ctx.showMonthPicker(...args))
          }, toDisplayString(_ctx.t(`el.datepicker.month${_ctx.month + 1}`)), 3), [
            [vShow, _ctx.currentView === "date"]
          ]),
          createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.nextYear`),
            class: "el-picker-panel__icon-btn el-date-picker__next-btn el-icon-d-arrow-right",
            onClick: _cache[6] || (_cache[6] = (...args) => _ctx.nextYear_ && _ctx.nextYear_(...args))
          }, null, 8, _hoisted_10$1$1),
          withDirectives(createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.nextMonth`),
            class: "el-picker-panel__icon-btn el-date-picker__next-btn el-icon-arrow-right",
            onClick: _cache[7] || (_cache[7] = (...args) => _ctx.nextMonth_ && _ctx.nextMonth_(...args))
          }, null, 8, _hoisted_11$1$1), [
            [vShow, _ctx.currentView === "date"]
          ])
        ], 2), [
          [vShow, _ctx.currentView !== "time"]
        ]),
        createElementVNode("div", _hoisted_12$1$1, [
          _ctx.currentView === "date" ? (openBlock(), createBlock(_component_date_table, {
            key: 0,
            "selection-mode": _ctx.selectionMode,
            date: _ctx.innerDate,
            "parsed-value": _ctx.parsedValue,
            "disabled-date": _ctx.disabledDate,
            onPick: _ctx.handleDatePick
          }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "onPick"])) : createCommentVNode("v-if", true),
          _ctx.currentView === "year" ? (openBlock(), createBlock(_component_year_table, {
            key: 1,
            date: _ctx.innerDate,
            "disabled-date": _ctx.disabledDate,
            "parsed-value": _ctx.parsedValue,
            onPick: _ctx.handleYearPick
          }, null, 8, ["date", "disabled-date", "parsed-value", "onPick"])) : createCommentVNode("v-if", true),
          _ctx.currentView === "month" ? (openBlock(), createBlock(_component_month_table, {
            key: 2,
            date: _ctx.innerDate,
            "parsed-value": _ctx.parsedValue,
            "disabled-date": _ctx.disabledDate,
            onPick: _ctx.handleMonthPick
          }, null, 8, ["date", "parsed-value", "disabled-date", "onPick"])) : createCommentVNode("v-if", true)
        ])
      ])
    ]),
    withDirectives(createElementVNode("div", _hoisted_13$7, [
      withDirectives(createVNode(_component_el_button, {
        size: "mini",
        type: "text",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.changeToNow
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.now")), 1)
        ]),
        _: 1
      }, 8, ["onClick"]), [
        [vShow, _ctx.selectionMode !== "dates"]
      ]),
      createVNode(_component_el_button, {
        plain: "",
        size: "mini",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.onConfirm
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])
    ], 512), [
      [vShow, _ctx.footerVisible && _ctx.currentView === "date"]
    ])
  ], 2);
}
script$3$7.render = render$3$5;
script$3$7.__file = "packages/components/date-picker/src/date-picker-com/panel-date-pick.vue";
var script$4$4 = defineComponent({
  directives: { clickoutside: ClickOutside$1 },
  components: { TimePickPanel: script$2$i, DateTable: script$C, ElInput: ElInput$1, ElButton: _Button },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    },
    type: {
      type: String,
      required: true,
      validator: isValidDatePickType
    }
  },
  emits: ["pick", "set-picker-option", "calendar-change"],
  setup(props2, ctx2) {
    const { t, lang } = useLocaleInject();
    const leftDate = ref(dayjs().locale(lang.value));
    const rightDate = ref(dayjs().locale(lang.value).add(1, "month"));
    const minDate = ref(null);
    const maxDate = ref(null);
    const dateUserInput = ref({
      min: null,
      max: null
    });
    const timeUserInput = ref({
      min: null,
      max: null
    });
    const leftLabel = computed(() => {
      return leftDate.value.year() + " " + t("el.datepicker.year") + " " + t(`el.datepicker.month${leftDate.value.month() + 1}`);
    });
    const rightLabel = computed(() => {
      return rightDate.value.year() + " " + t("el.datepicker.year") + " " + t(`el.datepicker.month${rightDate.value.month() + 1}`);
    });
    const leftYear = computed(() => {
      return leftDate.value.year();
    });
    const leftMonth = computed(() => {
      return leftDate.value.month();
    });
    const rightYear = computed(() => {
      return rightDate.value.year();
    });
    const rightMonth = computed(() => {
      return rightDate.value.month();
    });
    const hasShortcuts = computed(() => !!shortcuts.length);
    const minVisibleDate = computed(() => {
      if (dateUserInput.value.min !== null)
        return dateUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(dateFormat.value);
      return "";
    });
    const maxVisibleDate = computed(() => {
      if (dateUserInput.value.max !== null)
        return dateUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(dateFormat.value);
      return "";
    });
    const minVisibleTime = computed(() => {
      if (timeUserInput.value.min !== null)
        return timeUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(timeFormat.value);
      return "";
    });
    const maxVisibleTime = computed(() => {
      if (timeUserInput.value.max !== null)
        return timeUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(timeFormat.value);
      return "";
    });
    const timeFormat = computed(() => {
      return extractTimeFormat(format2);
    });
    const dateFormat = computed(() => {
      return extractDateFormat(format2);
    });
    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");
      if (!props2.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
    };
    const leftPrevMonth = () => {
      leftDate.value = leftDate.value.subtract(1, "month");
      if (!props2.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
    };
    const rightNextYear = () => {
      if (!props2.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "year");
      }
    };
    const rightNextMonth = () => {
      if (!props2.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "month");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "month");
      }
    };
    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
    };
    const leftNextMonth = () => {
      leftDate.value = leftDate.value.add(1, "month");
    };
    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
    };
    const rightPrevMonth = () => {
      rightDate.value = rightDate.value.subtract(1, "month");
    };
    const enableMonthArrow = computed(() => {
      const nextMonth = (leftMonth.value + 1) % 12;
      const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
      return props2.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
    });
    const enableYearArrow = computed(() => {
      return props2.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
    });
    const isValidValue = (value2) => {
      return Array.isArray(value2) && value2[0] && value2[1] && value2[0].valueOf() <= value2[1].valueOf();
    };
    const rangeState = ref({
      endDate: null,
      selecting: false
    });
    const btnDisabled = computed(() => {
      return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidValue([minDate.value, maxDate.value]));
    });
    const handleChangeRange = (val) => {
      rangeState.value = val;
    };
    const onSelect = (selecting) => {
      rangeState.value.selecting = selecting;
      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };
    const showTime = computed(() => props2.type === "datetime" || props2.type === "datetimerange");
    const handleConfirm = (visible2 = false) => {
      if (isValidValue([minDate.value, maxDate.value])) {
        ctx2.emit("pick", [minDate.value, maxDate.value], visible2);
      }
    };
    const formatEmit = (emitDayjs, index2) => {
      if (!emitDayjs)
        return;
      if (defaultTime) {
        const defaultTimeD = dayjs(defaultTime[index2] || defaultTime).locale(lang.value);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      return emitDayjs;
    };
    const handleRangePick = (val, close2 = true) => {
      const min_ = val.minDate;
      const max_ = val.maxDate;
      const minDate_ = formatEmit(min_, 0);
      const maxDate_ = formatEmit(max_, 1);
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      ctx2.emit("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2 || showTime.value)
        return;
      handleConfirm();
    };
    const handleShortcutClick = (shortcut) => {
      const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      if (shortcutValues) {
        ctx2.emit("pick", [
          dayjs(shortcutValues[0]).locale(lang.value),
          dayjs(shortcutValues[1]).locale(lang.value)
        ]);
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick(ctx2);
      }
    };
    const minTimePickerVisible = ref(false);
    const maxTimePickerVisible = ref(false);
    const handleMinTimeClose = () => {
      minTimePickerVisible.value = false;
    };
    const handleMaxTimeClose = () => {
      maxTimePickerVisible.value = false;
    };
    const handleDateInput = (value2, type2) => {
      dateUserInput.value[type2] = value2;
      const parsedValueD = dayjs(value2, dateFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (disabledDate && disabledDate(parsedValueD.toDate())) {
          return;
        }
        if (type2 === "min") {
          leftDate.value = parsedValueD;
          minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props2.unlinkPanels) {
            rightDate.value = parsedValueD.add(1, "month");
            maxDate.value = minDate.value.add(1, "month");
          }
        } else {
          rightDate.value = parsedValueD;
          maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props2.unlinkPanels) {
            leftDate.value = parsedValueD.subtract(1, "month");
            minDate.value = maxDate.value.subtract(1, "month");
          }
        }
      }
    };
    const handleDateChange = (_, type2) => {
      dateUserInput.value[type2] = null;
    };
    const handleTimeInput = (value2, type2) => {
      timeUserInput.value[type2] = value2;
      const parsedValueD = dayjs(value2, timeFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (type2 === "min") {
          minTimePickerVisible.value = true;
          minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
            maxDate.value = minDate.value;
          }
        } else {
          maxTimePickerVisible.value = true;
          maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          rightDate.value = maxDate.value;
          if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
            minDate.value = maxDate.value;
          }
        }
      }
    };
    const handleTimeChange = (value2, type2) => {
      timeUserInput.value[type2] = null;
      if (type2 === "min") {
        leftDate.value = minDate.value;
        minTimePickerVisible.value = false;
      } else {
        rightDate.value = maxDate.value;
        maxTimePickerVisible.value = false;
      }
    };
    const handleMinTimePick = (value2, visible2, first) => {
      if (timeUserInput.value.min)
        return;
      if (value2) {
        leftDate.value = value2;
        minDate.value = (minDate.value || leftDate.value).hour(value2.hour()).minute(value2.minute()).second(value2.second());
      }
      if (!first) {
        minTimePickerVisible.value = visible2;
      }
      if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
        maxDate.value = minDate.value;
        rightDate.value = value2;
      }
    };
    const handleMaxTimePick = (value2, visible2, first) => {
      if (timeUserInput.value.max)
        return;
      if (value2) {
        rightDate.value = value2;
        maxDate.value = (maxDate.value || rightDate.value).hour(value2.hour()).minute(value2.minute()).second(value2.second());
      }
      if (!first) {
        maxTimePickerVisible.value = visible2;
      }
      if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
        minDate.value = maxDate.value;
      }
    };
    const handleClear = () => {
      leftDate.value = getDefaultValue()[0];
      rightDate.value = leftDate.value.add(1, "month");
      ctx2.emit("pick", null);
    };
    const formatToString = (value2) => {
      return Array.isArray(value2) ? value2.map((_) => _.format(format2)) : value2.format(format2);
    };
    const parseUserInput = (value2) => {
      return Array.isArray(value2) ? value2.map((_) => dayjs(_, format2).locale(lang.value)) : dayjs(value2, format2).locale(lang.value);
    };
    const getDefaultValue = () => {
      let start2;
      if (Array.isArray(defaultValue2)) {
        const left2 = dayjs(defaultValue2[0]);
        let right2 = dayjs(defaultValue2[1]);
        if (!props2.unlinkPanels) {
          right2 = left2.add(1, "month");
        }
        return [left2, right2];
      } else if (defaultValue2) {
        start2 = dayjs(defaultValue2);
      } else {
        start2 = dayjs();
      }
      start2 = start2.locale(lang.value);
      return [start2, start2.add(1, "month")];
    };
    ctx2.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx2.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx2.emit("set-picker-option", ["formatToString", formatToString]);
    ctx2.emit("set-picker-option", ["handleClear", handleClear]);
    const pickerBase = inject("EP_PICKER_BASE");
    const {
      shortcuts,
      disabledDate,
      cellClassName,
      format: format2,
      defaultTime,
      defaultValue: defaultValue2,
      arrowControl,
      clearable
    } = pickerBase.props;
    watch(() => props2.parsedValue, (newVal) => {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;
        if (props2.unlinkPanels && maxDate.value) {
          const minDateYear = minDate.value.year();
          const minDateMonth = minDate.value.month();
          const maxDateYear = maxDate.value.year();
          const maxDateMonth = maxDate.value.month();
          rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate.value.add(1, "month") : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, "month");
          if (maxDate.value) {
            rightDate.value = rightDate.value.hour(maxDate.value.hour()).minute(maxDate.value.minute()).second(maxDate.value.second());
          }
        }
      } else {
        const defaultArr = getDefaultValue();
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, { immediate: true });
    return {
      shortcuts,
      disabledDate,
      cellClassName,
      minTimePickerVisible,
      maxTimePickerVisible,
      handleMinTimeClose,
      handleMaxTimeClose,
      handleShortcutClick,
      rangeState,
      minDate,
      maxDate,
      handleRangePick,
      onSelect,
      handleChangeRange,
      btnDisabled,
      enableYearArrow,
      enableMonthArrow,
      rightPrevMonth,
      rightPrevYear,
      rightNextMonth,
      rightNextYear,
      leftPrevMonth,
      leftPrevYear,
      leftNextMonth,
      leftNextYear,
      hasShortcuts,
      leftLabel,
      rightLabel,
      leftDate,
      rightDate,
      showTime,
      t,
      minVisibleDate,
      maxVisibleDate,
      minVisibleTime,
      maxVisibleTime,
      arrowControl,
      handleDateInput,
      handleDateChange,
      handleTimeInput,
      handleTimeChange,
      handleMinTimePick,
      handleMaxTimePick,
      handleClear,
      handleConfirm,
      timeFormat,
      clearable
    };
  }
});
const _hoisted_1$4$3 = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$2$3 = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$2$3 = ["onClick"];
const _hoisted_4$2$1 = { class: "el-picker-panel__body" };
const _hoisted_5$2$1 = {
  key: 0,
  class: "el-date-range-picker__time-header"
};
const _hoisted_6$2$1 = { class: "el-date-range-picker__editors-wrap" };
const _hoisted_7$2$1 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_8$2$1 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_9$2$1 = /* @__PURE__ */ createElementVNode("span", { class: "el-icon-arrow-right" }, null, -1);
const _hoisted_10$2$1 = { class: "el-date-range-picker__editors-wrap is-right" };
const _hoisted_11$2$1 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_12$2$1 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_13$1$1 = { class: "el-picker-panel__content el-date-range-picker__content is-left" };
const _hoisted_14$6 = { class: "el-date-range-picker__header" };
const _hoisted_15$5 = ["disabled"];
const _hoisted_16$5 = ["disabled"];
const _hoisted_17$5 = { class: "el-picker-panel__content el-date-range-picker__content is-right" };
const _hoisted_18$5 = { class: "el-date-range-picker__header" };
const _hoisted_19$5 = ["disabled"];
const _hoisted_20$5 = ["disabled"];
const _hoisted_21$5 = {
  key: 0,
  class: "el-picker-panel__footer"
};
function render$4$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_time_pick_panel = resolveComponent("time-pick-panel");
  const _component_date_table = resolveComponent("date-table");
  const _component_el_button = resolveComponent("el-button");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-picker-panel el-date-range-picker", [{
      "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
      "has-time": _ctx.showTime
    }]])
  }, [
    createElementVNode("div", _hoisted_1$4$3, [
      renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (openBlock(), createElementBlock("div", _hoisted_2$2$3, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (shortcut, key) => {
          return openBlock(), createElementBlock("button", {
            key,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, toDisplayString(shortcut.text), 9, _hoisted_3$2$3);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_4$2$1, [
        _ctx.showTime ? (openBlock(), createElementBlock("div", _hoisted_5$2$1, [
          createElementVNode("span", _hoisted_6$2$1, [
            createElementVNode("span", _hoisted_7$2$1, [
              createVNode(_component_el_input, {
                size: "small",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.startDate"),
                class: "el-date-range-picker__editor",
                "model-value": _ctx.minVisibleDate,
                onInput: _cache[0] || (_cache[0] = (val) => _ctx.handleDateInput(val, "min")),
                onChange: _cache[1] || (_cache[1] = (val) => _ctx.handleDateChange(val, "min"))
              }, null, 8, ["disabled", "placeholder", "model-value"])
            ]),
            withDirectives(createElementVNode("span", _hoisted_8$2$1, [
              createVNode(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.startTime"),
                "model-value": _ctx.minVisibleTime,
                onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.minTimePickerVisible = true),
                onInput: _cache[3] || (_cache[3] = (val) => _ctx.handleTimeInput(val, "min")),
                onChange: _cache[4] || (_cache[4] = (val) => _ctx.handleTimeChange(val, "min"))
              }, null, 8, ["disabled", "placeholder", "model-value"]),
              createVNode(_component_time_pick_panel, {
                visible: _ctx.minTimePickerVisible,
                format: _ctx.timeFormat,
                "datetime-role": "start",
                "time-arrow-control": _ctx.arrowControl,
                "parsed-value": _ctx.leftDate,
                onPick: _ctx.handleMinTimePick
              }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
            ], 512), [
              [_directive_clickoutside, _ctx.handleMinTimeClose]
            ])
          ]),
          _hoisted_9$2$1,
          createElementVNode("span", _hoisted_10$2$1, [
            createElementVNode("span", _hoisted_11$2$1, [
              createVNode(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.endDate"),
                "model-value": _ctx.maxVisibleDate,
                readonly: !_ctx.minDate,
                onInput: _cache[5] || (_cache[5] = (val) => _ctx.handleDateInput(val, "max")),
                onChange: _cache[6] || (_cache[6] = (val) => _ctx.handleDateChange(val, "max"))
              }, null, 8, ["disabled", "placeholder", "model-value", "readonly"])
            ]),
            withDirectives(createElementVNode("span", _hoisted_12$2$1, [
              createVNode(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.endTime"),
                "model-value": _ctx.maxVisibleTime,
                readonly: !_ctx.minDate,
                onFocus: _cache[7] || (_cache[7] = ($event) => _ctx.minDate && (_ctx.maxTimePickerVisible = true)),
                onInput: _cache[8] || (_cache[8] = (val) => _ctx.handleTimeInput(val, "max")),
                onChange: _cache[9] || (_cache[9] = (val) => _ctx.handleTimeChange(val, "max"))
              }, null, 8, ["disabled", "placeholder", "model-value", "readonly"]),
              createVNode(_component_time_pick_panel, {
                "datetime-role": "end",
                visible: _ctx.maxTimePickerVisible,
                format: _ctx.timeFormat,
                "time-arrow-control": _ctx.arrowControl,
                "parsed-value": _ctx.rightDate,
                onPick: _ctx.handleMaxTimePick
              }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
            ], 512), [
              [_directive_clickoutside, _ctx.handleMaxTimeClose]
            ])
          ])
        ])) : createCommentVNode("v-if", true),
        createElementVNode("div", _hoisted_13$1$1, [
          createElementVNode("div", _hoisted_14$6, [
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-d-arrow-left",
              onClick: _cache[10] || (_cache[10] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
            }),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-arrow-left",
              onClick: _cache[11] || (_cache[11] = (...args) => _ctx.leftPrevMonth && _ctx.leftPrevMonth(...args))
            }),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn el-icon-d-arrow-right"]),
              onClick: _cache[12] || (_cache[12] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
            }, null, 10, _hoisted_15$5)) : createCommentVNode("v-if", true),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              disabled: !_ctx.enableMonthArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableMonthArrow }, "el-picker-panel__icon-btn el-icon-arrow-right"]),
              onClick: _cache[13] || (_cache[13] = (...args) => _ctx.leftNextMonth && _ctx.leftNextMonth(...args))
            }, null, 10, _hoisted_16$5)) : createCommentVNode("v-if", true),
            createElementVNode("div", null, toDisplayString(_ctx.leftLabel), 1)
          ]),
          createVNode(_component_date_table, {
            "selection-mode": "range",
            date: _ctx.leftDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            "cell-class-name": _ctx.cellClassName,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])
        ]),
        createElementVNode("div", _hoisted_17$5, [
          createElementVNode("div", _hoisted_18$5, [
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn el-icon-d-arrow-left"]),
              onClick: _cache[14] || (_cache[14] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
            }, null, 10, _hoisted_19$5)) : createCommentVNode("v-if", true),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              disabled: !_ctx.enableMonthArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableMonthArrow }, "el-picker-panel__icon-btn el-icon-arrow-left"]),
              onClick: _cache[15] || (_cache[15] = (...args) => _ctx.rightPrevMonth && _ctx.rightPrevMonth(...args))
            }, null, 10, _hoisted_20$5)) : createCommentVNode("v-if", true),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-d-arrow-right",
              onClick: _cache[16] || (_cache[16] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
            }),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-arrow-right",
              onClick: _cache[17] || (_cache[17] = (...args) => _ctx.rightNextMonth && _ctx.rightNextMonth(...args))
            }),
            createElementVNode("div", null, toDisplayString(_ctx.rightLabel), 1)
          ]),
          createVNode(_component_date_table, {
            "selection-mode": "range",
            date: _ctx.rightDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            "cell-class-name": _ctx.cellClassName,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])
        ])
      ])
    ]),
    _ctx.showTime ? (openBlock(), createElementBlock("div", _hoisted_21$5, [
      _ctx.clearable ? (openBlock(), createBlock(_component_el_button, {
        key: 0,
        size: "mini",
        type: "text",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.handleClear
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.clear")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])) : createCommentVNode("v-if", true),
      createVNode(_component_el_button, {
        plain: "",
        size: "mini",
        class: "el-picker-panel__link-btn",
        disabled: _ctx.btnDisabled,
        onClick: _cache[18] || (_cache[18] = ($event) => _ctx.handleConfirm(false))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ]),
        _: 1
      }, 8, ["disabled"])
    ])) : createCommentVNode("v-if", true)
  ], 2);
}
script$4$4.render = render$4$3;
script$4$4.__file = "packages/components/date-picker/src/date-picker-com/panel-date-range.vue";
var script$5$2 = defineComponent({
  components: { MonthTable: script$1$j },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    }
  },
  emits: ["pick", "set-picker-option"],
  setup(props2, ctx2) {
    const { t, lang } = useLocaleInject();
    const leftDate = ref(dayjs().locale(lang.value));
    const rightDate = ref(dayjs().locale(lang.value).add(1, "year"));
    const hasShortcuts = computed(() => !!shortcuts.length);
    const handleShortcutClick = (shortcut) => {
      const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      if (shortcutValues) {
        ctx2.emit("pick", [
          dayjs(shortcutValues[0]).locale(lang.value),
          dayjs(shortcutValues[1]).locale(lang.value)
        ]);
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick(ctx2);
      }
    };
    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");
      if (!props2.unlinkPanels) {
        rightDate.value = rightDate.value.subtract(1, "year");
      }
    };
    const rightNextYear = () => {
      if (!props2.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
      }
      rightDate.value = rightDate.value.add(1, "year");
    };
    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
    };
    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
    };
    const leftLabel = computed(() => {
      return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
    });
    const rightLabel = computed(() => {
      return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
    });
    const leftYear = computed(() => {
      return leftDate.value.year();
    });
    const rightYear = computed(() => {
      return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
    });
    const enableYearArrow = computed(() => {
      return props2.unlinkPanels && rightYear.value > leftYear.value + 1;
    });
    const minDate = ref(null);
    const maxDate = ref(null);
    const rangeState = ref({
      endDate: null,
      selecting: false
    });
    const handleChangeRange = (val) => {
      rangeState.value = val;
    };
    const handleRangePick = (val, close2 = true) => {
      const minDate_ = val.minDate;
      const maxDate_ = val.maxDate;
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2)
        return;
      handleConfirm();
    };
    const isValidValue = (value2) => {
      return Array.isArray(value2) && value2 && value2[0] && value2[1] && value2[0].valueOf() <= value2[1].valueOf();
    };
    const handleConfirm = (visible2 = false) => {
      if (isValidValue([minDate.value, maxDate.value])) {
        ctx2.emit("pick", [minDate.value, maxDate.value], visible2);
      }
    };
    const onSelect = (selecting) => {
      rangeState.value.selecting = selecting;
      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };
    const formatToString = (value2) => {
      return value2.map((_) => _.format(format2));
    };
    const getDefaultValue = () => {
      let start2;
      if (Array.isArray(defaultValue2)) {
        const left2 = dayjs(defaultValue2[0]);
        let right2 = dayjs(defaultValue2[1]);
        if (!props2.unlinkPanels) {
          right2 = left2.add(1, "year");
        }
        return [left2, right2];
      } else if (defaultValue2) {
        start2 = dayjs(defaultValue2);
      } else {
        start2 = dayjs();
      }
      start2 = start2.locale(lang.value);
      return [start2, start2.add(1, "year")];
    };
    ctx2.emit("set-picker-option", ["formatToString", formatToString]);
    const pickerBase = inject("EP_PICKER_BASE");
    const { shortcuts, disabledDate, format: format2, defaultValue: defaultValue2 } = pickerBase.props;
    watch(() => props2.parsedValue, (newVal) => {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;
        if (props2.unlinkPanels && maxDate.value) {
          const minDateYear = minDate.value.year();
          const maxDateYear = maxDate.value.year();
          rightDate.value = minDateYear === maxDateYear ? maxDate.value.add(1, "year") : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, "year");
        }
      } else {
        const defaultArr = getDefaultValue();
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, { immediate: true });
    return {
      shortcuts,
      disabledDate,
      onSelect,
      handleRangePick,
      rangeState,
      handleChangeRange,
      minDate,
      maxDate,
      enableYearArrow,
      leftLabel,
      rightLabel,
      leftNextYear,
      leftPrevYear,
      rightNextYear,
      rightPrevYear,
      t,
      leftDate,
      rightDate,
      hasShortcuts,
      handleShortcutClick
    };
  }
});
const _hoisted_1$5$2 = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$3$2 = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$3$2 = ["onClick"];
const _hoisted_4$3$1 = { class: "el-picker-panel__body" };
const _hoisted_5$3$1 = { class: "el-picker-panel__content el-date-range-picker__content is-left" };
const _hoisted_6$3$1 = { class: "el-date-range-picker__header" };
const _hoisted_7$3$1 = ["disabled"];
const _hoisted_8$3$1 = { class: "el-picker-panel__content el-date-range-picker__content is-right" };
const _hoisted_9$3$1 = { class: "el-date-range-picker__header" };
const _hoisted_10$3$1 = ["disabled"];
function render$5$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_month_table = resolveComponent("month-table");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-picker-panel el-date-range-picker", [{
      "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts
    }]])
  }, [
    createElementVNode("div", _hoisted_1$5$2, [
      renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (openBlock(), createElementBlock("div", _hoisted_2$3$2, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (shortcut, key) => {
          return openBlock(), createElementBlock("button", {
            key,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, toDisplayString(shortcut.text), 9, _hoisted_3$3$2);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_4$3$1, [
        createElementVNode("div", _hoisted_5$3$1, [
          createElementVNode("div", _hoisted_6$3$1, [
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-d-arrow-left",
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
            }),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn el-icon-d-arrow-right"]),
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
            }, null, 10, _hoisted_7$3$1)) : createCommentVNode("v-if", true),
            createElementVNode("div", null, toDisplayString(_ctx.leftLabel), 1)
          ]),
          createVNode(_component_month_table, {
            "selection-mode": "range",
            date: _ctx.leftDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])
        ]),
        createElementVNode("div", _hoisted_8$3$1, [
          createElementVNode("div", _hoisted_9$3$1, [
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn el-icon-d-arrow-left"]),
              onClick: _cache[2] || (_cache[2] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
            }, null, 10, _hoisted_10$3$1)) : createCommentVNode("v-if", true),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn el-icon-d-arrow-right",
              onClick: _cache[3] || (_cache[3] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
            }),
            createElementVNode("div", null, toDisplayString(_ctx.rightLabel), 1)
          ]),
          createVNode(_component_month_table, {
            "selection-mode": "range",
            date: _ctx.rightDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])
        ])
      ])
    ])
  ], 2);
}
script$5$2.render = render$5$2;
script$5$2.__file = "packages/components/date-picker/src/date-picker-com/panel-month-range.vue";
var __defProp$i = Object.defineProperty;
var __defProps$g = Object.defineProperties;
var __getOwnPropDescs$g = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$i = (obj, key, value2) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$i = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$i.call(b, prop))
      __defNormalProp$i(a, prop, b[prop]);
  if (__getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(b)) {
      if (__propIsEnum$i.call(b, prop))
        __defNormalProp$i(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$g = (a, b) => __defProps$g(a, __getOwnPropDescs$g(b));
dayjs.extend(localeData);
dayjs.extend(advancedFormat);
dayjs.extend(customParseFormat);
dayjs.extend(weekOfYear);
dayjs.extend(weekYear);
dayjs.extend(dayOfYear);
dayjs.extend(isSameOrAfter);
dayjs.extend(isSameOrBefore);
const getPanel = function(type2) {
  if (type2 === "daterange" || type2 === "datetimerange") {
    return script$4$4;
  } else if (type2 === "monthrange") {
    return script$5$2;
  }
  return script$3$7;
};
var DatePicker = defineComponent({
  name: "ElDatePicker",
  install: null,
  props: __spreadProps$g(__spreadValues$i({}, timePickerDefaultProps), {
    type: {
      type: String,
      default: "date"
    }
  }),
  emits: ["update:modelValue"],
  setup(props2, ctx2) {
    provide("ElPopperOptions", props2.popperOptions);
    const commonPicker = ref(null);
    const refProps = __spreadProps$g(__spreadValues$i({}, props2), {
      focus: () => {
        var _a;
        (_a = commonPicker.value) == null ? void 0 : _a.handleFocus();
      }
    });
    ctx2.expose(refProps);
    return () => {
      var _a;
      const format2 = (_a = props2.format) != null ? _a : DEFAULT_FORMATS_DATEPICKER[props2.type] || DEFAULT_FORMATS_DATE;
      return h(script$Q, __spreadProps$g(__spreadValues$i({}, props2), {
        format: format2,
        type: props2.type,
        ref: commonPicker,
        "onUpdate:modelValue": (value2) => ctx2.emit("update:modelValue", value2)
      }), {
        default: (scopedProps) => h(getPanel(props2.type), scopedProps)
      });
    };
  }
});
const _DatePicker = DatePicker;
_DatePicker.install = (app) => {
  app.component(_DatePicker.name, _DatePicker);
};
const ElDatePicker = _DatePicker;
const elDescriptionsKey = "elDescriptions";
var DescriptionsCell = defineComponent({
  name: "ElDescriptionsCell",
  props: {
    cell: {
      type: Object
    },
    tag: {
      type: String
    },
    type: {
      type: String
    }
  },
  setup() {
    const descriptions = inject(elDescriptionsKey, {});
    return {
      descriptions
    };
  },
  render() {
    var _a, _b, _c, _d, _e, _f;
    const item = getNormalizedProps(this.cell);
    const label = ((_c = (_b = (_a = this.cell) == null ? void 0 : _a.children) == null ? void 0 : _b.label) == null ? void 0 : _c.call(_b)) || item.label;
    const content = (_f = (_e = (_d = this.cell) == null ? void 0 : _d.children) == null ? void 0 : _e.default) == null ? void 0 : _f.call(_e);
    const span = item.span;
    const align = item.align ? `is-${item.align}` : "";
    const labelAlign = item.labelAlign ? `is-${item.labelAlign}` : align;
    const className = item.className;
    const labelClassName = item.labelClassName;
    const style = {
      width: addUnit(item.width),
      minWidth: addUnit(item.minWidth)
    };
    switch (this.type) {
      case "label":
        return h(this.tag, {
          style,
          class: ["el-descriptions__cell", "el-descriptions__label", { "is-bordered-label": this.descriptions.border }, labelAlign, labelClassName],
          colSpan: this.descriptions.direction === "vertical" ? span : 1
        }, label);
      case "content":
        return h(this.tag, {
          style,
          class: ["el-descriptions__cell", "el-descriptions__content", align, className],
          colSpan: this.descriptions.direction === "vertical" ? span : span * 2 - 1
        }, content);
      default:
        return h("td", {
          style,
          class: [align],
          colSpan: span
        }, [
          h("span", {
            class: ["el-descriptions__cell", "el-descriptions__label", labelClassName]
          }, label),
          h("span", {
            class: ["el-descriptions__cell", "el-descriptions__content", className]
          }, content)
        ]);
    }
  }
});
var script$B = defineComponent({
  name: "ElDescriptionsRow",
  components: {
    [DescriptionsCell.name]: DescriptionsCell
  },
  props: {
    row: {
      type: Array
    }
  },
  setup() {
    const descriptions = inject(elDescriptionsKey, {});
    return {
      descriptions
    };
  }
});
const _hoisted_1$V = { key: 1 };
function render$z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_descriptions_cell = resolveComponent("el-descriptions-cell");
  return _ctx.descriptions.direction === "vertical" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
    createElementVNode("tr", null, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, index2) => {
        return openBlock(), createBlock(_component_el_descriptions_cell, {
          key: `tr1-${index2}`,
          cell,
          tag: "th",
          type: "label"
        }, null, 8, ["cell"]);
      }), 128))
    ]),
    createElementVNode("tr", null, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, index2) => {
        return openBlock(), createBlock(_component_el_descriptions_cell, {
          key: `tr2-${index2}`,
          cell,
          tag: "td",
          type: "content"
        }, null, 8, ["cell"]);
      }), 128))
    ])
  ], 64)) : (openBlock(), createElementBlock("tr", _hoisted_1$V, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, index2) => {
      return openBlock(), createElementBlock(Fragment, {
        key: `tr3-${index2}`
      }, [
        _ctx.descriptions.border ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createVNode(_component_el_descriptions_cell, {
            cell,
            tag: "td",
            type: "label"
          }, null, 8, ["cell"]),
          createVNode(_component_el_descriptions_cell, {
            cell,
            tag: "td",
            type: "content"
          }, null, 8, ["cell"])
        ], 64)) : (openBlock(), createBlock(_component_el_descriptions_cell, {
          key: 1,
          cell,
          tag: "td",
          type: "both"
        }, null, 8, ["cell"]))
      ], 64);
    }), 128))
  ]));
}
script$B.render = render$z;
script$B.__file = "packages/components/descriptions/src/descriptions-row.vue";
var script$1$i = defineComponent({
  name: "ElDescriptions",
  components: {
    [script$B.name]: script$B
  },
  props: {
    border: {
      type: Boolean,
      default: false
    },
    column: {
      type: Number,
      default: 3
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    title: {
      type: String,
      default: ""
    },
    extra: {
      type: String,
      default: ""
    }
  },
  setup(props2, { slots }) {
    provide(elDescriptionsKey, props2);
    const $ELEMENT2 = useGlobalConfig();
    const descriptionsSize = computed(() => {
      return props2.size || $ELEMENT2.size;
    });
    const flattedChildren = (children) => {
      const temp = Array.isArray(children) ? children : [children];
      const res = [];
      temp.forEach((child) => {
        if (Array.isArray(child.children)) {
          res.push(...flattedChildren(child.children));
        } else {
          res.push(child);
        }
      });
      return res;
    };
    const filledNode = (node, span, count, isLast = false) => {
      if (!node.props) {
        node.props = {};
      }
      if (span > count) {
        node.props.span = count;
      }
      if (isLast) {
        node.props.span = span;
      }
      return node;
    };
    const getRows = () => {
      var _a;
      const children = flattedChildren((_a = slots.default) == null ? void 0 : _a.call(slots)).filter((node) => {
        var _a2;
        return ((_a2 = node == null ? void 0 : node.type) == null ? void 0 : _a2.name) === "ElDescriptionsItem";
      });
      const rows = [];
      let temp = [];
      let count = props2.column;
      let totalSpan = 0;
      children.forEach((node, index2) => {
        var _a2;
        let span = ((_a2 = node.props) == null ? void 0 : _a2.span) || 1;
        if (index2 < children.length - 1) {
          totalSpan += span > count ? count : span;
        }
        if (index2 === children.length - 1) {
          const lastSpan = props2.column - totalSpan % props2.column;
          temp.push(filledNode(node, lastSpan, count, true));
          rows.push(temp);
          return;
        }
        if (span < count) {
          count -= span;
          temp.push(node);
        } else {
          temp.push(filledNode(node, span, count));
          rows.push(temp);
          count = props2.column;
          temp = [];
        }
      });
      return rows;
    };
    return {
      descriptionsSize,
      getRows
    };
  }
});
const _hoisted_1$1$c = { class: "el-descriptions" };
const _hoisted_2$M = {
  key: 0,
  class: "el-descriptions__header"
};
const _hoisted_3$J = { class: "el-descriptions__title" };
const _hoisted_4$x = { class: "el-descriptions__extra" };
const _hoisted_5$r = { class: "el-descriptions__body" };
function render$1$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_descriptions_row = resolveComponent("el-descriptions-row");
  return openBlock(), createElementBlock("div", _hoisted_1$1$c, [
    _ctx.title || _ctx.extra || _ctx.$slots.title || _ctx.$slots.extra ? (openBlock(), createElementBlock("div", _hoisted_2$M, [
      createElementVNode("div", _hoisted_3$J, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ])
      ]),
      createElementVNode("div", _hoisted_4$x, [
        renderSlot(_ctx.$slots, "extra", {}, () => [
          createTextVNode(toDisplayString(_ctx.extra), 1)
        ])
      ])
    ])) : createCommentVNode("v-if", true),
    createElementVNode("div", _hoisted_5$r, [
      createElementVNode("table", {
        class: normalizeClass(["el-descriptions__table", { "is-bordered": _ctx.border }, _ctx.descriptionsSize ? `el-descriptions--${_ctx.descriptionsSize}` : ""])
      }, [
        createElementVNode("tbody", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getRows(), (row, index2) => {
            return openBlock(), createBlock(_component_el_descriptions_row, {
              key: index2,
              row
            }, null, 8, ["row"]);
          }), 128))
        ])
      ], 2)
    ])
  ]);
}
script$1$i.render = render$1$h;
script$1$i.__file = "packages/components/descriptions/src/workprogress.vue";
var DescriptionsItem = defineComponent({
  name: "ElDescriptionsItem",
  props: {
    label: {
      type: String,
      default: ""
    },
    span: {
      type: Number,
      default: 1
    },
    width: {
      type: [String, Number],
      default: ""
    },
    minWidth: {
      type: [String, Number],
      default: ""
    },
    align: {
      type: String,
      default: "left"
    },
    labelAlign: {
      type: String,
      default: ""
    },
    className: {
      type: String,
      default: ""
    },
    labelClassName: {
      type: String,
      default: ""
    }
  }
});
script$1$i.install = (app) => {
  app.component(script$1$i.name, script$1$i);
  app.component(ElDescriptionsItem.name, ElDescriptionsItem);
};
script$1$i.DescriptionsItem = DescriptionsItem;
const _Descriptions = script$1$i;
const ElDescriptions = _Descriptions;
const ElDescriptionsItem = DescriptionsItem;
var script$A = defineComponent({
  name: "ElOverlay",
  props: {
    mask: {
      type: Boolean,
      default: true
    },
    overlayClass: {
      type: [String, Array, Object]
    },
    zIndex: {
      type: Number
    }
  },
  emits: ["click"],
  setup(props2, { slots, emit: emit2 }) {
    let mousedownTarget = false;
    let mouseupTarget = false;
    const onMaskClick = (e) => {
      if (mousedownTarget && mouseupTarget) {
        emit2("click", e);
      }
      mousedownTarget = mouseupTarget = false;
    };
    return () => {
      return props2.mask ? createVNode("div", {
        class: ["el-overlay", props2.overlayClass],
        style: {
          zIndex: props2.zIndex
        },
        onClick: onMaskClick,
        onMousedown: (e) => {
          if (props2.mask) {
            mousedownTarget = e.target === e.currentTarget;
          }
        },
        onMouseup: (e) => {
          if (props2.mask) {
            mouseupTarget = e.target === e.currentTarget;
          }
        }
      }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h("div", {
        class: props2.overlayClass,
        style: {
          zIndex: props2.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px"
        }
      }, [renderSlot(slots, "default")]);
    };
  }
});
script$A.__file = "packages/components/overlay/src/workprogress.vue";
const CLOSE_EVENT$1 = "close";
const OPEN_EVENT = "open";
const CLOSED_EVENT = "closed";
const OPENED_EVENT = "opened";
const useDialogEmits = [
  CLOSE_EVENT$1,
  CLOSED_EVENT,
  OPEN_EVENT,
  OPENED_EVENT,
  UPDATE_MODEL_EVENT
];
const useDialogProps = {
  appendToBody: {
    type: Boolean,
    default: false
  },
  beforeClose: {
    type: Function
  },
  destroyOnClose: {
    type: Boolean,
    default: false
  },
  center: {
    type: Boolean,
    default: false
  },
  customClass: {
    type: String,
    default: ""
  },
  closeOnClickModal: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  fullscreen: {
    type: Boolean,
    default: false
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  modal: {
    type: Boolean,
    default: true
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String,
    default: "15vh"
  },
  modelValue: {
    type: Boolean,
    required: true
  },
  modalClass: String,
  width: {
    type: [String, Number],
    default: "50%",
    validator: isValidWidthUnit
  },
  zIndex: {
    type: Number
  }
};
function useDialog(props2, ctx2, targetRef) {
  const visible2 = ref(false);
  const closed = ref(false);
  const dialogRef = ref(null);
  const openTimer = ref(null);
  const closeTimer = ref(null);
  const rendered = ref(false);
  const zIndex2 = ref(props2.zIndex || PopupManager$1.nextZIndex());
  const modalRef = ref(null);
  const normalizeWidth = () => {
    if (isNumber$1(props2.width))
      return `${props2.width}px`;
    else
      return props2.width;
  };
  const style = computed(() => {
    const style2 = {};
    if (!props2.fullscreen) {
      style2.marginTop = props2.top;
      if (props2.width) {
        style2.width = normalizeWidth();
      }
    }
    return style2;
  });
  function afterEnter() {
    ctx2.emit(OPENED_EVENT);
  }
  function afterLeave() {
    ctx2.emit(CLOSED_EVENT);
    ctx2.emit(UPDATE_MODEL_EVENT, false);
    if (props2.destroyOnClose) {
      rendered.value = false;
    }
  }
  function beforeLeave() {
    ctx2.emit(CLOSE_EVENT$1);
  }
  function open() {
    clearTimer(closeTimer);
    clearTimer(openTimer);
    if (props2.openDelay && props2.openDelay > 0) {
      openTimer.value = window.setTimeout(() => {
        openTimer.value = null;
        doOpen();
      }, props2.openDelay);
    } else {
      doOpen();
    }
  }
  function close2() {
    clearTimer(openTimer);
    clearTimer(closeTimer);
    if (props2.closeDelay && props2.closeDelay > 0) {
      closeTimer.value = window.setTimeout(() => {
        closeTimer.value = null;
        doClose();
      }, props2.closeDelay);
    } else {
      doClose();
    }
  }
  function hide2(shouldCancel) {
    if (shouldCancel)
      return;
    closed.value = true;
    visible2.value = false;
  }
  function handleClose() {
    if (props2.beforeClose) {
      props2.beforeClose(hide2);
    } else {
      close2();
    }
  }
  function onModalClick2() {
    if (props2.closeOnClickModal) {
      handleClose();
    }
  }
  function doOpen() {
    if (isServer) {
      return;
    }
    visible2.value = true;
  }
  function doClose() {
    visible2.value = false;
  }
  if (props2.lockScroll) {
    useLockScreen(visible2);
  }
  if (props2.closeOnPressEscape) {
    useModal({
      handleClose
    }, visible2);
  }
  useRestoreActive(visible2);
  watch(() => props2.modelValue, (val) => {
    if (val) {
      closed.value = false;
      open();
      rendered.value = true;
      ctx2.emit(OPEN_EVENT);
      zIndex2.value = props2.zIndex ? zIndex2.value++ : PopupManager$1.nextZIndex();
      nextTick(() => {
        if (targetRef.value) {
          targetRef.value.scrollTop = 0;
        }
      });
    } else {
      if (visible2.value) {
        close2();
      }
    }
  });
  onMounted(() => {
    if (props2.modelValue) {
      visible2.value = true;
      rendered.value = true;
      open();
    }
  });
  return {
    afterEnter,
    afterLeave,
    beforeLeave,
    handleClose,
    onModalClick: onModalClick2,
    closed,
    dialogRef,
    style,
    rendered,
    modalRef,
    visible: visible2,
    zIndex: zIndex2
  };
}
var __defProp$h = Object.defineProperty;
var __defProps$f = Object.defineProperties;
var __getOwnPropDescs$f = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key, value2) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$h = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$h.call(b, prop))
      __defNormalProp$h(a, prop, b[prop]);
  if (__getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(b)) {
      if (__propIsEnum$h.call(b, prop))
        __defNormalProp$h(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$f = (a, b) => __defProps$f(a, __getOwnPropDescs$f(b));
var script$z = defineComponent({
  name: "ElDialog",
  components: {
    "el-overlay": script$A
  },
  directives: {
    TrapFocus: TrapFocus$1
  },
  props: useDialogProps,
  emits: useDialogEmits,
  setup(props2, ctx2) {
    const dialogRef = ref(null);
    return __spreadProps$f(__spreadValues$h({}, useDialog(props2, ctx2, dialogRef)), {
      dialogRef
    });
  }
});
const _hoisted_1$U = ["aria-label"];
const _hoisted_2$L = { class: "el-dialog__header" };
const _hoisted_3$I = { class: "el-dialog__title" };
const _hoisted_4$w = /* @__PURE__ */ createElementVNode("i", { class: "el-dialog__close el-icon el-icon-close" }, null, -1);
const _hoisted_5$q = [
  _hoisted_4$w
];
const _hoisted_6$n = {
  key: 0,
  class: "el-dialog__body"
};
const _hoisted_7$i = {
  key: 1,
  class: "el-dialog__footer"
};
function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_overlay = resolveComponent("el-overlay");
  const _directive_trap_focus = resolveDirective("trap-focus");
  return openBlock(), createBlock(Teleport, {
    to: "body",
    disabled: !_ctx.appendToBody
  }, [
    createVNode(Transition, {
      name: "dialog-fade",
      onAfterEnter: _ctx.afterEnter,
      onAfterLeave: _ctx.afterLeave,
      onBeforeLeave: _ctx.beforeLeave
    }, {
      default: withCtx(() => [
        withDirectives(createVNode(_component_el_overlay, {
          mask: _ctx.modal,
          "overlay-class": _ctx.modalClass,
          "z-index": _ctx.zIndex,
          onClick: _ctx.onModalClick
        }, {
          default: withCtx(() => [
            withDirectives(createElementVNode("div", {
              ref: "dialogRef",
              class: normalizeClass([
                "el-dialog",
                {
                  "is-fullscreen": _ctx.fullscreen,
                  "el-dialog--center": _ctx.center
                },
                _ctx.customClass
              ]),
              "aria-modal": "true",
              role: "dialog",
              "aria-label": _ctx.title || "dialog",
              style: normalizeStyle(_ctx.style),
              onClick: _cache[1] || (_cache[1] = withModifiers(() => {
              }, ["stop"]))
            }, [
              createElementVNode("div", _hoisted_2$L, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createElementVNode("span", _hoisted_3$I, toDisplayString(_ctx.title), 1)
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": "close",
                  class: "el-dialog__headerbtn",
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
                }, _hoisted_5$q)) : createCommentVNode("v-if", true)
              ]),
              _ctx.rendered ? (openBlock(), createElementBlock("div", _hoisted_6$n, [
                renderSlot(_ctx.$slots, "default")
              ])) : createCommentVNode("v-if", true),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_7$i, [
                renderSlot(_ctx.$slots, "footer")
              ])) : createCommentVNode("v-if", true)
            ], 14, _hoisted_1$U), [
              [_directive_trap_focus]
            ])
          ]),
          _: 3
        }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
          [vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
  ], 8, ["disabled"]);
}
script$z.render = render$y;
script$z.__file = "packages/components/dialog/src/workprogress.vue";
script$z.install = (app) => {
  app.component(script$z.name, script$z);
};
const _Dialog = script$z;
const ElDialog = _Dialog;
var script$y = defineComponent({
  name: "ElDivider",
  props: {
    direction: {
      type: String,
      default: "horizontal",
      validator(val) {
        return ["horizontal", "vertical"].indexOf(val) !== -1;
      }
    },
    contentPosition: {
      type: String,
      default: "center",
      validator(val) {
        return ["left", "center", "right"].indexOf(val) !== -1;
      }
    }
  }
});
function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-divider", `el-divider--${_ctx.direction}`])
  }, [
    _ctx.$slots.default && _ctx.direction !== "vertical" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["el-divider__text", `is-${_ctx.contentPosition}`])
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
script$y.render = render$x;
script$y.__file = "packages/components/divider/src/workprogress.vue";
script$y.install = (app) => {
  app.component(script$y.name, script$y);
};
const _Divider = script$y;
const ElDivider = _Divider;
var __defProp$g = Object.defineProperty;
var __defProps$e = Object.defineProperties;
var __getOwnPropDescs$e = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key, value2) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$g = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$g.call(b, prop))
      __defNormalProp$g(a, prop, b[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b)) {
      if (__propIsEnum$g.call(b, prop))
        __defNormalProp$g(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$e = (a, b) => __defProps$e(a, __getOwnPropDescs$e(b));
var script$x = defineComponent({
  name: "ElDrawer",
  components: {
    [script$A.name]: script$A
  },
  directives: {
    TrapFocus: TrapFocus$1
  },
  props: __spreadProps$e(__spreadValues$g({}, useDialogProps), {
    direction: {
      type: String,
      default: "rtl",
      validator: (val) => {
        return ["ltr", "rtl", "ttb", "btt"].indexOf(val) !== -1;
      }
    },
    size: {
      type: [String, Number],
      default: "30%"
    },
    withHeader: {
      type: Boolean,
      default: true
    },
    modalFade: {
      type: Boolean,
      default: true
    }
  }),
  emits: useDialogEmits,
  setup(props2, ctx2) {
    const drawerRef = ref(null);
    return __spreadProps$e(__spreadValues$g({}, useDialog(props2, ctx2, drawerRef)), {
      drawerRef,
      isHorizontal: computed(() => props2.direction === "rtl" || props2.direction === "ltr"),
      drawerSize: computed(() => typeof props2.size === "number" ? `${props2.size}px` : props2.size)
    });
  }
});
const _hoisted_1$T = ["aria-label"];
const _hoisted_2$K = {
  key: 0,
  id: "el-drawer__title",
  class: "el-drawer__header"
};
const _hoisted_3$H = ["title"];
const _hoisted_4$v = ["aria-label"];
const _hoisted_5$p = /* @__PURE__ */ createElementVNode("i", { class: "el-drawer__close el-icon el-icon-close" }, null, -1);
const _hoisted_6$m = [
  _hoisted_5$p
];
const _hoisted_7$h = {
  key: 1,
  class: "el-drawer__body"
};
function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_overlay = resolveComponent("el-overlay");
  const _directive_trap_focus = resolveDirective("trap-focus");
  return openBlock(), createBlock(Teleport, {
    to: "body",
    disabled: !_ctx.appendToBody
  }, [
    createVNode(Transition, {
      name: "el-drawer-fade",
      onAfterEnter: _ctx.afterEnter,
      onAfterLeave: _ctx.afterLeave,
      onBeforeLeave: _ctx.beforeLeave
    }, {
      default: withCtx(() => [
        withDirectives(createVNode(_component_el_overlay, {
          mask: _ctx.modal,
          "overlay-class": _ctx.modalClass,
          "z-index": _ctx.zIndex,
          onClick: _ctx.onModalClick
        }, {
          default: withCtx(() => [
            withDirectives(createElementVNode("div", {
              ref: "drawerRef",
              "aria-modal": "true",
              "aria-labelledby": "el-drawer__title",
              "aria-label": _ctx.title,
              class: normalizeClass(["el-drawer", _ctx.direction, _ctx.customClass]),
              style: normalizeStyle(_ctx.isHorizontal ? "width: " + _ctx.drawerSize : "height: " + _ctx.drawerSize),
              role: "dialog",
              onClick: _cache[1] || (_cache[1] = withModifiers(() => {
              }, ["stop"]))
            }, [
              _ctx.withHeader ? (openBlock(), createElementBlock("header", _hoisted_2$K, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createElementVNode("span", {
                    role: "heading",
                    title: _ctx.title
                  }, toDisplayString(_ctx.title), 9, _hoisted_3$H)
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": "close " + (_ctx.title || "drawer"),
                  class: "el-drawer__close-btn",
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
                }, _hoisted_6$m, 8, _hoisted_4$v)) : createCommentVNode("v-if", true)
              ])) : createCommentVNode("v-if", true),
              _ctx.rendered ? (openBlock(), createElementBlock("section", _hoisted_7$h, [
                renderSlot(_ctx.$slots, "default")
              ])) : createCommentVNode("v-if", true)
            ], 14, _hoisted_1$T), [
              [_directive_trap_focus]
            ])
          ]),
          _: 3
        }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
          [vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
  ], 8, ["disabled"]);
}
script$x.render = render$w;
script$x.__file = "packages/components/drawer/src/workprogress.vue";
script$x.install = (app) => {
  app.component(script$x.name, script$x);
};
const _Drawer = script$x;
const ElDrawer = _Drawer;
const useDropdown = () => {
  const ELEMENT = useGlobalConfig();
  const elDropdown = inject("elDropdown", {});
  const _elDropdownSize = computed(() => elDropdown == null ? void 0 : elDropdown.dropdownSize);
  return {
    ELEMENT,
    elDropdown,
    _elDropdownSize
  };
};
const initDropdownDomEvent = (dropdownChildren, triggerElm, _instance) => {
  const menuItems = ref(null);
  const menuItemsArray = ref(null);
  const dropdownElm = ref(null);
  const listId = ref(`dropdown-menu-${generateId()}`);
  dropdownElm.value = dropdownChildren == null ? void 0 : dropdownChildren.subTree.el;
  function removeTabindex() {
    var _a;
    triggerElm.setAttribute("tabindex", "-1");
    (_a = menuItemsArray.value) == null ? void 0 : _a.forEach((item) => {
      item.setAttribute("tabindex", "-1");
    });
  }
  function resetTabindex(ele) {
    removeTabindex();
    ele == null ? void 0 : ele.setAttribute("tabindex", "0");
  }
  function handleTriggerKeyDown(ev) {
    const code = ev.code;
    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {
      removeTabindex();
      resetTabindex(menuItems.value[0]);
      menuItems.value[0].focus();
      ev.preventDefault();
      ev.stopPropagation();
    } else if (code === EVENT_CODE.enter) {
      _instance.handleClick();
    } else if ([EVENT_CODE.tab, EVENT_CODE.esc].includes(code)) {
      _instance.hide();
    }
  }
  function handleItemKeyDown(ev) {
    const code = ev.code;
    const target = ev.target;
    const currentIndex = menuItemsArray.value.indexOf(target);
    const max2 = menuItemsArray.value.length - 1;
    let nextIndex;
    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {
      if (code === EVENT_CODE.up) {
        nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
      } else {
        nextIndex = currentIndex < max2 ? currentIndex + 1 : max2;
      }
      removeTabindex();
      resetTabindex(menuItems.value[nextIndex]);
      menuItems.value[nextIndex].focus();
      ev.preventDefault();
      ev.stopPropagation();
    } else if (code === EVENT_CODE.enter) {
      triggerElmFocus();
      target.click();
      if (_instance.props.hideOnClick) {
        _instance.hide();
      }
    } else if ([EVENT_CODE.tab, EVENT_CODE.esc].includes(code)) {
      _instance.hide();
      triggerElmFocus();
    }
  }
  function initAria() {
    dropdownElm.value.setAttribute("id", listId.value);
    triggerElm.setAttribute("aria-haspopup", "list");
    triggerElm.setAttribute("aria-controls", listId.value);
    if (!_instance.props.splitButton) {
      triggerElm.setAttribute("role", "button");
      triggerElm.setAttribute("tabindex", _instance.props.tabindex);
      addClass$1(triggerElm, "el-dropdown-selfdefine");
    }
  }
  function initEvent() {
    on$2(triggerElm, "keydown", handleTriggerKeyDown);
    on$2(dropdownElm.value, "keydown", handleItemKeyDown, true);
  }
  function initDomOperation() {
    menuItems.value = dropdownElm.value.querySelectorAll("[tabindex='-1']");
    menuItemsArray.value = [].slice.call(menuItems.value);
    initEvent();
    initAria();
  }
  function triggerElmFocus() {
    triggerElm.focus();
  }
  initDomOperation();
};
const { ButtonGroup: ElButtonGroup } = _Button;
var script$w = defineComponent({
  name: "ElDropdown",
  components: {
    ElButton: _Button,
    ElButtonGroup,
    ElScrollbar: _Scrollbar,
    ElPopper: ElPopper$1
  },
  props: {
    trigger: {
      type: String,
      default: "hover"
    },
    type: String,
    size: {
      type: String,
      default: ""
    },
    splitButton: Boolean,
    hideOnClick: {
      type: Boolean,
      default: true
    },
    placement: {
      type: String,
      default: "bottom"
    },
    showTimeout: {
      type: Number,
      default: 150
    },
    hideTimeout: {
      type: Number,
      default: 150
    },
    tabindex: {
      type: [Number, String],
      default: 0
    },
    effect: {
      type: String,
      default: "light"
    },
    maxHeight: {
      type: [Number, String],
      default: ""
    }
  },
  emits: ["visible-change", "click", "command"],
  setup(props2, { emit: emit2 }) {
    const _instance = getCurrentInstance();
    const { ELEMENT } = useDropdown();
    const timeout = ref(null);
    const visible2 = ref(false);
    const scrollbar = ref(null);
    const wrapStyle = computed(() => `max-height: ${addUnit(props2.maxHeight)}`);
    watch(() => visible2.value, (val) => {
      if (val)
        triggerElmFocus();
      if (!val)
        triggerElmBlur();
      emit2("visible-change", val);
    });
    const focusing = ref(false);
    watch(() => focusing.value, (val) => {
      const selfDefine = triggerElm.value;
      if (selfDefine) {
        if (val) {
          addClass$1(selfDefine, "focusing");
        } else {
          removeClass(selfDefine, "focusing");
        }
      }
    });
    const triggerVnode = ref(null);
    const triggerElm = computed(() => {
      var _a, _b, _c, _d;
      const _ = (_c = (_b = (_a = triggerVnode.value) == null ? void 0 : _a.$refs.triggerRef) == null ? void 0 : _b.children[0]) != null ? _c : {};
      return !props2.splitButton ? _ : (_d = _.children) == null ? void 0 : _d[1];
    });
    function handleClick() {
      var _a;
      if ((_a = triggerElm.value) == null ? void 0 : _a.disabled)
        return;
      if (visible2.value) {
        hide2();
      } else {
        show();
      }
    }
    function show() {
      var _a;
      if ((_a = triggerElm.value) == null ? void 0 : _a.disabled)
        return;
      timeout.value && clearTimeout(timeout.value);
      timeout.value = window.setTimeout(() => {
        visible2.value = true;
      }, ["click", "contextmenu"].includes(props2.trigger) ? 0 : props2.showTimeout);
    }
    function hide2() {
      var _a;
      if ((_a = triggerElm.value) == null ? void 0 : _a.disabled)
        return;
      removeTabindex();
      if (props2.tabindex >= 0) {
        resetTabindex(triggerElm.value);
      }
      clearTimeout(timeout.value);
      timeout.value = window.setTimeout(() => {
        visible2.value = false;
      }, ["click", "contextmenu"].includes(props2.trigger) ? 0 : props2.hideTimeout);
    }
    function removeTabindex() {
      var _a;
      (_a = triggerElm.value) == null ? void 0 : _a.setAttribute("tabindex", "-1");
    }
    function resetTabindex(ele) {
      removeTabindex();
      ele == null ? void 0 : ele.setAttribute("tabindex", "0");
    }
    function triggerElmFocus() {
      var _a, _b;
      (_b = (_a = triggerElm.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    }
    function triggerElmBlur() {
      var _a, _b;
      (_b = (_a = triggerElm.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
    }
    const dropdownSize = computed(() => props2.size || ELEMENT.size);
    function commandHandler(...args) {
      emit2("command", ...args);
    }
    provide("elDropdown", {
      instance: _instance,
      dropdownSize,
      visible: visible2,
      handleClick,
      commandHandler,
      show,
      hide: hide2,
      trigger: computed(() => props2.trigger),
      hideOnClick: computed(() => props2.hideOnClick),
      triggerElm
    });
    onMounted(() => {
      if (!props2.splitButton) {
        on$2(triggerElm.value, "focus", () => {
          focusing.value = true;
        });
        on$2(triggerElm.value, "blur", () => {
          focusing.value = false;
        });
        on$2(triggerElm.value, "click", () => {
          focusing.value = false;
        });
      }
      if (props2.trigger === "hover") {
        on$2(triggerElm.value, "mouseenter", show);
        on$2(triggerElm.value, "mouseleave", hide2);
      } else if (props2.trigger === "click") {
        on$2(triggerElm.value, "click", handleClick);
      } else if (props2.trigger === "contextmenu") {
        on$2(triggerElm.value, "contextmenu", (e) => {
          e.preventDefault();
          handleClick();
        });
      }
      Object.assign(_instance, {
        handleClick,
        hide: hide2,
        resetTabindex
      });
    });
    const handlerMainButtonClick = (event2) => {
      emit2("click", event2);
      hide2();
    };
    return {
      visible: visible2,
      scrollbar,
      wrapStyle,
      dropdownSize,
      handlerMainButtonClick,
      triggerVnode
    };
  }
});
const _hoisted_1$S = /* @__PURE__ */ createElementVNode("i", { class: "el-dropdown__icon el-icon-arrow-down" }, null, -1);
function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_button_group = resolveComponent("el-button-group");
  const _component_el_popper = resolveComponent("el-popper");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "triggerVnode",
    visible: _ctx.visible,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.visible = $event),
    placement: _ctx.placement,
    "fallback-placements": ["bottom", "top", "right", "left"],
    effect: _ctx.effect,
    pure: "",
    "manual-mode": true,
    trigger: [_ctx.trigger],
    "popper-class": "el-dropdown__popper",
    "append-to-body": "",
    transition: "el-zoom-in-top",
    "stop-popper-mouse-event": false,
    "gpu-acceleration": false
  }, {
    default: withCtx(() => [
      createVNode(_component_el_scrollbar, {
        ref: "scrollbar",
        tag: "ul",
        "wrap-style": _ctx.wrapStyle,
        "view-class": "el-dropdown__list"
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "dropdown")
        ]),
        _: 3
      }, 8, ["wrap-style"])
    ]),
    trigger: withCtx(() => [
      createElementVNode("div", {
        class: normalizeClass(["el-dropdown", _ctx.dropdownSize ? "el-dropdown--" + _ctx.dropdownSize : ""])
      }, [
        !_ctx.splitButton ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createBlock(_component_el_button_group, { key: 1 }, {
          default: withCtx(() => [
            createVNode(_component_el_button, {
              size: _ctx.dropdownSize,
              type: _ctx.type,
              onClick: _ctx.handlerMainButtonClick
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["size", "type", "onClick"]),
            createVNode(_component_el_button, {
              size: _ctx.dropdownSize,
              type: _ctx.type,
              class: "el-dropdown__caret-button"
            }, {
              default: withCtx(() => [
                _hoisted_1$S
              ]),
              _: 1
            }, 8, ["size", "type"])
          ]),
          _: 3
        }))
      ], 2)
    ]),
    _: 3
  }, 8, ["visible", "placement", "effect", "trigger"]);
}
script$w.render = render$v;
script$w.__file = "packages/components/dropdown/src/dropdown.vue";
var script$1$h = defineComponent({
  name: "ElDropdownItem",
  props: {
    command: {
      type: [Object, String, Number],
      default: () => ({})
    },
    disabled: Boolean,
    divided: Boolean,
    icon: String
  },
  setup(props2) {
    const { elDropdown } = useDropdown();
    const _instance = getCurrentInstance();
    function handleClick(e) {
      var _a, _b;
      if (props2.disabled) {
        e.stopImmediatePropagation();
        return;
      }
      if (elDropdown.hideOnClick.value) {
        (_a = elDropdown.handleClick) == null ? void 0 : _a.call(elDropdown);
      }
      (_b = elDropdown.commandHandler) == null ? void 0 : _b.call(elDropdown, props2.command, _instance, e);
    }
    return {
      handleClick
    };
  }
});
const _hoisted_1$1$b = ["aria-disabled", "tabindex"];
function render$1$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["el-dropdown-menu__item", {
      "is-disabled": _ctx.disabled,
      "el-dropdown-menu__item--divided": _ctx.divided
    }]),
    "aria-disabled": _ctx.disabled,
    tabindex: _ctx.disabled ? null : -1,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.icon ? (openBlock(), createElementBlock("i", {
      key: 0,
      class: normalizeClass(_ctx.icon)
    }, null, 2)) : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_1$1$b);
}
script$1$h.render = render$1$g;
script$1$h.__file = "packages/components/dropdown/src/dropdown-item.vue";
var script$2$b = defineComponent({
  name: "ElDropdownMenu",
  directives: {
    ClickOutside: ClickOutside$1
  },
  setup() {
    const { _elDropdownSize, elDropdown } = useDropdown();
    const size = _elDropdownSize.value;
    function show() {
      var _a;
      if (["click", "contextmenu"].includes(elDropdown.trigger.value))
        return;
      (_a = elDropdown.show) == null ? void 0 : _a.call(elDropdown);
    }
    function hide2() {
      if (["click", "contextmenu"].includes(elDropdown.trigger.value))
        return;
      _hide();
    }
    function _hide() {
      var _a;
      (_a = elDropdown.hide) == null ? void 0 : _a.call(elDropdown);
    }
    onMounted(() => {
      const dropdownMenu = getCurrentInstance();
      initDropdownDomEvent(dropdownMenu, elDropdown.triggerElm.value, elDropdown.instance);
    });
    return {
      size,
      show,
      hide: hide2,
      innerHide: _hide,
      triggerElm: elDropdown.triggerElm
    };
  }
});
function render$2$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_clickOutside = resolveDirective("clickOutside");
  return withDirectives((openBlock(), createElementBlock("ul", {
    class: normalizeClass([[_ctx.size && `el-dropdown-menu--${_ctx.size}`], "el-dropdown-menu"]),
    onMouseenter: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.show && _ctx.show(...args), ["stop"])),
    onMouseleave: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.hide && _ctx.hide(...args), ["stop"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34)), [
    [_directive_clickOutside, _ctx.innerHide, _ctx.triggerElm]
  ]);
}
script$2$b.render = render$2$8;
script$2$b.__file = "packages/components/dropdown/src/dropdown-menu.vue";
script$w.install = (app) => {
  app.component(script$w.name, script$w);
  app.component(script$1$h.name, script$1$h);
  app.component(script$2$b.name, script$2$b);
};
script$w.DropdownItem = script$1$h;
script$w.DropdownMenu = script$2$b;
const _Dropdown = script$w;
const ElDropdown = _Dropdown;
let id = 0;
var script$v = defineComponent({
  name: "ImgEmpty",
  setup() {
    return {
      id: ++id
    };
  }
});
const _hoisted_1$R = {
  viewBox: "0 0 79 86",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2$J = ["id"];
const _hoisted_3$G = /* @__PURE__ */ createElementVNode("stop", {
  "stop-color": "#FCFCFD",
  offset: "0%"
}, null, -1);
const _hoisted_4$u = /* @__PURE__ */ createElementVNode("stop", {
  "stop-color": "#EEEFF3",
  offset: "100%"
}, null, -1);
const _hoisted_5$o = [
  _hoisted_3$G,
  _hoisted_4$u
];
const _hoisted_6$l = ["id"];
const _hoisted_7$g = /* @__PURE__ */ createElementVNode("stop", {
  "stop-color": "#FCFCFD",
  offset: "0%"
}, null, -1);
const _hoisted_8$e = /* @__PURE__ */ createElementVNode("stop", {
  "stop-color": "#E9EBEF",
  offset: "100%"
}, null, -1);
const _hoisted_9$e = [
  _hoisted_7$g,
  _hoisted_8$e
];
const _hoisted_10$b = ["id"];
const _hoisted_11$9 = {
  id: "Illustrations",
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
};
const _hoisted_12$8 = {
  id: "B-type",
  transform: "translate(-1268.000000, -535.000000)"
};
const _hoisted_13$6 = {
  id: "Group-2",
  transform: "translate(1268.000000, 535.000000)"
};
const _hoisted_14$5 = /* @__PURE__ */ createElementVNode("path", {
  id: "Oval-Copy-2",
  d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
  fill: "#F7F8FC"
}, null, -1);
const _hoisted_15$4 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-14",
  fill: "#E5E7E9",
  transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
  points: "13 58 53 58 42 45 2 45"
}, null, -1);
const _hoisted_16$4 = {
  id: "Group-Copy",
  transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)"
};
const _hoisted_17$4 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-10",
  fill: "#E5E7E9",
  transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
  points: "2.84078316e-14 3 18 3 23 7 5 7"
}, null, -1);
const _hoisted_18$4 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-11",
  fill: "#EDEEF2",
  points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
}, null, -1);
const _hoisted_19$4 = ["fill"];
const _hoisted_20$4 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-13",
  fill: "#F8F9FB",
  transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
  points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
}, null, -1);
const _hoisted_21$4 = ["fill"];
const _hoisted_22$4 = {
  id: "Rectangle-Copy-17",
  transform: "translate(53.000000, 45.000000)"
};
const _hoisted_23$4 = ["id"];
const _hoisted_24$4 = ["xlink:href"];
const _hoisted_25$4 = ["xlink:href"];
const _hoisted_26$4 = ["mask"];
const _hoisted_27$4 = /* @__PURE__ */ createElementVNode("polygon", {
  id: "Rectangle-Copy-18",
  fill: "#F8F9FB",
  transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
  points: "62 45 79 45 70 58 53 58"
}, null, -1);
function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$R, [
    createElementVNode("defs", null, [
      createElementVNode("linearGradient", {
        id: `linearGradient-1-${_ctx.id}`,
        x1: "38.8503086%",
        y1: "0%",
        x2: "61.1496914%",
        y2: "100%"
      }, _hoisted_5$o, 8, _hoisted_2$J),
      createElementVNode("linearGradient", {
        id: `linearGradient-2-${_ctx.id}`,
        x1: "0%",
        y1: "9.5%",
        x2: "100%",
        y2: "90.5%"
      }, _hoisted_9$e, 8, _hoisted_6$l),
      createElementVNode("rect", {
        id: `path-3-${_ctx.id}`,
        x: "0",
        y: "0",
        width: "17",
        height: "36"
      }, null, 8, _hoisted_10$b)
    ]),
    createElementVNode("g", _hoisted_11$9, [
      createElementVNode("g", _hoisted_12$8, [
        createElementVNode("g", _hoisted_13$6, [
          _hoisted_14$5,
          _hoisted_15$4,
          createElementVNode("g", _hoisted_16$4, [
            _hoisted_17$4,
            _hoisted_18$4,
            createElementVNode("rect", {
              id: "Rectangle-Copy-12",
              fill: `url(#linearGradient-1-${_ctx.id})`,
              transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
              x: "38",
              y: "7",
              width: "17",
              height: "36"
            }, null, 8, _hoisted_19$4),
            _hoisted_20$4
          ]),
          createElementVNode("rect", {
            id: "Rectangle-Copy-15",
            fill: `url(#linearGradient-2-${_ctx.id})`,
            x: "13",
            y: "45",
            width: "40",
            height: "36"
          }, null, 8, _hoisted_21$4),
          createElementVNode("g", _hoisted_22$4, [
            createElementVNode("mask", {
              id: `mask-4-${_ctx.id}`,
              fill: "white"
            }, [
              createElementVNode("use", {
                "xlink:href": `#path-3-${_ctx.id}`
              }, null, 8, _hoisted_24$4)
            ], 8, _hoisted_23$4),
            createElementVNode("use", {
              id: "Mask",
              fill: "#E0E3E9",
              transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
              "xlink:href": `#path-3-${_ctx.id}`
            }, null, 8, _hoisted_25$4),
            createElementVNode("polygon", {
              id: "Rectangle-Copy",
              fill: "#D5D7DE",
              mask: `url(#mask-4-${_ctx.id})`,
              transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
              points: "7 0 24 0 20 18 -1.70530257e-13 16"
            }, null, 8, _hoisted_26$4)
          ]),
          _hoisted_27$4
        ])
      ])
    ])
  ]);
}
script$v.render = render$u;
script$v.__file = "packages/components/empty/src/img-empty.vue";
var script$1$g = defineComponent({
  name: "ElEmpty",
  components: {
    [script$v.name]: script$v
  },
  props: {
    image: {
      type: String,
      default: ""
    },
    imageSize: Number,
    description: {
      type: String,
      default: ""
    }
  },
  setup(props2) {
    const { t } = useLocaleInject();
    const emptyDescription = computed(() => props2.description || t("el.table.emptyText"));
    const imageStyle = computed(() => {
      return {
        width: props2.imageSize ? `${props2.imageSize}px` : ""
      };
    });
    return {
      emptyDescription,
      imageStyle
    };
  }
});
const _hoisted_1$1$a = { class: "el-empty" };
const _hoisted_2$1$7 = ["src"];
const _hoisted_3$1$7 = { class: "el-empty__description" };
const _hoisted_4$1$2 = { key: 1 };
const _hoisted_5$1$2 = {
  key: 0,
  class: "el-empty__bottom"
};
function render$1$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_img_empty = resolveComponent("img-empty");
  return openBlock(), createElementBlock("div", _hoisted_1$1$a, [
    createElementVNode("div", {
      class: "el-empty__image",
      style: normalizeStyle(_ctx.imageStyle)
    }, [
      _ctx.image ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: _ctx.image,
        ondragstart: "return false"
      }, null, 8, _hoisted_2$1$7)) : renderSlot(_ctx.$slots, "image", { key: 1 }, () => [
        createVNode(_component_img_empty)
      ])
    ], 4),
    createElementVNode("div", _hoisted_3$1$7, [
      _ctx.$slots.description ? renderSlot(_ctx.$slots, "description", { key: 0 }) : (openBlock(), createElementBlock("p", _hoisted_4$1$2, toDisplayString(_ctx.emptyDescription), 1))
    ]),
    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_5$1$2, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("v-if", true)
  ]);
}
script$1$g.render = render$1$f;
script$1$g.__file = "packages/components/empty/src/workprogress.vue";
script$1$g.install = (app) => {
  app.component(script$1$g.name, script$1$g);
};
const _Empty = script$1$g;
const ElEmpty = _Empty;
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = arguments[i2];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning = function warning2() {
};
if (typeof process !== "undefined" && process.env && true && typeof window !== "undefined" && typeof document !== "undefined") {
  warning = function warning3(type2, errors) {
    if (typeof console !== "undefined" && console.warn) {
      if (errors.every(function(e) {
        return typeof e === "string";
      })) {
        console.warn(type2, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var i2 = 1;
  var f = args[0];
  var len = args.length;
  if (typeof f === "function") {
    return f.apply(null, args.slice(1));
  }
  if (typeof f === "string") {
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === "%%") {
        return "%";
      }
      if (i2 >= len) {
        return x;
      }
      switch (x) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_) {
            return "[Circular]";
          }
          break;
        default:
          return x;
      }
    });
    return str;
  }
  return f;
}
function isNativeStringType(type2) {
  return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
}
function isEmptyValue(value2, type2) {
  if (value2 === void 0 || value2 === null) {
    return true;
  }
  if (type2 === "array" && Array.isArray(value2) && !value2.length) {
    return true;
  }
  if (isNativeStringType(type2) && typeof value2 === "string" && !value2) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a) {
    func(a, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }
  next([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k) {
    ret.push.apply(ret, objArr[k]);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option2, func, callback) {
  if (option2.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve();
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });
    _pending["catch"](function(e) {
      return e;
    });
    return _pending;
  }
  var firstFields = option2.firstFields || [];
  if (firstFields === true) {
    firstFields = Object.keys(objArr);
  }
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next = function next2(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve();
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve();
    }
    objArrKeys.forEach(function(key) {
      var arr = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function(e) {
    return e;
  });
  return pending;
}
function complementError(rule) {
  return function(oe) {
    if (oe && oe.message) {
      oe.field = oe.field || rule.fullField;
      return oe;
    }
    return {
      message: typeof oe === "function" ? oe() : oe,
      field: oe.field || rule.fullField
    };
  };
}
function deepMerge(target, source2) {
  if (source2) {
    for (var s in source2) {
      if (source2.hasOwnProperty(s)) {
        var value2 = source2[s];
        if (typeof value2 === "object" && typeof target[s] === "object") {
          target[s] = _extends$1({}, target[s], value2);
        } else {
          target[s] = value2;
        }
      }
    }
  }
  return target;
}
function required(rule, value2, source2, errors, options2, type2) {
  if (rule.required && (!source2.hasOwnProperty(rule.field) || isEmptyValue(value2, type2 || rule.type))) {
    errors.push(format(options2.messages.required, rule.fullField));
  }
}
function whitespace(rule, value2, source2, errors, options2) {
  if (/^\s+$/.test(value2) || value2 === "") {
    errors.push(format(options2.messages.whitespace, rule.fullField));
  }
}
var pattern = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i"),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer2(value2) {
    return types.number(value2) && parseInt(value2, 10) === value2;
  },
  "float": function float(value2) {
    return types.number(value2) && !types.integer(value2);
  },
  array: function array2(value2) {
    return Array.isArray(value2);
  },
  regexp: function regexp2(value2) {
    if (value2 instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value2);
    } catch (e) {
      return false;
    }
  },
  date: function date2(value2) {
    return typeof value2.getTime === "function" && typeof value2.getMonth === "function" && typeof value2.getYear === "function" && !isNaN(value2.getTime());
  },
  number: function number2(value2) {
    if (isNaN(value2)) {
      return false;
    }
    return typeof value2 === "number";
  },
  object: function object2(value2) {
    return typeof value2 === "object" && !types.array(value2);
  },
  method: function method2(value2) {
    return typeof value2 === "function";
  },
  email: function email(value2) {
    return typeof value2 === "string" && !!value2.match(pattern.email) && value2.length < 255;
  },
  url: function url(value2) {
    return typeof value2 === "string" && !!value2.match(pattern.url);
  },
  hex: function hex(value2) {
    return typeof value2 === "string" && !!value2.match(pattern.hex);
  }
};
function type(rule, value2, source2, errors, options2) {
  if (rule.required && value2 === void 0) {
    required(rule, value2, source2, errors, options2);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value2)) {
      errors.push(format(options2.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value2 !== rule.type) {
    errors.push(format(options2.messages.types[ruleType], rule.fullField, rule.type));
  }
}
function range$1(rule, value2, source2, errors, options2) {
  var len = typeof rule.len === "number";
  var min2 = typeof rule.min === "number";
  var max2 = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value2;
  var key = null;
  var num = typeof value2 === "number";
  var str = typeof value2 === "string";
  var arr = Array.isArray(value2);
  if (num) {
    key = "number";
  } else if (str) {
    key = "string";
  } else if (arr) {
    key = "array";
  }
  if (!key) {
    return false;
  }
  if (arr) {
    val = value2.length;
  }
  if (str) {
    val = value2.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format(options2.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min2 && !max2 && val < rule.min) {
    errors.push(format(options2.messages[key].min, rule.fullField, rule.min));
  } else if (max2 && !min2 && val > rule.max) {
    errors.push(format(options2.messages[key].max, rule.fullField, rule.max));
  } else if (min2 && max2 && (val < rule.min || val > rule.max)) {
    errors.push(format(options2.messages[key].range, rule.fullField, rule.min, rule.max));
  }
}
var ENUM = "enum";
function enumerable(rule, value2, source2, errors, options2) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];
  if (rule[ENUM].indexOf(value2) === -1) {
    errors.push(format(options2.messages[ENUM], rule.fullField, rule[ENUM].join(", ")));
  }
}
function pattern$1(rule, value2, source2, errors, options2) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value2)) {
        errors.push(format(options2.messages.pattern.mismatch, rule.fullField, value2, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value2)) {
        errors.push(format(options2.messages.pattern.mismatch, rule.fullField, value2, rule.pattern));
      }
    }
  }
}
var rules = {
  required,
  whitespace,
  type,
  range: range$1,
  "enum": enumerable,
  pattern: pattern$1
};
function string(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2, "string");
    if (!isEmptyValue(value2, "string")) {
      rules.type(rule, value2, source2, errors, options2);
      rules.range(rule, value2, source2, errors, options2);
      rules.pattern(rule, value2, source2, errors, options2);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value2, source2, errors, options2);
      }
    }
  }
  callback(errors);
}
function method(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (value2 !== void 0) {
      rules.type(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function number(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (value2 === "") {
      value2 = void 0;
    }
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (value2 !== void 0) {
      rules.type(rule, value2, source2, errors, options2);
      rules.range(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function _boolean(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (value2 !== void 0) {
      rules.type(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function regexp(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (!isEmptyValue(value2)) {
      rules.type(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function integer(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (value2 !== void 0) {
      rules.type(rule, value2, source2, errors, options2);
      rules.range(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function floatFn(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (value2 !== void 0) {
      rules.type(rule, value2, source2, errors, options2);
      rules.range(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function array(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if ((value2 === void 0 || value2 === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2, "array");
    if (value2 !== void 0 && value2 !== null) {
      rules.type(rule, value2, source2, errors, options2);
      rules.range(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function object(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (value2 !== void 0) {
      rules.type(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
var ENUM$1 = "enum";
function enumerable$1(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (value2 !== void 0) {
      rules[ENUM$1](rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function pattern$2(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (!isEmptyValue(value2, "string")) {
      rules.pattern(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function date(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
    if (!isEmptyValue(value2, "date")) {
      var dateObject;
      if (value2 instanceof Date) {
        dateObject = value2;
      } else {
        dateObject = new Date(value2);
      }
      rules.type(rule, dateObject, source2, errors, options2);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source2, errors, options2);
      }
    }
  }
  callback(errors);
}
function required$1(rule, value2, callback, source2, options2) {
  var errors = [];
  var type2 = Array.isArray(value2) ? "array" : typeof value2;
  rules.required(rule, value2, source2, errors, options2, type2);
  callback(errors);
}
function type$1(rule, value2, callback, source2, options2) {
  var ruleType = rule.type;
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2, ruleType);
    if (!isEmptyValue(value2, ruleType)) {
      rules.type(rule, value2, source2, errors, options2);
    }
  }
  callback(errors);
}
function any(rule, value2, callback, source2, options2) {
  var errors = [];
  var validate2 = rule.required || !rule.required && source2.hasOwnProperty(rule.field);
  if (validate2) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source2, errors, options2);
  }
  callback(errors);
}
var validators = {
  string,
  method,
  number,
  "boolean": _boolean,
  regexp,
  integer,
  "float": floatFn,
  array,
  object,
  "enum": enumerable$1,
  pattern: pattern$2,
  date,
  url: type$1,
  hex: type$1,
  email: type$1,
  required: required$1,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone2() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
function Schema(descriptor) {
  this.rules = null;
  this._messages = messages;
  this.define(descriptor);
}
Schema.prototype = {
  messages: function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  },
  define: function define(rules2) {
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    var z;
    var item;
    for (z in rules2) {
      if (rules2.hasOwnProperty(z)) {
        item = rules2[z];
        this.rules[z] = Array.isArray(item) ? item : [item];
      }
    }
  },
  validate: function validate(source_, o, oc) {
    var _this = this;
    if (o === void 0) {
      o = {};
    }
    if (oc === void 0) {
      oc = function oc2() {
      };
    }
    var source2 = source_;
    var options2 = o;
    var callback = oc;
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback();
      }
      return Promise.resolve();
    }
    function complete(results) {
      var i2;
      var errors = [];
      var fields = {};
      function add(e) {
        if (Array.isArray(e)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }
      for (i2 = 0; i2 < results.length; i2++) {
        add(results[i2]);
      }
      if (!errors.length) {
        errors = null;
        fields = null;
      } else {
        fields = convertFieldsError(errors);
      }
      callback(errors, fields);
    }
    if (options2.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options2.messages);
      options2.messages = messages$1;
    } else {
      options2.messages = this.messages();
    }
    var arr;
    var value2;
    var series = {};
    var keys2 = options2.keys || Object.keys(this.rules);
    keys2.forEach(function(z) {
      arr = _this.rules[z];
      value2 = source2[z];
      arr.forEach(function(r) {
        var rule = r;
        if (typeof rule.transform === "function") {
          if (source2 === source_) {
            source2 = _extends$1({}, source2);
          }
          value2 = source2[z] = rule.transform(value2);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends$1({}, rule);
        }
        rule.validator = _this.getValidationMethod(rule);
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this.getType(rule);
        if (!rule.validator) {
          return;
        }
        series[z] = series[z] || [];
        series[z].push({
          rule,
          value: value2,
          source: source2,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options2, function(data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullfield(key, schema) {
        return _extends$1({}, schema, {
          fullField: rule.fullField + "." + key
        });
      }
      function cb(e) {
        if (e === void 0) {
          e = [];
        }
        var errors = e;
        if (!Array.isArray(errors)) {
          errors = [errors];
        }
        if (!options2.suppressWarning && errors.length) {
          Schema.warning("async-validator:", errors);
        }
        if (errors.length && rule.message !== void 0) {
          errors = [].concat(rule.message);
        }
        errors = errors.map(complementError(rule));
        if (options2.first && errors.length) {
          errorFields[rule.field] = 1;
          return doIt(errors);
        }
        if (!deep) {
          doIt(errors);
        } else {
          if (rule.required && !data.value) {
            if (rule.message !== void 0) {
              errors = [].concat(rule.message).map(complementError(rule));
            } else if (options2.error) {
              errors = [options2.error(rule, format(options2.messages.required, rule.field))];
            }
            return doIt(errors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            for (var k in data.value) {
              if (data.value.hasOwnProperty(k)) {
                fieldsSchema[k] = rule.defaultField;
              }
            }
          }
          fieldsSchema = _extends$1({}, fieldsSchema, data.rule.fields);
          for (var f in fieldsSchema) {
            if (fieldsSchema.hasOwnProperty(f)) {
              var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
              fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
            }
          }
          var schema = new Schema(fieldsSchema);
          schema.messages(options2.messages);
          if (data.rule.options) {
            data.rule.options.messages = options2.messages;
            data.rule.options.error = options2.error;
          }
          schema.validate(data.value, data.rule.options || options2, function(errs) {
            var finalErrors = [];
            if (errors && errors.length) {
              finalErrors.push.apply(finalErrors, errors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options2);
      } else if (rule.validator) {
        res = rule.validator(rule, data.value, cb, data.source, options2);
        if (res === true) {
          cb();
        } else if (res === false) {
          cb(rule.message || rule.field + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb();
        }, function(e) {
          return cb(e);
        });
      }
    }, function(results) {
      complete(results);
    });
  },
  getType: function getType(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  },
  getValidationMethod: function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || false;
  }
};
Schema.register = function register(type2, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type2] = validator;
};
Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;
var __defProp$f = Object.defineProperty;
var __defProps$d = Object.defineProperties;
var __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key, value2) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$f = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$f.call(b, prop))
      __defNormalProp$f(a, prop, b[prop]);
  if (__getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(b)) {
      if (__propIsEnum$f.call(b, prop))
        __defNormalProp$f(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$d = (a, b) => __defProps$d(a, __getOwnPropDescs$d(b));
function useFormLabelWidth() {
  const potentialLabelWidthArr = ref([]);
  const autoLabelWidth = computed(() => {
    if (!potentialLabelWidthArr.value.length)
      return "0";
    const max2 = Math.max(...potentialLabelWidthArr.value);
    return max2 ? `${max2}px` : "";
  });
  function getLabelWidthIndex(width2) {
    const index2 = potentialLabelWidthArr.value.indexOf(width2);
    if (index2 === -1) {
      console.warn("[Element Warn][ElementForm]unexpected width " + width2);
    }
    return index2;
  }
  function registerLabelWidth(val, oldVal) {
    if (val && oldVal) {
      const index2 = getLabelWidthIndex(oldVal);
      potentialLabelWidthArr.value.splice(index2, 1, val);
    } else if (val) {
      potentialLabelWidthArr.value.push(val);
    }
  }
  function deregisterLabelWidth(val) {
    const index2 = getLabelWidthIndex(val);
    index2 > -1 && potentialLabelWidthArr.value.splice(index2, 1);
  }
  return {
    autoLabelWidth,
    registerLabelWidth,
    deregisterLabelWidth
  };
}
var script$u = defineComponent({
  name: "ElForm",
  props: {
    model: Object,
    rules: Object,
    labelPosition: String,
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    labelSuffix: {
      type: String,
      default: ""
    },
    inline: Boolean,
    inlineMessage: Boolean,
    statusIcon: Boolean,
    showMessage: {
      type: Boolean,
      default: true
    },
    size: String,
    disabled: Boolean,
    validateOnRuleChange: {
      type: Boolean,
      default: true
    },
    hideRequiredAsterisk: {
      type: Boolean,
      default: false
    }
  },
  emits: ["validate"],
  setup(props2, { emit: emit2 }) {
    const formMitt = mitt();
    const fields = [];
    watch(() => props2.rules, () => {
      fields.forEach((field) => {
        field.removeValidateEvents();
        field.addValidateEvents();
      });
      if (props2.validateOnRuleChange) {
        validate2(() => ({}));
      }
    });
    formMitt.on(elFormEvents.addField, (field) => {
      if (field) {
        fields.push(field);
      }
    });
    formMitt.on(elFormEvents.removeField, (field) => {
      if (field.prop) {
        fields.splice(fields.indexOf(field), 1);
      }
    });
    const resetFields = () => {
      if (!props2.model) {
        console.warn("[Element Warn][Form]model is required for resetFields to work.");
        return;
      }
      fields.forEach((field) => {
        field.resetField();
      });
    };
    const clearValidate = (props22 = []) => {
      const fds = props22.length ? typeof props22 === "string" ? fields.filter((field) => props22 === field.prop) : fields.filter((field) => props22.indexOf(field.prop) > -1) : fields;
      fds.forEach((field) => {
        field.clearValidate();
      });
    };
    const validate2 = (callback) => {
      if (!props2.model) {
        console.warn("[Element Warn][Form]model is required for validate to work!");
        return;
      }
      let promise;
      if (typeof callback !== "function") {
        promise = new Promise((resolve, reject) => {
          callback = function(valid2, invalidFields2) {
            if (valid2) {
              resolve(true);
            } else {
              reject(invalidFields2);
            }
          };
        });
      }
      if (fields.length === 0) {
        callback(true);
      }
      let valid = true;
      let count = 0;
      let invalidFields = {};
      for (const field of fields) {
        field.validate("", (message2, field2) => {
          if (message2) {
            valid = false;
          }
          invalidFields = __spreadValues$f(__spreadValues$f({}, invalidFields), field2);
          if (++count === fields.length) {
            callback(valid, invalidFields);
          }
        });
      }
      return promise;
    };
    const validateField = (props22, cb) => {
      props22 = [].concat(props22);
      const fds = fields.filter((field) => props22.indexOf(field.prop) !== -1);
      if (!fields.length) {
        console.warn("[Element Warn]please pass correct props!");
        return;
      }
      fds.forEach((field) => {
        field.validate("", cb);
      });
    };
    const elForm = reactive(__spreadValues$f(__spreadProps$d(__spreadValues$f({
      formMitt
    }, toRefs(props2)), {
      resetFields,
      clearValidate,
      validateField,
      emit: emit2
    }), useFormLabelWidth()));
    provide(elFormKey, elForm);
    return {
      validate: validate2,
      resetFields,
      clearValidate,
      validateField
    };
  }
});
function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("form", {
    class: normalizeClass(["el-form", [
      _ctx.labelPosition ? "el-form--label-" + _ctx.labelPosition : "",
      { "el-form--inline": _ctx.inline }
    ]])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
script$u.render = render$t;
script$u.__file = "packages/components/form/src/form.vue";
var LabelWrap = defineComponent({
  name: "ElLabelWrap",
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(props2, { slots }) {
    const el = ref(null);
    const elForm = inject(elFormKey);
    const elFormItem = inject(elFormItemKey);
    const computedWidth = ref(0);
    watch(computedWidth, (val, oldVal) => {
      if (props2.updateAll) {
        elForm.registerLabelWidth(val, oldVal);
        elFormItem.updateComputedLabelWidth(val);
      }
    });
    const getLabelWidth = () => {
      var _a;
      if ((_a = el.value) == null ? void 0 : _a.firstElementChild) {
        const width2 = window.getComputedStyle(el.value.firstElementChild).width;
        return Math.ceil(parseFloat(width2));
      } else {
        return 0;
      }
    };
    const updateLabelWidth = (action = "update") => {
      nextTick(() => {
        if (slots.default && props2.isAutoWidth) {
          if (action === "update") {
            computedWidth.value = getLabelWidth();
          } else if (action === "remove") {
            elForm.deregisterLabelWidth(computedWidth.value);
          }
        }
      });
    };
    const updateLabelWidthFn = () => updateLabelWidth("update");
    onMounted(() => {
      addResizeListener(el.value.firstElementChild, updateLabelWidthFn);
      updateLabelWidthFn();
    });
    onUpdated(updateLabelWidthFn);
    onBeforeUnmount(() => {
      updateLabelWidth("remove");
      removeResizeListener(el.value.firstElementChild, updateLabelWidthFn);
    });
    function render2() {
      var _a, _b;
      if (!slots)
        return null;
      if (props2.isAutoWidth) {
        const autoLabelWidth = elForm.autoLabelWidth;
        const style = {};
        if (autoLabelWidth && autoLabelWidth !== "auto") {
          const marginWidth = Math.max(0, parseInt(autoLabelWidth, 10) - computedWidth.value);
          const marginPosition = elForm.labelPosition === "left" ? "marginRight" : "marginLeft";
          if (marginWidth) {
            style[marginPosition] = marginWidth + "px";
          }
        }
        return h("div", {
          ref: el,
          class: ["el-form-item__label-wrap"],
          style
        }, (_a = slots.default) == null ? void 0 : _a.call(slots));
      } else {
        return h(Fragment, { ref: el }, (_b = slots.default) == null ? void 0 : _b.call(slots));
      }
    }
    return render2;
  }
});
var __defProp$1$6 = Object.defineProperty;
var __defProps$1$5 = Object.defineProperties;
var __getOwnPropDescs$1$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$6 = (obj, key, value2) => key in obj ? __defProp$1$6(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$6.call(b, prop))
      __defNormalProp$1$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$6)
    for (var prop of __getOwnPropSymbols$1$6(b)) {
      if (__propIsEnum$1$6.call(b, prop))
        __defNormalProp$1$6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1$5 = (a, b) => __defProps$1$5(a, __getOwnPropDescs$1$5(b));
var script$1$f = defineComponent({
  name: "ElFormItem",
  componentName: "ElFormItem",
  components: {
    LabelWrap
  },
  props: {
    label: String,
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    prop: String,
    required: {
      type: Boolean,
      default: void 0
    },
    rules: [Object, Array],
    error: String,
    validateStatus: String,
    for: String,
    inlineMessage: {
      type: [String, Boolean],
      default: ""
    },
    showMessage: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      validator: isValidComponentSize
    }
  },
  setup(props2, { slots }) {
    const formItemMitt = mitt();
    const $ELEMENT2 = useGlobalConfig();
    const elForm = inject(elFormKey, {});
    const validateState = ref("");
    const validateMessage = ref("");
    const validateDisabled = ref(false);
    const computedLabelWidth = ref("");
    const vm = getCurrentInstance();
    const isNested = computed(() => {
      let parent2 = vm.parent;
      while (parent2 && parent2.type.name !== "ElForm") {
        if (parent2.type.name === "ElFormItem") {
          return true;
        }
        parent2 = parent2.parent;
      }
      return false;
    });
    let initialValue = void 0;
    watch(() => props2.error, (val) => {
      validateMessage.value = val;
      validateState.value = val ? "error" : "";
    }, {
      immediate: true
    });
    watch(() => props2.validateStatus, (val) => {
      validateState.value = val;
    });
    const labelFor = computed(() => props2.for || props2.prop);
    const labelStyle = computed(() => {
      const ret = {};
      if (elForm.labelPosition === "top")
        return ret;
      const labelWidth = addUnit(props2.labelWidth) || addUnit(elForm.labelWidth);
      if (labelWidth) {
        ret.width = labelWidth;
      }
      return ret;
    });
    const contentStyle = computed(() => {
      const ret = {};
      if (elForm.labelPosition === "top" || elForm.inline) {
        return ret;
      }
      if (!props2.label && !props2.labelWidth && isNested.value) {
        return ret;
      }
      const labelWidth = addUnit(props2.labelWidth) || addUnit(elForm.labelWidth);
      if (!props2.label && !slots.label) {
        ret.marginLeft = labelWidth;
      }
      return ret;
    });
    const fieldValue = computed(() => {
      const model = elForm.model;
      if (!model || !props2.prop) {
        return;
      }
      let path = props2.prop;
      if (path.indexOf(":") !== -1) {
        path = path.replace(/:/, ".");
      }
      return getPropByPath(model, path, true).v;
    });
    const isRequired = computed(() => {
      let rules2 = getRules();
      let required2 = false;
      if (rules2 && rules2.length) {
        rules2.every((rule) => {
          if (rule.required) {
            required2 = true;
            return false;
          }
          return true;
        });
      }
      return required2;
    });
    const elFormItemSize = computed(() => props2.size || elForm.size);
    const sizeClass = computed(() => {
      return elFormItemSize.value || $ELEMENT2.size;
    });
    const validate2 = (trigger, callback = NOOP) => {
      validateDisabled.value = false;
      const rules2 = getFilteredRule(trigger);
      if ((!rules2 || rules2.length === 0) && props2.required === void 0) {
        callback();
        return;
      }
      validateState.value = "validating";
      const descriptor = {};
      if (rules2 && rules2.length > 0) {
        rules2.forEach((rule) => {
          delete rule.trigger;
        });
      }
      descriptor[props2.prop] = rules2;
      const validator = new Schema(descriptor);
      const model = {};
      model[props2.prop] = fieldValue.value;
      validator.validate(model, { firstFields: true }, (errors, invalidFields) => {
        var _a;
        validateState.value = !errors ? "success" : "error";
        validateMessage.value = errors ? errors[0].message : "";
        callback(validateMessage.value, invalidFields);
        (_a = elForm.emit) == null ? void 0 : _a.call(elForm, "validate", props2.prop, !errors, validateMessage.value || null);
      });
    };
    const clearValidate = () => {
      validateState.value = "";
      validateMessage.value = "";
      validateDisabled.value = false;
    };
    const resetField = () => {
      validateState.value = "";
      validateMessage.value = "";
      let model = elForm.model;
      let value2 = fieldValue.value;
      let path = props2.prop;
      if (path.indexOf(":") !== -1) {
        path = path.replace(/:/, ".");
      }
      let prop = getPropByPath(model, path, true);
      validateDisabled.value = true;
      if (Array.isArray(value2)) {
        prop.o[prop.k] = [].concat(initialValue);
      } else {
        prop.o[prop.k] = initialValue;
      }
      nextTick(() => {
        validateDisabled.value = false;
      });
    };
    const getRules = () => {
      const formRules = elForm.rules;
      const selfRules = props2.rules;
      const requiredRule = props2.required !== void 0 ? { required: !!props2.required } : [];
      const prop = getPropByPath(formRules, props2.prop || "", false);
      const normalizedRule = formRules ? prop.o[props2.prop || ""] || prop.v : [];
      return [].concat(selfRules || normalizedRule || []).concat(requiredRule);
    };
    const getFilteredRule = (trigger) => {
      const rules2 = getRules();
      return rules2.filter((rule) => {
        if (!rule.trigger || trigger === "")
          return true;
        if (Array.isArray(rule.trigger)) {
          return rule.trigger.indexOf(trigger) > -1;
        } else {
          return rule.trigger === trigger;
        }
      }).map((rule) => __spreadValues$1$6({}, rule));
    };
    const onFieldBlur = () => {
      validate2("blur");
    };
    const onFieldChange = () => {
      if (validateDisabled.value) {
        validateDisabled.value = false;
        return;
      }
      validate2("change");
    };
    const updateComputedLabelWidth = (width2) => {
      computedLabelWidth.value = width2 ? `${width2}px` : "";
    };
    const addValidateEvents = () => {
      const rules2 = getRules();
      if (rules2.length || props2.required !== void 0) {
        formItemMitt.on("el.form.blur", onFieldBlur);
        formItemMitt.on("el.form.change", onFieldChange);
      }
    };
    const removeValidateEvents = () => {
      formItemMitt.off("el.form.blur", onFieldBlur);
      formItemMitt.off("el.form.change", onFieldChange);
    };
    const elFormItem = reactive(__spreadProps$1$5(__spreadValues$1$6({}, toRefs(props2)), {
      size: sizeClass,
      validateState,
      removeValidateEvents,
      addValidateEvents,
      resetField,
      clearValidate,
      validate: validate2,
      formItemMitt,
      updateComputedLabelWidth
    }));
    onMounted(() => {
      var _a;
      if (props2.prop) {
        (_a = elForm.formMitt) == null ? void 0 : _a.emit(elFormEvents.addField, elFormItem);
        let value2 = fieldValue.value;
        initialValue = Array.isArray(value2) ? [...value2] : value2;
        addValidateEvents();
      }
    });
    onBeforeUnmount(() => {
      var _a;
      (_a = elForm.formMitt) == null ? void 0 : _a.emit(elFormEvents.removeField, elFormItem);
    });
    provide(elFormItemKey, elFormItem);
    const formItemClass = computed(() => [
      {
        "el-form-item--feedback": elForm.statusIcon,
        "is-error": validateState.value === "error",
        "is-validating": validateState.value === "validating",
        "is-success": validateState.value === "success",
        "is-required": isRequired.value || props2.required,
        "is-no-asterisk": elForm.hideRequiredAsterisk
      },
      sizeClass.value ? "el-form-item--" + sizeClass.value : ""
    ]);
    const shouldShowError = computed(() => {
      return validateState.value === "error" && props2.showMessage && elForm.showMessage;
    });
    return {
      formItemClass,
      shouldShowError,
      elForm,
      labelStyle,
      contentStyle,
      validateMessage,
      labelFor,
      resetField,
      clearValidate
    };
  }
});
const _hoisted_1$Q = ["for"];
function render$1$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LabelWrap = resolveComponent("LabelWrap");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-form-item", _ctx.formItemClass])
  }, [
    createVNode(_component_LabelWrap, {
      "is-auto-width": _ctx.labelStyle.width === "auto",
      "update-all": _ctx.elForm.labelWidth === "auto"
    }, {
      default: withCtx(() => [
        _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          for: _ctx.labelFor,
          class: "el-form-item__label",
          style: normalizeStyle(_ctx.labelStyle)
        }, [
          renderSlot(_ctx.$slots, "label", {
            label: _ctx.label + _ctx.elForm.labelSuffix
          }, () => [
            createTextVNode(toDisplayString(_ctx.label + _ctx.elForm.labelSuffix), 1)
          ])
        ], 12, _hoisted_1$Q)) : createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 8, ["is-auto-width", "update-all"]),
    createElementVNode("div", {
      class: "el-form-item__content",
      style: normalizeStyle(_ctx.contentStyle)
    }, [
      renderSlot(_ctx.$slots, "default"),
      createVNode(Transition, { name: "el-zoom-in-top" }, {
        default: withCtx(() => [
          _ctx.shouldShowError ? renderSlot(_ctx.$slots, "error", {
            key: 0,
            error: _ctx.validateMessage
          }, () => [
            createElementVNode("div", {
              class: normalizeClass(["el-form-item__error", {
                "el-form-item__error--inline": typeof _ctx.inlineMessage === "boolean" ? _ctx.inlineMessage : _ctx.elForm.inlineMessage || false
              }])
            }, toDisplayString(_ctx.validateMessage), 3)
          ]) : createCommentVNode("v-if", true)
        ]),
        _: 3
      })
    ], 4)
  ], 2);
}
script$1$f.render = render$1$e;
script$1$f.__file = "packages/components/form/src/form-item.vue";
script$u.install = (app) => {
  app.component(script$u.name, script$u);
  app.component(script$1$f.name, script$1$f);
};
script$u.FormItem = script$1$f;
const _Form = script$u;
const ElForm = _Form;
var __defProp$e = Object.defineProperty;
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key, value2) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$e = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$e.call(b, prop))
      __defNormalProp$e(a, prop, b[prop]);
  if (__getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(b)) {
      if (__propIsEnum$e.call(b, prop))
        __defNormalProp$e(a, prop, b[prop]);
    }
  return a;
};
var script$t = defineComponent({
  name: "ElIcon",
  props: {
    size: {
      type: Number
    },
    color: {
      type: String
    }
  },
  setup(props2) {
    return {
      style: computed(() => {
        if (!props2.size && !props2.color) {
          return {};
        }
        return __spreadValues$e(__spreadValues$e({}, props2.size ? { "--font-size": `${props2.size}px` } : {}), props2.color ? { "--color": props2.color } : {});
      })
    };
  }
});
function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("i", mergeProps({
    class: "el-icon",
    style: _ctx.style
  }, _ctx.$attrs), [
    renderSlot(_ctx.$slots, "default")
  ], 16);
}
script$t.render = render$s;
script$t.__file = "packages/components/icon/src/workprogress.vue";
script$t.install = (app) => {
  app.component(script$t.name, script$t);
};
const _Icon = script$t;
const ElIcon = _Icon;
var __defProp$d = Object.defineProperty;
var __defProps$c = Object.defineProperties;
var __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key, value2) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$d = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$d.call(b, prop))
      __defNormalProp$d(a, prop, b[prop]);
  if (__getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(b)) {
      if (__propIsEnum$d.call(b, prop))
        __defNormalProp$d(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$c = (a, b) => __defProps$c(a, __getOwnPropDescs$c(b));
const Mode = {
  CONTAIN: {
    name: "contain",
    icon: "el-icon-full-screen"
  },
  ORIGINAL: {
    name: "original",
    icon: "el-icon-c-scale-to-original"
  }
};
const mousewheelEventName = isFirefox$1() ? "DOMMouseScroll" : "mousewheel";
const CLOSE_EVENT = "close";
const SWITCH_EVENT = "switch";
var script$s = defineComponent({
  name: "ElImageViewer",
  props: {
    urlList: {
      type: Array,
      default: []
    },
    zIndex: {
      type: Number,
      default: 2e3
    },
    initialIndex: {
      type: Number,
      default: 0
    },
    infinite: {
      type: Boolean,
      default: true
    },
    hideOnClickModal: {
      type: Boolean,
      default: false
    }
  },
  emits: [CLOSE_EVENT, SWITCH_EVENT],
  setup(props2, { emit: emit2 }) {
    const { t } = useLocaleInject();
    let _keyDownHandler = null;
    let _mouseWheelHandler = null;
    let _dragHandler = null;
    const loading = ref(true);
    const index2 = ref(props2.initialIndex);
    const wrapper = ref(null);
    const img = ref(null);
    const mode = ref(Mode.CONTAIN);
    let transform = ref({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: false
    });
    const isSingle = computed(() => {
      const { urlList } = props2;
      return urlList.length <= 1;
    });
    const isFirst = computed(() => {
      return index2.value === 0;
    });
    const isLast = computed(() => {
      return index2.value === props2.urlList.length - 1;
    });
    const currentImg = computed(() => {
      return props2.urlList[index2.value];
    });
    const imgStyle = computed(() => {
      const { scale, deg, offsetX, offsetY, enableTransition } = transform.value;
      const style = {
        transform: `scale(${scale}) rotate(${deg}deg)`,
        transition: enableTransition ? "transform .3s" : "",
        marginLeft: `${offsetX}px`,
        marginTop: `${offsetY}px`
      };
      if (mode.value.name === Mode.CONTAIN.name) {
        style.maxWidth = style.maxHeight = "100%";
      }
      return style;
    });
    function hide2() {
      deviceSupportUninstall();
      emit2(CLOSE_EVENT);
    }
    function deviceSupportInstall() {
      _keyDownHandler = rafThrottle((e) => {
        switch (e.code) {
          case EVENT_CODE.esc:
            hide2();
            break;
          case EVENT_CODE.space:
            toggleMode();
            break;
          case EVENT_CODE.left:
            prev();
            break;
          case EVENT_CODE.up:
            handleActions("zoomIn");
            break;
          case EVENT_CODE.right:
            next();
            break;
          case EVENT_CODE.down:
            handleActions("zoomOut");
            break;
        }
      });
      _mouseWheelHandler = rafThrottle((e) => {
        const delta = e.wheelDelta ? e.wheelDelta : -e.detail;
        if (delta > 0) {
          handleActions("zoomIn", {
            zoomRate: 0.015,
            enableTransition: false
          });
        } else {
          handleActions("zoomOut", {
            zoomRate: 0.015,
            enableTransition: false
          });
        }
      });
      on$2(document, "keydown", _keyDownHandler);
      on$2(document, mousewheelEventName, _mouseWheelHandler);
    }
    function deviceSupportUninstall() {
      off$2(document, "keydown", _keyDownHandler);
      off$2(document, mousewheelEventName, _mouseWheelHandler);
      _keyDownHandler = null;
      _mouseWheelHandler = null;
    }
    function handleImgLoad() {
      loading.value = false;
    }
    function handleImgError(e) {
      loading.value = false;
      e.target.alt = t("el.image.error");
    }
    function handleMouseDown(e) {
      if (loading.value || e.button !== 0)
        return;
      const { offsetX, offsetY } = transform.value;
      const startX = e.pageX;
      const startY = e.pageY;
      _dragHandler = rafThrottle((ev) => {
        transform.value = __spreadProps$c(__spreadValues$d({}, transform.value), {
          offsetX: offsetX + ev.pageX - startX,
          offsetY: offsetY + ev.pageY - startY
        });
      });
      on$2(document, "mousemove", _dragHandler);
      on$2(document, "mouseup", () => {
        off$2(document, "mousemove", _dragHandler);
      });
      e.preventDefault();
    }
    function reset() {
      transform.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: false
      };
    }
    function toggleMode() {
      if (loading.value)
        return;
      const modeNames = Object.keys(Mode);
      const modeValues = Object.values(Mode);
      const currentMode = mode.value.name;
      const index22 = modeValues.findIndex((i2) => i2.name === currentMode);
      const nextIndex = (index22 + 1) % modeNames.length;
      mode.value = Mode[modeNames[nextIndex]];
      reset();
    }
    function prev() {
      if (isFirst.value && !props2.infinite)
        return;
      const len = props2.urlList.length;
      index2.value = (index2.value - 1 + len) % len;
    }
    function next() {
      if (isLast.value && !props2.infinite)
        return;
      const len = props2.urlList.length;
      index2.value = (index2.value + 1) % len;
    }
    function handleActions(action, options2 = {}) {
      if (loading.value)
        return;
      const { zoomRate, rotateDeg, enableTransition } = __spreadValues$d({
        zoomRate: 0.2,
        rotateDeg: 90,
        enableTransition: true
      }, options2);
      switch (action) {
        case "zoomOut":
          if (transform.value.scale > 0.2) {
            transform.value.scale = parseFloat((transform.value.scale - zoomRate).toFixed(3));
          }
          break;
        case "zoomIn":
          transform.value.scale = parseFloat((transform.value.scale + zoomRate).toFixed(3));
          break;
        case "clocelise":
          transform.value.deg += rotateDeg;
          break;
        case "anticlocelise":
          transform.value.deg -= rotateDeg;
          break;
      }
      transform.value.enableTransition = enableTransition;
    }
    watch(currentImg, () => {
      nextTick(() => {
        const $img = img.value;
        if (!$img.complete) {
          loading.value = true;
        }
      });
    });
    watch(index2, (val) => {
      reset();
      emit2(SWITCH_EVENT, val);
    });
    onMounted(() => {
      var _a, _b;
      deviceSupportInstall();
      (_b = (_a = wrapper.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    });
    return {
      index: index2,
      wrapper,
      img,
      isSingle,
      isFirst,
      isLast,
      currentImg,
      imgStyle,
      mode,
      handleActions,
      prev,
      next,
      hide: hide2,
      toggleMode,
      handleImgLoad,
      handleImgError,
      handleMouseDown
    };
  }
});
const _hoisted_1$P = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-close" }, null, -1);
const _hoisted_2$I = [
  _hoisted_1$P
];
const _hoisted_3$F = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-arrow-left" }, null, -1);
const _hoisted_4$t = [
  _hoisted_3$F
];
const _hoisted_5$n = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-arrow-right" }, null, -1);
const _hoisted_6$k = [
  _hoisted_5$n
];
const _hoisted_7$f = { class: "el-image-viewer__btn el-image-viewer__actions" };
const _hoisted_8$d = { class: "el-image-viewer__actions__inner" };
const _hoisted_9$d = /* @__PURE__ */ createElementVNode("i", { class: "el-image-viewer__actions__divider" }, null, -1);
const _hoisted_10$a = /* @__PURE__ */ createElementVNode("i", { class: "el-image-viewer__actions__divider" }, null, -1);
const _hoisted_11$8 = { class: "el-image-viewer__canvas" };
const _hoisted_12$7 = ["src"];
function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, { name: "viewer-fade" }, {
    default: withCtx(() => [
      createElementVNode("div", {
        ref: "wrapper",
        tabindex: -1,
        class: "el-image-viewer__wrapper",
        style: normalizeStyle({ zIndex: _ctx.zIndex })
      }, [
        createElementVNode("div", {
          class: "el-image-viewer__mask",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.hideOnClickModal && _ctx.hide(), ["self"]))
        }),
        createCommentVNode(" CLOSE "),
        createElementVNode("span", {
          class: "el-image-viewer__btn el-image-viewer__close",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.hide && _ctx.hide(...args))
        }, _hoisted_2$I),
        createCommentVNode(" ARROW "),
        !_ctx.isSingle ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createElementVNode("span", {
            class: normalizeClass(["el-image-viewer__btn el-image-viewer__prev", { "is-disabled": !_ctx.infinite && _ctx.isFirst }]),
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.prev && _ctx.prev(...args))
          }, _hoisted_4$t, 2),
          createElementVNode("span", {
            class: normalizeClass(["el-image-viewer__btn el-image-viewer__next", { "is-disabled": !_ctx.infinite && _ctx.isLast }]),
            onClick: _cache[3] || (_cache[3] = (...args) => _ctx.next && _ctx.next(...args))
          }, _hoisted_6$k, 2)
        ], 64)) : createCommentVNode("v-if", true),
        createCommentVNode(" ACTIONS "),
        createElementVNode("div", _hoisted_7$f, [
          createElementVNode("div", _hoisted_8$d, [
            createElementVNode("i", {
              class: "el-icon-zoom-out",
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.handleActions("zoomOut"))
            }),
            createElementVNode("i", {
              class: "el-icon-zoom-in",
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleActions("zoomIn"))
            }),
            _hoisted_9$d,
            createElementVNode("i", {
              class: normalizeClass(_ctx.mode.icon),
              onClick: _cache[6] || (_cache[6] = (...args) => _ctx.toggleMode && _ctx.toggleMode(...args))
            }, null, 2),
            _hoisted_10$a,
            createElementVNode("i", {
              class: "el-icon-refresh-left",
              onClick: _cache[7] || (_cache[7] = ($event) => _ctx.handleActions("anticlocelise"))
            }),
            createElementVNode("i", {
              class: "el-icon-refresh-right",
              onClick: _cache[8] || (_cache[8] = ($event) => _ctx.handleActions("clocelise"))
            })
          ])
        ]),
        createCommentVNode(" CANVAS "),
        createElementVNode("div", _hoisted_11$8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.urlList, (url2, i2) => {
            return withDirectives((openBlock(), createElementBlock("img", {
              ref: "img",
              key: url2,
              src: url2,
              style: normalizeStyle(_ctx.imgStyle),
              class: "el-image-viewer__img",
              onLoad: _cache[9] || (_cache[9] = (...args) => _ctx.handleImgLoad && _ctx.handleImgLoad(...args)),
              onError: _cache[10] || (_cache[10] = (...args) => _ctx.handleImgError && _ctx.handleImgError(...args)),
              onMousedown: _cache[11] || (_cache[11] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args))
            }, null, 44, _hoisted_12$7)), [
              [vShow, i2 === _ctx.index]
            ]);
          }), 128))
        ])
      ], 4)
    ]),
    _: 1
  });
}
script$s.render = render$r;
script$s.__file = "packages/components/image-viewer/src/workprogress.vue";
script$s.install = (app) => {
  app.component(script$s.name, script$s);
};
const _ImageViewer = script$s;
const ElImageViewer = _ImageViewer;
const isSupportObjectFit = () => document.documentElement.style.objectFit !== void 0;
const isHtmlEle = (e) => e && e.nodeType === 1;
const ObjectFit = {
  NONE: "none",
  CONTAIN: "contain",
  COVER: "cover",
  FILL: "fill",
  SCALE_DOWN: "scale-down"
};
let prevOverflow = "";
var script$r = defineComponent({
  name: "ElImage",
  components: {
    ImageViewer: _ImageViewer
  },
  inheritAttrs: false,
  props: {
    appendToBody: {
      type: Boolean,
      default: false
    },
    hideOnClickModal: {
      type: Boolean,
      default: false
    },
    src: {
      type: String,
      default: ""
    },
    fit: {
      type: String,
      default: ""
    },
    lazy: {
      type: Boolean,
      default: false
    },
    scrollContainer: {
      type: [String, Object],
      default: null
    },
    previewSrcList: {
      type: Array,
      default: () => []
    },
    zIndex: {
      type: Number,
      default: 2e3
    }
  },
  emits: ["error"],
  setup(props2, { emit: emit2 }) {
    const { t } = useLocaleInject();
    const attrs = useAttrs();
    const hasLoadError = ref(false);
    const loading = ref(true);
    const imgWidth = ref(0);
    const imgHeight = ref(0);
    const showViewer = ref(false);
    const container = ref(null);
    let _scrollContainer = null;
    let _lazyLoadHandler = null;
    const imageStyle = computed(() => {
      const { fit } = props2;
      if (!isServer && fit) {
        return isSupportObjectFit() ? { "object-fit": fit } : getImageStyle(fit);
      }
      return {};
    });
    const alignCenter = computed(() => {
      const { fit } = props2;
      return !isServer && !isSupportObjectFit() && fit !== ObjectFit.FILL;
    });
    const preview = computed(() => {
      const { previewSrcList } = props2;
      return Array.isArray(previewSrcList) && previewSrcList.length > 0;
    });
    const imageIndex = computed(() => {
      const { src, previewSrcList } = props2;
      let previewIndex = 0;
      const srcIndex = previewSrcList.indexOf(src);
      if (srcIndex >= 0) {
        previewIndex = srcIndex;
      }
      return previewIndex;
    });
    function getImageStyle(fit) {
      const imageWidth = imgWidth.value;
      const imageHeight = imgHeight.value;
      if (!container.value)
        return {};
      const {
        clientWidth: containerWidth,
        clientHeight: containerHeight
      } = container.value;
      if (!imageWidth || !imageHeight || !containerWidth || !containerHeight)
        return {};
      const imageAspectRatio = imageWidth / imageHeight;
      const containerAspectRatio = containerWidth / containerHeight;
      if (fit === ObjectFit.SCALE_DOWN) {
        const isSmaller = imageWidth < containerWidth && imageHeight < containerHeight;
        fit = isSmaller ? ObjectFit.NONE : ObjectFit.CONTAIN;
      }
      switch (fit) {
        case ObjectFit.NONE:
          return { width: "auto", height: "auto" };
        case ObjectFit.CONTAIN:
          return imageAspectRatio < containerAspectRatio ? { width: "auto" } : { height: "auto" };
        case ObjectFit.COVER:
          return imageAspectRatio < containerAspectRatio ? { height: "auto" } : { width: "auto" };
        default:
          return {};
      }
    }
    const loadImage = () => {
      if (isServer)
        return;
      const attributes2 = attrs.value;
      loading.value = true;
      hasLoadError.value = false;
      const img = new Image();
      img.onload = (e) => handleLoad(e, img);
      img.onerror = handleError;
      Object.keys(attributes2).forEach((key) => {
        if (key.toLowerCase() === "onload")
          return;
        const value2 = attributes2[key];
        img.setAttribute(key, value2);
      });
      img.src = props2.src;
    };
    function handleLoad(e, img) {
      imgWidth.value = img.width;
      imgHeight.value = img.height;
      loading.value = false;
      hasLoadError.value = false;
    }
    function handleError(e) {
      loading.value = false;
      hasLoadError.value = true;
      emit2("error", e);
    }
    function handleLazyLoad() {
      if (isInContainer(container.value, _scrollContainer)) {
        loadImage();
        removeLazyLoadListener();
      }
    }
    function addLazyLoadListener() {
      if (isServer)
        return;
      const { scrollContainer } = props2;
      if (isHtmlEle(scrollContainer)) {
        _scrollContainer = scrollContainer;
      } else if (isString$1(scrollContainer) && scrollContainer !== "") {
        _scrollContainer = document.querySelector(scrollContainer);
      } else {
        _scrollContainer = getScrollContainer(container.value);
      }
      if (_scrollContainer) {
        _lazyLoadHandler = throttle_1(handleLazyLoad, 200);
        on$2(_scrollContainer, "scroll", _lazyLoadHandler);
        setTimeout(() => handleLazyLoad(), 100);
      }
    }
    function removeLazyLoadListener() {
      if (isServer || !_scrollContainer || !_lazyLoadHandler)
        return;
      off$2(_scrollContainer, "scroll", _lazyLoadHandler);
      _scrollContainer = null;
      _lazyLoadHandler = null;
    }
    function clickHandler() {
      if (!preview.value) {
        return;
      }
      prevOverflow = document.body.style.overflow;
      document.body.style.overflow = "hidden";
      showViewer.value = true;
    }
    function closeViewer() {
      document.body.style.overflow = prevOverflow;
      showViewer.value = false;
    }
    watch(() => props2.src, () => {
      loadImage();
    });
    onMounted(() => {
      if (props2.lazy) {
        nextTick(addLazyLoadListener);
      } else {
        loadImage();
      }
    });
    onBeforeUnmount(() => {
      props2.lazy && removeLazyLoadListener();
    });
    return {
      attrs,
      loading,
      hasLoadError,
      showViewer,
      imgWidth,
      imgHeight,
      imageStyle,
      alignCenter,
      preview,
      imageIndex,
      clickHandler,
      closeViewer,
      container,
      handleError,
      t
    };
  }
});
const _hoisted_1$O = /* @__PURE__ */ createElementVNode("div", { class: "el-image__placeholder" }, null, -1);
const _hoisted_2$H = { class: "el-image__error" };
const _hoisted_3$E = ["src"];
function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_image_viewer = resolveComponent("image-viewer");
  return openBlock(), createElementBlock("div", {
    ref: "container",
    class: normalizeClass(["el-image", _ctx.$attrs.class]),
    style: normalizeStyle(_ctx.$attrs.style)
  }, [
    _ctx.loading ? renderSlot(_ctx.$slots, "placeholder", { key: 0 }, () => [
      _hoisted_1$O
    ]) : _ctx.hasLoadError ? renderSlot(_ctx.$slots, "error", { key: 1 }, () => [
      createElementVNode("div", _hoisted_2$H, toDisplayString(_ctx.t("el.image.error")), 1)
    ]) : (openBlock(), createElementBlock("img", mergeProps({
      key: 2,
      class: "el-image__inner"
    }, _ctx.attrs, {
      src: _ctx.src,
      style: _ctx.imageStyle,
      class: { "el-image__inner--center": _ctx.alignCenter, "el-image__preview": _ctx.preview },
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickHandler && _ctx.clickHandler(...args))
    }), null, 16, _hoisted_3$E)),
    (openBlock(), createBlock(Teleport, {
      to: "body",
      disabled: !_ctx.appendToBody
    }, [
      _ctx.preview ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.showViewer ? (openBlock(), createBlock(_component_image_viewer, {
          key: 0,
          "z-index": _ctx.zIndex,
          "initial-index": _ctx.imageIndex,
          "url-list": _ctx.previewSrcList,
          "hide-on-click-modal": _ctx.hideOnClickModal,
          onClose: _ctx.closeViewer
        }, null, 8, ["z-index", "initial-index", "url-list", "hide-on-click-modal", "onClose"])) : createCommentVNode("v-if", true)
      ], 2112)) : createCommentVNode("v-if", true)
    ], 8, ["disabled"]))
  ], 6);
}
script$r.render = render$q;
script$r.__file = "packages/components/image/src/workprogress.vue";
script$r.install = (app) => {
  app.component(script$r.name, script$r);
};
const _Image = script$r;
const ElImage = _Image;
var script$q = defineComponent({
  name: "ElInputNumber",
  components: {
    ElInput: ElInput$1
  },
  directives: {
    RepeatClick
  },
  props: {
    step: {
      type: Number,
      default: 1
    },
    stepStrictly: {
      type: Boolean,
      default: false
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    modelValue: {
      required: true,
      type: Number
    },
    disabled: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    controls: {
      type: Boolean,
      default: true
    },
    controlsPosition: {
      type: String,
      default: ""
    },
    name: String,
    label: String,
    placeholder: String,
    precision: {
      type: Number,
      validator: (val) => val >= 0 && val === parseInt(val + "", 10)
    }
  },
  emits: ["update:modelValue", "change", "input", "blur", "focus"],
  setup(props2, { emit: emit2 }) {
    const ELEMENT = useGlobalConfig();
    const elForm = inject(elFormKey, {});
    const elFormItem = inject(elFormItemKey, {});
    const input2 = ref(null);
    const data = reactive({
      currentValue: props2.modelValue,
      userInput: null
    });
    const minDisabled = computed(() => {
      return _decrease(props2.modelValue) < props2.min;
    });
    const maxDisabled = computed(() => {
      return _increase(props2.modelValue) > props2.max;
    });
    const numPrecision = computed(() => {
      const stepPrecision = getPrecision(props2.step);
      if (props2.precision !== void 0) {
        if (stepPrecision > props2.precision) {
          console.warn("[ElementPlus Warn][InputNumber] precision should not be less than the decimal places of step");
        }
        return props2.precision;
      } else {
        return Math.max(getPrecision(props2.modelValue), stepPrecision);
      }
    });
    const controlsAtRight = computed(() => {
      return props2.controls && props2.controlsPosition === "right";
    });
    const inputNumberSize = computed(() => {
      return props2.size || elFormItem.size || ELEMENT.size;
    });
    const inputNumberDisabled = computed(() => {
      return props2.disabled || elForm.disabled;
    });
    const displayValue = computed(() => {
      if (data.userInput !== null) {
        return data.userInput;
      }
      let currentValue = data.currentValue;
      if (typeof currentValue === "number") {
        if (props2.precision !== void 0) {
          currentValue = currentValue.toFixed(props2.precision);
        }
      }
      return currentValue;
    });
    const toPrecision = (num, pre) => {
      if (pre === void 0)
        pre = numPrecision.value;
      return parseFloat(Math.round(num * Math.pow(10, pre)) / Math.pow(10, pre) + "");
    };
    const getPrecision = (value2) => {
      if (value2 === void 0)
        return 0;
      const valueString = value2.toString();
      const dotPosition = valueString.indexOf(".");
      let precision = 0;
      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }
      return precision;
    };
    const _increase = (val) => {
      if (typeof val !== "number" && val !== void 0)
        return data.currentValue;
      const precisionFactor = Math.pow(10, numPrecision.value);
      return toPrecision((precisionFactor * val + precisionFactor * props2.step) / precisionFactor);
    };
    const _decrease = (val) => {
      if (typeof val !== "number" && val !== void 0)
        return data.currentValue;
      const precisionFactor = Math.pow(10, numPrecision.value);
      return toPrecision((precisionFactor * val - precisionFactor * props2.step) / precisionFactor);
    };
    const increase = () => {
      if (inputNumberDisabled.value || maxDisabled.value)
        return;
      const value2 = props2.modelValue || 0;
      const newVal = _increase(value2);
      setCurrentValue(newVal);
    };
    const decrease = () => {
      if (inputNumberDisabled.value || minDisabled.value)
        return;
      const value2 = props2.modelValue || 0;
      const newVal = _decrease(value2);
      setCurrentValue(newVal);
    };
    const setCurrentValue = (newVal) => {
      const oldVal = data.currentValue;
      if (typeof newVal === "number" && props2.precision !== void 0) {
        newVal = toPrecision(newVal, props2.precision);
      }
      if (newVal !== void 0 && newVal >= props2.max)
        newVal = props2.max;
      if (newVal !== void 0 && newVal <= props2.min)
        newVal = props2.min;
      if (oldVal === newVal)
        return;
      data.userInput = null;
      emit2("update:modelValue", newVal);
      emit2("input", newVal);
      emit2("change", newVal, oldVal);
      data.currentValue = newVal;
    };
    const handleInput = (value2) => {
      return data.userInput = value2;
    };
    const handleInputChange = (value2) => {
      const newVal = value2 === "" ? void 0 : Number(value2);
      if (!isNaN(newVal) || value2 === "") {
        setCurrentValue(newVal);
      }
      data.userInput = null;
    };
    watch(() => props2.modelValue, (value2) => {
      let newVal = value2 === void 0 ? value2 : Number(value2);
      if (newVal !== void 0) {
        if (isNaN(newVal))
          return;
        if (props2.stepStrictly) {
          const stepPrecision = getPrecision(props2.step);
          const precisionFactor = Math.pow(10, stepPrecision);
          newVal = Math.round(newVal / props2.step) * precisionFactor * props2.step / precisionFactor;
        }
        if (props2.precision !== void 0) {
          newVal = toPrecision(newVal, props2.precision);
        }
      }
      if (newVal !== void 0 && newVal >= props2.max) {
        newVal = props2.max;
        emit2("update:modelValue", newVal);
      }
      if (newVal !== void 0 && newVal <= props2.min) {
        newVal = props2.min;
        emit2("update:modelValue", newVal);
      }
      data.currentValue = newVal;
      data.userInput = null;
    }, { immediate: true });
    onMounted(() => {
      let innerInput = input2.value.input;
      innerInput.setAttribute("role", "spinbutton");
      innerInput.setAttribute("aria-valuemax", props2.max);
      innerInput.setAttribute("aria-valuemin", props2.min);
      innerInput.setAttribute("aria-valuenow", data.currentValue);
      innerInput.setAttribute("aria-disabled", inputNumberDisabled.value);
      if (toRawType(props2.modelValue) !== "Number" && props2.modelValue !== void 0) {
        emit2("update:modelValue", void 0);
      }
    });
    onUpdated(() => {
      let innerInput = input2.value.input;
      innerInput.setAttribute("aria-valuenow", data.currentValue);
    });
    return {
      input: input2,
      displayValue,
      handleInput,
      handleInputChange,
      controlsAtRight,
      decrease,
      increase,
      inputNumberSize,
      inputNumberDisabled,
      maxDisabled,
      minDisabled
    };
  }
});
function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _directive_repeat_click = resolveDirective("repeat-click");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      "el-input-number",
      _ctx.inputNumberSize ? "el-input-number--" + _ctx.inputNumberSize : "",
      { "is-disabled": _ctx.inputNumberDisabled },
      { "is-without-controls": !_ctx.controls },
      { "is-controls-right": _ctx.controlsAtRight }
    ]),
    onDragstart: _cache[4] || (_cache[4] = withModifiers(() => {
    }, ["prevent"]))
  }, [
    _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(["el-input-number__decrease", { "is-disabled": _ctx.minDisabled }]),
      role: "button",
      onKeydown: _cache[0] || (_cache[0] = withKeys((...args) => _ctx.decrease && _ctx.decrease(...args), ["enter"]))
    }, [
      createElementVNode("i", {
        class: normalizeClass(`el-icon-${_ctx.controlsAtRight ? "arrow-down" : "minus"}`)
      }, null, 2)
    ], 34)), [
      [_directive_repeat_click, _ctx.decrease]
    ]) : createCommentVNode("v-if", true),
    _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass(["el-input-number__increase", { "is-disabled": _ctx.maxDisabled }]),
      role: "button",
      onKeydown: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.increase && _ctx.increase(...args), ["enter"]))
    }, [
      createElementVNode("i", {
        class: normalizeClass(`el-icon-${_ctx.controlsAtRight ? "arrow-up" : "plus"}`)
      }, null, 2)
    ], 34)), [
      [_directive_repeat_click, _ctx.increase]
    ]) : createCommentVNode("v-if", true),
    createVNode(_component_el_input, {
      ref: "input",
      "model-value": _ctx.displayValue,
      placeholder: _ctx.placeholder,
      disabled: _ctx.inputNumberDisabled,
      size: _ctx.inputNumberSize,
      max: _ctx.max,
      min: _ctx.min,
      name: _ctx.name,
      label: _ctx.label,
      onKeydown: [
        withKeys(withModifiers(_ctx.increase, ["prevent"]), ["up"]),
        withKeys(withModifiers(_ctx.decrease, ["prevent"]), ["down"])
      ],
      onBlur: _cache[2] || (_cache[2] = (event2) => _ctx.$emit("blur", event2)),
      onFocus: _cache[3] || (_cache[3] = (event2) => _ctx.$emit("focus", event2)),
      onInput: _ctx.handleInput,
      onChange: _ctx.handleInputChange
    }, null, 8, ["model-value", "placeholder", "disabled", "size", "max", "min", "name", "label", "onKeydown", "onInput", "onChange"])
  ], 34);
}
script$q.render = render$p;
script$q.__file = "packages/components/input-number/src/workprogress.vue";
script$q.install = (app) => {
  app.component(script$q.name, script$q);
};
const _InputNumber = script$q;
const ElInputNumber = _InputNumber;
var script$p = defineComponent({
  name: "ElLink",
  props: {
    type: {
      type: String,
      default: "default",
      validator: (val) => {
        return ["default", "primary", "success", "warning", "info", "danger"].includes(val);
      }
    },
    underline: {
      type: Boolean,
      default: true
    },
    disabled: { type: Boolean, default: false },
    href: { type: String, default: "" },
    icon: { type: String, default: "" }
  },
  emits: ["click"],
  setup(props2, { emit: emit2 }) {
    function handleClick(event2) {
      if (!props2.disabled) {
        emit2("click", event2);
      }
    }
    return {
      handleClick
    };
  }
});
const _hoisted_1$N = ["href"];
const _hoisted_2$G = {
  key: 1,
  class: "el-link--inner"
};
function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("a", {
    class: normalizeClass([
      "el-link",
      _ctx.type ? `el-link--${_ctx.type}` : "",
      _ctx.disabled && "is-disabled",
      _ctx.underline && !_ctx.disabled && "is-underline"
    ]),
    href: _ctx.disabled || !_ctx.href ? null : _ctx.href,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.icon ? (openBlock(), createElementBlock("i", {
      key: 0,
      class: normalizeClass(_ctx.icon)
    }, null, 2)) : createCommentVNode("v-if", true),
    _ctx.$slots.default ? (openBlock(), createElementBlock("span", _hoisted_2$G, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("v-if", true),
    _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 2 }) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$N);
}
script$p.render = render$o;
script$p.__file = "packages/components/link/src/workprogress.vue";
script$p.install = (app) => {
  app.component(script$p.name, script$p);
};
const _Link = script$p;
const ElLink = _Link;
class SubMenu {
  constructor(parent2, domNode) {
    this.parent = parent2;
    this.domNode = domNode;
    this.subIndex = 0;
    this.subIndex = 0;
    this.init();
  }
  init() {
    this.subMenuItems = this.domNode.querySelectorAll("li");
    this.addListeners();
  }
  gotoSubIndex(idx) {
    if (idx === this.subMenuItems.length) {
      idx = 0;
    } else if (idx < 0) {
      idx = this.subMenuItems.length - 1;
    }
    this.subMenuItems[idx].focus();
    this.subIndex = idx;
  }
  addListeners() {
    const parentNode = this.parent.domNode;
    Array.prototype.forEach.call(this.subMenuItems, (el) => {
      el.addEventListener("keydown", (event2) => {
        let prevDef = false;
        switch (event2.code) {
          case EVENT_CODE.down: {
            this.gotoSubIndex(this.subIndex + 1);
            prevDef = true;
            break;
          }
          case EVENT_CODE.up: {
            this.gotoSubIndex(this.subIndex - 1);
            prevDef = true;
            break;
          }
          case EVENT_CODE.tab: {
            triggerEvent(parentNode, "mouseleave");
            break;
          }
          case EVENT_CODE.enter:
          case EVENT_CODE.space: {
            prevDef = true;
            event2.currentTarget.click();
            break;
          }
        }
        if (prevDef) {
          event2.preventDefault();
          event2.stopPropagation();
        }
        return false;
      });
    });
  }
}
var SubMenu$1 = SubMenu;
class MenuItem {
  constructor(domNode) {
    this.domNode = domNode;
    this.submenu = null;
    this.submenu = null;
    this.init();
  }
  init() {
    this.domNode.setAttribute("tabindex", "0");
    const menuChild = this.domNode.querySelector(".el-menu");
    if (menuChild) {
      this.submenu = new SubMenu$1(this, menuChild);
    }
    this.addListeners();
  }
  addListeners() {
    this.domNode.addEventListener("keydown", (event2) => {
      let prevDef = false;
      switch (event2.code) {
        case EVENT_CODE.down: {
          triggerEvent(event2.currentTarget, "mouseenter");
          this.submenu && this.submenu.gotoSubIndex(0);
          prevDef = true;
          break;
        }
        case EVENT_CODE.up: {
          triggerEvent(event2.currentTarget, "mouseenter");
          this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
          prevDef = true;
          break;
        }
        case EVENT_CODE.tab: {
          triggerEvent(event2.currentTarget, "mouseleave");
          break;
        }
        case EVENT_CODE.enter:
        case EVENT_CODE.space: {
          prevDef = true;
          event2.currentTarget.click();
          break;
        }
      }
      if (prevDef) {
        event2.preventDefault();
      }
    });
  }
}
var MenuItem$1 = MenuItem;
class Menu {
  constructor(domNode) {
    this.domNode = domNode;
    this.init();
  }
  init() {
    const menuChildren = this.domNode.childNodes;
    [].filter.call(menuChildren, (child) => child.nodeType === 1).forEach((child) => {
      new MenuItem$1(child);
    });
  }
}
var Menubar = Menu;
var __defProp$c = Object.defineProperty;
var __defProps$b = Object.defineProperties;
var __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key, value2) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$c = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$c.call(b, prop))
      __defNormalProp$c(a, prop, b[prop]);
  if (__getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(b)) {
      if (__propIsEnum$c.call(b, prop))
        __defNormalProp$c(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$b = (a, b) => __defProps$b(a, __getOwnPropDescs$b(b));
var Tooltip = defineComponent({
  name: "ElTooltip",
  components: {
    ElPopper: ElPopper$1
  },
  props: __spreadProps$b(__spreadValues$c({}, defaultProps$4), {
    manual: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: Boolean,
      validator: (val) => {
        return typeof val === "boolean";
      },
      default: void 0
    },
    openDelay: {
      type: Number,
      default: 0
    },
    visibleArrow: {
      type: Boolean,
      default: true
    },
    tabindex: {
      type: [String, Number],
      default: "0"
    }
  }),
  emits: [UPDATE_MODEL_EVENT],
  setup(props2, ctx2) {
    if (props2.manual && typeof props2.modelValue === "undefined") {
      throwError("[ElTooltip]", "You need to pass a v-model to el-tooltip when `manual` is true");
    }
    const popper2 = ref(null);
    const onUpdateVisible = (val) => {
      ctx2.emit(UPDATE_MODEL_EVENT, val);
    };
    const updatePopper = () => {
      return popper2.value.update();
    };
    return {
      popper: popper2,
      onUpdateVisible,
      updatePopper
    };
  },
  render() {
    const {
      $slots,
      content,
      manual,
      openDelay,
      onUpdateVisible,
      showAfter,
      visibleArrow,
      modelValue,
      tabindex
    } = this;
    const throwErrorTip = () => {
      throwError("[ElTooltip]", "you need to provide a valid default slot.");
    };
    const popper2 = h(ElPopper$1, __spreadProps$b(__spreadValues$c({}, Object.keys(defaultProps$4).reduce((result, key) => {
      return __spreadProps$b(__spreadValues$c({}, result), { [key]: this[key] });
    }, {})), {
      ref: "popper",
      manualMode: manual,
      showAfter: openDelay || showAfter,
      showArrow: visibleArrow,
      visible: modelValue,
      "onUpdate:visible": onUpdateVisible
    }), {
      default: () => $slots.content ? $slots.content() : content,
      trigger: () => {
        if ($slots.default) {
          const firstVnode = getFirstValidNode($slots.default(), 1);
          if (!firstVnode)
            throwErrorTip();
          return cloneVNode(firstVnode, { tabindex }, true);
        }
        throwErrorTip();
      }
    });
    return popper2;
  }
});
Tooltip.install = (app) => {
  app.component(Tooltip.name, Tooltip);
};
const _Tooltip = Tooltip;
const ElTooltip = _Tooltip;
var script$o = defineComponent({
  name: "ElMenuCollapseTransition",
  setup() {
    return {
      on: {
        beforeEnter(el) {
          el.style.opacity = "0.2";
        },
        enter(el, done) {
          addClass$1(el, "el-opacity-transition");
          el.style.opacity = "1";
          done();
        },
        afterEnter(el) {
          removeClass(el, "el-opacity-transition");
          el.style.opacity = "";
        },
        beforeLeave(el) {
          if (!el.dataset) {
            el.dataset = {};
          }
          if (hasClass(el, "el-menu--collapse")) {
            removeClass(el, "el-menu--collapse");
            el.dataset.oldOverflow = el.style.overflow;
            el.dataset.scrollWidth = el.clientWidth.toString();
            addClass$1(el, "el-menu--collapse");
          } else {
            addClass$1(el, "el-menu--collapse");
            el.dataset.oldOverflow = el.style.overflow;
            el.dataset.scrollWidth = el.clientWidth.toString();
            removeClass(el, "el-menu--collapse");
          }
          el.style.width = el.scrollWidth + "px";
          el.style.overflow = "hidden";
        },
        leave(el) {
          addClass$1(el, "horizontal-collapse-transition");
          el.style.width = el.dataset.scrollWidth + "px";
        }
      }
    };
  }
});
function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ mode: "out-in" }, toHandlers(_ctx.on)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
script$o.render = render$n;
script$o.__file = "packages/components/menu/src/menu-collapse-transition.vue";
function useMenuColor(props2) {
  const menuBarColor = computed(() => {
    const color = props2.backgroundColor;
    if (!color) {
      return "";
    } else {
      return mixColor(color);
    }
  });
  function calcColorChannels(c) {
    let rawColor = c.replace("#", "");
    if (/^[0-9a-fA-F]{3}$/.test(rawColor)) {
      const color = rawColor.split("");
      for (let i2 = 2; i2 >= 0; i2--) {
        color.splice(i2, 0, color[i2]);
      }
      rawColor = color.join("");
    }
    if (/^[0-9a-fA-F]{6}$/.test(rawColor)) {
      return {
        red: parseInt(rawColor.slice(0, 2), 16),
        green: parseInt(rawColor.slice(2, 4), 16),
        blue: parseInt(rawColor.slice(4, 6), 16)
      };
    } else {
      return {
        red: 255,
        green: 255,
        blue: 255
      };
    }
  }
  function mixColor(color, percent = 0.2) {
    let { red, green, blue } = calcColorChannels(color);
    if (percent > 0) {
      red *= 1 - percent;
      green *= 1 - percent;
      blue *= 1 - percent;
    } else {
      red += (255 - red) * percent;
      green += (255 - green) * percent;
      blue += (255 - blue) * percent;
    }
    return `rgb(${Math.round(red)}, ${Math.round(green)}, ${Math.round(blue)})`;
  }
  return menuBarColor;
}
var script$1$e = defineComponent({
  name: "ElMenu",
  componentName: "ElMenu",
  components: {
    ElMenuCollapseTransition: script$o
  },
  props: {
    mode: {
      type: String,
      default: "vertical"
    },
    defaultActive: {
      type: String,
      default: ""
    },
    defaultOpeneds: Array,
    uniqueOpened: Boolean,
    router: Boolean,
    menuTrigger: {
      type: String,
      default: "hover"
    },
    collapse: Boolean,
    backgroundColor: { type: String },
    textColor: { type: String },
    activeTextColor: { type: String },
    collapseTransition: {
      type: Boolean,
      default: true
    }
  },
  emits: ["close", "open", "select"],
  setup(props2, ctx2) {
    const openedMenus = ref(props2.defaultOpeneds && !props2.collapse ? props2.defaultOpeneds.slice(0) : []);
    const instance = getCurrentInstance();
    const activeIndex = ref(props2.defaultActive);
    const items = ref({});
    const submenus = ref({});
    const alteredCollapse = ref(false);
    const rootMenuEmitter = mitt();
    const router = instance.appContext.config.globalProperties.$router;
    const hoverBackground = useMenuColor(props2);
    const isMenuPopup = computed(() => {
      return props2.mode === "horizontal" || props2.mode === "vertical" && props2.collapse;
    });
    const initializeMenu = () => {
      const index2 = activeIndex.value;
      const activeItem = items.value[index2];
      if (!activeItem || props2.mode === "horizontal" || props2.collapse)
        return;
      let indexPath = activeItem.indexPath;
      indexPath.forEach((index22) => {
        let submenu = submenus.value[index22];
        submenu && openMenu(index22, submenu == null ? void 0 : submenu.indexPath);
      });
    };
    const addSubMenu = (item) => {
      submenus.value[item.index] = item;
    };
    const removeSubMenu = (item) => {
      delete submenus.value[item.index];
    };
    const addMenuItem = (item) => {
      items.value[item.index] = item;
    };
    const removeMenuItem = (item) => {
      delete items.value[item.index];
    };
    const openMenu = (index2, indexPath) => {
      if (openedMenus.value.includes(index2))
        return;
      if (props2.uniqueOpened) {
        openedMenus.value = openedMenus.value.filter((index22) => {
          return (isRef(indexPath) ? indexPath.value : indexPath).indexOf(index22) !== -1;
        });
      }
      openedMenus.value.push(index2);
    };
    const closeMenu = (index2) => {
      const i2 = openedMenus.value.indexOf(index2);
      if (i2 !== -1) {
        openedMenus.value.splice(i2, 1);
      }
    };
    const open = (index2) => {
      const { indexPath } = submenus.value[index2.toString()];
      indexPath.forEach((i2) => openMenu(i2, indexPath));
    };
    const close2 = (index2) => {
      closeMenu(index2);
    };
    const handleSubMenuClick = (submenu) => {
      const { index: index2, indexPath } = submenu;
      let isOpened = openedMenus.value.includes(index2);
      if (isOpened) {
        closeMenu(index2);
        ctx2.emit("close", index2, indexPath.value);
      } else {
        openMenu(index2, indexPath);
        ctx2.emit("open", index2, indexPath.value);
      }
    };
    const handleItemClick = (item) => {
      const { index: index2, indexPath } = item;
      const hasIndex = item.index !== null;
      const emitParams = [index2, indexPath.value, item];
      if (props2.mode === "horizontal" || props2.collapse) {
        openedMenus.value = [];
      }
      if (!hasIndex) {
        return;
      }
      if (props2.router && router) {
        let route = item.route || item.index;
        const routerResult = router.push(route).then((navigationResult) => {
          if (!navigationResult) {
            activeIndex.value = item.index;
          }
          return navigationResult;
        });
        ctx2.emit("select", ...emitParams.concat(routerResult));
      } else {
        activeIndex.value = item.index;
        ctx2.emit("select", ...emitParams);
      }
    };
    const updateActiveIndex = (val) => {
      const itemsInData = items.value;
      const item = itemsInData[val] || itemsInData[activeIndex.value] || itemsInData[props2.defaultActive];
      if (item) {
        activeIndex.value = item.index;
        initializeMenu();
      } else {
        if (!alteredCollapse.value) {
          activeIndex.value = null;
        } else {
          alteredCollapse.value = false;
        }
      }
    };
    watch(() => props2.defaultActive, (currentActive) => {
      if (!items.value[currentActive]) {
        activeIndex.value = "";
      }
      updateActiveIndex(currentActive);
    });
    watch(items.value, () => {
      updateActiveIndex();
    });
    watch(() => props2.collapse, (value2, prev) => {
      if (value2 !== prev) {
        alteredCollapse.value = true;
      }
      if (value2)
        openedMenus.value = [];
      rootMenuEmitter.emit("rootMenu:toggle-collapse", Boolean(props2.collapse));
    });
    provide("rootMenu", {
      props: props2,
      openedMenus,
      items,
      submenus,
      hoverBackground,
      activeIndex,
      isMenuPopup,
      methods: {
        addMenuItem,
        removeMenuItem,
        addSubMenu,
        removeSubMenu,
        openMenu,
        closeMenu
      },
      rootMenuEmit: rootMenuEmitter.emit,
      rootMenuOn: rootMenuEmitter.on
    });
    provide(`subMenu:${instance.uid}`, {
      addSubMenu,
      removeSubMenu
    });
    onMounted(() => {
      initializeMenu();
      rootMenuEmitter.on("menuItem:item-click", handleItemClick);
      rootMenuEmitter.on("submenu:submenu-click", handleSubMenuClick);
      if (props2.mode === "horizontal") {
        new Menubar(instance.vnode.el);
      }
    });
    return {
      hoverBackground,
      isMenuPopup,
      props: props2,
      open,
      close: close2
    };
  }
});
function render$1$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_menu_collapse_transition = resolveComponent("el-menu-collapse-transition");
  return _ctx.collapseTransition ? (openBlock(), createBlock(_component_el_menu_collapse_transition, { key: 0 }, {
    default: withCtx(() => [
      (openBlock(), createElementBlock("ul", {
        key: +_ctx.collapse,
        role: "menubar",
        style: normalizeStyle({ backgroundColor: _ctx.backgroundColor || "" }),
        class: normalizeClass({
          "el-menu": true,
          "el-menu--horizontal": _ctx.mode === "horizontal",
          "el-menu--collapse": _ctx.collapse
        })
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6))
    ]),
    _: 3
  })) : (openBlock(), createElementBlock("ul", {
    key: +_ctx.collapse,
    role: "menubar",
    style: normalizeStyle({ backgroundColor: _ctx.backgroundColor || "" }),
    class: normalizeClass({
      "el-menu": true,
      "el-menu--horizontal": _ctx.mode === "horizontal",
      "el-menu--collapse": _ctx.collapse
    })
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6));
}
script$1$e.render = render$1$d;
script$1$e.__file = "packages/components/menu/src/menu.vue";
function useMenu(instance, currentIndex) {
  const rootMenu = inject("rootMenu");
  const indexPath = computed(() => {
    let parent2 = instance.parent;
    const path = [currentIndex];
    while (parent2.type.name !== "ElMenu") {
      if (parent2.props.index) {
        path.unshift(parent2.props.index);
      }
      parent2 = parent2.parent;
    }
    return path;
  });
  const parentMenu = computed(() => {
    let parent2 = instance.parent;
    while (parent2 && ["ElMenu", "ElSubMenu"].indexOf(parent2.type.name) === -1) {
      parent2 = parent2.parent;
    }
    return parent2;
  });
  const paddingStyle = computed(() => {
    let parent2 = instance.parent;
    if (rootMenu.props.mode !== "vertical")
      return {};
    let padding = 20;
    if (rootMenu.props.collapse) {
      padding = 20;
    } else {
      while (parent2 && parent2.type.name !== "ElMenu") {
        if (parent2.type.name === "ElSubMenu") {
          padding += 20;
        }
        parent2 = parent2.parent;
      }
    }
    return { paddingLeft: padding + "px" };
  });
  return { parentMenu, paddingStyle, indexPath };
}
var script$2$a = defineComponent({
  name: "ElMenuItem",
  components: { ElTooltip: _Tooltip },
  props: {
    index: {
      type: String,
      default: null
    },
    route: [String, Object],
    disabled: Boolean
  },
  emits: ["click"],
  setup(props2, { emit: emit2, slots }) {
    const instance = getCurrentInstance();
    const rootMenu = inject("rootMenu");
    const { parentMenu, paddingStyle, indexPath } = useMenu(instance, props2.index);
    const { addSubMenu, removeSubMenu } = inject(`subMenu:${parentMenu.value.uid}`);
    const active = computed(() => {
      return props2.index === rootMenu.activeIndex.value;
    });
    const hoverBackground = computed(() => {
      return rootMenu.hoverBackground.value;
    });
    const backgroundColor = computed(() => {
      return rootMenu.props.backgroundColor || "";
    });
    const activeTextColor = computed(() => {
      return rootMenu.props.activeTextColor || "";
    });
    const textColor = computed(() => {
      return rootMenu.props.textColor || "";
    });
    const mode = computed(() => {
      return rootMenu.props.mode;
    });
    const isNested = computed(() => {
      return parentMenu.value.type.name !== "ElMenu";
    });
    const itemStyle = computed(() => {
      const style = {
        color: active.value ? activeTextColor.value : textColor.value,
        borderBottomColor: ""
      };
      if (mode.value === "horizontal" && !isNested.value) {
        style.borderBottomColor = active.value ? rootMenu.props.activeTextColor ? activeTextColor.value : "" : "transparent";
      }
      return style;
    });
    const onMouseEnter = () => {
      if (mode.value === "horizontal" && !rootMenu.props.backgroundColor)
        return;
      instance.vnode.el.style.backgroundColor = hoverBackground.value;
    };
    const onMouseLeave = () => {
      if (mode.value === "horizontal" && !rootMenu.props.backgroundColor)
        return;
      instance.vnode.el.style.backgroundColor = backgroundColor.value;
    };
    const handleClick = () => {
      if (!props2.disabled) {
        rootMenu.rootMenuEmit("menuItem:item-click", {
          index: props2.index,
          indexPath,
          route: props2.route
        });
        emit2("click", {
          index: props2.index,
          indexPath: indexPath.value
        });
      }
    };
    onMounted(() => {
      addSubMenu({ index: props2.index, indexPath, active });
      rootMenu.methods.addMenuItem({ index: props2.index, indexPath, active });
    });
    onBeforeUnmount(() => {
      removeSubMenu({ index: props2.index, indexPath, active });
      rootMenu.methods.removeMenuItem({ index: props2.index, indexPath, active });
    });
    return {
      parentMenu,
      rootMenu,
      slots,
      paddingStyle,
      itemStyle,
      backgroundColor,
      active,
      handleClick,
      onMouseEnter,
      onMouseLeave
    };
  }
});
const _hoisted_1$M = { style: { "position": "absolute", "left": "0", "top": "0", "height": "100%", "width": "100%", "display": "inline-block", "box-sizing": "border-box", "padding": "0 20px" } };
function render$2$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["el-menu-item", {
      "is-active": _ctx.active,
      "is-disabled": _ctx.disabled
    }]),
    role: "menuitem",
    tabindex: "-1",
    style: normalizeStyle([_ctx.paddingStyle, _ctx.itemStyle, { backgroundColor: _ctx.backgroundColor }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
    onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
    onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args))
  }, [
    _ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.slots.title ? (openBlock(), createBlock(_component_el_tooltip, {
      key: 0,
      effect: "dark",
      placement: "right"
    }, {
      content: withCtx(() => [
        renderSlot(_ctx.$slots, "title")
      ]),
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$M, [
          renderSlot(_ctx.$slots, "default")
        ])
      ]),
      _: 3
    })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      renderSlot(_ctx.$slots, "default"),
      renderSlot(_ctx.$slots, "title")
    ], 64))
  ], 38);
}
script$2$a.render = render$2$7;
script$2$a.__file = "packages/components/menu/src/menuItem.vue";
var script$3$6 = defineComponent({
  name: "ElMenuItemGroup",
  componentName: "ElMenuItemGroup",
  props: {
    title: {
      type: String
    }
  },
  setup(props2, { slots }) {
    const data = reactive({
      paddingLeft: 20
    });
    const instance = getCurrentInstance();
    const levelPadding = computed(() => {
      let padding = 20;
      let parent2 = instance.parent;
      if (rootProps.collapse)
        return 20;
      while (parent2 && parent2.type.name !== "ElMenu") {
        if (parent2.type.name === "ElSubMenu") {
          padding += 20;
        }
        parent2 = parent2.parent;
      }
      return padding;
    });
    const { props: rootProps } = inject("rootMenu");
    return {
      data,
      levelPadding,
      props: props2,
      slots
    };
  }
});
const _hoisted_1$1$9 = { class: "el-menu-item-group" };
function render$3$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", _hoisted_1$1$9, [
    createElementVNode("div", {
      class: "el-menu-item-group__title",
      style: normalizeStyle({ paddingLeft: _ctx.levelPadding + "px" })
    }, [
      !_ctx.slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ], 2112)) : renderSlot(_ctx.$slots, "title", { key: 1 })
    ], 4),
    createElementVNode("ul", null, [
      renderSlot(_ctx.$slots, "default")
    ])
  ]);
}
script$3$6.render = render$3$4;
script$3$6.__file = "packages/components/menu/src/menuItemGroup.vue";
var script$4$3 = defineComponent({
  name: "ElSubMenu",
  componentName: "ElSubMenu",
  props: {
    index: {
      type: String,
      required: true
    },
    showTimeout: {
      type: Number,
      default: 300
    },
    hideTimeout: {
      type: Number,
      default: 300
    },
    popperClass: String,
    disabled: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: void 0
    }
  },
  setup(props2) {
    const data = reactive({
      popperJS: null,
      timeout: null,
      items: {},
      submenus: {},
      currentPlacement: "",
      mouseInChild: false,
      opened: false
    });
    const verticalTitleRef = ref(null);
    const popperVnode = ref(null);
    const instance = getCurrentInstance();
    const { paddingStyle, indexPath, parentMenu } = useMenu(instance, props2.index);
    const {
      openedMenus,
      isMenuPopup,
      hoverBackground: rootHoverBackground,
      methods: rootMethods,
      props: rootProps,
      methods: { closeMenu },
      rootMenuOn,
      rootMenuEmit
    } = inject("rootMenu");
    const {
      addSubMenu: parentAddSubMenu,
      removeSubMenu: parentRemoveSubMenu,
      handleMouseleave: parentHandleMouseleave
    } = inject(`subMenu:${parentMenu.value.uid}`);
    const submenuTitleIcon = computed(() => {
      return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootProps.collapse ? "el-icon-arrow-down" : "el-icon-arrow-right";
    });
    const isFirstLevel = computed(() => {
      let isFirstLevel2 = true;
      let parent2 = instance.parent;
      while (parent2 && parent2.type.name !== "ElMenu") {
        if (["ElSubMenu", "ElMenuItemGroup"].includes(parent2.type.name)) {
          isFirstLevel2 = false;
          break;
        } else {
          parent2 = parent2.parent;
        }
      }
      return isFirstLevel2;
    });
    const appendToBody = computed(() => {
      return props2.popperAppendToBody === void 0 ? isFirstLevel.value : Boolean(props2.popperAppendToBody);
    });
    const menuTransitionName = computed(() => {
      return rootProps.collapse ? "el-zoom-in-left" : "el-zoom-in-top";
    });
    const opened = computed(() => {
      return openedMenus.value.includes(props2.index);
    });
    const active = computed(() => {
      let isActive = false;
      const submenus = data.submenus;
      const items = data.items;
      Object.keys(items).forEach((index2) => {
        if (items[index2].active) {
          isActive = true;
        }
      });
      Object.keys(submenus).forEach((index2) => {
        if (submenus[index2].active) {
          isActive = true;
        }
      });
      return isActive;
    });
    const backgroundColor = computed(() => {
      return rootProps.backgroundColor || "";
    });
    const activeTextColor = computed(() => {
      return rootProps.activeTextColor || "";
    });
    const textColor = computed(() => {
      return rootProps.textColor || "";
    });
    const mode = computed(() => {
      return rootProps.mode;
    });
    const titleStyle = computed(() => {
      if (mode.value !== "horizontal") {
        return {
          color: textColor.value
        };
      }
      return {
        borderBottomColor: active.value ? rootProps.activeTextColor ? activeTextColor.value : "" : "transparent",
        color: active.value ? activeTextColor.value : textColor.value
      };
    });
    const subMenuEmitter = mitt();
    const doDestroy = () => {
      var _a;
      (_a = popperVnode.value) == null ? void 0 : _a.doDestroy();
    };
    const handleCollapseToggle = (value2) => {
      if (value2) {
        updatePlacement();
      } else {
        doDestroy();
      }
    };
    const addItem = (item) => {
      data.items[item.index] = item;
    };
    const removeItem = (item) => {
      delete data.items[item.index];
    };
    const addSubMenu = (item) => {
      data.submenus[item.index] = item;
    };
    const removeSubMenu = (item) => {
      delete data.submenus[item.index];
    };
    const handleClick = () => {
      const disabled = props2.disabled;
      if (rootProps.menuTrigger === "hover" && rootProps.mode === "horizontal" || rootProps.collapse && rootProps.mode === "vertical" || disabled) {
        return;
      }
      rootMenuEmit("submenu:submenu-click", { index: props2.index, indexPath });
    };
    const handleMouseenter = (event2, showTimeout = props2.showTimeout) => {
      if (!("ActiveXObject" in window) && event2.type === "focus" && !event2.relatedTarget) {
        return;
      }
      const disabled = props2.disabled;
      if (rootProps.menuTrigger === "click" && rootProps.mode === "horizontal" || !rootProps.collapse && rootProps.mode === "vertical" || disabled) {
        return;
      }
      subMenuEmitter.emit("submenu:mouse-enter-child");
      clearTimeout(data.timeout);
      data.timeout = setTimeout(() => {
        rootMethods.openMenu(props2.index, indexPath);
      }, showTimeout);
      if (appendToBody.value) {
        parentMenu.value.vnode.el.dispatchEvent(new MouseEvent("mouseenter"));
      }
    };
    const handleMouseleave = (deepDispatch = false) => {
      if (rootProps.menuTrigger === "click" && rootProps.mode === "horizontal" || !rootProps.collapse && rootProps.mode === "vertical") {
        return;
      }
      subMenuEmitter.emit("submenu:mouse-leave-child");
      clearTimeout(data.timeout);
      data.timeout = setTimeout(() => {
        !data.mouseInChild && closeMenu(props2.index);
      }, props2.hideTimeout);
      if (appendToBody.value && deepDispatch) {
        if (instance.parent.type.name === "ElSubMenu") {
          parentHandleMouseleave(true);
        }
      }
    };
    const handleTitleMouseenter = () => {
      var _a;
      if (mode.value === "horizontal" && !rootProps.backgroundColor)
        return;
      const title = ((_a = popperVnode.value) == null ? void 0 : _a.triggerRef) || verticalTitleRef.value;
      title && (title.style.backgroundColor = rootHoverBackground.value);
    };
    const handleTitleMouseleave = () => {
      var _a;
      if (mode.value === "horizontal" && !rootProps.backgroundColor)
        return;
      const title = ((_a = popperVnode.value) == null ? void 0 : _a.triggerRef) || verticalTitleRef.value;
      title && (title.style.backgroundColor = rootProps.backgroundColor || "");
    };
    const updatePlacement = () => {
      data.currentPlacement = mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start";
    };
    provide(`subMenu:${instance.uid}`, {
      addSubMenu,
      removeSubMenu,
      handleMouseleave
    });
    onBeforeMount(() => {
      rootMenuOn("rootMenu:toggle-collapse", (val) => {
        handleCollapseToggle(val);
      });
      subMenuEmitter.on("submenu:mouse-enter-child", () => {
        data.mouseInChild = true;
        clearTimeout(data.timeout);
      });
      subMenuEmitter.on("submenu:mouse-leave-child", () => {
        data.mouseInChild = false;
        clearTimeout(data.timeout);
      });
    });
    onMounted(() => {
      rootMethods.addSubMenu({
        index: props2.index,
        indexPath,
        active
      });
      parentAddSubMenu({
        index: props2.index,
        indexPath,
        active
      });
      updatePlacement();
    });
    onBeforeUnmount(() => {
      parentRemoveSubMenu({
        index: props2.index,
        indexPath,
        active
      });
      rootMethods.removeSubMenu({
        index: props2.index,
        indexPath,
        active
      });
    });
    return {
      data,
      props: props2,
      mode,
      active,
      isMenuPopup,
      opened,
      paddingStyle,
      titleStyle,
      backgroundColor,
      rootProps,
      menuTransitionName,
      submenuTitleIcon,
      appendToBody,
      handleClick,
      handleMouseenter,
      handleMouseleave,
      handleTitleMouseenter,
      handleTitleMouseleave,
      addItem,
      removeItem,
      addSubMenu,
      removeSubMenu,
      popperVnode,
      verticalTitleRef
    };
  },
  render() {
    var _a, _b;
    const titleTag = [
      (_b = (_a = this.$slots).title) == null ? void 0 : _b.call(_a),
      h("i", {
        class: ["el-sub-menu__icon-arrow", this.submenuTitleIcon]
      }, null)
    ];
    const ulStyle = {
      backgroundColor: this.rootProps.backgroundColor || ""
    };
    const child = this.isMenuPopup ? h(ElPopper$1, {
      ref: "popperVNode",
      manualMode: true,
      visible: this.opened,
      "onUpdate:visible": (val) => this.opened = val,
      effect: "light",
      pure: true,
      offset: 6,
      showArrow: false,
      popperClass: this.popperClass,
      placement: this.data.currentPlacement,
      appendToBody: this.appendToBody,
      transition: this.menuTransitionName,
      gpuAcceleration: false
    }, {
      default: () => {
        var _a2, _b2;
        return h("div", {
          ref: "menu",
          class: [
            `el-menu--${this.mode}`,
            this.popperClass
          ],
          onMouseenter: ($event) => this.handleMouseenter($event, 100),
          onMouseleave: () => this.handleMouseleave(true),
          onFocus: ($event) => this.handleMouseenter($event, 100)
        }, [
          h("ul", {
            class: [
              "el-menu el-menu--popup",
              `el-menu--popup-${this.data.currentPlacement}`
            ],
            style: ulStyle
          }, [(_b2 = (_a2 = this.$slots).default) == null ? void 0 : _b2.call(_a2)])
        ]);
      },
      trigger: () => h("div", {
        class: "el-sub-menu__title",
        style: [this.paddingStyle, this.titleStyle, { backgroundColor: this.backgroundColor }],
        onClick: this.handleClick,
        onMouseenter: this.handleTitleMouseenter,
        onMouseleave: this.handleTitleMouseleave
      }, titleTag)
    }) : h(Fragment, {}, [
      h("div", {
        class: "el-sub-menu__title",
        style: [this.paddingStyle, this.titleStyle, { backgroundColor: this.backgroundColor }],
        ref: "verticalTitleRef",
        onClick: this.handleClick,
        onMouseenter: this.handleTitleMouseenter,
        onMouseleave: this.handleTitleMouseleave
      }, titleTag),
      h(ElCollapseTransition$1, {}, {
        default: () => {
          var _a2, _b2;
          return withDirectives(h("ul", {
            role: "menu",
            class: "el-menu el-menu--inline",
            style: ulStyle
          }, [(_b2 = (_a2 = this.$slots).default) == null ? void 0 : _b2.call(_a2)]), [[vShow, this.opened]]);
        }
      })
    ]);
    return h("li", {
      class: [
        "el-sub-menu",
        {
          "is-active": this.active,
          "is-opened": this.opened,
          "is-disabled": this.disabled
        }
      ],
      role: "menuitem",
      ariaHaspopup: true,
      ariaExpanded: this.opened,
      onMouseenter: this.handleMouseenter,
      onMouseleave: () => this.handleMouseleave(true),
      onFocus: this.handleMouseenter
    }, [child]);
  }
});
script$4$3.__file = "packages/components/menu/src/submenu.vue";
script$1$e.install = (app) => {
  app.component(script$1$e.name, script$1$e);
  app.component(script$2$a.name, script$2$a);
  app.component(script$3$6.name, script$3$6);
  app.component(script$4$3.name, script$4$3);
};
script$1$e.MenuItem = script$2$a;
script$1$e.MenuItemGroup = script$3$6;
script$1$e.SubMenu = script$4$3;
const _Menu = script$1$e;
const ElMenu = _Menu;
var script$n = defineComponent({
  name: "ElPageHeader",
  props: {
    icon: {
      type: String,
      default: "el-icon-back"
    },
    title: {
      type: String
    },
    content: {
      type: String,
      default: ""
    }
  },
  emits: ["back"],
  setup(_, { emit: emit2 }) {
    const { t } = useLocaleInject();
    function handleClick() {
      emit2("back");
    }
    return {
      handleClick,
      t
    };
  }
});
const _hoisted_1$L = { class: "el-page-header" };
const _hoisted_2$F = {
  key: 0,
  class: "el-page-header__icon"
};
const _hoisted_3$D = { class: "el-page-header__title" };
const _hoisted_4$s = { class: "el-page-header__content" };
function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$L, [
    createElementVNode("div", {
      class: "el-page-header__left",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.icon || _ctx.$slots.icon ? (openBlock(), createElementBlock("div", _hoisted_2$F, [
        renderSlot(_ctx.$slots, "icon", {}, () => [
          createElementVNode("i", {
            class: normalizeClass(_ctx.icon)
          }, null, 2)
        ])
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_3$D, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString(_ctx.title || _ctx.t("el.pageHeader.title")), 1)
        ])
      ])
    ]),
    createElementVNode("div", _hoisted_4$s, [
      renderSlot(_ctx.$slots, "content", {}, () => [
        createTextVNode(toDisplayString(_ctx.content), 1)
      ])
    ])
  ]);
}
script$n.render = render$m;
script$n.__file = "packages/components/page-header/src/workprogress.vue";
script$n.install = (app) => {
  app.component(script$n.name, script$n);
};
const _PageHeader = script$n;
const ElPageHeader = _PageHeader;
const selectGroupKey = "ElSelectGroup";
const selectKey = "ElSelect";
const selectEvents = {
  queryChange: "elOptionQueryChange",
  groupQueryChange: "elOptionGroupQueryChange"
};
function useOption$1(props2, states) {
  const select = inject(selectKey);
  const selectGroup = inject(selectGroupKey, { disabled: false });
  const isObject2 = computed(() => {
    return Object.prototype.toString.call(props2.value).toLowerCase() === "[object object]";
  });
  const itemSelected = computed(() => {
    if (!select.props.multiple) {
      return isEqual2(props2.value, select.props.modelValue);
    } else {
      return contains2(select.props.modelValue, props2.value);
    }
  });
  const limitReached = computed(() => {
    if (select.props.multiple) {
      const modelValue = select.props.modelValue || [];
      return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
    } else {
      return false;
    }
  });
  const currentLabel = computed(() => {
    return props2.label || (isObject2.value ? "" : props2.value);
  });
  const currentValue = computed(() => {
    return props2.value || props2.label || "";
  });
  const isDisabled = computed(() => {
    return props2.disabled || states.groupDisabled || limitReached.value;
  });
  const instance = getCurrentInstance();
  const contains2 = (arr = [], target) => {
    if (!isObject2.value) {
      return arr && arr.indexOf(target) > -1;
    } else {
      const valueKey = select.props.valueKey;
      return arr && arr.some((item) => {
        return getValueByPath(item, valueKey) === getValueByPath(target, valueKey);
      });
    }
  };
  const isEqual2 = (a, b) => {
    if (!isObject2.value) {
      return a === b;
    } else {
      const { valueKey } = select.props;
      return getValueByPath(a, valueKey) === getValueByPath(b, valueKey);
    }
  };
  const hoverItem = () => {
    if (!props2.disabled && !selectGroup.disabled) {
      select.hoverIndex = select.optionsArray.indexOf(instance);
    }
  };
  const queryChange = (query) => {
    const regexp3 = new RegExp(escapeRegexpString(query), "i");
    states.visible = regexp3.test(currentLabel.value) || props2.created;
    if (!states.visible) {
      select.filteredOptionsCount--;
    }
  };
  watch(() => currentLabel.value, () => {
    if (!props2.created && !select.props.remote)
      select.setSelected();
  });
  watch(() => props2.value, (val, oldVal) => {
    const { remote, valueKey } = select.props;
    if (!props2.created && !remote) {
      if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
        return;
      }
      select.setSelected();
    }
  });
  watch(() => selectGroup.disabled, () => {
    states.groupDisabled = selectGroup.disabled;
  }, { immediate: true });
  select.selectEmitter.on(selectEvents.queryChange, queryChange);
  onBeforeUnmount(() => {
    select.selectEmitter.off(selectEvents.queryChange, queryChange);
  });
  return {
    select,
    currentLabel,
    currentValue,
    itemSelected,
    isDisabled,
    hoverItem
  };
}
var script$m = defineComponent({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: true,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const states = reactive({
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    });
    const {
      currentLabel,
      itemSelected,
      isDisabled,
      select,
      hoverItem
    } = useOption$1(props2, states);
    const {
      visible: visible2,
      hover
    } = toRefs(states);
    const vm = getCurrentInstance().proxy;
    const key = vm.value;
    select.onOptionCreate(vm);
    onBeforeUnmount(() => {
      const { selected } = select;
      let selectedOptions = select.props.multiple ? selected : [selected];
      const doesExist = select.cachedOptions.has(key);
      const doesSelected = selectedOptions.some((item) => {
        return item.value === vm.value;
      });
      if (doesExist && !doesSelected) {
        select.cachedOptions.delete(key);
      }
      select.onOptionDestroy(key);
    });
    function selectOptionClick() {
      if (props2.disabled !== true && states.groupDisabled !== true) {
        select.handleOptionSelect(vm, true);
      }
    }
    return {
      currentLabel,
      itemSelected,
      isDisabled,
      select,
      hoverItem,
      visible: visible2,
      hover,
      selectOptionClick
    };
  }
});
function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("li", {
    class: normalizeClass(["el-select-dropdown__item", {
      "selected": _ctx.itemSelected,
      "is-disabled": _ctx.isDisabled,
      "hover": _ctx.hover
    }]),
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
    onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createElementVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
    ])
  ], 34)), [
    [vShow, _ctx.visible]
  ]);
}
script$m.render = render$l;
script$m.__file = "packages/components/select/src/option.vue";
var script$1$d = defineComponent({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const select = inject(selectKey);
    const popperClass = computed(() => select.props.popperClass);
    const isMultiple = computed(() => select.props.multiple);
    const minWidth = ref("");
    function updateMinWidth() {
      var _a;
      minWidth.value = ((_a = select.selectWrapper) == null ? void 0 : _a.getBoundingClientRect().width) + "px";
    }
    onMounted(() => {
      addResizeListener(select.selectWrapper, updateMinWidth);
    });
    onBeforeUnmount(() => {
      removeResizeListener(select.selectWrapper, updateMinWidth);
    });
    return {
      minWidth,
      popperClass,
      isMultiple
    };
  }
});
function render$1$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-select-dropdown", [{ "is-multiple": _ctx.isMultiple }, _ctx.popperClass]]),
    style: normalizeStyle({ minWidth: _ctx.minWidth })
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
script$1$d.render = render$1$c;
script$1$d.__file = "packages/components/select/src/select-dropdown.vue";
function useSelectStates(props2) {
  const { t } = useLocaleInject();
  const selectEmitter = mitt();
  return reactive({
    options: new Map(),
    cachedOptions: new Map(),
    createdLabel: null,
    createdSelected: false,
    selected: props2.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    initialInputHeight: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: false,
    softFocus: false,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: false,
    cachedPlaceHolder: "",
    currentPlaceholder: t("el.select.placeholder"),
    menuVisibleOnFocus: false,
    isOnComposition: false,
    isSilentBlur: false,
    selectEmitter,
    prefixWidth: null,
    tagInMultiLine: false
  });
}
const useSelect$1 = (props2, states, ctx2) => {
  const ELEMENT = useGlobalConfig();
  const { t } = useLocaleInject();
  const reference2 = ref(null);
  const input2 = ref(null);
  const popper2 = ref(null);
  const tags2 = ref(null);
  const selectWrapper = ref(null);
  const scrollbar = ref(null);
  const hoverOption = ref(-1);
  const elForm = inject(elFormKey, {});
  const elFormItem = inject(elFormItemKey, {});
  const readonly = computed(() => !props2.filterable || props2.multiple || !isIE() && !isEdge() && !states.visible);
  const selectDisabled = computed(() => props2.disabled || elForm.disabled);
  const showClose = computed(() => {
    const hasValue = props2.multiple ? Array.isArray(props2.modelValue) && props2.modelValue.length > 0 : props2.modelValue !== void 0 && props2.modelValue !== null && props2.modelValue !== "";
    const criteria = props2.clearable && !selectDisabled.value && states.inputHovering && hasValue;
    return criteria;
  });
  const iconClass = computed(() => props2.remote && props2.filterable ? "" : states.visible ? "arrow-up is-reverse" : "arrow-up");
  const debounce2 = computed(() => props2.remote ? 300 : 0);
  const emptyText = computed(() => {
    if (props2.loading) {
      return props2.loadingText || t("el.select.loading");
    } else {
      if (props2.remote && states.query === "" && states.options.size === 0)
        return false;
      if (props2.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
        return props2.noMatchText || t("el.select.noMatch");
      }
      if (states.options.size === 0) {
        return props2.noDataText || t("el.select.noData");
      }
    }
    return null;
  });
  const optionsArray = computed(() => Array.from(states.options.values()));
  const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
  const showNewOption = computed(() => {
    const hasExistingOption = optionsArray.value.filter((option2) => {
      return !option2.created;
    }).some((option2) => {
      return option2.currentLabel === states.query;
    });
    return props2.filterable && props2.allowCreate && states.query !== "" && !hasExistingOption;
  });
  const selectSize = computed(() => props2.size || elFormItem.size || ELEMENT.size);
  const collapseTagSize = computed(() => ["small", "mini"].indexOf(selectSize.value) > -1 ? "mini" : "small");
  const dropMenuVisible = computed(() => states.visible && emptyText.value !== false);
  watch(() => selectDisabled.value, () => {
    nextTick(() => {
      resetInputHeight();
    });
  });
  watch(() => props2.placeholder, (val) => {
    states.cachedPlaceHolder = states.currentPlaceholder = val;
  });
  watch(() => props2.modelValue, (val, oldVal) => {
    var _a;
    if (props2.multiple) {
      resetInputHeight();
      if (val && val.length > 0 || input2.value && states.query !== "") {
        states.currentPlaceholder = "";
      } else {
        states.currentPlaceholder = states.cachedPlaceHolder;
      }
      if (props2.filterable && !props2.reserveKeyword) {
        states.query = "";
        handleQueryChange(states.query);
      }
    }
    setSelected();
    if (props2.filterable && !props2.multiple) {
      states.inputLength = 20;
    }
    if (!isEqual_1(val, oldVal)) {
      (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", val);
    }
  }, {
    flush: "post",
    deep: true
  });
  watch(() => states.visible, (val) => {
    var _a, _b;
    if (!val) {
      input2.value && input2.value.blur();
      states.query = "";
      states.previousQuery = null;
      states.selectedLabel = "";
      states.inputLength = 20;
      states.menuVisibleOnFocus = false;
      resetHoverIndex();
      nextTick(() => {
        if (input2.value && input2.value.value === "" && states.selected.length === 0) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      });
      if (!props2.multiple) {
        if (states.selected) {
          if (props2.filterable && props2.allowCreate && states.createdSelected && states.createdLabel) {
            states.selectedLabel = states.createdLabel;
          } else {
            states.selectedLabel = states.selected.currentLabel;
          }
          if (props2.filterable)
            states.query = states.selectedLabel;
        }
        if (props2.filterable) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      }
    } else {
      (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
      if (props2.filterable) {
        states.filteredOptionsCount = states.optionsCount;
        states.query = props2.remote ? "" : states.selectedLabel;
        if (props2.multiple) {
          input2.value.focus();
        } else {
          if (states.selectedLabel) {
            states.currentPlaceholder = states.selectedLabel;
            states.selectedLabel = "";
          }
        }
        handleQueryChange(states.query);
        if (!props2.multiple && !props2.remote) {
          states.selectEmitter.emit("elOptionQueryChange", "");
          states.selectEmitter.emit("elOptionGroupQueryChange");
        }
      }
    }
    ctx2.emit("visible-change", val);
  });
  watch(() => states.options.entries(), () => {
    var _a, _b, _c;
    if (isServer)
      return;
    (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    if (props2.multiple) {
      resetInputHeight();
    }
    const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
    if ([].indexOf.call(inputs, document.activeElement) === -1) {
      setSelected();
    }
    if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  }, {
    flush: "post"
  });
  watch(() => states.hoverIndex, (val) => {
    if (typeof val === "number" && val > -1) {
      hoverOption.value = optionsArray.value[val] || {};
    }
    optionsArray.value.forEach((option2) => {
      option2.hover = hoverOption.value === option2;
    });
  });
  const resetInputHeight = () => {
    if (props2.collapseTags && !props2.filterable)
      return;
    nextTick(() => {
      var _a, _b;
      if (!reference2.value)
        return;
      const inputChildNodes = reference2.value.$el.childNodes;
      const input22 = [].filter.call(inputChildNodes, (item) => item.tagName === "INPUT")[0];
      const _tags = tags2.value;
      const sizeInMap = states.initialInputHeight || 40;
      input22.style.height = states.selected.length === 0 ? sizeInMap + "px" : Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap) + "px";
      states.tagInMultiLine = parseFloat(input22.style.height) > sizeInMap;
      if (states.visible && emptyText.value !== false) {
        (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
      }
    });
  };
  const handleQueryChange = (val) => {
    if (states.previousQuery === val || states.isOnComposition)
      return;
    if (states.previousQuery === null && (typeof props2.filterMethod === "function" || typeof props2.remoteMethod === "function")) {
      states.previousQuery = val;
      return;
    }
    states.previousQuery = val;
    nextTick(() => {
      var _a, _b;
      if (states.visible)
        (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    });
    states.hoverIndex = -1;
    if (props2.multiple && props2.filterable) {
      nextTick(() => {
        const length = input2.value.length * 15 + 20;
        states.inputLength = props2.collapseTags ? Math.min(50, length) : length;
        managePlaceholder();
        resetInputHeight();
      });
    }
    if (props2.remote && typeof props2.remoteMethod === "function") {
      states.hoverIndex = -1;
      props2.remoteMethod(val);
    } else if (typeof props2.filterMethod === "function") {
      props2.filterMethod(val);
      states.selectEmitter.emit("elOptionGroupQueryChange");
    } else {
      states.filteredOptionsCount = states.optionsCount;
      states.selectEmitter.emit("elOptionQueryChange", val);
      states.selectEmitter.emit("elOptionGroupQueryChange");
    }
    if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  };
  const managePlaceholder = () => {
    if (states.currentPlaceholder !== "") {
      states.currentPlaceholder = input2.value.value ? "" : states.cachedPlaceHolder;
    }
  };
  const checkDefaultFirstOption = () => {
    const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.groupDisabled);
    const userCreatedOption = optionsInDropdown.filter((n) => n.created)[0];
    const firstOriginOption = optionsInDropdown[0];
    states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
  };
  const setSelected = () => {
    var _a;
    if (!props2.multiple) {
      const option2 = getOption(props2.modelValue);
      if ((_a = option2.props) == null ? void 0 : _a.created) {
        states.createdLabel = option2.props.value;
        states.createdSelected = true;
      } else {
        states.createdSelected = false;
      }
      states.selectedLabel = option2.currentLabel;
      states.selected = option2;
      if (props2.filterable)
        states.query = states.selectedLabel;
      return;
    }
    const result = [];
    if (Array.isArray(props2.modelValue)) {
      props2.modelValue.forEach((value2) => {
        result.push(getOption(value2));
      });
    }
    states.selected = result;
    nextTick(() => {
      resetInputHeight();
    });
  };
  const getOption = (value2) => {
    let option2;
    const isObjectValue = toRawType(value2).toLowerCase() === "object";
    const isNull2 = toRawType(value2).toLowerCase() === "null";
    const isUndefined2 = toRawType(value2).toLowerCase() === "undefined";
    for (let i2 = states.cachedOptions.size - 1; i2 >= 0; i2--) {
      const cachedOption = cachedOptionsArray.value[i2];
      const isEqualValue = isObjectValue ? getValueByPath(cachedOption.value, props2.valueKey) === getValueByPath(value2, props2.valueKey) : cachedOption.value === value2;
      if (isEqualValue) {
        option2 = {
          value: value2,
          currentLabel: cachedOption.currentLabel,
          isDisabled: cachedOption.isDisabled
        };
        break;
      }
    }
    if (option2)
      return option2;
    const label = !isObjectValue && !isNull2 && !isUndefined2 ? value2 : "";
    const newOption = {
      value: value2,
      currentLabel: label
    };
    if (props2.multiple) {
      newOption.hitState = false;
    }
    return newOption;
  };
  const resetHoverIndex = () => {
    setTimeout(() => {
      const valueKey = props2.valueKey;
      if (!props2.multiple) {
        states.hoverIndex = optionsArray.value.findIndex((item) => {
          return getValueByPath(item, valueKey) === getValueByPath(states.selected, valueKey);
        });
      } else {
        if (states.selected.length > 0) {
          states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
            return optionsArray.value.findIndex((item) => {
              return getValueByPath(item, valueKey) === getValueByPath(selected, valueKey);
            });
          }));
        } else {
          states.hoverIndex = -1;
        }
      }
    }, 300);
  };
  const handleResize = () => {
    var _a, _b;
    resetInputWidth();
    (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    if (props2.multiple)
      resetInputHeight();
  };
  const resetInputWidth = () => {
    var _a;
    states.inputWidth = (_a = reference2.value) == null ? void 0 : _a.$el.getBoundingClientRect().width;
  };
  const onInputChange = () => {
    if (props2.filterable && states.query !== states.selectedLabel) {
      states.query = states.selectedLabel;
      handleQueryChange(states.query);
    }
  };
  const debouncedOnInputChange = debounce_1(() => {
    onInputChange();
  }, debounce2.value);
  const debouncedQueryChange = debounce_1((e) => {
    handleQueryChange(e.target.value);
  }, debounce2.value);
  const emitChange = (val) => {
    if (!isEqual_1(props2.modelValue, val)) {
      ctx2.emit(CHANGE_EVENT, val);
    }
  };
  const deletePrevTag = (e) => {
    if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
      const value2 = props2.modelValue.slice();
      value2.pop();
      ctx2.emit(UPDATE_MODEL_EVENT, value2);
      emitChange(value2);
    }
    if (e.target.value.length === 1 && props2.modelValue.length === 0) {
      states.currentPlaceholder = states.cachedPlaceHolder;
    }
  };
  const deleteTag = (event2, tag) => {
    const index2 = states.selected.indexOf(tag);
    if (index2 > -1 && !selectDisabled.value) {
      const value2 = props2.modelValue.slice();
      value2.splice(index2, 1);
      ctx2.emit(UPDATE_MODEL_EVENT, value2);
      emitChange(value2);
      ctx2.emit("remove-tag", tag.value);
    }
    event2.stopPropagation();
  };
  const deleteSelected = (event2) => {
    event2.stopPropagation();
    const value2 = props2.multiple ? [] : "";
    if (typeof value2 !== "string") {
      for (const item of states.selected) {
        if (item.isDisabled)
          value2.push(item.value);
      }
    }
    ctx2.emit(UPDATE_MODEL_EVENT, value2);
    emitChange(value2);
    states.visible = false;
    ctx2.emit("clear");
  };
  const handleOptionSelect = (option2, byClick) => {
    if (props2.multiple) {
      const value2 = (props2.modelValue || []).slice();
      const optionIndex = getValueIndex(value2, option2.value);
      if (optionIndex > -1) {
        value2.splice(optionIndex, 1);
      } else if (props2.multipleLimit <= 0 || value2.length < props2.multipleLimit) {
        value2.push(option2.value);
      }
      ctx2.emit(UPDATE_MODEL_EVENT, value2);
      emitChange(value2);
      if (option2.created) {
        states.query = "";
        handleQueryChange("");
        states.inputLength = 20;
      }
      if (props2.filterable)
        input2.value.focus();
    } else {
      ctx2.emit(UPDATE_MODEL_EVENT, option2.value);
      emitChange(option2.value);
      states.visible = false;
    }
    states.isSilentBlur = byClick;
    setSoftFocus();
    if (states.visible)
      return;
    nextTick(() => {
      scrollToOption(option2);
    });
  };
  const getValueIndex = (arr = [], value2) => {
    if (!isObject$b(value2))
      return arr.indexOf(value2);
    const valueKey = props2.valueKey;
    let index2 = -1;
    arr.some((item, i2) => {
      if (getValueByPath(item, valueKey) === getValueByPath(value2, valueKey)) {
        index2 = i2;
        return true;
      }
      return false;
    });
    return index2;
  };
  const setSoftFocus = () => {
    states.softFocus = true;
    const _input = input2.value || reference2.value;
    if (_input) {
      _input.focus();
    }
  };
  const scrollToOption = (option2) => {
    var _a, _b, _c, _d;
    const targetOption = Array.isArray(option2) ? option2[0] : option2;
    let target = null;
    if (targetOption == null ? void 0 : targetOption.value) {
      const options2 = optionsArray.value.filter((item) => item.value === targetOption.value);
      if (options2.length > 0) {
        target = options2[0].$el;
      }
    }
    if (popper2.value && target) {
      const menu = (_c = (_b = (_a = popper2.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.querySelector) == null ? void 0 : _c.call(_b, ".el-select-dropdown__wrap");
      if (menu) {
        scrollIntoView$1(menu, target);
      }
    }
    (_d = scrollbar.value) == null ? void 0 : _d.handleScroll();
  };
  const onOptionCreate = (vm) => {
    states.optionsCount++;
    states.filteredOptionsCount++;
    states.options.set(vm.value, vm);
    states.cachedOptions.set(vm.value, vm);
  };
  const onOptionDestroy = (key) => {
    states.optionsCount--;
    states.filteredOptionsCount--;
    states.options.delete(key);
  };
  const resetInputState = (e) => {
    if (e.code !== EVENT_CODE.backspace)
      toggleLastOptionHitState(false);
    states.inputLength = input2.value.length * 15 + 20;
    resetInputHeight();
  };
  const toggleLastOptionHitState = (hit) => {
    if (!Array.isArray(states.selected))
      return;
    const option2 = states.selected[states.selected.length - 1];
    if (!option2)
      return;
    if (hit === true || hit === false) {
      option2.hitState = hit;
      return hit;
    }
    option2.hitState = !option2.hitState;
    return option2.hitState;
  };
  const handleComposition = (event2) => {
    const text = event2.target.value;
    if (event2.type === "compositionend") {
      states.isOnComposition = false;
      nextTick(() => handleQueryChange(text));
    } else {
      const lastCharacter = text[text.length - 1] || "";
      states.isOnComposition = !isKorean(lastCharacter);
    }
  };
  const handleMenuEnter = () => {
    nextTick(() => scrollToOption(states.selected));
  };
  const handleFocus = (event2) => {
    if (!states.softFocus) {
      if (props2.automaticDropdown || props2.filterable) {
        states.visible = true;
        if (props2.filterable) {
          states.menuVisibleOnFocus = true;
        }
      }
      ctx2.emit("focus", event2);
    } else {
      states.softFocus = false;
    }
  };
  const blur = () => {
    states.visible = false;
    reference2.value.blur();
  };
  const handleBlur = (event2) => {
    nextTick(() => {
      if (states.isSilentBlur) {
        states.isSilentBlur = false;
      } else {
        ctx2.emit("blur", event2);
      }
    });
    states.softFocus = false;
  };
  const handleClearClick = (event2) => {
    deleteSelected(event2);
  };
  const handleClose = () => {
    states.visible = false;
  };
  const toggleMenu = () => {
    if (props2.automaticDropdown)
      return;
    if (!selectDisabled.value) {
      if (states.menuVisibleOnFocus) {
        states.menuVisibleOnFocus = false;
      } else {
        states.visible = !states.visible;
      }
      if (states.visible) {
        (input2.value || reference2.value).focus();
      }
    }
  };
  const selectOption = () => {
    if (!states.visible) {
      toggleMenu();
    } else {
      if (optionsArray.value[states.hoverIndex]) {
        handleOptionSelect(optionsArray.value[states.hoverIndex], void 0);
      }
    }
  };
  const getValueKey = (item) => {
    return isObject$b(item.value) ? getValueByPath(item.value, props2.valueKey) : item.value;
  };
  const optionsAllDisabled = computed(() => optionsArray.value.filter((option2) => option2.visible).every((option2) => option2.disabled));
  const navigateOptions = (direction) => {
    if (!states.visible) {
      states.visible = true;
      return;
    }
    if (states.options.size === 0 || states.filteredOptionsCount === 0)
      return;
    if (!optionsAllDisabled.value) {
      if (direction === "next") {
        states.hoverIndex++;
        if (states.hoverIndex === states.options.size) {
          states.hoverIndex = 0;
        }
      } else if (direction === "prev") {
        states.hoverIndex--;
        if (states.hoverIndex < 0) {
          states.hoverIndex = states.options.size - 1;
        }
      }
      const option2 = optionsArray.value[states.hoverIndex];
      if (option2.disabled === true || option2.groupDisabled === true || !option2.visible) {
        navigateOptions(direction);
      }
      nextTick(() => scrollToOption(hoverOption.value));
    }
  };
  return {
    optionsArray,
    selectSize,
    handleResize,
    debouncedOnInputChange,
    debouncedQueryChange,
    deletePrevTag,
    deleteTag,
    deleteSelected,
    handleOptionSelect,
    scrollToOption,
    readonly,
    resetInputHeight,
    showClose,
    iconClass,
    showNewOption,
    collapseTagSize,
    setSelected,
    managePlaceholder,
    selectDisabled,
    emptyText,
    toggleLastOptionHitState,
    resetInputState,
    handleComposition,
    onOptionCreate,
    onOptionDestroy,
    handleMenuEnter,
    handleFocus,
    blur,
    handleBlur,
    handleClearClick,
    handleClose,
    toggleMenu,
    selectOption,
    getValueKey,
    navigateOptions,
    dropMenuVisible,
    reference: reference2,
    input: input2,
    popper: popper2,
    tags: tags2,
    selectWrapper,
    scrollbar
  };
};
var script$2$9 = defineComponent({
  name: "ElSelect",
  componentName: "ElSelect",
  components: {
    ElInput: ElInput$1,
    ElSelectMenu: script$1$d,
    ElOption: script$m,
    ElTag: ElTag$1,
    ElScrollbar: _Scrollbar,
    ElPopper: ElPopper$1
  },
  directives: { ClickOutside: ClickOutside$1 },
  props: {
    name: String,
    id: String,
    modelValue: [Array, String, Number, Boolean, Object],
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: Boolean,
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: true
    },
    clearIcon: {
      type: String,
      default: "el-icon-circle-close"
    }
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, "remove-tag", "clear", "visible-change", "focus", "blur"],
  setup(props2, ctx2) {
    const { t } = useLocaleInject();
    const states = useSelectStates(props2);
    const {
      optionsArray,
      selectSize,
      readonly,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      setSelected,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconClass,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      onOptionCreate,
      onOptionDestroy,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      reference: reference2,
      input: input2,
      popper: popper2,
      tags: tags2,
      selectWrapper,
      scrollbar
    } = useSelect$1(props2, states, ctx2);
    const { focus } = useFocus(reference2);
    const {
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible: visible2,
      softFocus,
      selectedLabel,
      hoverIndex,
      query,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options: options2,
      cachedOptions,
      optionsCount,
      prefixWidth,
      tagInMultiLine
    } = toRefs(states);
    provide(selectKey, reactive({
      props: props2,
      options: options2,
      optionsArray,
      cachedOptions,
      optionsCount,
      filteredOptionsCount,
      hoverIndex,
      handleOptionSelect,
      selectEmitter: states.selectEmitter,
      onOptionCreate,
      onOptionDestroy,
      selectWrapper,
      selected,
      setSelected
    }));
    onMounted(() => {
      states.cachedPlaceHolder = currentPlaceholder.value = props2.placeholder || t("el.select.placeholder");
      if (props2.multiple && Array.isArray(props2.modelValue) && props2.modelValue.length > 0) {
        currentPlaceholder.value = "";
      }
      addResizeListener(selectWrapper.value, handleResize);
      if (reference2.value && reference2.value.$el) {
        const sizeMap = {
          medium: 36,
          small: 32,
          mini: 28
        };
        const input22 = reference2.value.input;
        states.initialInputHeight = input22.getBoundingClientRect().height || sizeMap[selectSize.value];
      }
      if (props2.remote && props2.multiple) {
        resetInputHeight();
      }
      nextTick(() => {
        if (reference2.value.$el) {
          inputWidth.value = reference2.value.$el.getBoundingClientRect().width;
        }
        if (ctx2.slots.prefix) {
          const inputChildNodes = reference2.value.$el.childNodes;
          const input22 = [].filter.call(inputChildNodes, (item) => item.tagName === "INPUT")[0];
          const prefix = reference2.value.$el.querySelector(".el-input__prefix");
          prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 5, 30);
          if (states.prefixWidth) {
            input22.style.paddingLeft = `${Math.max(states.prefixWidth, 30)}px`;
          }
        }
      });
      setSelected();
    });
    onBeforeUnmount(() => {
      removeResizeListener(selectWrapper.value, handleResize);
    });
    if (props2.multiple && !Array.isArray(props2.modelValue)) {
      ctx2.emit(UPDATE_MODEL_EVENT, []);
    }
    if (!props2.multiple && Array.isArray(props2.modelValue)) {
      ctx2.emit(UPDATE_MODEL_EVENT, "");
    }
    const popperPaneRef = computed(() => {
      var _a;
      return (_a = popper2.value) == null ? void 0 : _a.popperRef;
    });
    return {
      tagInMultiLine,
      prefixWidth,
      selectSize,
      readonly,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible: visible2,
      softFocus,
      selectedLabel,
      hoverIndex,
      query,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options: options2,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconClass,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      focus,
      reference: reference2,
      input: input2,
      popper: popper2,
      popperPaneRef,
      tags: tags2,
      selectWrapper,
      scrollbar
    };
  }
});
const _hoisted_1$K = { class: "select-trigger" };
const _hoisted_2$E = { key: 0 };
const _hoisted_3$C = { class: "el-select__tags-text" };
const _hoisted_4$r = ["disabled", "autocomplete"];
const _hoisted_5$m = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
const _hoisted_6$j = {
  key: 1,
  class: "el-select-dropdown__empty"
};
function render$2$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_option = resolveComponent("el-option");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_select_menu = resolveComponent("el-select-menu");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_click_outside = resolveDirective("click-outside");
  return withDirectives((openBlock(), createElementBlock("div", {
    ref: "selectWrapper",
    class: normalizeClass(["el-select", [_ctx.selectSize ? "el-select--" + _ctx.selectSize : ""]]),
    onClick: _cache[25] || (_cache[25] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
  }, [
    createVNode(_component_el_popper, {
      ref: "popper",
      visible: _ctx.dropMenuVisible,
      "onUpdate:visible": _cache[24] || (_cache[24] = ($event) => _ctx.dropMenuVisible = $event),
      placement: "bottom-start",
      "append-to-body": _ctx.popperAppendToBody,
      "popper-class": `el-select__popper ${_ctx.popperClass}`,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      "manual-mode": "",
      effect: "light",
      pure: "",
      trigger: "click",
      transition: "el-zoom-in-top",
      "stop-popper-mouse-event": false,
      "gpu-acceleration": false,
      onBeforeEnter: _ctx.handleMenuEnter
    }, {
      trigger: withCtx(() => [
        createElementVNode("div", _hoisted_1$K, [
          _ctx.multiple ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref: "tags",
            class: "el-select__tags",
            style: normalizeStyle({ "max-width": _ctx.inputWidth - 32 + "px", width: "100%" })
          }, [
            _ctx.collapseTags && _ctx.selected.length ? (openBlock(), createElementBlock("span", _hoisted_2$E, [
              createVNode(_component_el_tag, {
                closable: !_ctx.selectDisabled && !_ctx.selected[0].isDisabled,
                size: _ctx.collapseTagSize,
                hit: _ctx.selected[0].hitState,
                type: "info",
                "disable-transitions": "",
                onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.selected[0]))
              }, {
                default: withCtx(() => [
                  createElementVNode("span", {
                    class: "el-select__tags-text",
                    style: normalizeStyle({ "max-width": _ctx.inputWidth - 123 + "px" })
                  }, toDisplayString(_ctx.selected[0].currentLabel), 5)
                ]),
                _: 1
              }, 8, ["closable", "size", "hit"]),
              _ctx.selected.length > 1 ? (openBlock(), createBlock(_component_el_tag, {
                key: 0,
                closable: false,
                size: _ctx.collapseTagSize,
                type: "info",
                "disable-transitions": ""
              }, {
                default: withCtx(() => [
                  createElementVNode("span", _hoisted_3$C, "+ " + toDisplayString(_ctx.selected.length - 1), 1)
                ]),
                _: 1
              }, 8, ["size"])) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true),
            createCommentVNode(" <div> "),
            !_ctx.collapseTags ? (openBlock(), createBlock(Transition, {
              key: 1,
              onAfterLeave: _ctx.resetInputHeight
            }, {
              default: withCtx(() => [
                createElementVNode("span", {
                  style: normalizeStyle({ marginLeft: _ctx.prefixWidth && _ctx.selected.length ? `${_ctx.prefixWidth}px` : null })
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item) => {
                    return openBlock(), createBlock(_component_el_tag, {
                      key: _ctx.getValueKey(item),
                      closable: !_ctx.selectDisabled && !item.isDisabled,
                      size: _ctx.collapseTagSize,
                      hit: item.hitState,
                      type: "info",
                      "disable-transitions": "",
                      onClose: ($event) => _ctx.deleteTag($event, item)
                    }, {
                      default: withCtx(() => [
                        createElementVNode("span", {
                          class: "el-select__tags-text",
                          style: normalizeStyle({ "max-width": _ctx.inputWidth - 75 + "px" })
                        }, toDisplayString(item.currentLabel), 5)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "onClose"]);
                  }), 128))
                ], 4)
              ]),
              _: 1
            }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
            createCommentVNode(" </div> "),
            _ctx.filterable ? withDirectives((openBlock(), createElementBlock("input", {
              key: 2,
              ref: "input",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.query = $event),
              type: "text",
              class: normalizeClass(["el-select__input", [_ctx.selectSize ? `is-${_ctx.selectSize}` : ""]]),
              disabled: _ctx.selectDisabled,
              autocomplete: _ctx.autocomplete,
              style: normalizeStyle({ marginLeft: _ctx.prefixWidth && !_ctx.selected.length || _ctx.tagInMultiLine ? `${_ctx.prefixWidth}px` : null, flexGrow: "1", width: `${_ctx.inputLength / (_ctx.inputWidth - 32)}%`, maxWidth: `${_ctx.inputWidth - 42}px` }),
              onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
              onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
              onKeyup: _cache[4] || (_cache[4] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
              onKeydown: [
                _cache[5] || (_cache[5] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.visible = false, ["stop", "prevent"]), ["esc"])),
                _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                _cache[10] || (_cache[10] = withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                _cache[11] || (_cache[11] = withKeys(($event) => _ctx.visible = false, ["tab"]))
              ],
              onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onInput: _cache[15] || (_cache[15] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
            }, null, 46, _hoisted_4$r)), [
              [vModelText, _ctx.query]
            ]) : createCommentVNode("v-if", true)
          ], 4)) : createCommentVNode("v-if", true),
          createVNode(_component_el_input, {
            id: _ctx.id,
            ref: "reference",
            modelValue: _ctx.selectedLabel,
            "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => _ctx.selectedLabel = $event),
            type: "text",
            placeholder: _ctx.currentPlaceholder,
            name: _ctx.name,
            autocomplete: _ctx.autocomplete,
            size: _ctx.selectSize,
            disabled: _ctx.selectDisabled,
            readonly: _ctx.readonly,
            "validate-event": false,
            class: normalizeClass({ "is-focus": _ctx.visible }),
            tabindex: _ctx.multiple && _ctx.filterable ? "-1" : null,
            onFocus: _ctx.handleFocus,
            onBlur: _ctx.handleBlur,
            onInput: _ctx.debouncedOnInputChange,
            onPaste: _ctx.debouncedOnInputChange,
            onKeydown: [
              _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
              _cache[19] || (_cache[19] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
              withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
              _cache[20] || (_cache[20] = withKeys(withModifiers(($event) => _ctx.visible = false, ["stop", "prevent"]), ["esc"])),
              _cache[21] || (_cache[21] = withKeys(($event) => _ctx.visible = false, ["tab"]))
            ],
            onMouseenter: _cache[22] || (_cache[22] = ($event) => _ctx.inputHovering = true),
            onMouseleave: _cache[23] || (_cache[23] = ($event) => _ctx.inputHovering = false)
          }, createSlots({
            suffix: withCtx(() => [
              withDirectives(createElementVNode("i", {
                class: normalizeClass(["el-select__caret", "el-input__icon", "el-icon-" + _ctx.iconClass])
              }, null, 2), [
                [vShow, !_ctx.showClose]
              ]),
              _ctx.showClose ? (openBlock(), createElementBlock("i", {
                key: 0,
                class: normalizeClass(`el-select__caret el-input__icon ${_ctx.clearIcon}`),
                onClick: _cache[16] || (_cache[16] = (...args) => _ctx.handleClearClick && _ctx.handleClearClick(...args))
              }, null, 2)) : createCommentVNode("v-if", true)
            ]),
            _: 2
          }, [
            _ctx.$slots.prefix ? {
              name: "prefix",
              fn: withCtx(() => [
                createElementVNode("div", _hoisted_5$m, [
                  renderSlot(_ctx.$slots, "prefix")
                ])
              ])
            } : void 0
          ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onKeydown"])
        ])
      ]),
      default: withCtx(() => [
        createVNode(_component_el_select_menu, null, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_el_scrollbar, {
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": "el-select-dropdown__wrap",
              "view-class": "el-select-dropdown__list",
              class: normalizeClass({ "is-empty": !_ctx.allowCreate && _ctx.query && _ctx.filteredOptionsCount === 0 })
            }, {
              default: withCtx(() => [
                _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                  key: 0,
                  value: _ctx.query,
                  created: true
                }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class"]), [
              [vShow, _ctx.options.size > 0 && !_ctx.loading]
            ]),
            _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _ctx.$slots.empty ? renderSlot(_ctx.$slots, "empty", { key: 0 }) : (openBlock(), createElementBlock("p", _hoisted_6$j, toDisplayString(_ctx.emptyText), 1))
            ], 2112)) : createCommentVNode("v-if", true)
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["visible", "append-to-body", "popper-class", "onBeforeEnter"])
  ], 2)), [
    [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
  ]);
}
script$2$9.render = render$2$6;
script$2$9.__file = "packages/components/select/src/select.vue";
var __defProp$b = Object.defineProperty;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key, value2) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$b.call(b, prop))
      __defNormalProp$b(a, prop, b[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b)) {
      if (__propIsEnum$b.call(b, prop))
        __defNormalProp$b(a, prop, b[prop]);
    }
  return a;
};
var script$3$5 = defineComponent({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const visible2 = ref(true);
    const instance = getCurrentInstance();
    const children = ref([]);
    provide(selectGroupKey, reactive(__spreadValues$b({}, toRefs(props2))));
    const select = inject(selectKey);
    onMounted(() => {
      children.value = flattedChildren(instance.subTree);
    });
    const flattedChildren = (node) => {
      const children2 = [];
      if (Array.isArray(node.children)) {
        node.children.forEach((child) => {
          var _a;
          if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
            children2.push(child.component.proxy);
          } else if ((_a = child.children) == null ? void 0 : _a.length) {
            children2.push(...flattedChildren(child));
          }
        });
      }
      return children2;
    };
    const queryChange = () => {
      visible2.value = children.value.some((option2) => option2.visible === true);
    };
    select.selectEmitter.on(selectEvents.groupQueryChange, queryChange);
    return {
      visible: visible2
    };
  }
});
const _hoisted_1$1$8 = { class: "el-select-group__wrap" };
const _hoisted_2$1$6 = { class: "el-select-group__title" };
const _hoisted_3$1$6 = { class: "el-select-group" };
function render$3$3(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("ul", _hoisted_1$1$8, [
    createElementVNode("li", _hoisted_2$1$6, toDisplayString(_ctx.label), 1),
    createElementVNode("li", null, [
      createElementVNode("ul", _hoisted_3$1$6, [
        renderSlot(_ctx.$slots, "default")
      ])
    ])
  ], 512)), [
    [vShow, _ctx.visible]
  ]);
}
script$3$5.render = render$3$3;
script$3$5.__file = "packages/components/select/src/option-group.vue";
script$2$9.install = (app) => {
  app.component(script$2$9.name, script$2$9);
  app.component(script$m.name, script$m);
  app.component(script$3$5.name, script$3$5);
};
script$2$9.Option = script$m;
script$2$9.OptionGroup = script$3$5;
const _Select$1 = script$2$9;
const ElSelect = _Select$1;
const ElOption$2 = script$m;
const ElOptionGroup = script$3$5;
var script$l = defineComponent({
  name: "Prev",
  props: {
    disabled: Boolean,
    currentPage: {
      type: Number,
      default: 1
    },
    prevText: {
      type: String,
      default: ""
    }
  },
  setup(props2) {
    const internalDisabled = computed(() => props2.disabled || props2.currentPage <= 1);
    return {
      internalDisabled
    };
  }
});
const _hoisted_1$J = ["disabled", "aria-disabled"];
const _hoisted_2$D = { key: 0 };
const _hoisted_3$B = {
  key: 1,
  class: "el-icon el-icon-arrow-left"
};
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    type: "button",
    class: "btn-prev",
    disabled: _ctx.internalDisabled,
    "aria-disabled": _ctx.internalDisabled,
    onClick: _cache[0] || (_cache[0] = withModifiers(() => {
    }, ["self", "prevent"]))
  }, [
    _ctx.prevText ? (openBlock(), createElementBlock("span", _hoisted_2$D, toDisplayString(_ctx.prevText), 1)) : (openBlock(), createElementBlock("i", _hoisted_3$B))
  ], 8, _hoisted_1$J);
}
script$l.render = render$k;
script$l.__file = "packages/components/pagination/src/prev.vue";
var script$1$c = defineComponent({
  name: "Next",
  props: {
    disabled: Boolean,
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      default: 50
    },
    nextText: {
      type: String,
      default: ""
    }
  },
  setup(props2) {
    const internalDisabled = computed(() => props2.disabled || props2.currentPage === props2.pageCount || props2.pageCount === 0);
    return {
      internalDisabled
    };
  }
});
const _hoisted_1$1$7 = ["disabled", "aria-disabled"];
const _hoisted_2$1$5 = { key: 0 };
const _hoisted_3$1$5 = {
  key: 1,
  class: "el-icon el-icon-arrow-right"
};
function render$1$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    type: "button",
    class: "btn-next",
    disabled: _ctx.internalDisabled,
    "aria-disabled": _ctx.internalDisabled,
    onClick: _cache[0] || (_cache[0] = withModifiers(() => {
    }, ["self", "prevent"]))
  }, [
    _ctx.nextText ? (openBlock(), createElementBlock("span", _hoisted_2$1$5, toDisplayString(_ctx.nextText), 1)) : (openBlock(), createElementBlock("i", _hoisted_3$1$5))
  ], 8, _hoisted_1$1$7);
}
script$1$c.render = render$1$b;
script$1$c.__file = "packages/components/pagination/src/next.vue";
const usePagination = () => {
  const pagination = inject("pagination", {});
  return {
    pagination,
    pageCount: pagination.pageCount,
    disabled: pagination.disabled,
    currentPage: pagination.currentPage
  };
};
const { Option: ElOption$1 } = _Select$1;
var script$2$8 = defineComponent({
  name: "Sizes",
  components: {
    ElSelect: _Select$1,
    ElOption: ElOption$1
  },
  props: {
    pageSize: Number,
    pageSizes: {
      type: Array,
      default: () => {
        return [10, 20, 30, 40, 50, 100];
      }
    },
    popperClass: {
      type: String,
      default: ""
    },
    disabled: Boolean
  },
  emits: ["page-size-change"],
  setup(props2, { emit: emit2 }) {
    const { t } = useLocaleInject();
    const { pagination } = usePagination();
    const innerPageSize = ref(props2.pageSize);
    watch(() => props2.pageSizes, (newVal, oldVal) => {
      if (isEqual_1(newVal, oldVal))
        return;
      if (Array.isArray(newVal)) {
        const pageSize = newVal.indexOf(props2.pageSize) > -1 ? props2.pageSize : props2.pageSizes[0];
        emit2("page-size-change", pageSize);
      }
    });
    watch(() => props2.pageSize, (newVal) => {
      innerPageSize.value = newVal;
    });
    const innerPagesizes = computed(() => props2.pageSizes);
    function handleChange(val) {
      if (val !== innerPageSize.value) {
        innerPageSize.value = val;
        pagination == null ? void 0 : pagination.handleSizeChange(Number(val));
      }
    }
    return {
      t,
      innerPagesizes,
      innerPageSize,
      handleChange
    };
  }
});
const _hoisted_1$2$2 = { class: "el-pagination__sizes" };
function render$2$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = resolveComponent("el-option");
  const _component_el_select = resolveComponent("el-select");
  return openBlock(), createElementBlock("span", _hoisted_1$2$2, [
    createVNode(_component_el_select, {
      "model-value": _ctx.innerPageSize,
      disabled: _ctx.disabled,
      "popper-class": _ctx.popperClass,
      size: "mini",
      onChange: _ctx.handleChange
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.innerPagesizes, (item) => {
          return openBlock(), createBlock(_component_el_option, {
            key: item,
            value: item,
            label: item + _ctx.t("el.pagination.pagesize")
          }, null, 8, ["value", "label"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["model-value", "disabled", "popper-class", "onChange"])
  ]);
}
script$2$8.render = render$2$5;
script$2$8.__file = "packages/components/pagination/src/sizes.vue";
var script$3$4 = defineComponent({
  components: {
    ElInput: ElInput$1
  },
  setup() {
    const { t } = useLocaleInject();
    const { pagination, pageCount, disabled, currentPage } = usePagination();
    const userInput = ref(null);
    const innerValue = computed(() => {
      var _a;
      return (_a = userInput.value) != null ? _a : currentPage.value;
    });
    function handleInput(val) {
      userInput.value = Number(val);
    }
    function handleChange(val) {
      pagination == null ? void 0 : pagination.changeEvent(Number(val));
      userInput.value = null;
    }
    return {
      t,
      userInput,
      pageCount,
      disabled,
      handleInput,
      handleChange,
      innerValue
    };
  }
});
const _hoisted_1$3$2 = { class: "el-pagination__jump" };
function render$3$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  return openBlock(), createElementBlock("span", _hoisted_1$3$2, [
    createTextVNode(toDisplayString(_ctx.t("el.pagination.goto")) + " ", 1),
    createVNode(_component_el_input, {
      size: "mini",
      class: "el-pagination__editor is-in-pagination",
      min: 1,
      max: _ctx.pageCount,
      disabled: _ctx.disabled,
      "model-value": _ctx.innerValue,
      type: "number",
      "onUpdate:modelValue": _ctx.handleInput,
      onChange: _ctx.handleChange
    }, null, 8, ["max", "disabled", "model-value", "onUpdate:modelValue", "onChange"]),
    createTextVNode(" " + toDisplayString(_ctx.t("el.pagination.pageClassifier")), 1)
  ]);
}
script$3$4.render = render$3$2;
script$3$4.__file = "packages/components/pagination/src/jumper.vue";
var script$4$2 = defineComponent({
  name: "Total",
  props: {
    total: {
      type: Number,
      default: 1e3
    }
  },
  setup() {
    const { t } = useLocaleInject();
    return {
      t
    };
  }
});
const _hoisted_1$4$2 = { class: "el-pagination__total" };
function render$4$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", _hoisted_1$4$2, toDisplayString(_ctx.t("el.pagination.total", {
    total: _ctx.total
  })), 1);
}
script$4$2.render = render$4$2;
script$4$2.__file = "packages/components/pagination/src/total.vue";
var script$5$1 = defineComponent({
  name: "ElPager",
  props: {
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number
    },
    pagerCount: {
      type: Number,
      default: 7
    },
    disabled: Boolean
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    const showPrevMore = ref(false);
    const showNextMore = ref(false);
    const quicknextIconClass = ref("el-icon-more");
    const quickprevIconClass = ref("el-icon-more");
    const pagers = computed(() => {
      const pagerCount = props2.pagerCount;
      const halfPagerCount = (pagerCount - 1) / 2;
      const currentPage = Number(props2.currentPage);
      const pageCount = Number(props2.pageCount);
      let showPrevMore2 = false;
      let showNextMore2 = false;
      if (pageCount > pagerCount) {
        if (currentPage > pagerCount - halfPagerCount) {
          showPrevMore2 = true;
        }
        if (currentPage < pageCount - halfPagerCount) {
          showNextMore2 = true;
        }
      }
      const array3 = [];
      if (showPrevMore2 && !showNextMore2) {
        const startPage = pageCount - (pagerCount - 2);
        for (let i2 = startPage; i2 < pageCount; i2++) {
          array3.push(i2);
        }
      } else if (!showPrevMore2 && showNextMore2) {
        for (let i2 = 2; i2 < pagerCount; i2++) {
          array3.push(i2);
        }
      } else if (showPrevMore2 && showNextMore2) {
        const offset2 = Math.floor(pagerCount / 2) - 1;
        for (let i2 = currentPage - offset2; i2 <= currentPage + offset2; i2++) {
          array3.push(i2);
        }
      } else {
        for (let i2 = 2; i2 < pageCount; i2++) {
          array3.push(i2);
        }
      }
      return array3;
    });
    watchEffect(() => {
      const halfPagerCount = (props2.pagerCount - 1) / 2;
      showPrevMore.value = false;
      showNextMore.value = false;
      if (props2.pageCount > props2.pagerCount) {
        if (props2.currentPage > props2.pagerCount - halfPagerCount) {
          showPrevMore.value = true;
        }
        if (props2.currentPage < props2.pageCount - halfPagerCount) {
          showNextMore.value = true;
        }
      }
    });
    watchEffect(() => {
      if (!showPrevMore.value)
        quickprevIconClass.value = "el-icon-more";
    });
    watchEffect(() => {
      if (!showNextMore.value)
        quicknextIconClass.value = "el-icon-more";
    });
    function onMouseenter(direction) {
      if (props2.disabled)
        return;
      if (direction === "left") {
        quickprevIconClass.value = "el-icon-d-arrow-left";
      } else {
        quicknextIconClass.value = "el-icon-d-arrow-right";
      }
    }
    function onEnter(e) {
      const target = e.target;
      if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
        const newPage = Number(target.textContent);
        if (newPage !== props2.currentPage) {
          emit2("change", newPage);
        }
      }
    }
    function onPagerClick(event2) {
      const target = event2.target;
      if (target.tagName.toLowerCase() === "ul" || props2.disabled) {
        return;
      }
      let newPage = Number(target.textContent);
      const pageCount = props2.pageCount;
      const currentPage = props2.currentPage;
      const pagerCountOffset = props2.pagerCount - 2;
      if (target.className.includes("more")) {
        if (target.className.includes("quickprev")) {
          newPage = currentPage - pagerCountOffset;
        } else if (target.className.includes("quicknext")) {
          newPage = currentPage + pagerCountOffset;
        }
      }
      if (!isNaN(newPage)) {
        if (newPage < 1) {
          newPage = 1;
        }
        if (newPage > pageCount) {
          newPage = pageCount;
        }
      }
      if (newPage !== currentPage) {
        emit2("change", newPage);
      }
    }
    return {
      showPrevMore,
      showNextMore,
      quicknextIconClass,
      quickprevIconClass,
      pagers,
      onMouseenter,
      onPagerClick,
      onEnter
    };
  }
});
const _hoisted_1$5$1 = ["aria-current"];
const _hoisted_2$2$2 = ["aria-current"];
const _hoisted_3$2$2 = ["aria-current"];
function render$5$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("ul", {
    class: "el-pager",
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onPagerClick && _ctx.onPagerClick(...args)),
    onKeyup: _cache[5] || (_cache[5] = withKeys((...args) => _ctx.onEnter && _ctx.onEnter(...args), ["enter"]))
  }, [
    _ctx.pageCount > 0 ? (openBlock(), createElementBlock("li", {
      key: 0,
      class: normalizeClass([{ active: _ctx.currentPage === 1, disabled: _ctx.disabled }, "number"]),
      "aria-current": _ctx.currentPage === 1,
      tabindex: "0"
    }, " 1 ", 10, _hoisted_1$5$1)) : createCommentVNode("v-if", true),
    _ctx.showPrevMore ? (openBlock(), createElementBlock("li", {
      key: 1,
      class: normalizeClass(["el-icon more btn-quickprev", [_ctx.quickprevIconClass, { disabled: _ctx.disabled }]]),
      onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.onMouseenter("left")),
      onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.quickprevIconClass = "el-icon-more")
    }, null, 34)) : createCommentVNode("v-if", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.pagers, (pager) => {
      return openBlock(), createElementBlock("li", {
        key: pager,
        class: normalizeClass([{ active: _ctx.currentPage === pager, disabled: _ctx.disabled }, "number"]),
        "aria-current": _ctx.currentPage === pager,
        tabindex: "0"
      }, toDisplayString(pager), 11, _hoisted_2$2$2);
    }), 128)),
    _ctx.showNextMore ? (openBlock(), createElementBlock("li", {
      key: 2,
      class: normalizeClass(["el-icon more btn-quicknext", [_ctx.quicknextIconClass, { disabled: _ctx.disabled }]]),
      onMouseenter: _cache[2] || (_cache[2] = ($event) => _ctx.onMouseenter("right")),
      onMouseleave: _cache[3] || (_cache[3] = ($event) => _ctx.quicknextIconClass = "el-icon-more")
    }, null, 34)) : createCommentVNode("v-if", true),
    _ctx.pageCount > 1 ? (openBlock(), createElementBlock("li", {
      key: 3,
      class: normalizeClass([{ active: _ctx.currentPage === _ctx.pageCount, disabled: _ctx.disabled }, "number"]),
      "aria-current": _ctx.currentPage === _ctx.pageCount,
      tabindex: "0"
    }, toDisplayString(_ctx.pageCount), 11, _hoisted_3$2$2)) : createCommentVNode("v-if", true)
  ], 32);
}
script$5$1.render = render$5$1;
script$5$1.__file = "packages/components/pagination/src/pager.vue";
const isAbsent = (v) => typeof v !== "number";
const componentName = "ElPagination";
var Pagination = defineComponent({
  name: componentName,
  components: {
    Prev: script$l,
    Next: script$1$c,
    Sizes: script$2$8,
    Jumper: script$3$4,
    Total: script$4$2,
    Pager: script$5$1
  },
  props: {
    total: {
      type: Number
    },
    pageSize: {
      type: Number
    },
    defaultPageSize: {
      type: Number
    },
    currentPage: {
      type: Number
    },
    defaultCurrentPage: {
      type: Number
    },
    pageCount: {
      type: Number
    },
    pagerCount: {
      type: Number,
      validator: (value2) => {
        return (value2 | 0) === value2 && value2 > 4 && value2 < 22 && value2 % 2 === 1;
      },
      default: 7
    },
    layout: {
      type: String,
      default: "prev, pager, next, jumper, ->, total"
    },
    pageSizes: {
      type: Array,
      default: () => {
        return [10, 20, 30, 40, 50, 100];
      }
    },
    popperClass: {
      type: String,
      default: ""
    },
    prevText: {
      type: String,
      default: ""
    },
    nextText: {
      type: String,
      default: ""
    },
    small: Boolean,
    background: Boolean,
    disabled: Boolean,
    hideOnSinglePage: Boolean
  },
  emits: [
    "update:current-page",
    "update:page-size",
    "size-change",
    "current-change",
    "prev-click",
    "next-click"
  ],
  setup(props2, { emit: emit2, slots }) {
    const { t } = useLocaleInject();
    const vnodeProps = getCurrentInstance().vnode.props || {};
    const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
    const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
    const assertValidUsage = computed(() => {
      if (isAbsent(props2.total) && isAbsent(props2.pageCount))
        return false;
      if (!isAbsent(props2.currentPage) && !hasCurrentPageListener)
        return false;
      if (props2.layout.includes("sizes")) {
        if (!isAbsent(props2.pageCount)) {
          if (!hasPageSizeListener)
            return false;
        } else if (!isAbsent(props2.total)) {
          if (!isAbsent(props2.pageSize)) {
            if (!hasPageSizeListener) {
              return false;
            }
          }
        }
      }
      return true;
    });
    const innerPageSize = ref(isAbsent(props2.defaultPageSize) ? 10 : props2.defaultPageSize);
    const innerCurrentPage = ref(isAbsent(props2.defaultCurrentPage) ? 1 : props2.defaultCurrentPage);
    const pageSizeBridge = computed({
      get() {
        return isAbsent(props2.pageSize) ? innerPageSize.value : props2.pageSize;
      },
      set(v) {
        if (isAbsent(props2.pageSize)) {
          innerPageSize.value = v;
        }
        if (hasPageSizeListener) {
          emit2("update:page-size", v);
          emit2("size-change", v);
        }
      }
    });
    const pageCountBridge = computed(() => {
      let pageCount = 0;
      if (!isAbsent(props2.pageCount)) {
        pageCount = props2.pageCount;
      } else if (!isAbsent(props2.total)) {
        pageCount = Math.max(1, Math.ceil(props2.total / pageSizeBridge.value));
      }
      if (currentPageBridge.value > pageCount) {
        currentPageBridge.value = pageCount;
      }
      return pageCount;
    });
    const currentPageBridge = computed({
      get() {
        return isAbsent(props2.currentPage) ? innerCurrentPage.value : props2.currentPage;
      },
      set(v) {
        let newCurrentPage = v;
        if (v < 1) {
          newCurrentPage = 1;
        } else if (v > pageCountBridge.value) {
          newCurrentPage = pageCountBridge.value;
        }
        if (isAbsent(props2.currentPage)) {
          innerCurrentPage.value = newCurrentPage;
        }
        if (hasCurrentPageListener) {
          emit2("update:current-page", newCurrentPage);
          emit2("current-change", newCurrentPage);
        }
      }
    });
    function handleCurrentChange(val) {
      currentPageBridge.value = val;
    }
    function handleSizeChange(val) {
      pageSizeBridge.value = val;
      const newPageCount = pageCountBridge.value;
      if (currentPageBridge.value > newPageCount) {
        currentPageBridge.value = newPageCount;
      }
    }
    function prev() {
      if (props2.disabled)
        return;
      currentPageBridge.value -= 1;
      emit2("prev-click", currentPageBridge.value);
    }
    function next() {
      if (props2.disabled)
        return;
      currentPageBridge.value += 1;
      emit2("next-click", currentPageBridge.value);
    }
    provide("pagination", {
      pageCount: pageCountBridge,
      disabled: computed(() => props2.disabled),
      currentPage: currentPageBridge,
      changeEvent: handleCurrentChange,
      handleSizeChange
    });
    return () => {
      var _a, _b;
      if (!assertValidUsage.value) {
        warn(componentName, t("el.pagination.deprecationWarning"));
        return null;
      }
      if (!props2.layout)
        return null;
      if (props2.hideOnSinglePage && pageCountBridge.value <= 1)
        return null;
      const rootChildren = [];
      const rightWrapperChildren = [];
      const rightWrapperRoot = h("div", { class: "el-pagination__rightwrapper" }, rightWrapperChildren);
      const TEMPLATE_MAP = {
        prev: h(script$l, {
          disabled: props2.disabled,
          currentPage: currentPageBridge.value,
          prevText: props2.prevText,
          onClick: prev
        }),
        jumper: h(script$3$4),
        pager: h(script$5$1, {
          currentPage: currentPageBridge.value,
          pageCount: pageCountBridge.value,
          pagerCount: props2.pagerCount,
          onChange: handleCurrentChange,
          disabled: props2.disabled
        }),
        next: h(script$1$c, {
          disabled: props2.disabled,
          currentPage: currentPageBridge.value,
          pageCount: pageCountBridge.value,
          nextText: props2.nextText,
          onClick: next
        }),
        sizes: h(script$2$8, {
          pageSize: pageSizeBridge.value,
          pageSizes: props2.pageSizes,
          popperClass: props2.popperClass,
          disabled: props2.disabled
        }),
        slot: (_b = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : null,
        total: h(script$4$2, { total: isAbsent(props2.total) ? 0 : props2.total })
      };
      const components2 = props2.layout.split(",").map((item) => item.trim());
      let haveRightWrapper = false;
      components2.forEach((c) => {
        if (c === "->") {
          haveRightWrapper = true;
          return;
        }
        if (!haveRightWrapper) {
          rootChildren.push(TEMPLATE_MAP[c]);
        } else {
          rightWrapperChildren.push(TEMPLATE_MAP[c]);
        }
      });
      if (haveRightWrapper && rightWrapperChildren.length > 0) {
        rootChildren.unshift(rightWrapperRoot);
      }
      return h("div", {
        role: "pagination",
        "aria-label": "pagination",
        class: [
          "el-pagination",
          {
            "is-background": props2.background,
            "el-pagination--small": props2.small
          }
        ]
      }, rootChildren);
    };
  }
});
const _Pagination = Pagination;
_Pagination.install = (app) => {
  app.component(_Pagination.name, _Pagination);
};
const ElPagination = _Pagination;
var script$k = defineComponent({
  name: "ElPopconfirm",
  components: {
    ElButton: _Button,
    ElPopper: ElPopper$1
  },
  props: {
    title: {
      type: String
    },
    confirmButtonText: {
      type: String
    },
    cancelButtonText: {
      type: String
    },
    confirmButtonType: {
      type: String,
      default: "primary"
    },
    cancelButtonType: {
      type: String,
      default: "text"
    },
    icon: {
      type: String,
      default: "el-icon-question"
    },
    iconColor: {
      type: String,
      default: "#f90"
    },
    hideIcon: {
      type: Boolean,
      default: false
    }
  },
  emits: ["confirm", "cancel"],
  setup(props2, { emit: emit2 }) {
    const { t } = useLocaleInject();
    const visible2 = ref(false);
    const confirm2 = () => {
      visible2.value = false;
      emit2("confirm");
    };
    const cancel = () => {
      visible2.value = false;
      emit2("cancel");
    };
    const confirmButtonText_ = computed(() => {
      return props2.confirmButtonText || t("el.popconfirm.confirmButtonText");
    });
    const cancelButtonText_ = computed(() => {
      return props2.cancelButtonText || t("el.popconfirm.cancelButtonText");
    });
    return {
      visible: visible2,
      confirm: confirm2,
      cancel,
      confirmButtonText_,
      cancelButtonText_
    };
  }
});
const _hoisted_1$I = { class: "el-popconfirm" };
const _hoisted_2$C = { class: "el-popconfirm__main" };
const _hoisted_3$A = { class: "el-popconfirm__action" };
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_el_popper = resolveComponent("el-popper");
  return openBlock(), createBlock(_component_el_popper, {
    visible: _ctx.visible,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.visible = $event),
    trigger: "click",
    effect: "light",
    "popper-class": "el-popover",
    "append-to-body": "",
    "fallback-placements": ["bottom", "top", "right", "left"]
  }, {
    trigger: withCtx(() => [
      renderSlot(_ctx.$slots, "reference")
    ]),
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$I, [
        createElementVNode("p", _hoisted_2$C, [
          !_ctx.hideIcon ? (openBlock(), createElementBlock("i", {
            key: 0,
            class: normalizeClass([_ctx.icon, "el-popconfirm__icon"]),
            style: normalizeStyle({ color: _ctx.iconColor })
          }, null, 6)) : createCommentVNode("v-if", true),
          createTextVNode(" " + toDisplayString(_ctx.title), 1)
        ]),
        createElementVNode("div", _hoisted_3$A, [
          createVNode(_component_el_button, {
            size: "mini",
            type: _ctx.cancelButtonType,
            onClick: _ctx.cancel
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.cancelButtonText_), 1)
            ]),
            _: 1
          }, 8, ["type", "onClick"]),
          createVNode(_component_el_button, {
            size: "mini",
            type: _ctx.confirmButtonType,
            onClick: _ctx.confirm
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.confirmButtonText_), 1)
            ]),
            _: 1
          }, 8, ["type", "onClick"])
        ])
      ])
    ]),
    _: 3
  }, 8, ["visible"]);
}
script$k.render = render$j;
script$k.__file = "packages/components/popconfirm/src/workprogress.vue";
script$k.install = (app) => {
  app.component(script$k.name, script$k);
};
const _Popconfirm = script$k;
const ElPopconfirm = _Popconfirm;
var __defProp$a = Object.defineProperty;
var __defProps$a = Object.defineProperties;
var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value2) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));
const SHOW_EVENT = "show";
const HIDE_EVENT = "hide";
function usePopover(props2, ctx2) {
  const zIndex2 = ref(PopupManager$1.nextZIndex());
  const width2 = computed(() => {
    if (isString$1(props2.width)) {
      return props2.width;
    }
    return props2.width + "px";
  });
  const popperStyle = computed(() => {
    return {
      width: width2.value,
      zIndex: zIndex2.value
    };
  });
  const popperProps = usePopper(props2, ctx2);
  watch(popperProps.visibility, (val) => {
    if (val) {
      zIndex2.value = PopupManager$1.nextZIndex();
    }
    ctx2.emit(val ? SHOW_EVENT : HIDE_EVENT);
  });
  return __spreadProps$a(__spreadValues$a({}, popperProps), {
    popperStyle
  });
}
var __defProp$1$5 = Object.defineProperty;
var __defProps$1$4 = Object.defineProperties;
var __getOwnPropDescs$1$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$5 = (obj, key, value2) => key in obj ? __defProp$1$5(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$5.call(b, prop))
      __defNormalProp$1$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$5)
    for (var prop of __getOwnPropSymbols$1$5(b)) {
      if (__propIsEnum$1$5.call(b, prop))
        __defNormalProp$1$5(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1$4 = (a, b) => __defProps$1$4(a, __getOwnPropDescs$1$4(b));
const emits$1 = ["update:visible", "after-enter", "after-leave", SHOW_EVENT, HIDE_EVENT];
const NAME = "ElPopover";
const _hoist = { key: 0, class: "el-popover__title", role: "title" };
var script$j = defineComponent({
  name: NAME,
  components: {
    ElPopper: ElPopper$1
  },
  props: __spreadProps$1$4(__spreadValues$1$5({}, defaultProps$4), {
    content: {
      type: String
    },
    trigger: {
      type: String,
      default: "click"
    },
    title: {
      type: String
    },
    transition: {
      type: String,
      default: "fade-in-linear"
    },
    width: {
      type: [String, Number],
      default: 150
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    tabindex: [String, Number]
  }),
  emits: emits$1,
  setup(props2, ctx2) {
    if (props2.visible && !ctx2.slots.reference) {
      warn(NAME, `
        You cannot init popover without given reference
      `);
    }
    const states = usePopover(props2, ctx2);
    return states;
  },
  render() {
    const { $slots } = this;
    const trigger = $slots.reference ? $slots.reference() : null;
    const title = renderIf(this.title, "div", _hoist, toDisplayString(this.title), PatchFlags.TEXT);
    const content = renderSlot($slots, "default", {}, () => [createTextVNode(toDisplayString(this.content), PatchFlags.TEXT)]);
    const {
      events: events2,
      onAfterEnter,
      onAfterLeave,
      onPopperMouseEnter,
      onPopperMouseLeave,
      popperStyle,
      popperId,
      popperClass,
      showArrow,
      transition,
      visibility,
      tabindex
    } = this;
    const kls = [
      this.content ? "el-popover--plain" : "",
      "el-popover",
      popperClass
    ].join(" ");
    let popover = renderPopper({
      effect: Effect.LIGHT,
      name: transition,
      popperClass: kls,
      popperStyle,
      popperId,
      visibility,
      onMouseenter: onPopperMouseEnter,
      onMouseleave: onPopperMouseLeave,
      onAfterEnter,
      onAfterLeave,
      stopPopperMouseEvent: false
    }, [
      title,
      content,
      renderArrow(showArrow)
    ]);
    const _trigger = trigger ? renderTrigger(trigger, __spreadValues$1$5({
      ariaDescribedby: popperId,
      ref: "triggerRef",
      tabindex
    }, events2)) : createCommentVNode("v-if", true);
    return h(Fragment, null, [
      this.trigger === "click" ? withDirectives(_trigger, [[ClickOutside$1, this.hide]]) : _trigger,
      h(Teleport, {
        disabled: !this.appendToBody,
        to: "body"
      }, [popover])
    ]);
  }
});
script$j.__file = "packages/components/popover/src/workprogress.vue";
const attachEvents = (el, binding, vnode) => {
  const _ref = binding.arg || binding.value;
  const popover = vnode.dirs[0].instance.$refs[_ref];
  if (popover) {
    popover.triggerRef = el;
    el.setAttribute("tabindex", popover.tabindex);
    Object.entries(popover.events).forEach(([eventName, e]) => {
      on$2(el, eventName.toLowerCase().slice(2), e);
    });
  }
};
var PopoverDirective = {
  mounted(el, binding, vnode) {
    attachEvents(el, binding, vnode);
  },
  updated(el, binding, vnode) {
    attachEvents(el, binding, vnode);
  }
};
const VPopover = "popover";
script$j.install = (app) => {
  app.component(script$j.name, script$j);
};
PopoverDirective.install = (app) => {
  app.directive(VPopover, PopoverDirective);
};
const _PopoverDirective = PopoverDirective;
script$j.directive = _PopoverDirective;
const _Popover = script$j;
const ElPopover = _Popover;
const ElPopoverDirective = _PopoverDirective;
var script$i = defineComponent({
  name: "ElProgress",
  props: {
    type: {
      type: String,
      default: "line",
      validator: (val) => ["line", "circle", "dashboard"].indexOf(val) > -1
    },
    percentage: {
      type: Number,
      default: 0,
      required: true,
      validator: (val) => val >= 0 && val <= 100
    },
    status: {
      type: String,
      default: "",
      validator: (val) => ["", "success", "exception", "warning"].indexOf(val) > -1
    },
    indeterminate: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 3
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    strokeLinecap: {
      type: String,
      default: "round"
    },
    textInside: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 126
    },
    showText: {
      type: Boolean,
      default: true
    },
    color: {
      type: [String, Array, Function],
      default: ""
    },
    format: {
      type: Function,
      default: (percentage) => `${percentage}%`
    }
  },
  setup(props2) {
    const barStyle = computed(() => {
      return {
        width: `${props2.percentage}%`,
        animationDuration: `${props2.duration}s`,
        backgroundColor: getCurrentColor(props2.percentage)
      };
    });
    const relativeStrokeWidth = computed(() => {
      return (props2.strokeWidth / props2.width * 100).toFixed(1);
    });
    const radius = computed(() => {
      if (props2.type === "circle" || props2.type === "dashboard") {
        return parseInt(`${50 - parseFloat(relativeStrokeWidth.value) / 2}`, 10);
      } else {
        return 0;
      }
    });
    const trackPath = computed(() => {
      const r = radius.value;
      const isDashboard = props2.type === "dashboard";
      return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
    });
    const perimeter = computed(() => {
      return 2 * Math.PI * radius.value;
    });
    const rate = computed(() => {
      return props2.type === "dashboard" ? 0.75 : 1;
    });
    const strokeDashoffset = computed(() => {
      const offset2 = -1 * perimeter.value * (1 - rate.value) / 2;
      return `${offset2}px`;
    });
    const trailPathStyle = computed(() => {
      return {
        strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
        strokeDashoffset: strokeDashoffset.value
      };
    });
    const circlePathStyle = computed(() => {
      return {
        strokeDasharray: `${perimeter.value * rate.value * (props2.percentage / 100)}px, ${perimeter.value}px`,
        strokeDashoffset: strokeDashoffset.value,
        transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease"
      };
    });
    const stroke = computed(() => {
      let ret;
      if (props2.color) {
        ret = getCurrentColor(props2.percentage);
      } else {
        switch (props2.status) {
          case "success":
            ret = "#13ce66";
            break;
          case "exception":
            ret = "#ff4949";
            break;
          case "warning":
            ret = "#e6a23c";
            break;
          default:
            ret = "#20a0ff";
        }
      }
      return ret;
    });
    const iconClass = computed(() => {
      if (props2.status === "warning") {
        return "el-icon-warning";
      }
      if (props2.type === "line") {
        return props2.status === "success" ? "el-icon-circle-check" : "el-icon-circle-close";
      } else {
        return props2.status === "success" ? "el-icon-check" : "el-icon-close";
      }
    });
    const progressTextSize = computed(() => {
      return props2.type === "line" ? 12 + props2.strokeWidth * 0.4 : props2.width * 0.111111 + 2;
    });
    const content = computed(() => {
      return props2.format(props2.percentage);
    });
    const getCurrentColor = (percentage) => {
      var _a;
      const { color } = props2;
      if (typeof color === "function") {
        return color(percentage);
      } else if (typeof color === "string") {
        return color;
      } else {
        const span = 100 / color.length;
        const seriesColors = color.map((seriesColor, index2) => {
          if (typeof seriesColor === "string") {
            return {
              color: seriesColor,
              percentage: (index2 + 1) * span
            };
          }
          return seriesColor;
        });
        const colorArray = seriesColors.sort((a, b) => a.percentage - b.percentage);
        for (let i2 = 0; i2 < colorArray.length; i2++) {
          if (colorArray[i2].percentage > percentage) {
            return colorArray[i2].color;
          }
        }
        return (_a = colorArray[colorArray.length - 1]) == null ? void 0 : _a.color;
      }
    };
    const slotData = computed(() => {
      return {
        percentage: props2.percentage
      };
    });
    return {
      barStyle,
      relativeStrokeWidth,
      radius,
      trackPath,
      perimeter,
      rate,
      strokeDashoffset,
      trailPathStyle,
      circlePathStyle,
      stroke,
      iconClass,
      progressTextSize,
      content,
      getCurrentColor,
      slotData
    };
  }
});
const _hoisted_1$H = ["aria-valuenow"];
const _hoisted_2$B = {
  key: 0,
  class: "el-progress-bar"
};
const _hoisted_3$z = {
  key: 0,
  class: "el-progress-bar__innerText"
};
const _hoisted_4$q = { viewBox: "0 0 100 100" };
const _hoisted_5$l = ["d", "stroke-width"];
const _hoisted_6$i = ["d", "stroke", "stroke-linecap", "stroke-width"];
const _hoisted_7$e = { key: 0 };
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-progress", [
      `el-progress--${_ctx.type}`,
      _ctx.status ? `is-${_ctx.status}` : "",
      {
        "el-progress--without-text": !_ctx.showText,
        "el-progress--text-inside": _ctx.textInside
      }
    ]]),
    role: "progressbar",
    "aria-valuenow": _ctx.percentage,
    "aria-valuemin": "0",
    "aria-valuemax": "100"
  }, [
    _ctx.type === "line" ? (openBlock(), createElementBlock("div", _hoisted_2$B, [
      createElementVNode("div", {
        class: "el-progress-bar__outer",
        style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
      }, [
        createElementVNode("div", {
          class: normalizeClass([
            "el-progress-bar__inner",
            { "el-progress-bar__inner--indeterminate": _ctx.indeterminate }
          ]),
          style: normalizeStyle(_ctx.barStyle)
        }, [
          (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", _hoisted_3$z, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)), () => [
              createElementVNode("span", null, toDisplayString(_ctx.content), 1)
            ])
          ])) : createCommentVNode("v-if", true)
        ], 6)
      ], 4)
    ])) : (openBlock(), createElementBlock("div", {
      key: 1,
      class: "el-progress-circle",
      style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
    }, [
      (openBlock(), createElementBlock("svg", _hoisted_4$q, [
        createElementVNode("path", {
          class: "el-progress-circle__track",
          d: _ctx.trackPath,
          stroke: "#e5e9f2",
          "stroke-width": _ctx.relativeStrokeWidth,
          fill: "none",
          style: normalizeStyle(_ctx.trailPathStyle)
        }, null, 12, _hoisted_5$l),
        createElementVNode("path", {
          class: "el-progress-circle__path",
          d: _ctx.trackPath,
          stroke: _ctx.stroke,
          fill: "none",
          "stroke-linecap": _ctx.strokeLinecap,
          "stroke-width": _ctx.percentage ? _ctx.relativeStrokeWidth : 0,
          style: normalizeStyle(_ctx.circlePathStyle)
        }, null, 12, _hoisted_6$i)
      ]))
    ], 4)),
    (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: "el-progress__text",
      style: normalizeStyle({ fontSize: `${_ctx.progressTextSize}px` })
    }, [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)), () => [
        !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_7$e, toDisplayString(_ctx.content), 1)) : (openBlock(), createElementBlock("i", {
          key: 1,
          class: normalizeClass(_ctx.iconClass)
        }, null, 2))
      ])
    ], 4)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$H);
}
script$i.render = render$i;
script$i.__file = "packages/components/progress/src/workprogress.vue";
script$i.install = (app) => {
  app.component(script$i.name, script$i);
};
const _Progress = script$i;
const ElProgress = _Progress;
var script$h = defineComponent({
  name: "ElRate",
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    lowThreshold: {
      type: Number,
      default: 2
    },
    highThreshold: {
      type: Number,
      default: 4
    },
    max: {
      type: Number,
      default: 5
    },
    colors: {
      type: [Array, Object],
      default: () => ["#F7BA2A", "#F7BA2A", "#F7BA2A"]
    },
    voidColor: {
      type: String,
      default: "#C6D1DE"
    },
    disabledVoidColor: {
      type: String,
      default: "#EFF2F7"
    },
    iconClasses: {
      type: [Array, Object],
      default: () => ["el-icon-star-on", "el-icon-star-on", "el-icon-star-on"]
    },
    voidIconClass: {
      type: String,
      default: "el-icon-star-off"
    },
    disabledVoidIconClass: {
      type: String,
      default: "el-icon-star-on"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    allowHalf: {
      type: Boolean,
      default: false
    },
    showText: {
      type: Boolean,
      default: false
    },
    showScore: {
      type: Boolean,
      default: false
    },
    textColor: {
      type: String,
      default: "#1f2d3d"
    },
    texts: {
      type: Array,
      default: () => ["Extremely bad", "Disappointed", "Fair", "Satisfied", "Surprise"]
    },
    scoreTemplate: {
      type: String,
      default: "{value}"
    }
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2, { emit: emit2 }) {
    const elForm = inject(elFormKey, {});
    const currentValue = ref(props2.modelValue);
    const rateDisabled = computed(() => props2.disabled || elForm.disabled);
    const text = computed(() => {
      let result = "";
      if (props2.showScore) {
        result = props2.scoreTemplate.replace(/\{\s*value\s*\}/, rateDisabled.value ? `${props2.modelValue}` : `${currentValue.value}`);
      } else if (props2.showText) {
        result = props2.texts[Math.ceil(currentValue.value) - 1];
      }
      return result;
    });
    function getValueFromMap(value2, map2) {
      const matchedKeys = Object.keys(map2).filter((key) => {
        const val = map2[key];
        const excluded = isObject$b(val) ? val.excluded : false;
        return excluded ? value2 < key : value2 <= key;
      }).sort((a, b) => a - b);
      const matchedValue = map2[matchedKeys[0]];
      return isObject$b(matchedValue) ? matchedValue.value : matchedValue || "";
    }
    const valueDecimal = computed(() => props2.modelValue * 100 - Math.floor(props2.modelValue) * 100);
    const colorMap = computed(() => isArray$9(props2.colors) ? {
      [props2.lowThreshold]: props2.colors[0],
      [props2.highThreshold]: { value: props2.colors[1], excluded: true },
      [props2.max]: props2.colors[2]
    } : props2.colors);
    const activeColor = computed(() => getValueFromMap(currentValue.value, colorMap.value));
    const decimalStyle = computed(() => {
      let width2 = "";
      if (rateDisabled.value) {
        width2 = `${valueDecimal.value}%`;
      } else if (props2.allowHalf) {
        width2 = "50%";
      }
      return {
        color: activeColor.value,
        width: width2
      };
    });
    const classMap = computed(() => isArray$9(props2.iconClasses) ? {
      [props2.lowThreshold]: props2.iconClasses[0],
      [props2.highThreshold]: { value: props2.iconClasses[1], excluded: true },
      [props2.max]: props2.iconClasses[2]
    } : props2.iconClasses);
    const decimalIconClass = computed(() => getValueFromMap(props2.modelValue, classMap.value));
    const voidClass = computed(() => rateDisabled.value ? props2.disabledVoidIconClass : props2.voidIconClass);
    const activeClass = computed(() => getValueFromMap(currentValue.value, classMap.value));
    const classes = computed(() => {
      let result = Array(props2.max);
      let threshold = currentValue.value;
      result.fill(activeClass.value, 0, threshold);
      result.fill(voidClass.value, threshold, props2.max);
      return result;
    });
    const pointerAtLeftHalf = ref(true);
    watch(() => props2.modelValue, (val) => {
      currentValue.value = val;
      pointerAtLeftHalf.value = props2.modelValue !== Math.floor(props2.modelValue);
    });
    function showDecimalIcon(item) {
      let showWhenDisabled = rateDisabled.value && valueDecimal.value > 0 && item - 1 < props2.modelValue && item > props2.modelValue;
      let showWhenAllowHalf = props2.allowHalf && pointerAtLeftHalf.value && item - 0.5 <= currentValue.value && item > currentValue.value;
      return showWhenDisabled || showWhenAllowHalf;
    }
    function getIconStyle(item) {
      const voidColor = rateDisabled.value ? props2.disabledVoidColor : props2.voidColor;
      return {
        color: item <= currentValue.value ? activeColor.value : voidColor
      };
    }
    function selectValue(value2) {
      if (rateDisabled.value) {
        return;
      }
      if (props2.allowHalf && pointerAtLeftHalf.value) {
        emit2(UPDATE_MODEL_EVENT, currentValue.value);
        if (props2.modelValue !== currentValue.value) {
          emit2("change", currentValue.value);
        }
      } else {
        emit2(UPDATE_MODEL_EVENT, value2);
        if (props2.modelValue !== value2) {
          emit2("change", value2);
        }
      }
    }
    function handleKey(e) {
      if (rateDisabled.value) {
        return;
      }
      let _currentValue = currentValue.value;
      const code = e.code;
      if (code === EVENT_CODE.up || code === EVENT_CODE.right) {
        if (props2.allowHalf) {
          _currentValue += 0.5;
        } else {
          _currentValue += 1;
        }
        e.stopPropagation();
        e.preventDefault();
      } else if (code === EVENT_CODE.left || code === EVENT_CODE.down) {
        if (props2.allowHalf) {
          _currentValue -= 0.5;
        } else {
          _currentValue -= 1;
        }
        e.stopPropagation();
        e.preventDefault();
      }
      _currentValue = _currentValue < 0 ? 0 : _currentValue;
      _currentValue = _currentValue > props2.max ? props2.max : _currentValue;
      emit2(UPDATE_MODEL_EVENT, _currentValue);
      emit2("change", _currentValue);
      return _currentValue;
    }
    const hoverIndex = ref(-1);
    function setCurrentValue(value2, event2) {
      if (rateDisabled.value) {
        return;
      }
      if (props2.allowHalf) {
        let target = event2.target;
        if (hasClass(target, "el-rate__item")) {
          target = target.querySelector(".el-rate__icon");
        }
        if (hasClass(target, "el-rate__decimal")) {
          target = target.parentNode;
        }
        pointerAtLeftHalf.value = event2.offsetX * 2 <= target.clientWidth;
        currentValue.value = pointerAtLeftHalf.value ? value2 - 0.5 : value2;
      } else {
        currentValue.value = value2;
      }
      hoverIndex.value = value2;
    }
    function resetCurrentValue() {
      if (rateDisabled.value) {
        return;
      }
      if (props2.allowHalf) {
        pointerAtLeftHalf.value = props2.modelValue !== Math.floor(props2.modelValue);
      }
      currentValue.value = props2.modelValue;
      hoverIndex.value = -1;
    }
    if (!props2.modelValue) {
      emit2(UPDATE_MODEL_EVENT, 0);
    }
    return {
      hoverIndex,
      currentValue,
      rateDisabled,
      text,
      decimalStyle,
      decimalIconClass,
      classes,
      showDecimalIcon,
      getIconStyle,
      selectValue,
      handleKey,
      setCurrentValue,
      resetCurrentValue
    };
  }
});
const _hoisted_1$G = ["aria-valuenow", "aria-valuetext", "aria-valuemax"];
const _hoisted_2$A = ["onMousemove", "onClick"];
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "el-rate",
    role: "slider",
    "aria-valuenow": _ctx.currentValue,
    "aria-valuetext": _ctx.text,
    "aria-valuemin": "0",
    "aria-valuemax": _ctx.max,
    tabindex: "0",
    onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.handleKey && _ctx.handleKey(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.max, (item, key) => {
      return openBlock(), createElementBlock("span", {
        key,
        class: "el-rate__item",
        style: normalizeStyle({ cursor: _ctx.rateDisabled ? "auto" : "pointer" }),
        onMousemove: ($event) => _ctx.setCurrentValue(item, $event),
        onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.resetCurrentValue && _ctx.resetCurrentValue(...args)),
        onClick: ($event) => _ctx.selectValue(item)
      }, [
        createElementVNode("i", {
          class: normalizeClass([[_ctx.classes[item - 1], { "hover": _ctx.hoverIndex === item }], "el-rate__icon"]),
          style: normalizeStyle(_ctx.getIconStyle(item))
        }, [
          _ctx.showDecimalIcon(item) ? (openBlock(), createElementBlock("i", {
            key: 0,
            class: normalizeClass([_ctx.decimalIconClass, "el-rate__decimal"]),
            style: normalizeStyle(_ctx.decimalStyle)
          }, null, 6)) : createCommentVNode("v-if", true)
        ], 6)
      ], 44, _hoisted_2$A);
    }), 128)),
    _ctx.showText || _ctx.showScore ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: "el-rate__text",
      style: normalizeStyle({ color: _ctx.textColor })
    }, toDisplayString(_ctx.text), 5)) : createCommentVNode("v-if", true)
  ], 40, _hoisted_1$G);
}
script$h.render = render$h;
script$h.__file = "packages/components/rate/src/workprogress.vue";
script$h.install = (app) => {
  app.component(script$h.name, script$h);
};
const _Rate = script$h;
const ElRate = _Rate;
var script$g = defineComponent({
  name: "IconSuccess"
});
const _hoisted_1$F = {
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$z = /* @__PURE__ */ createElementVNode("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M34.5548098,16.4485711 C33.9612228,15.8504763 32.9988282,15.8504763 32.4052412,16.4485711 L32.4052412,16.4485711 L21.413757,27.5805811 L21.413757,27.5805811 L21.4034642,27.590855 C21.0097542,27.9781674 20.3766105,27.9729811 19.9892981,27.5792711 L19.9892981,27.5792711 L15.5947588,23.1121428 C15.0011718,22.514048 14.0387772,22.514048 13.4451902,23.1121428 C12.8516033,23.7102376 12.8516033,24.6799409 13.4451902,25.2780357 L13.4451902,25.2780357 L19.6260786,31.5514289 C20.2196656,32.1495237 21.1820602,32.1495237 21.7756472,31.5514289 L21.7756472,31.5514289 L34.5548098,18.614464 C35.1483967,18.0163692 35.1483967,17.0466659 34.5548098,16.4485711 Z" }, null, -1);
const _hoisted_3$y = [
  _hoisted_2$z
];
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$F, _hoisted_3$y);
}
script$g.render = render$g;
script$g.__file = "packages/components/result/src/icon-success.vue";
var script$1$b = defineComponent({
  name: "IconError"
});
const _hoisted_1$1$6 = {
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1$4 = /* @__PURE__ */ createElementVNode("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M32.57818,15.42182 C32.0157534,14.8593933 31.1038797,14.8593933 30.541453,15.42182 L30.541453,15.42182 L24.0006789,21.9625941 L17.458547,15.42182 C16.8961203,14.8593933 15.9842466,14.8593933 15.42182,15.42182 C14.8593933,15.9842466 14.8593933,16.8961203 15.42182,17.458547 L15.42182,17.458547 L21.9639519,23.9993211 L15.42182,30.541453 C14.8593933,31.1038797 14.8593933,32.0157534 15.42182,32.57818 C15.9842466,33.1406067 16.8961203,33.1406067 17.458547,32.57818 L17.458547,32.57818 L24.0006789,26.0360481 L30.541453,32.57818 C31.1038797,33.1406067 32.0157534,33.1406067 32.57818,32.57818 C33.1406067,32.0157534 33.1406067,31.1038797 32.57818,30.541453 L32.57818,30.541453 L26.0374059,23.9993211 L32.57818,17.458547 C33.1406067,16.8961203 33.1406067,15.9842466 32.57818,15.42182 Z" }, null, -1);
const _hoisted_3$1$4 = [
  _hoisted_2$1$4
];
function render$1$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1$6, _hoisted_3$1$4);
}
script$1$b.render = render$1$a;
script$1$b.__file = "packages/components/result/src/icon-error.vue";
var script$2$7 = defineComponent({
  name: "IconWarning"
});
const _hoisted_1$2$1 = {
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2$1 = /* @__PURE__ */ createElementVNode("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M24,31 C22.8954305,31 22,31.8954305 22,33 C22,34.1045695 22.8954305,35 24,35 C25.1045695,35 26,34.1045695 26,33 C26,31.8954305 25.1045695,31 24,31 Z M24,14 C23.1715729,14 22.5,14.6715729 22.5,15.5 L22.5,15.5 L22.5,27.5 C22.5,28.3284271 23.1715729,29 24,29 C24.8284271,29 25.5,28.3284271 25.5,27.5 L25.5,27.5 L25.5,15.5 C25.5,14.6715729 24.8284271,14 24,14 Z" }, null, -1);
const _hoisted_3$2$1 = [
  _hoisted_2$2$1
];
function render$2$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2$1, _hoisted_3$2$1);
}
script$2$7.render = render$2$4;
script$2$7.__file = "packages/components/result/src/icon-warning.vue";
var script$3$3 = defineComponent({
  name: "IconInfo"
});
const _hoisted_1$3$1 = {
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3$1 = /* @__PURE__ */ createElementVNode("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M24,19 L21,19 C20.1715729,19 19.5,19.6715729 19.5,20.5 C19.5,21.3284271 20.1715729,22 21,22 L21,22 L22.5,22 L22.5,31 L21,31 C20.1715729,31 19.5,31.6715729 19.5,32.5 C19.5,33.3284271 20.1715729,34 21,34 L21,34 L27,34 C27.8284271,34 28.5,33.3284271 28.5,32.5 C28.5,31.6715729 27.8284271,31 27,31 L27,31 L25.5,31 L25.5,20.5 C25.5,19.6715729 24.8284271,19 24,19 L24,19 Z M24,13 C22.8954305,13 22,13.8954305 22,15 C22,16.1045695 22.8954305,17 24,17 C25.1045695,17 26,16.1045695 26,15 C26,13.8954305 25.1045695,13 24,13 Z" }, null, -1);
const _hoisted_3$3$1 = [
  _hoisted_2$3$1
];
function render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3$1, _hoisted_3$3$1);
}
script$3$3.render = render$3$1;
script$3$3.__file = "packages/components/result/src/icon-info.vue";
const IconMap = {
  success: "icon-success",
  warning: "icon-warning",
  error: "icon-error",
  info: "icon-info"
};
var script$4$1 = defineComponent({
  name: "ElResult",
  components: {
    [script$g.name]: script$g,
    [script$1$b.name]: script$1$b,
    [script$2$7.name]: script$2$7,
    [script$3$3.name]: script$3$3
  },
  props: {
    title: {
      type: String,
      default: ""
    },
    subTitle: {
      type: String,
      default: ""
    },
    icon: {
      type: String,
      default: "info"
    }
  },
  setup(props2) {
    const iconElement = computed(() => {
      const icon = props2.icon;
      return icon && IconMap[icon] ? IconMap[icon] : "icon-info";
    });
    return {
      iconElement
    };
  }
});
const _hoisted_1$4$1 = { class: "el-result" };
const _hoisted_2$4$1 = { class: "el-result__icon" };
const _hoisted_3$4$1 = {
  key: 0,
  class: "el-result__title"
};
const _hoisted_4$p = {
  key: 1,
  class: "el-result__subtitle"
};
const _hoisted_5$k = {
  key: 2,
  class: "el-result__extra"
};
function render$4$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$4$1, [
    createElementVNode("div", _hoisted_2$4$1, [
      renderSlot(_ctx.$slots, "icon", {}, () => [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconElement), {
          class: normalizeClass(_ctx.iconElement)
        }, null, 8, ["class"]))
      ])
    ]),
    _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("div", _hoisted_3$4$1, [
      renderSlot(_ctx.$slots, "title", {}, () => [
        createElementVNode("p", null, toDisplayString(_ctx.title), 1)
      ])
    ])) : createCommentVNode("v-if", true),
    _ctx.subTitle || _ctx.$slots.subTitle ? (openBlock(), createElementBlock("div", _hoisted_4$p, [
      renderSlot(_ctx.$slots, "subTitle", {}, () => [
        createElementVNode("p", null, toDisplayString(_ctx.subTitle), 1)
      ])
    ])) : createCommentVNode("v-if", true),
    _ctx.$slots.extra ? (openBlock(), createElementBlock("div", _hoisted_5$k, [
      renderSlot(_ctx.$slots, "extra")
    ])) : createCommentVNode("v-if", true)
  ]);
}
script$4$1.render = render$4$1;
script$4$1.__file = "packages/components/result/src/workprogress.vue";
script$4$1.install = (app) => {
  app.component(script$4$1.name, script$4$1);
};
const _Result = script$4$1;
const ElResult = _Result;
var Row = defineComponent({
  name: "ElRow",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    gutter: {
      type: Number,
      default: 0
    },
    justify: {
      type: String,
      default: "start"
    },
    align: {
      type: String,
      default: "top"
    }
  },
  setup(props2, { slots }) {
    const gutter = computed(() => props2.gutter);
    provide("ElRow", {
      gutter
    });
    const style = computed(() => {
      const ret = {
        marginLeft: "",
        marginRight: ""
      };
      if (props2.gutter) {
        ret.marginLeft = `-${props2.gutter / 2}px`;
        ret.marginRight = ret.marginLeft;
      }
      return ret;
    });
    return () => {
      var _a;
      return h(props2.tag, {
        class: [
          "el-row",
          props2.justify !== "start" ? `is-justify-${props2.justify}` : "",
          props2.align !== "top" ? `is-align-${props2.align}` : ""
        ],
        style: style.value
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
const _Row = Row;
_Row.install = (app) => {
  app.component(_Row.name, _Row);
};
const ElRow = _Row;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var memoize_1 = memoize;
let rAF = (fn2) => setTimeout(fn2, 16);
let cAF = (handle) => clearTimeout(handle);
if (!isServer) {
  rAF = (fn2) => window.requestAnimationFrame(fn2);
  cAF = (handle) => window.cancelAnimationFrame(handle);
}
var __defProp$9 = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value2) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
const DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;
const ITEM_RENDER_EVT = "item-rendered";
const SCROLL_EVT = "scroll";
const FORWARD = "forward";
const BACKWARD = "backward";
const AUTO_ALIGNMENT = "auto";
const SMART_ALIGNMENT = "smart";
const START_ALIGNMENT = "start";
const CENTERED_ALIGNMENT = "center";
const END_ALIGNMENT = "end";
const HORIZONTAL = "horizontal";
const VERTICAL = "vertical";
const LTR = "ltr";
const RTL = "rtl";
const RTL_OFFSET_NAG = "negative";
const RTL_OFFSET_POS_ASC = "positive-ascending";
const RTL_OFFSET_POS_DESC = "positive-descending";
const DefaultListProps = {
  cache: {
    type: Number,
    default: 2
  },
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: [String, Object],
    default: "div"
  },
  data: {
    type: [Array],
    default: () => []
  },
  direction: {
    type: String,
    default: "ltr",
    validator: (val) => {
      return val === LTR || val === RTL;
    }
  },
  estimatedItemSize: {
    type: [Number]
  },
  height: {
    type: [String, Number],
    required: true
  },
  layout: {
    type: String,
    default: VERTICAL
  },
  initScrollOffset: {
    type: Number,
    default: 0
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  total: {
    type: Number,
    required: true
  },
  itemSize: {
    type: [Number, Function],
    required: true
  },
  style: {
    type: [Object, String, Array],
    default: () => ({})
  },
  useIsScrolling: {
    type: Boolean,
    default: false
  },
  width: {
    type: [Number, String],
    required: true
  }
};
const DefaultGridProps = {
  className: DefaultListProps.className,
  columnCache: DefaultListProps.cache,
  columnWidth: DefaultListProps.itemSize,
  containerElement: DefaultListProps.containerElement,
  data: DefaultListProps.data,
  direction: DefaultListProps.direction,
  estimatedColumnWidth: DefaultListProps.estimatedItemSize,
  estimatedRowHeight: DefaultListProps.estimatedItemSize,
  height: __spreadProps$9(__spreadValues$9({}, DefaultListProps.height), {
    validator: (val) => isNumber$1(val)
  }),
  initScrollLeft: DefaultListProps.initScrollOffset,
  initScrollTop: DefaultListProps.initScrollOffset,
  innerElement: DefaultListProps.innerElement,
  rowCache: DefaultListProps.cache,
  rowHeight: DefaultListProps.itemSize,
  style: DefaultListProps.style,
  useIsScrolling: DefaultListProps.useIsScrolling,
  width: __spreadProps$9(__spreadValues$9({}, DefaultListProps.width), {
    validator: (val) => {
      return isNumber$1(val);
    }
  }),
  totalColumn: DefaultListProps.total,
  totalRow: DefaultListProps.total
};
const DefaultScrollBarProps = {
  layout: DefaultListProps.layout,
  total: Number,
  ratio: Number,
  clientSize: Number,
  scrollFrom: Number,
  visible: Boolean
};
const ScrollbarDirKey = {
  [HORIZONTAL]: "left",
  [VERTICAL]: "top"
};
const SCROLLBAR_MIN_SIZE = 20;
const getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;
const isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;
const isRTL = (dir) => dir === RTL;
let cachedRTLResult = null;
function getRTLOffsetType(recalculate = false) {
  if (cachedRTLResult === null || recalculate) {
    const outerDiv = document.createElement("div");
    const outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    const innerDiv = document.createElement("div");
    const innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = RTL_OFFSET_POS_DESC;
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = RTL_OFFSET_NAG;
      } else {
        cachedRTLResult = RTL_OFFSET_POS_ASC;
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
function renderThumbStyle({ move, size, bar }, layout) {
  const style = {};
  const translate2 = `translate${bar.axis}(${move}px)`;
  style[bar.size] = size;
  style.transform = translate2;
  style.msTransform = translate2;
  style.webkitTransform = translate2;
  if (layout === "horizontal") {
    style.height = "100%";
  } else {
    style.width = "100%";
  }
  return style;
}
const isFF = typeof navigator !== "undefined" && isObject$b(navigator) && /Firefox/i.test(navigator.userAgent);
const LayoutKeys = {
  [HORIZONTAL]: "deltaX",
  [VERTICAL]: "deltaY"
};
const useWheel = ({
  atEndEdge,
  atStartEdge,
  layout
}, onWheelDelta) => {
  let frameHandle = null;
  let offset2 = 0;
  const hasReachedEdge = (offset22) => {
    const edgeReached = offset22 < 0 && atStartEdge.value || offset22 > 0 && atEndEdge.value;
    return edgeReached;
  };
  const onWheel = (e) => {
    cAF(frameHandle);
    const newOffset = e[LayoutKeys[layout.value]];
    if (hasReachedEdge(offset2) && hasReachedEdge(offset2 + newOffset))
      return;
    offset2 += newOffset;
    if (!isFF) {
      e.preventDefault();
    }
    frameHandle = rAF(() => {
      onWheelDelta(offset2);
      offset2 = 0;
    });
  };
  return {
    hasReachedEdge,
    onWheel
  };
};
const ScrollBar = defineComponent({
  name: "ElVirtualScrollBar",
  props: DefaultScrollBarProps,
  emits: ["scroll", "start-move", "stop-move"],
  setup(props2, { emit: emit2 }) {
    const trackRef = ref(null);
    const thumbRef = ref(null);
    let frameHandle = null;
    let onselectstartStore = null;
    const state = reactive({
      isDragging: false,
      traveled: 0
    });
    const bar = computed(() => BAR_MAP[props2.layout]);
    const trackStyle = computed(() => ({
      display: props2.visible ? null : "none",
      position: "absolute",
      width: HORIZONTAL === props2.layout ? "100%" : "6px",
      height: HORIZONTAL === props2.layout ? "6px" : "auto",
      [ScrollbarDirKey[props2.layout]]: "2px",
      right: "2px",
      bottom: "2px",
      borderRadius: "4px"
    }));
    const thumbSize = computed(() => {
      if (props2.ratio >= 100) {
        return Number.POSITIVE_INFINITY;
      }
      if (props2.ratio >= 50) {
        return props2.ratio * props2.clientSize / 100;
      }
      const SCROLLBAR_MAX_SIZE = props2.clientSize / 3;
      return Math.floor(Math.min(Math.max(props2.ratio * props2.clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));
    });
    const thumbStyle = computed(() => {
      if (!Number.isFinite(thumbSize.value)) {
        return {
          display: "none"
        };
      }
      const thumb = `${thumbSize.value}px`;
      const style = renderThumbStyle({
        bar: bar.value,
        size: thumb,
        move: state.traveled
      }, props2.layout);
      return style;
    });
    const totalSteps = computed(() => Math.floor(props2.clientSize - thumbSize.value - 4));
    const attachEvents2 = () => {
      on$2(window, "mousemove", onMouseMove);
      on$2(window, "mouseup", onMouseUp);
      const thumbEl = thumbRef.value;
      onselectstartStore = document.onselectstart;
      document.onselectstart = () => false;
      on$2(thumbEl, "touchmove", onMouseMove);
      on$2(thumbEl, "touchend", onMouseUp);
    };
    const detachEvents = () => {
      off$2(window, "mousemove", onMouseMove);
      off$2(window, "mouseup", onMouseUp);
      document.onselectstart = onselectstartStore;
      onselectstartStore = null;
      const thumbEl = thumbRef.value;
      off$2(thumbEl, "touchmove", onMouseMove);
      off$2(thumbEl, "touchend", onMouseUp);
    };
    const onThumbMouseDown = (e) => {
      e.stopImmediatePropagation();
      if (e.ctrlKey || [1, 2].includes(e.button)) {
        return;
      }
      state.isDragging = true;
      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
      emit2("start-move");
      attachEvents2();
    };
    const onMouseUp = () => {
      state.isDragging = false;
      state[bar.value.axis] = 0;
      emit2("stop-move");
      detachEvents();
    };
    const onMouseMove = (e) => {
      const { isDragging: isDragging2 } = state;
      if (!isDragging2)
        return;
      const prevPage = state[bar.value.axis];
      if (!prevPage)
        return;
      cAF(frameHandle);
      const offset2 = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;
      const distance = offset2 - thumbClickPosition;
      frameHandle = rAF(() => {
        state.traveled = Math.max(2, Math.min(distance, totalSteps.value));
        emit2("scroll", distance, totalSteps.value);
      });
    };
    const onScrollbarTouchStart = (e) => e.preventDefault();
    watch(() => props2.scrollFrom, (v) => {
      if (state.isDragging)
        return;
      state.traveled = Math.ceil(v * props2.clientSize / (props2.clientSize / totalSteps.value));
    });
    onMounted(() => {
      if (isServer)
        return;
      on$2(trackRef.value, "touchstart", onScrollbarTouchStart);
      on$2(thumbRef.value, "touchstart", onThumbMouseDown);
    });
    onBeforeUnmount(() => {
      off$2(trackRef.value, "touchstart", onScrollbarTouchStart);
      detachEvents();
    });
    return () => {
      return h("div", {
        role: "presentation",
        ref: trackRef,
        class: "el-virtual-scrollbar",
        style: trackStyle.value,
        onMousedown: withModifiers(NOOP, ["stop", "prevent"])
      }, h("div", {
        ref: thumbRef,
        class: "el-scrollbar__thumb",
        style: thumbStyle.value,
        onMousedown: onThumbMouseDown
      }, null));
    };
  }
});
var __defProp$1$4 = Object.defineProperty;
var __defProps$1$3 = Object.defineProperties;
var __getOwnPropDescs$1$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$4 = (obj, key, value2) => key in obj ? __defProp$1$4(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$4.call(b, prop))
      __defNormalProp$1$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$4)
    for (var prop of __getOwnPropSymbols$1$4(b)) {
      if (__propIsEnum$1$4.call(b, prop))
        __defNormalProp$1$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1$3 = (a, b) => __defProps$1$3(a, __getOwnPropDescs$1$3(b));
const createList = ({
  name: name2,
  getOffset: getOffset2,
  getItemSize,
  getItemOffset,
  getEstimatedTotalSize: getEstimatedTotalSize2,
  getStartIndexForOffset,
  getStopIndexForStartIndex,
  initCache,
  clearCache,
  validateProps
}) => {
  return defineComponent({
    name: name2 != null ? name2 : "ElVirtualList",
    props: DefaultListProps,
    emits: [ITEM_RENDER_EVT, SCROLL_EVT],
    setup(props2, { emit: emit2, expose }) {
      validateProps(props2);
      const instance = getCurrentInstance();
      const dynamicSizeCache = ref(initCache(props2, instance));
      const windowRef = ref(null);
      const innerRef = ref(null);
      const scrollbarRef = ref(null);
      const states = ref({
        isScrolling: false,
        scrollDir: "forward",
        scrollOffset: isNumber$1(props2.initScrollOffset) ? props2.initScrollOffset : 0,
        updateRequested: false,
        isScrollbarDragging: false
      });
      const itemsToRender = computed(() => {
        const { total, cache } = props2;
        const { isScrolling, scrollDir, scrollOffset } = $(states);
        if (total === 0) {
          return [0, 0, 0, 0];
        }
        const startIndex = getStartIndexForOffset(props2, scrollOffset, $(dynamicSizeCache));
        const stopIndex = getStopIndexForStartIndex(props2, startIndex, scrollOffset, $(dynamicSizeCache));
        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;
        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;
        return [
          Math.max(0, startIndex - cacheBackward),
          Math.max(0, Math.min(total - 1, stopIndex + cacheForward)),
          startIndex,
          stopIndex
        ];
      });
      const estimatedTotalSize = computed(() => getEstimatedTotalSize2(props2, $(dynamicSizeCache)));
      const _isHorizontal = computed(() => isHorizontal(props2.layout));
      const windowStyle = computed(() => [
        {
          position: "relative",
          overflow: "hidden",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        __spreadValues$1$4({
          direction: props2.direction,
          height: isNumber$1(props2.height) ? `${props2.height}px` : props2.height,
          width: isNumber$1(props2.width) ? `${props2.width}px` : props2.width
        }, props2.style)
      ]);
      const innerStyle = computed(() => {
        const size = $(estimatedTotalSize);
        const horizontal = $(_isHorizontal);
        return {
          height: horizontal ? "100%" : `${size}px`,
          pointerEvents: $(states).isScrolling ? "none" : void 0,
          width: horizontal ? `${size}px` : "100%"
        };
      });
      const clientSize = computed(() => _isHorizontal.value ? props2.width : props2.height);
      const {
        onWheel
      } = useWheel({
        atStartEdge: computed(() => states.value.scrollOffset <= 0),
        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),
        layout: computed(() => props2.layout)
      }, (offset2) => {
        var _a, _b;
        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);
        scrollTo(Math.min(states.value.scrollOffset + offset2, estimatedTotalSize.value - clientSize.value));
      });
      const emitEvents = () => {
        const { total } = props2;
        if (total > 0) {
          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = $(itemsToRender);
          emit2(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
        }
        const { scrollDir, scrollOffset, updateRequested } = $(states);
        emit2(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
      };
      const scrollVertically = (e) => {
        const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;
        const _states = $(states);
        if (_states.scrollOffset === scrollTop) {
          return;
        }
        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
        states.value = __spreadProps$1$3(__spreadValues$1$4({}, _states), {
          isScrolling: true,
          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
          scrollOffset,
          updateRequested: false
        });
        nextTick(resetIsScrolling);
      };
      const scrollHorizontally = (e) => {
        const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;
        const _states = $(states);
        if (_states.scrollOffset === scrollLeft) {
          return;
        }
        const { direction } = props2;
        let scrollOffset = scrollLeft;
        if (direction === RTL) {
          switch (getRTLOffsetType()) {
            case RTL_OFFSET_NAG: {
              scrollOffset = -scrollLeft;
              break;
            }
            case RTL_OFFSET_POS_DESC: {
              scrollOffset = scrollWidth - clientWidth - scrollLeft;
              break;
            }
          }
        }
        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
        states.value = __spreadProps$1$3(__spreadValues$1$4({}, _states), {
          isScrolling: true,
          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
          scrollOffset,
          updateRequested: false
        });
        nextTick(resetIsScrolling);
      };
      const onScroll = (e) => {
        $(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);
        emitEvents();
      };
      const onScrollbarScroll = (distanceToGo, totalSteps) => {
        const offset2 = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset2));
      };
      const getItemStyleCache = memoize_1((_, __, ___) => ({}));
      const scrollTo = (offset2) => {
        offset2 = Math.max(offset2, 0);
        if (offset2 === $(states).scrollOffset) {
          return;
        }
        states.value = __spreadProps$1$3(__spreadValues$1$4({}, $(states)), {
          scrollOffset: offset2,
          scrollDir: getScrollDir($(states).scrollOffset, offset2),
          updateRequested: true
        });
        nextTick(resetIsScrolling);
      };
      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {
        const { scrollOffset } = $(states);
        idx = Math.max(0, Math.min(idx, props2.total - 1));
        scrollTo(getOffset2(props2, idx, alignment, scrollOffset, $(dynamicSizeCache)));
      };
      const getItemStyle = (idx) => {
        const { direction, itemSize, layout } = props2;
        const itemStyleCache = getItemStyleCache(clearCache && itemSize, clearCache && layout, clearCache && direction);
        let style;
        if (hasOwn(itemStyleCache, String(idx))) {
          style = itemStyleCache[idx];
        } else {
          const offset2 = getItemOffset(props2, idx, $(dynamicSizeCache));
          const size = getItemSize(props2, idx, $(dynamicSizeCache));
          const horizontal = $(_isHorizontal);
          const isRtl = direction === RTL;
          const offsetHorizontal = horizontal ? offset2 : 0;
          itemStyleCache[idx] = style = {
            position: "absolute",
            left: isRtl ? void 0 : `${offsetHorizontal}px`,
            right: isRtl ? `${offsetHorizontal}px` : void 0,
            top: !horizontal ? `${offset2}px` : 0,
            height: !horizontal ? `${size}px` : "100%",
            width: horizontal ? `${size}px` : "100%"
          };
        }
        return style;
      };
      const resetIsScrolling = () => {
        states.value.isScrolling = false;
        nextTick(() => {
          getItemStyleCache(-1, null, null);
        });
      };
      const resetScrollTop = () => {
        const window2 = windowRef.value;
        if (window2) {
          window2.scrollTop = 0;
        }
      };
      onMounted(() => {
        if (isServer)
          return;
        const { initScrollOffset } = props2;
        const windowElement = $(windowRef);
        if (isNumber$1(initScrollOffset) && windowElement !== null) {
          if ($(_isHorizontal)) {
            windowElement.scrollLeft = initScrollOffset;
          } else {
            windowElement.scrollTop = initScrollOffset;
          }
        }
        emitEvents();
      });
      onUpdated(() => {
        const { direction, layout } = props2;
        const { scrollOffset, updateRequested } = $(states);
        if (updateRequested && $(windowRef) !== null) {
          const windowElement = $(windowRef);
          if (layout === HORIZONTAL) {
            if (direction === RTL) {
              switch (getRTLOffsetType()) {
                case "negative": {
                  windowElement.scrollLeft = -scrollOffset;
                  break;
                }
                case "positive-ascending": {
                  windowElement.scrollLeft = scrollOffset;
                  break;
                }
                default: {
                  const { clientWidth, scrollWidth } = windowElement;
                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                  break;
                }
              }
            } else {
              windowElement.scrollLeft = scrollOffset;
            }
          } else {
            windowElement.scrollTop = scrollOffset;
          }
        }
      });
      const api = {
        clientSize,
        estimatedTotalSize,
        windowStyle,
        windowRef,
        innerRef,
        innerStyle,
        itemsToRender,
        scrollbarRef,
        states,
        getItemStyle,
        onScroll,
        onScrollbarScroll,
        onWheel,
        scrollTo,
        scrollToItem,
        resetScrollTop
      };
      expose({
        windowRef,
        innerRef,
        getItemStyleCache,
        scrollTo,
        scrollToItem,
        resetScrollTop,
        states
      });
      return api;
    },
    render(ctx2) {
      var _a;
      const {
        $slots,
        className,
        clientSize,
        containerElement,
        data,
        getItemStyle,
        innerElement,
        itemsToRender,
        innerStyle,
        layout,
        total,
        onScroll,
        onScrollbarScroll,
        onWheel,
        states,
        useIsScrolling,
        windowStyle
      } = ctx2;
      const [start2, end2] = itemsToRender;
      const Container = resolveDynamicComponent(containerElement);
      const Inner = resolveDynamicComponent(innerElement);
      const children = [];
      if (total > 0) {
        for (let i2 = start2; i2 <= end2; i2++) {
          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {
            data,
            key: i2,
            index: i2,
            isScrolling: useIsScrolling ? states.isScrolling : void 0,
            style: getItemStyle(i2)
          }));
        }
      }
      const InnerNode = [h(Inner, {
        style: innerStyle,
        ref: "innerRef"
      }, !isString$1(Inner) ? {
        default: () => children
      } : children)];
      const scrollbar = h(ScrollBar, {
        ref: "scrollbarRef",
        clientSize,
        layout,
        onScroll: onScrollbarScroll,
        ratio: clientSize * 100 / this.estimatedTotalSize,
        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
        total,
        visible: true
      });
      const listContainer = h(Container, {
        class: className,
        style: windowStyle,
        onScroll,
        onWheel,
        ref: "windowRef",
        key: 0
      }, !isString$1(Container) ? { default: () => [InnerNode] } : [InnerNode]);
      return h("div", {
        key: 0,
        class: "el-vl__wrapper"
      }, [
        listContainer,
        scrollbar
      ]);
    }
  });
};
const FixedSizeList = createList({
  name: "ElFixedSizeList",
  getItemOffset: ({ itemSize }, index2) => index2 * itemSize,
  getItemSize: ({ itemSize }) => itemSize,
  getEstimatedTotalSize: ({ total, itemSize }) => itemSize * total,
  getOffset: ({ height, total, itemSize, layout, width: width2 }, index2, alignment, scrollOffset) => {
    const size = isHorizontal(layout) ? width2 : height;
    if (isString$1(size)) {
      throwError("[ElVirtualList]", `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `);
    }
    const lastItemOffset = Math.max(0, total * itemSize - size);
    const maxOffset = Math.min(lastItemOffset, index2 * itemSize);
    const minOffset = Math.max(0, (index2 + 1) * itemSize - size);
    if (alignment === SMART_ALIGNMENT) {
      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
        alignment = AUTO_ALIGNMENT;
      } else {
        alignment = CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case START_ALIGNMENT: {
        return maxOffset;
      }
      case END_ALIGNMENT: {
        return minOffset;
      }
      case CENTERED_ALIGNMENT: {
        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(size / 2)) {
          return 0;
        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {
          return lastItemOffset;
        } else {
          return middleOffset;
        }
      }
      case AUTO_ALIGNMENT:
      default: {
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
      }
    }
  },
  getStartIndexForOffset: ({ total, itemSize }, offset2) => Math.max(0, Math.min(total - 1, Math.floor(offset2 / itemSize))),
  getStopIndexForStartIndex: ({ height, total, itemSize, layout, width: width2 }, startIndex, scrollOffset) => {
    const offset2 = startIndex * itemSize;
    const size = isHorizontal(layout) ? width2 : height;
    const numVisibleItems = Math.ceil((size + scrollOffset - offset2) / itemSize);
    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));
  },
  initCache() {
    return void 0;
  },
  clearCache: true,
  validateProps() {
  }
});
const SCOPE$1 = "ElDynamicSizeList";
const getItemFromCache = (props2, index2, listCache) => {
  const { itemSize } = props2;
  const { items, lastVisitedIndex } = listCache;
  if (index2 > lastVisitedIndex) {
    let offset2 = 0;
    if (lastVisitedIndex >= 0) {
      const item = items[lastVisitedIndex];
      offset2 = item.offset + item.size;
    }
    for (let i2 = lastVisitedIndex + 1; i2 <= index2; i2++) {
      const size = itemSize(i2);
      items[i2] = {
        offset: offset2,
        size
      };
      offset2 += size;
    }
    listCache.lastVisitedIndex = index2;
  }
  return items[index2];
};
const findItem = (props2, listCache, offset2) => {
  const { items, lastVisitedIndex } = listCache;
  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
  if (lastVisitedOffset >= offset2) {
    return bs(props2, listCache, 0, lastVisitedIndex, offset2);
  }
  return es(props2, listCache, Math.max(0, lastVisitedIndex), offset2);
};
const bs = (props2, listCache, low, high, offset2) => {
  while (low <= high) {
    const mid = low + Math.floor((high - low) / 2);
    const currentOffset = getItemFromCache(props2, mid, listCache).offset;
    if (currentOffset === offset2) {
      return mid;
    } else if (currentOffset < offset2) {
      low = mid + 1;
    } else if (currentOffset > offset2) {
      high = mid - 1;
    }
  }
  return Math.max(0, low - 1);
};
const es = (props2, listCache, index2, offset2) => {
  const { total } = props2;
  let exponent = 1;
  while (index2 < total && getItemFromCache(props2, index2, listCache).offset < offset2) {
    index2 += exponent;
    exponent *= 2;
  }
  return bs(props2, listCache, Math.floor(index2 / 2), Math.min(index2, total - 1), offset2);
};
const getEstimatedTotalSize = ({ total }, { items, estimatedItemSize, lastVisitedIndex }) => {
  let totalSizeOfMeasuredItems = 0;
  if (lastVisitedIndex >= total) {
    lastVisitedIndex = total - 1;
  }
  if (lastVisitedIndex >= 0) {
    const item = items[lastVisitedIndex];
    totalSizeOfMeasuredItems = item.offset + item.size;
  }
  const numUnmeasuredItems = total - lastVisitedIndex - 1;
  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;
  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};
const DynamicSizeList = createList({
  name: "ElDynamicSizeList",
  getItemOffset: (props2, index2, listCache) => getItemFromCache(props2, index2, listCache).offset,
  getItemSize: (_, index2, { items }) => items[index2].size,
  getEstimatedTotalSize,
  getOffset: (props2, index2, alignment, scrollOffset, listCache) => {
    const { height, layout, width: width2 } = props2;
    const size = isHorizontal(layout) ? width2 : height;
    const item = getItemFromCache(props2, index2, listCache);
    const estimatedTotalSize = getEstimatedTotalSize(props2, listCache);
    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));
    const minOffset = Math.max(0, item.offset - size + item.size);
    if (alignment === SMART_ALIGNMENT) {
      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
        alignment = AUTO_ALIGNMENT;
      } else {
        alignment = CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case START_ALIGNMENT: {
        return maxOffset;
      }
      case END_ALIGNMENT: {
        return minOffset;
      }
      case CENTERED_ALIGNMENT: {
        return Math.round(minOffset + (maxOffset - minOffset) / 2);
      }
      case AUTO_ALIGNMENT:
      default: {
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
      }
    }
  },
  getStartIndexForOffset: (props2, offset2, listCache) => findItem(props2, listCache, offset2),
  getStopIndexForStartIndex: (props2, startIndex, scrollOffset, listCache) => {
    const { height, total, layout, width: width2 } = props2;
    const size = isHorizontal(layout) ? width2 : height;
    const item = getItemFromCache(props2, startIndex, listCache);
    const maxOffset = scrollOffset + size;
    let offset2 = item.offset + item.size;
    let stopIndex = startIndex;
    while (stopIndex < total - 1 && offset2 < maxOffset) {
      stopIndex++;
      offset2 += getItemFromCache(props2, stopIndex, listCache).size;
    }
    return stopIndex;
  },
  initCache({ estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {
    const cache = {
      items: {},
      estimatedItemSize,
      lastVisitedIndex: -1
    };
    cache.clearCacheAfterIndex = (index2, forceUpdate = true) => {
      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index2 - 1);
      instance.exposed.getItemStyleCache(-1);
      if (forceUpdate) {
        instance.proxy.$forceUpdate();
      }
    };
    return cache;
  },
  clearCache: false,
  validateProps: ({ itemSize }) => {
    {
      if (typeof itemSize !== "function") {
        throwError(SCOPE$1, `
          itemSize is required as function, but the given value was ${typeof itemSize}
        `);
      }
    }
  }
});
var __defProp$2$3 = Object.defineProperty;
var __defProps$2$3 = Object.defineProperties;
var __getOwnPropDescs$2$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2$3 = (obj, key, value2) => key in obj ? __defProp$2$3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$2$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2$3.call(b, prop))
      __defNormalProp$2$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$2$3)
    for (var prop of __getOwnPropSymbols$2$3(b)) {
      if (__propIsEnum$2$3.call(b, prop))
        __defNormalProp$2$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2$3 = (a, b) => __defProps$2$3(a, __getOwnPropDescs$2$3(b));
const createGrid = ({
  name: name2,
  clearCache,
  getColumnPosition,
  getColumnStartIndexForOffset,
  getColumnStopIndexForStartIndex,
  getEstimatedTotalHeight: getEstimatedTotalHeight2,
  getEstimatedTotalWidth: getEstimatedTotalWidth2,
  getColumnOffset,
  getRowOffset,
  getRowPosition,
  getRowStartIndexForOffset,
  getRowStopIndexForStartIndex,
  initCache,
  validateProps
}) => {
  return defineComponent({
    name: name2 != null ? name2 : "ElVirtualList",
    props: DefaultGridProps,
    emits: [ITEM_RENDER_EVT, SCROLL_EVT],
    setup(props2, { emit: emit2, expose }) {
      validateProps(props2);
      const instance = getCurrentInstance();
      const cache = ref(initCache(props2, instance));
      const windowRef = ref(null);
      const innerRef = ref(null);
      const states = ref({
        isScrolling: false,
        scrollLeft: isNumber$1(props2.initScrollLeft) ? props2.initScrollLeft : 0,
        scrollTop: isNumber$1(props2.initScrollTop) ? props2.initScrollTop : 0,
        updateRequested: false,
        xAxisScrollDir: FORWARD,
        yAxisScrollDir: FORWARD
      });
      const columnsToRender = computed(() => {
        const { totalColumn, totalRow, columnCache } = props2;
        const { isScrolling, xAxisScrollDir, scrollLeft } = $(states);
        if (totalColumn === 0 || totalRow === 0) {
          return [0, 0, 0, 0];
        }
        const startIndex = getColumnStartIndexForOffset(props2, scrollLeft, $(cache));
        const stopIndex = getColumnStopIndexForStartIndex(props2, startIndex, scrollLeft, $(cache));
        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;
        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;
        return [
          Math.max(0, startIndex - cacheBackward),
          Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),
          startIndex,
          stopIndex
        ];
      });
      const rowsToRender = computed(() => {
        const { totalColumn, totalRow, rowCache } = props2;
        const { isScrolling, yAxisScrollDir, scrollTop } = $(states);
        if (totalColumn === 0 || totalRow === 0) {
          return [0, 0, 0, 0];
        }
        const startIndex = getRowStartIndexForOffset(props2, scrollTop, $(cache));
        const stopIndex = getRowStopIndexForStartIndex(props2, startIndex, scrollTop, $(cache));
        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;
        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;
        return [
          Math.max(0, startIndex - cacheBackward),
          Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),
          startIndex,
          stopIndex
        ];
      });
      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight2(props2, $(cache)));
      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth2(props2, $(cache)));
      const windowStyle = computed(() => [
        {
          position: "relative",
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        __spreadValues$2$3({
          direction: props2.direction,
          height: isNumber$1(props2.height) ? `${props2.height}px` : props2.height,
          width: isNumber$1(props2.width) ? `${props2.width}px` : props2.width
        }, props2.style)
      ]);
      const innerStyle = computed(() => {
        const width2 = `${$(estimatedTotalWidth)}px`;
        const height = `${$(estimatedTotalHeight)}px`;
        return {
          height,
          pointerEvents: $(states).isScrolling ? "none" : void 0,
          width: width2
        };
      });
      const emitEvents = () => {
        const { totalColumn, totalRow } = props2;
        if (totalColumn > 0 && totalRow > 0) {
          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = $(columnsToRender);
          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = $(rowsToRender);
          emit2(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);
        }
        const { scrollLeft, scrollTop, updateRequested, xAxisScrollDir, yAxisScrollDir } = $(states);
        emit2(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);
      };
      const onScroll = (e) => {
        const {
          clientHeight,
          clientWidth,
          scrollHeight,
          scrollLeft,
          scrollTop,
          scrollWidth
        } = e.currentTarget;
        const _states = $(states);
        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {
          return;
        }
        let _scrollLeft = scrollLeft;
        if (isRTL(props2.direction)) {
          switch (getRTLOffsetType()) {
            case RTL_OFFSET_NAG:
              _scrollLeft = -scrollLeft;
              break;
            case RTL_OFFSET_POS_DESC:
              _scrollLeft = scrollWidth - clientWidth - scrollLeft;
              break;
          }
        }
        states.value = __spreadProps$2$3(__spreadValues$2$3({}, _states), {
          isScrolling: true,
          scrollLeft: _scrollLeft,
          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),
          updateRequested: false,
          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),
          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)
        });
        nextTick(resetIsScrolling);
        emitEvents();
      };
      const getItemStyleCache = memoize_1((_, __, ___) => ({}));
      const scrollTo = ({
        scrollLeft,
        scrollTop
      }) => {
        scrollLeft = Math.max(scrollLeft, 0);
        scrollTop = Math.max(scrollTop, 0);
        const _states = $(states);
        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {
          return;
        }
        states.value = __spreadProps$2$3(__spreadValues$2$3({}, _states), {
          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),
          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),
          scrollLeft,
          scrollTop,
          updateRequested: true
        });
        nextTick(resetIsScrolling);
      };
      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {
        const _states = $(states);
        columnIdx = Math.max(0, Math.min(columnIdx, props2.totalColumn - 1));
        rowIndex = Math.max(0, Math.min(rowIndex, props2.totalRow - 1));
        const scrollBarWidth2 = scrollbarWidth();
        const _cache = $(cache);
        const estimatedHeight = getEstimatedTotalHeight2(props2, _cache);
        const estimatedWidth = getEstimatedTotalWidth2(props2, _cache);
        scrollTo({
          scrollLeft: getColumnOffset(props2, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props2.width ? scrollBarWidth2 : 0),
          scrollTop: getRowOffset(props2, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props2.height ? scrollBarWidth2 : 0)
        });
      };
      const getItemStyle = (rowIndex, columnIndex) => {
        const { columnWidth, direction, rowHeight } = props2;
        const itemStyleCache = getItemStyleCache(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);
        const key = `${rowIndex},${columnIndex}`;
        if (hasOwn(itemStyleCache, key)) {
          return itemStyleCache[key];
        } else {
          const [, left2] = getColumnPosition(props2, columnIndex, $(cache));
          const _cache = $(cache);
          const rtl = isRTL(direction);
          const [height, top2] = getRowPosition(props2, rowIndex, _cache);
          const [width2] = getColumnPosition(props2, columnIndex, _cache);
          itemStyleCache[key] = {
            position: "absolute",
            left: rtl ? void 0 : `${left2}px`,
            right: rtl ? `${left2}px` : void 0,
            top: `${top2}px`,
            height: `${height}px`,
            width: `${width2}px`
          };
          return itemStyleCache[key];
        }
      };
      const resetIsScrolling = () => {
        states.value.isScrolling = false;
        nextTick(() => {
          getItemStyleCache(-1, null, null);
        });
      };
      onMounted(() => {
        if (isServer)
          return;
        const { initScrollLeft, initScrollTop } = props2;
        const windowElement = $(windowRef);
        if (windowElement !== null) {
          if (isNumber$1(initScrollLeft)) {
            windowElement.scrollLeft = initScrollLeft;
          }
          if (isNumber$1(initScrollTop)) {
            windowElement.scrollTop = initScrollTop;
          }
        }
        emitEvents();
      });
      onUpdated(() => {
        const { direction } = props2;
        const { scrollLeft, scrollTop, updateRequested } = $(states);
        if (updateRequested && $(windowRef) !== null) {
          const windowElement = $(windowRef);
          if (direction === RTL) {
            switch (getRTLOffsetType()) {
              case RTL_OFFSET_NAG: {
                windowElement.scrollLeft = -scrollLeft;
                break;
              }
              case RTL_OFFSET_POS_ASC: {
                windowElement.scrollLeft = scrollLeft;
                break;
              }
              default: {
                const { clientWidth, scrollWidth } = windowElement;
                windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
              }
            }
          } else {
            windowElement.scrollLeft = Math.max(0, scrollLeft);
          }
          windowElement.scrollTop = Math.max(0, scrollTop);
        }
      });
      const api = {
        windowStyle,
        windowRef,
        columnsToRender,
        innerRef,
        innerStyle,
        states,
        rowsToRender,
        getItemStyle,
        onScroll,
        scrollTo,
        scrollToItem
      };
      expose({
        windowRef,
        innerRef,
        getItemStyleCache,
        scrollTo,
        scrollToItem,
        states
      });
      return api;
    },
    render(ctx2) {
      var _a;
      const {
        $slots,
        className,
        containerElement,
        columnsToRender,
        data,
        getItemStyle,
        innerElement,
        innerStyle,
        rowsToRender,
        onScroll,
        states,
        useIsScrolling,
        windowStyle,
        totalColumn,
        totalRow
      } = ctx2;
      const [columnStart, columnEnd] = columnsToRender;
      const [rowStart, rowEnd] = rowsToRender;
      const Container = resolveDynamicComponent(containerElement);
      const Inner = resolveDynamicComponent(innerElement);
      const children = [];
      if (totalRow > 0 && totalColumn > 0) {
        for (let row = rowStart; row <= rowEnd; row++) {
          for (let column = columnStart; column <= columnEnd; column++) {
            children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {
              columnIndex: column,
              data,
              key: column,
              isScrolling: useIsScrolling ? states.isScrolling : void 0,
              style: getItemStyle(row, column),
              rowIndex: row
            }));
          }
        }
      }
      const InnerNode = [h(Inner, {
        style: innerStyle,
        ref: "innerRef"
      }, !isString$1(Inner) ? {
        default: () => children
      } : children)];
      return h(Container, {
        class: className,
        style: windowStyle,
        onScroll,
        ref: "windowRef"
      }, !isString$1(Container) ? { default: () => InnerNode } : InnerNode);
    }
  });
};
const SCOPE$1$1 = "ElFixedSizeGrid";
createGrid({
  name: "ElFixedSizeGrid",
  getColumnPosition: ({ columnWidth }, index2) => [
    columnWidth,
    index2 * columnWidth
  ],
  getRowPosition: ({ rowHeight }, index2) => [
    rowHeight,
    index2 * rowHeight
  ],
  getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,
  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,
  getColumnOffset: ({ totalColumn, columnWidth, width: width2 }, columnIndex, alignment, scrollLeft, _, scrollBarWidth2) => {
    width2 = Number(width2);
    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width2);
    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
    const minOffset = Math.max(0, columnIndex * columnWidth - width2 + scrollBarWidth2 + columnWidth);
    if (alignment === "smart") {
      if (scrollLeft >= minOffset - width2 && scrollLeft <= maxOffset + width2) {
        alignment = AUTO_ALIGNMENT;
      } else {
        alignment = CENTERED_ALIGNMENT;
      }
    }
    switch (alignment) {
      case START_ALIGNMENT:
        return maxOffset;
      case END_ALIGNMENT:
        return minOffset;
      case CENTERED_ALIGNMENT:
        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(width2 / 2)) {
          return 0;
        } else if (middleOffset > lastColumnOffset + Math.floor(width2 / 2)) {
          return lastColumnOffset;
        } else {
          return middleOffset;
        }
      case AUTO_ALIGNMENT:
      default:
        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
          return scrollLeft;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollLeft < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _, scrollBarWidth2) => {
    height = Number(height);
    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);
    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth2 + rowHeight);
    if (align === SMART_ALIGNMENT) {
      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
        align = AUTO_ALIGNMENT;
      } else {
        align = CENTERED_ALIGNMENT;
      }
    }
    switch (align) {
      case START_ALIGNMENT:
        return maxOffset;
      case END_ALIGNMENT:
        return minOffset;
      case CENTERED_ALIGNMENT:
        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(height / 2)) {
          return 0;
        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
          return lastRowOffset;
        } else {
          return middleOffset;
        }
      case AUTO_ALIGNMENT:
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          return scrollTop;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollTop < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),
  getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width: width2 }, startIndex, scrollLeft) => {
    const left2 = startIndex * columnWidth;
    const visibleColumnsCount = Math.ceil((width2 + scrollLeft - left2) / columnWidth);
    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));
  },
  getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),
  getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {
    const top2 = startIndex * rowHeight;
    const numVisibleRows = Math.ceil((height + scrollTop - top2) / rowHeight);
    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));
  },
  initCache: () => void 0,
  clearCache: true,
  validateProps: ({ columnWidth, rowHeight }) => {
    {
      if (!isNumber$1(columnWidth)) {
        throwError(SCOPE$1$1, `
          "columnWidth" must be passed as number,
            instead ${typeof columnWidth} was given.
        `);
      }
      if (!isNumber$1(rowHeight)) {
        throwError(SCOPE$1$1, `
          "columnWidth" must be passed as number,
            instead ${typeof rowHeight} was given.
        `);
      }
    }
  }
});
const { max, min, floor } = Math;
const SCOPE$2 = "ElDynamicSizeGrid";
const ACCESS_SIZER_KEY_MAP = {
  column: "columnWidth",
  row: "rowHeight"
};
const ACCESS_LAST_VISITED_KEY_MAP = {
  column: "lastVisitedColumnIndex",
  row: "lastVisitedRowIndex"
};
const getItemFromCache$1 = (props2, index2, gridCache, type2) => {
  const [cachedItems, sizer, lastVisited] = [
    gridCache[type2],
    props2[ACCESS_SIZER_KEY_MAP[type2]],
    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type2]]
  ];
  if (index2 > lastVisited) {
    let offset2 = 0;
    if (lastVisited >= 0) {
      const item = cachedItems[lastVisited];
      offset2 = item.offset + item.size;
    }
    for (let i2 = lastVisited + 1; i2 <= index2; i2++) {
      const size = sizer(i2);
      cachedItems[i2] = {
        offset: offset2,
        size
      };
      offset2 += size;
    }
    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type2]] = index2;
  }
  return cachedItems[index2];
};
const bs$1 = (props2, gridCache, low, high, offset2, type2) => {
  while (low <= high) {
    const mid = low + floor((high - low) / 2);
    const currentOffset = getItemFromCache$1(props2, mid, gridCache, type2).offset;
    if (currentOffset === offset2) {
      return mid;
    } else if (currentOffset < offset2) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return max(0, low - 1);
};
const es$1 = (props2, gridCache, idx, offset2, type2) => {
  const total = type2 === "column" ? props2.totalColumn : props2.totalRow;
  let exponent = 1;
  while (idx < total && getItemFromCache$1(props2, idx, gridCache, type2).offset < offset2) {
    idx += exponent;
    exponent *= 2;
  }
  return bs$1(props2, gridCache, floor(idx / 2), min(idx, total - 1), offset2, type2);
};
const findItem$1 = (props2, gridCache, offset2, type2) => {
  const [cache, lastVisitedIndex] = [
    gridCache[type2],
    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type2]]
  ];
  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;
  if (lastVisitedItemOffset >= offset2) {
    return bs$1(props2, gridCache, 0, lastVisitedIndex, offset2, type2);
  }
  return es$1(props2, gridCache, max(0, lastVisitedIndex), offset2, type2);
};
const getEstimatedTotalHeight = ({ totalRow }, {
  estimatedRowHeight,
  lastVisitedRowIndex,
  row
}) => {
  let sizeOfVisitedRows = 0;
  if (lastVisitedRowIndex >= totalRow) {
    lastVisitedRowIndex = totalRow - 1;
  }
  if (lastVisitedRowIndex >= 0) {
    const item = row[lastVisitedRowIndex];
    sizeOfVisitedRows = item.offset + item.size;
  }
  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;
  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;
  return sizeOfVisitedRows + sizeOfUnvisitedItems;
};
const getEstimatedTotalWidth = ({
  totalColumn
}, {
  column,
  estimatedColumnWidth,
  lastVisitedColumnIndex
}) => {
  let sizeOfVisitedColumns = 0;
  if (lastVisitedColumnIndex > totalColumn) {
    lastVisitedColumnIndex = totalColumn - 1;
  }
  if (lastVisitedColumnIndex >= 0) {
    const item = column[lastVisitedColumnIndex];
    sizeOfVisitedColumns = item.offset + item.size;
  }
  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;
  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;
  return sizeOfVisitedColumns + sizeOfUnvisitedItems;
};
const ACCESS_ESTIMATED_SIZE_KEY_MAP = {
  column: getEstimatedTotalWidth,
  row: getEstimatedTotalHeight
};
const getOffset = (props2, index2, alignment, scrollOffset, cache, type2, scrollBarWidth2) => {
  const [
    size,
    estimatedSizeAssociates
  ] = [
    type2 === "row" ? props2.height : props2.width,
    ACCESS_ESTIMATED_SIZE_KEY_MAP[type2]
  ];
  const item = getItemFromCache$1(props2, index2, cache, type2);
  const estimatedSize = estimatedSizeAssociates(props2, cache);
  const maxOffset = max(0, min(estimatedSize - size, item.offset));
  const minOffset = max(0, item.offset - size + scrollBarWidth2 + item.size);
  if (alignment === SMART_ALIGNMENT) {
    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
      alignment = AUTO_ALIGNMENT;
    } else {
      alignment = CENTERED_ALIGNMENT;
    }
  }
  switch (alignment) {
    case START_ALIGNMENT: {
      return maxOffset;
    }
    case END_ALIGNMENT: {
      return minOffset;
    }
    case CENTERED_ALIGNMENT: {
      return Math.round(minOffset + (maxOffset - minOffset) / 2);
    }
    case AUTO_ALIGNMENT:
    default: {
      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
        return scrollOffset;
      } else if (minOffset > maxOffset) {
        return minOffset;
      } else if (scrollOffset < minOffset) {
        return minOffset;
      } else {
        return maxOffset;
      }
    }
  }
};
createGrid({
  name: "ElDynamicSizeGrid",
  getColumnPosition: (props2, idx, cache) => {
    const item = getItemFromCache$1(props2, idx, cache, "column");
    return [item.size, item.offset];
  },
  getRowPosition: (props2, idx, cache) => {
    const item = getItemFromCache$1(props2, idx, cache, "row");
    return [item.size, item.offset];
  },
  getColumnOffset: (props2, columnIndex, alignment, scrollLeft, cache, scrollBarWidth2) => getOffset(props2, columnIndex, alignment, scrollLeft, cache, "column", scrollBarWidth2),
  getRowOffset: (props2, rowIndex, alignment, scrollTop, cache, scrollBarWidth2) => getOffset(props2, rowIndex, alignment, scrollTop, cache, "row", scrollBarWidth2),
  getColumnStartIndexForOffset: (props2, scrollLeft, cache) => findItem$1(props2, cache, scrollLeft, "column"),
  getColumnStopIndexForStartIndex: (props2, startIndex, scrollLeft, cache) => {
    const item = getItemFromCache$1(props2, startIndex, cache, "column");
    const maxOffset = scrollLeft + props2.width;
    let offset2 = item.offset + item.size;
    let stopIndex = startIndex;
    while (stopIndex < props2.totalColumn - 1 && offset2 < maxOffset) {
      stopIndex++;
      offset2 += getItemFromCache$1(props2, startIndex, cache, "column").size;
    }
    return stopIndex;
  },
  getEstimatedTotalHeight,
  getEstimatedTotalWidth,
  getRowStartIndexForOffset: (props2, scrollTop, cache) => findItem$1(props2, cache, scrollTop, "row"),
  getRowStopIndexForStartIndex: (props2, startIndex, scrollTop, cache) => {
    const { totalRow, height } = props2;
    const item = getItemFromCache$1(props2, startIndex, cache, "row");
    const maxOffset = scrollTop + height;
    let offset2 = item.size + item.offset;
    let stopIndex = startIndex;
    while (stopIndex < totalRow - 1 && offset2 < maxOffset) {
      stopIndex++;
      offset2 += getItemFromCache$1(props2, stopIndex, cache, "row").size;
    }
    return stopIndex;
  },
  initCache: ({
    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,
    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE
  }) => {
    const cache = {
      column: {},
      estimatedColumnWidth,
      estimatedRowHeight,
      lastVisitedColumnIndex: -1,
      lastVisitedRowIndex: -1,
      row: {}
    };
    return cache;
  },
  clearCache: true,
  validateProps: ({ columnWidth, rowHeight }) => {
    {
      if (!isFunction$4(columnWidth)) {
        throwError(SCOPE$2, `
          "columnWidth" must be passed as function,
            instead ${typeof columnWidth} was given.
        `);
      }
      if (!isFunction$4(rowHeight)) {
        throwError(SCOPE$2, `
          "columnWidth" must be passed as function,
            instead ${typeof rowHeight} was given.
        `);
      }
    }
  }
});
var script$f = defineComponent({
  props: {
    item: {
      type: Object,
      required: true
    },
    style: Object,
    height: Number
  }
});
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.item.isTitle ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: "el-select-group__title",
    style: normalizeStyle([_ctx.style, { lineHeight: `${_ctx.height}px` }])
  }, toDisplayString(_ctx.item.label), 5)) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: "el-select-group__split",
    style: normalizeStyle(_ctx.style)
  }, [
    createElementVNode("span", {
      class: "el-select-group__split-dash",
      style: normalizeStyle({ top: `${_ctx.height / 2}px` })
    }, null, 4)
  ], 4));
}
script$f.render = render$f;
script$f.__file = "packages/components/select-v2/src/group-item.vue";
function useOption(props2, { emit: emit2 }) {
  return {
    hoverItem: () => {
      emit2("hover", props2.index);
    },
    selectOptionClick: () => {
      if (!props2.disabled) {
        emit2("select", props2.item, props2.index);
      }
    }
  };
}
const SelectProps = {
  allowCreate: Boolean,
  autocomplete: {
    type: String,
    default: "none"
  },
  automaticDropdown: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: String,
    default: "el-icon-circle-close"
  },
  collapseTags: Boolean,
  defaultFirstOption: Boolean,
  disabled: Boolean,
  estimatedOptionHeight: {
    type: Number,
    default: void 0
  },
  filterable: Boolean,
  filterMethod: Function,
  height: {
    type: Number,
    default: 170
  },
  itemHeight: {
    type: Number,
    default: 34
  },
  id: String,
  loading: Boolean,
  loadingText: String,
  label: String,
  modelValue: [Array, String, Number, Boolean, Object],
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  name: String,
  noDataText: String,
  noMatchText: String,
  remoteMethod: Function,
  reserveKeyword: Boolean,
  options: {
    type: Array,
    required: true
  },
  placeholder: {
    type: String
  },
  popperAppendToBody: {
    type: Boolean,
    default: true
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: () => ({})
  },
  remote: Boolean,
  size: {
    type: String,
    validator: isValidComponentSize
  },
  valueKey: {
    type: String,
    default: "value"
  }
};
const OptionProps = {
  data: Array,
  disabled: Boolean,
  hovering: Boolean,
  item: Object,
  index: Number,
  style: Object,
  selected: Boolean,
  created: Boolean
};
var script$1$a = defineComponent({
  props: OptionProps,
  emits: ["select", "hover"],
  setup(props2, { emit: emit2 }) {
    const { hoverItem, selectOptionClick } = useOption(props2, { emit: emit2 });
    return {
      hoverItem,
      selectOptionClick
    };
  }
});
const _hoisted_1$E = ["aria-selected"];
function render$1$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    "aria-selected": _ctx.selected,
    style: normalizeStyle(_ctx.style),
    class: normalizeClass({
      "el-select-dropdown__option-item": true,
      "is-selected": _ctx.selected,
      "is-disabled": _ctx.disabled,
      "is-craeted": _ctx.created,
      "hover": _ctx.hovering
    }),
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
    onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
  }, [
    renderSlot(_ctx.$slots, "default", {
      item: _ctx.item,
      index: _ctx.index,
      disabled: _ctx.disabled
    }, () => [
      createElementVNode("span", null, toDisplayString(_ctx.item.label), 1)
    ])
  ], 46, _hoisted_1$E);
}
script$1$a.render = render$1$9;
script$1$a.__file = "packages/components/select-v2/src/option-item.vue";
const selectV2InjectionKey = "ElSelectV2Injection";
var __defProp$8 = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value2) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
var script$2$6 = defineComponent({
  name: "ElSelectDropdown",
  props: {
    data: Array,
    hoveringIndex: Number,
    width: Number
  },
  setup(props2) {
    const select = inject(selectV2InjectionKey);
    const cachedHeights = ref([]);
    const listRef = ref(null);
    const isSized = computed(() => isUndefined$1(select.props.estimatedOptionHeight));
    const listProps = computed(() => {
      if (isSized.value) {
        return {
          itemSize: select.props.itemHeight
        };
      }
      return {
        estimatedSize: select.props.estimatedOptionHeight,
        itemSize: (idx) => cachedHeights.value[idx]
      };
    });
    const contains2 = (arr = [], target) => {
      const {
        props: {
          valueKey
        }
      } = select;
      if (!isObject$b(target)) {
        return arr.includes(target);
      }
      return arr && arr.some((item) => {
        return getValueByPath(item, valueKey) === getValueByPath(target, valueKey);
      });
    };
    const isEqual2 = (selected, target) => {
      if (!isObject$b(target)) {
        return selected === target;
      } else {
        const { valueKey } = select.props;
        return getValueByPath(selected, valueKey) === getValueByPath(target, valueKey);
      }
    };
    const isItemSelected = (modelValue, target) => {
      if (select.props.multiple) {
        return contains2(modelValue, target.value);
      }
      return isEqual2(modelValue, target.value);
    };
    const isItemDisabled = (modelValue, selected) => {
      const { disabled, multiple, multipleLimit } = select.props;
      return disabled || !selected && (multiple ? multipleLimit > 0 && modelValue.length >= multipleLimit : false);
    };
    const isItemHovering = (target) => props2.hoveringIndex === target;
    const scrollToItem = (index2) => {
      const list = listRef.value;
      if (list) {
        listRef.value.scrollToItem(index2);
      }
    };
    const resetScrollTop = () => {
      const list = listRef.value;
      if (list) {
        listRef.value.resetScrollTop();
      }
    };
    return {
      select,
      listProps,
      listRef,
      isSized,
      isItemDisabled,
      isItemHovering,
      isItemSelected,
      scrollToItem,
      resetScrollTop
    };
  },
  render(_ctx, _cache) {
    var _a;
    const {
      $slots,
      data,
      listProps,
      select,
      isSized,
      width: width2,
      isItemDisabled,
      isItemHovering,
      isItemSelected
    } = _ctx;
    const Comp = isSized ? FixedSizeList : DynamicSizeList;
    const { props: selectProps, onSelect, onKeyboardNavigate, onKeyboardSelect } = select;
    const { height, modelValue, multiple } = selectProps;
    if (data.length === 0) {
      return h("div", {
        class: "el-select-dropdown",
        style: {
          width: `${width2}px`
        }
      }, (_a = $slots.empty) == null ? void 0 : _a.call($slots));
    }
    const ListItem = withCtx((scoped) => {
      const { index: index2, data: data2 } = scoped;
      const item = data2[index2];
      if (data2[index2].type === "Group") {
        return h(script$f, {
          item,
          style: scoped.style,
          height: isSized ? listProps.itemSize : listProps.estimatedSize
        });
      }
      const selected = isItemSelected(modelValue, item);
      const itemDisabled = isItemDisabled(modelValue, selected);
      return h(script$1$a, __spreadProps$8(__spreadValues$8({}, scoped), {
        selected,
        disabled: item.disabled || itemDisabled,
        created: !!item.created,
        hovering: isItemHovering(index2),
        item,
        onSelect
      }), {
        default: withCtx((props2) => {
          return renderSlot($slots, "default", props2, () => [h("span", item.label)]);
        })
      });
    });
    const List = h(Comp, __spreadValues$8({
      ref: "listRef",
      className: "el-select-dropdown__list",
      data,
      height,
      width: width2,
      total: data.length,
      onKeydown: [
        _cache[1] || (_cache[1] = withKeys(withModifiers(() => onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
        _cache[2] || (_cache[2] = withKeys(withModifiers(() => onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
        _cache[3] || (_cache[3] = withKeys(withModifiers(onKeyboardSelect, ["stop", "prevent"]), ["enter"])),
        _cache[4] || (_cache[4] = withKeys(withModifiers(() => select.expanded = false, ["stop", "prevent"]), ["esc"])),
        _cache[5] || (_cache[5] = withKeys(() => select.expanded = false, ["tab"]))
      ]
    }, listProps), {
      default: ListItem
    });
    return h("div", {
      class: {
        "is-multiple": multiple,
        "el-select-dropdown": true
      }
    }, [List]);
  }
});
script$2$6.__file = "packages/components/select-v2/src/select-dropdown.vue";
function useAllowCreate(props2, states) {
  const createOptionCount = ref(0);
  const cachedSelectedOption = ref(null);
  const enableAllowCreateMode = computed(() => {
    return props2.allowCreate && props2.filterable;
  });
  function hasExistingOption(query) {
    const hasValue = (option2) => option2.value === query;
    return props2.options && props2.options.some(hasValue) || states.createdOptions.some(hasValue);
  }
  function selectNewOption(option2) {
    if (!enableAllowCreateMode.value) {
      return;
    }
    if (props2.multiple && option2.created) {
      createOptionCount.value++;
    } else {
      cachedSelectedOption.value = option2;
    }
  }
  function createNewOption(query) {
    if (enableAllowCreateMode.value) {
      if (query && query.length > 0 && !hasExistingOption(query)) {
        const newOption = {
          value: query,
          label: query,
          created: true,
          disabled: false
        };
        if (states.createdOptions.length >= createOptionCount.value) {
          states.createdOptions[createOptionCount.value] = newOption;
        } else {
          states.createdOptions.push(newOption);
        }
      } else {
        if (props2.multiple) {
          states.createdOptions.length = createOptionCount.value;
        } else {
          const selectedOption = cachedSelectedOption.value;
          states.createdOptions.length = 0;
          if (selectedOption && selectedOption.created) {
            states.createdOptions.push(selectedOption);
          }
        }
      }
    }
  }
  function removeNewOption(option2) {
    if (!enableAllowCreateMode.value || !option2 || !option2.created) {
      return;
    }
    const idx = states.createdOptions.findIndex((it) => it.value === option2.value);
    if (~idx) {
      states.createdOptions.splice(idx, 1);
      createOptionCount.value--;
    }
  }
  function clearAllNewOption() {
    if (enableAllowCreateMode.value) {
      states.createdOptions.length = 0;
      createOptionCount.value = 0;
    }
  }
  return {
    createNewOption,
    removeNewOption,
    selectNewOption,
    clearAllNewOption
  };
}
const flattenOptions = (options2) => {
  const flattened = [];
  options2.map((option2) => {
    if (isArray$9(option2.options)) {
      flattened.push({
        label: option2.label,
        isTitle: true,
        type: "Group"
      });
      option2.options.forEach((o) => {
        flattened.push(o);
      });
      flattened.push({
        type: "Group"
      });
    } else {
      flattened.push(option2);
    }
  });
  return flattened;
};
var __defProp$1$3 = Object.defineProperty;
var __defProps$1$2 = Object.defineProperties;
var __getOwnPropDescs$1$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$3 = (obj, key, value2) => key in obj ? __defProp$1$3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$3.call(b, prop))
      __defNormalProp$1$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$3)
    for (var prop of __getOwnPropSymbols$1$3(b)) {
      if (__propIsEnum$1$3.call(b, prop))
        __defNormalProp$1$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1$2 = (a, b) => __defProps$1$2(a, __getOwnPropDescs$1$2(b));
const DEFAULT_INPUT_PLACEHOLDER = "";
const MINIMUM_INPUT_WIDTH = 4;
const useSelect = (props2, emit2) => {
  const { t } = useLocaleInject();
  const elForm = inject(elFormKey, {});
  const elFormItem = inject(elFormItemKey, {});
  const $ELEMENT2 = useGlobalConfig();
  const states = reactive({
    inputValue: DEFAULT_INPUT_PLACEHOLDER,
    displayInputValue: DEFAULT_INPUT_PLACEHOLDER,
    calculatedWidth: 0,
    cachedPlaceholder: "",
    cachedOptions: [],
    createdOptions: [],
    createdLabel: "",
    createdSelected: false,
    currentPlaceholder: "",
    hoveringIndex: -1,
    comboBoxHovering: false,
    isOnComposition: false,
    isSilentBlur: false,
    isComposing: false,
    inputLength: 20,
    inputWidth: 240,
    initialInputHeight: 0,
    previousQuery: null,
    query: "",
    selectedLabel: "",
    softFocus: false,
    tagInMultiLine: false
  });
  const selectedIndex = ref(-1);
  const popperSize = ref(-1);
  const controlRef = ref(null);
  const inputRef = ref(null);
  const menuRef = ref(null);
  const popper2 = ref(null);
  const selectRef = ref(null);
  const selectionRef = ref(null);
  const calculatorRef = ref(null);
  const expanded = ref(false);
  const selectDisabled = computed(() => props2.disabled || elForm.disabled);
  const popupHeight = computed(() => {
    const totalHeight = filteredOptions.value.length * 34;
    return totalHeight > props2.height ? props2.height : totalHeight;
  });
  const showClearBtn = computed(() => {
    const hasValue = props2.multiple ? Array.isArray(props2.modelValue) && props2.modelValue.length > 0 : props2.modelValue !== void 0 && props2.modelValue !== null && props2.modelValue !== "";
    const criteria = props2.clearable && !selectDisabled.value && states.comboBoxHovering && hasValue;
    return criteria;
  });
  const iconClass = computed(() => props2.remote && props2.filterable ? "" : expanded.value ? "arrow-up is-reverse" : "arrow-up");
  const debounce2 = computed(() => props2.remote ? 300 : 0);
  const emptyText = computed(() => {
    const options2 = filteredOptions.value;
    if (props2.loading) {
      return props2.loadingText || t("el.select.loading");
    } else {
      if (props2.remote && states.query === "" && options2.length === 0)
        return false;
      if (props2.filterable && states.query && options2.length > 0) {
        return props2.noMatchText || t("el.select.noMatch");
      }
      if (options2.length === 0) {
        return props2.noDataText || t("el.select.noData");
      }
    }
    return null;
  });
  const filteredOptions = computed(() => {
    const isValidOption = (o) => {
      const query = states.inputValue;
      const containsQueryString = query ? o.label.includes(query) : true;
      return containsQueryString;
    };
    return flattenOptions(props2.options.concat(states.createdOptions).map((v) => {
      if (isArray$9(v.options)) {
        const filtered = v.options.filter(isValidOption);
        if (filtered.length > 0) {
          return __spreadProps$1$2(__spreadValues$1$3({}, v), {
            options: filtered
          });
        }
      } else {
        if (isValidOption(v)) {
          return v;
        }
      }
      return null;
    }).filter((v) => v !== null));
  });
  const selectSize = computed(() => props2.size || elFormItem.size || $ELEMENT2.size);
  const collapseTagSize = computed(() => ["small", "mini"].indexOf(selectSize.value) > -1 ? "mini" : "small");
  const calculatePopperSize = () => {
    var _a, _b, _c;
    popperSize.value = ((_c = (_b = (_a = selectRef.value) == null ? void 0 : _a.getBoundingClientRect) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.width) || 200;
  };
  const inputWrapperStyle = computed(() => {
    return {
      width: `${states.calculatedWidth === 0 ? MINIMUM_INPUT_WIDTH : Math.ceil(states.calculatedWidth) + MINIMUM_INPUT_WIDTH}px`
    };
  });
  const shouldShowPlaceholder = computed(() => {
    if (isArray$9(props2.modelValue)) {
      return props2.modelValue.length === 0 && !states.displayInputValue;
    }
    return props2.filterable ? states.displayInputValue.length === 0 : true;
  });
  const currentPlaceholder = computed(() => {
    const _placeholder = props2.placeholder || t("el.select.placeholder");
    return props2.multiple ? _placeholder : states.selectedLabel || _placeholder;
  });
  const popperRef = computed(() => {
    var _a;
    return (_a = popper2.value) == null ? void 0 : _a.popperRef;
  });
  const indexRef = computed(() => {
    if (props2.multiple) {
      if (props2.modelValue.length > 0) {
        return filteredOptions.value.findIndex((o) => o.value === props2.modelValue[0]);
      }
    } else {
      if (props2.modelValue) {
        return filteredOptions.value.findIndex((o) => o.value === props2.modelValue);
      }
    }
    return -1;
  });
  const { createNewOption, removeNewOption, selectNewOption, clearAllNewOption } = useAllowCreate(props2, states);
  const focusAndUpdatePopup = () => {
    var _a, _b, _c, _d;
    (_b = (_a = inputRef.value).focus) == null ? void 0 : _b.call(_a);
    (_d = (_c = popper2.value).update) == null ? void 0 : _d.call(_c);
  };
  const toggleMenu = () => {
    var _a, _b;
    if (props2.automaticDropdown)
      return;
    if (!selectDisabled.value) {
      if (states.isComposing)
        states.softFocus = true;
      expanded.value = !expanded.value;
      (_b = (_a = inputRef.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    }
  };
  const handleQueryChange = (val) => {
    if (states.previousQuery === val || states.isOnComposition)
      return;
    if (states.previousQuery === null && (isFunction$4(props2.filterMethod) || isFunction$4(props2.remoteMethod))) {
      states.previousQuery = val;
      return;
    }
    states.previousQuery = val;
    nextTick(() => {
      var _a, _b;
      if (expanded.value)
        (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    });
    states.hoveringIndex = -1;
    if (props2.multiple && props2.filterable) {
      nextTick(() => {
        const length = inputRef.value.value.length * 15 + 20;
        states.inputLength = props2.collapseTags ? Math.min(50, length) : length;
        resetInputHeight();
      });
    }
    if (props2.remote && isFunction$4(props2.remoteMethod)) {
      states.hoveringIndex = -1;
      props2.remoteMethod(val);
    } else if (isFunction$4(props2.filterMethod)) {
      props2.filterMethod(val);
    } else
      ;
    if (props2.defaultFirstOption && (props2.filterable || props2.remote))
      ;
  };
  const onInputChange = () => {
    if (props2.filterable && states.inputValue !== states.selectedLabel) {
      states.query = states.selectedLabel;
      handleQueryChange(states.query);
    }
  };
  const debouncedOnInputChange = debounce_1(onInputChange, debounce2.value);
  const debouncedQueryChange = debounce_1((e) => {
    handleQueryChange(e.target.value);
  }, debounce2.value);
  const emitChange = (val) => {
    if (!isEqual_1(props2.modelValue, val)) {
      emit2(CHANGE_EVENT, val);
    }
  };
  const update = (val) => {
    emit2(UPDATE_MODEL_EVENT, val);
    emitChange(val);
  };
  const getValueIndex = (arr = [], value2) => {
    if (!isObject$b(value2))
      return arr.indexOf(value2);
    const valueKey = props2.valueKey;
    let index2 = -1;
    arr.some((item, i2) => {
      if (getValueByPath(item, valueKey) === getValueByPath(value2, valueKey)) {
        index2 = i2;
        return true;
      }
      return false;
    });
    return index2;
  };
  const getValueKey = (item) => {
    return isObject$b(item) ? getValueByPath(item, props2.valueKey) : item;
  };
  const getLabel = (item) => {
    return isObject$b(item) ? item.label : item;
  };
  const resetInputHeight = () => {
    if (props2.collapseTags && !props2.filterable)
      return;
    nextTick(() => {
      var _a, _b;
      if (!inputRef.value)
        return;
      const selection = selectionRef.value;
      selectRef.value.height = selection.offsetHeight;
      if (expanded.value && emptyText.value !== false) {
        (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
      }
    });
  };
  const handleResize = () => {
    var _a, _b;
    resetInputWidth();
    calculatePopperSize();
    (_b = (_a = popper2.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);
    if (props2.multiple)
      resetInputHeight();
  };
  const resetInputWidth = () => {
    if (inputRef.value) {
      states.inputWidth = inputRef.value.getBoundingClientRect().width;
    }
  };
  const onSelect = (option2, idx, byClick = true) => {
    var _a, _b;
    if (props2.multiple) {
      let selectedOptions = props2.modelValue.slice();
      const index2 = getValueIndex(selectedOptions, option2.value);
      if (index2 > -1) {
        selectedOptions = [
          ...selectedOptions.slice(0, index2),
          ...selectedOptions.slice(index2 + 1)
        ];
        states.cachedOptions.splice(index2, 1);
        removeNewOption(option2);
      } else if (props2.multipleLimit <= 0 || selectedOptions.length < props2.multipleLimit) {
        selectedOptions = [...selectedOptions, option2.value];
        states.cachedOptions.push(option2);
        selectNewOption(option2);
      }
      update(selectedOptions);
      if (option2.created) {
        states.query = "";
        handleQueryChange("");
        states.inputLength = 20;
      }
      if (props2.filterable) {
        (_b = (_a = inputRef.value).focus) == null ? void 0 : _b.call(_a);
        onUpdateInputValue("");
      }
      if (props2.filterable) {
        states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
      }
      resetInputHeight();
    } else {
      selectedIndex.value = idx;
      states.selectedLabel = option2.label;
      update(option2.value);
      expanded.value = false;
      states.isComposing = false;
      states.isSilentBlur = byClick;
      selectNewOption(option2);
      if (!option2.created) {
        clearAllNewOption();
      }
    }
  };
  const deleteTag = (event2, tag) => {
    const index2 = props2.modelValue.indexOf(tag.value);
    if (index2 > -1 && !selectDisabled.value) {
      const value2 = [
        ...props2.modelValue.slice(0, index2),
        ...props2.modelValue.slice(index2 + 1)
      ];
      states.cachedOptions.splice(index2, 1);
      update(value2);
      emit2("remove-tag", tag.value);
      states.softFocus = true;
      nextTick(focusAndUpdatePopup);
      removeNewOption(tag);
    }
    event2.stopPropagation();
  };
  const handleInputBoxClick = () => {
    if (states.displayInputValue.length === 0 && expanded.value) {
      expanded.value = false;
    }
  };
  const handleFocus = (event2) => {
    const focused = states.isComposing;
    states.isComposing = true;
    if (!states.softFocus) {
      if (props2.automaticDropdown || props2.filterable) {
        expanded.value = true;
      }
      if (!focused)
        emit2("focus", event2);
    } else {
      states.softFocus = false;
    }
  };
  const handleBlur = () => {
    states.softFocus = false;
    nextTick(() => {
      var _a, _b;
      (_b = (_a = inputRef.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
      if (calculatorRef.value) {
        states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
      }
      if (states.isSilentBlur) {
        states.isSilentBlur = false;
      } else {
        if (states.isComposing) {
          emit2("blur");
        }
      }
      states.isComposing = false;
    });
  };
  const handleEsc = () => {
    if (states.displayInputValue.length > 0) {
      onUpdateInputValue("");
    } else {
      expanded.value = false;
    }
  };
  const handleDel = (e) => {
    if (states.displayInputValue.length === 0) {
      e.preventDefault();
      const selected = props2.modelValue.slice();
      selected.pop();
      removeNewOption(states.cachedOptions.pop());
      update(selected);
    }
  };
  const handleClear = () => {
    let emptyValue;
    if (isArray$9(props2.modelValue)) {
      emptyValue = [];
    } else {
      emptyValue = "";
    }
    states.softFocus = true;
    if (props2.multiple) {
      states.cachedOptions = [];
    } else {
      states.selectedLabel = "";
    }
    expanded.value = false;
    update(emptyValue);
    emit2("clear");
    clearAllNewOption();
    nextTick(focusAndUpdatePopup);
  };
  const onUpdateInputValue = (val) => {
    states.displayInputValue = val;
    states.inputValue = val;
  };
  const onKeyboardNavigate = (direction) => {
    if (selectDisabled.value)
      return;
    if (props2.multiple) {
      expanded.value = true;
      return;
    }
    let newIndex2;
    if (props2.options.length === 0 || filteredOptions.value.length === 0)
      return;
    if (filteredOptions.value.length > 0) {
      if (direction === "forward") {
        newIndex2 = selectedIndex.value + 1;
        if (newIndex2 > filteredOptions.value.length - 1) {
          newIndex2 = 0;
        }
      } else {
        newIndex2 = selectedIndex.value - 1;
        if (newIndex2 < 0) {
          newIndex2 = filteredOptions.value.length - 1;
        }
      }
      selectedIndex.value = newIndex2;
      const option2 = filteredOptions.value[newIndex2];
      if (option2.disabled || option2.type === "Group") {
        onKeyboardNavigate(direction);
        return;
      }
      emit2(UPDATE_MODEL_EVENT, filteredOptions.value[newIndex2]);
      emitChange(filteredOptions.value[newIndex2]);
    }
  };
  const onKeyboardSelect = () => {
    if (!expanded.value) {
      toggleMenu();
    } else {
      onSelect(filteredOptions.value[states.hoveringIndex], states.hoveringIndex, false);
    }
  };
  const onInput = () => {
    if (states.displayInputValue.length > 0 && !expanded.value) {
      expanded.value = true;
    }
    states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;
    if (props2.multiple) {
      resetInputHeight();
    }
    debouncedOnInputChange();
    createNewOption(states.displayInputValue);
  };
  const onCompositionUpdate = (e) => {
    onUpdateInputValue(states.displayInputValue += e.data);
    onInput();
  };
  const handleClickOutside = () => {
    expanded.value = false;
    handleBlur();
  };
  const handleMenuEnter = () => {
    states.inputValue = states.displayInputValue;
    nextTick(() => {
      if (~indexRef.value) {
        scrollToItem(indexRef.value);
      }
    });
  };
  const scrollToItem = (index2) => {
    menuRef.value.scrollToItem(index2);
  };
  const initStates = () => {
    if (props2.multiple) {
      if (props2.modelValue.length > 0) {
        states.cachedOptions.length = 0;
        props2.modelValue.map((selected) => {
          const item = filteredOptions.value.find((option2) => option2.value === selected);
          if (item) {
            states.cachedOptions.push(item);
          }
        });
      }
    } else {
      if (props2.modelValue) {
        const selectedItem = filteredOptions.value.find((o) => o.value === props2.modelValue);
        if (selectedItem) {
          states.selectedLabel = selectedItem.label;
        } else {
          states.selectedLabel = `${props2.modelValue}`;
        }
      } else {
        states.selectedLabel = "";
      }
    }
    calculatePopperSize();
  };
  watch(expanded, (val) => {
    var _a, _b;
    emit2("visible-change", val);
    if (val) {
      (_b = (_a = popper2.value).update) == null ? void 0 : _b.call(_a);
    } else {
      states.displayInputValue = "";
      createNewOption("");
    }
  });
  watch([() => props2.modelValue, () => props2.options], () => {
    initStates();
  }, {
    deep: true
  });
  watch(filteredOptions, () => {
    return nextTick(menuRef.value.resetScrollTop);
  });
  onMounted(() => {
    initStates();
    addResizeListener(selectRef.value, handleResize);
  });
  onBeforeMount(() => {
    removeResizeListener(selectRef.value, handleResize);
  });
  return {
    collapseTagSize,
    currentPlaceholder,
    expanded,
    emptyText,
    popupHeight,
    debounce: debounce2,
    filteredOptions,
    iconClass,
    inputWrapperStyle,
    popperSize,
    shouldShowPlaceholder,
    selectDisabled,
    selectSize,
    showClearBtn,
    states,
    calculatorRef,
    controlRef,
    inputRef,
    menuRef,
    popper: popper2,
    selectRef,
    selectionRef,
    popperRef,
    debouncedOnInputChange,
    debouncedQueryChange,
    deleteTag,
    getLabel,
    getValueKey,
    handleBlur,
    handleClear,
    handleClickOutside,
    handleDel,
    handleEsc,
    handleFocus,
    handleInputBoxClick,
    handleMenuEnter,
    toggleMenu,
    scrollTo: scrollToItem,
    onCompositionUpdate,
    onInput,
    onKeyboardNavigate,
    onKeyboardSelect,
    onSelect,
    onUpdateInputValue
  };
};
var __defProp$2$2 = Object.defineProperty;
var __defProps$2$2 = Object.defineProperties;
var __getOwnPropDescs$2$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2$2 = (obj, key, value2) => key in obj ? __defProp$2$2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$2$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2$2.call(b, prop))
      __defNormalProp$2$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2$2)
    for (var prop of __getOwnPropSymbols$2$2(b)) {
      if (__propIsEnum$2$2.call(b, prop))
        __defNormalProp$2$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2$2 = (a, b) => __defProps$2$2(a, __getOwnPropDescs$2$2(b));
var script$3$2 = defineComponent({
  name: "ElSelectV2",
  components: {
    ElSelectMenu: script$2$6,
    ElTag: ElTag$1,
    ElPopper: ElPopper$1
  },
  directives: { ClickOutside: ClickOutside$1, ModelText: vModelText },
  props: SelectProps,
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, "remove-tag", "clear", "visible-change", "focus", "blur"],
  setup(props2, { emit: emit2 }) {
    const API = useSelect(props2, emit2);
    provide(selectV2InjectionKey, {
      props: reactive(__spreadProps$2$2(__spreadValues$2$2({}, toRefs(props2)), {
        height: API.popupHeight
      })),
      onSelect: API.onSelect,
      onKeyboardNavigate: API.onKeyboardNavigate,
      onKeyboardSelect: API.onKeyboardSelect
    });
    return API;
  }
});
const _hoisted_1$1$5 = { key: 0 };
const _hoisted_2$y = {
  key: 1,
  class: "el-select-v2__selection"
};
const _hoisted_3$x = {
  key: 0,
  class: "el-select-v2__selected-item"
};
const _hoisted_4$o = { class: "el-select-v2__tags-text" };
const _hoisted_5$j = ["id", "autocomplete", "aria-expanded", "aria-labelledby", "disabled", "readonly", "name", "unselectable"];
const _hoisted_6$h = ["textContent"];
const _hoisted_7$d = { class: "el-select-v2__selected-item el-select-v2__input-wrapper" };
const _hoisted_8$c = ["id", "aria-labelledby", "aria-expanded", "autocomplete", "disabled", "name", "readonly", "unselectable"];
const _hoisted_9$c = ["textContent"];
const _hoisted_10$9 = { class: "el-select-v2__suffix" };
const _hoisted_11$7 = { class: "el-select-v2__empty" };
function render$2$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_select_menu = resolveComponent("el-select-menu");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_model_text = resolveDirective("model-text");
  const _directive_click_outside = resolveDirective("click-outside");
  return withDirectives((openBlock(), createElementBlock("div", {
    ref: "selectRef",
    class: normalizeClass([[_ctx.selectSize ? "el-select-v2--" + _ctx.selectSize : ""], "el-select-v2"]),
    onClick: _cache[19] || (_cache[19] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"])),
    onMouseenter: _cache[20] || (_cache[20] = ($event) => _ctx.states.comboBoxHovering = true),
    onMouseleave: _cache[21] || (_cache[21] = ($event) => _ctx.states.comboBoxHovering = false)
  }, [
    createVNode(_component_el_popper, {
      ref: "popper",
      visible: _ctx.expanded,
      "onUpdate:visible": _cache[17] || (_cache[17] = ($event) => _ctx.expanded = $event),
      "append-to-body": _ctx.popperAppendToBody,
      "popper-class": `el-select-v2__popper ${_ctx.popperClass}`,
      "gpu-acceleration": false,
      "stop-popper-mouse-event": false,
      "popper-options": _ctx.popperOptions,
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: "light",
      "manual-mode": "",
      placement: "bottom-start",
      pure: "",
      transition: "el-zoom-in-top",
      trigger: "click",
      onBeforeEnter: _ctx.handleMenuEnter,
      onAfterLeave: _cache[18] || (_cache[18] = ($event) => _ctx.states.inputValue = _ctx.states.displayInputValue)
    }, {
      trigger: withCtx(() => [
        createElementVNode("div", {
          ref: "selectionRef",
          class: normalizeClass(["el-select-v2__wrapper", {
            "is-focused": _ctx.states.isComposing,
            "is-hovering": _ctx.states.comboBoxHovering,
            "is-filterable": _ctx.filterable,
            "is-disabled": _ctx.disabled
          }])
        }, [
          _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", _hoisted_1$1$5, [
            renderSlot(_ctx.$slots, "prefix")
          ])) : createCommentVNode("v-if", true),
          _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_2$y, [
            _ctx.collapseTags && _ctx.modelValue.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$x, [
              createVNode(_component_el_tag, {
                closable: !_ctx.selectDisabled && !_ctx.states.cachedOptions[0].disable,
                size: _ctx.collapseTagSize,
                type: "info",
                "disable-transitions": "",
                onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.states.cachedOptions[0]))
              }, {
                default: withCtx(() => [
                  createElementVNode("span", {
                    class: "el-select-v2__tags-text",
                    style: normalizeStyle({ maxWidth: _ctx.states.inputWidth - 123 + "px" })
                  }, toDisplayString(_ctx.states.cachedOptions[0].label), 5)
                ]),
                _: 1
              }, 8, ["closable", "size"]),
              _ctx.modelValue.length > 1 ? (openBlock(), createBlock(_component_el_tag, {
                key: 0,
                closable: false,
                size: _ctx.collapseTagSize,
                type: "info",
                "disable-transitions": ""
              }, {
                default: withCtx(() => [
                  createElementVNode("span", _hoisted_4$o, "+ " + toDisplayString(_ctx.modelValue.length - 1), 1)
                ]),
                _: 1
              }, 8, ["size"])) : createCommentVNode("v-if", true)
            ])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.states.cachedOptions, (selected, idx) => {
              return openBlock(), createElementBlock("div", {
                key: idx,
                class: "el-select-v2__selected-item"
              }, [
                createVNode(_component_el_tag, {
                  key: _ctx.getValueKey(selected),
                  closable: !_ctx.selectDisabled && !selected.disabled,
                  size: _ctx.collapseTagSize,
                  type: "info",
                  "disable-transitions": "",
                  onClose: ($event) => _ctx.deleteTag($event, selected)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.getLabel(selected)), 1)
                  ]),
                  _: 2
                }, 1032, ["closable", "size", "onClose"])
              ]);
            }), 128)),
            createElementVNode("div", {
              class: "el-select-v2__selected-item el-select-v2__input-wrapper",
              style: normalizeStyle(_ctx.inputWrapperStyle)
            }, [
              withDirectives(createElementVNode("input", {
                id: _ctx.id,
                ref: "inputRef",
                autocomplete: _ctx.autocomplete,
                "aria-autocomplete": "list",
                "aria-haspopup": "listbox",
                autocapitalize: "off",
                "aria-expanded": _ctx.expanded,
                "aria-labelledby": _ctx.label,
                class: normalizeClass(["el-select-v2__combobox-input", [_ctx.selectSize ? `is-${_ctx.selectSize}` : ""]]),
                disabled: _ctx.disabled,
                role: "combobox",
                readonly: !_ctx.filterable,
                spellcheck: "false",
                type: "text",
                name: _ctx.name,
                unselectable: _ctx.expanded ? "on" : void 0,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args)),
                onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleInputBoxClick && _ctx.handleInputBoxClick(...args), ["stop", "prevent"])),
                onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                onInput: _cache[4] || (_cache[4] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                onCompositionupdate: _cache[5] || (_cache[5] = (...args) => _ctx.onCompositionUpdate && _ctx.onCompositionUpdate(...args)),
                onCompositionend: _cache[6] || (_cache[6] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                onKeydown: [
                  _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                  _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.handleDel && _ctx.handleDel(...args), ["stop"]), ["delete"]))
                ]
              }, null, 42, _hoisted_5$j), [
                [_directive_model_text, _ctx.states.displayInputValue]
              ]),
              _ctx.filterable ? (openBlock(), createElementBlock("span", {
                key: 0,
                ref: "calculatorRef",
                "aria-hidden": "true",
                class: "el-select-v2__input-calculator",
                textContent: toDisplayString(_ctx.states.displayInputValue)
              }, null, 8, _hoisted_6$h)) : createCommentVNode("v-if", true)
            ], 4)
          ])) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createElementVNode("div", _hoisted_7$d, [
              withDirectives(createElementVNode("input", {
                id: _ctx.id,
                ref: "inputRef",
                "aria-autocomplete": "list",
                "aria-haspopup": "listbox",
                "aria-labelledby": _ctx.label,
                "aria-expanded": _ctx.expanded,
                autocapitalize: "off",
                autocomplete: _ctx.autocomplete,
                class: "el-select-v2__combobox-input",
                disabled: _ctx.disabled,
                name: _ctx.name,
                role: "combobox",
                readonly: !_ctx.filterable,
                spellcheck: "false",
                type: "text",
                unselectable: _ctx.expanded ? "on" : void 0,
                onClick: _cache[9] || (_cache[9] = withModifiers((...args) => _ctx.handleInputBoxClick && _ctx.handleInputBoxClick(...args), ["stop", "prevent"])),
                onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                onCompositionupdate: _cache[11] || (_cache[11] = (...args) => _ctx.onCompositionUpdate && _ctx.onCompositionUpdate(...args)),
                onFocus: _cache[12] || (_cache[12] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                onInput: _cache[13] || (_cache[13] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                onKeydown: _cache[14] || (_cache[14] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                "onUpdate:modelValue": _cache[15] || (_cache[15] = (...args) => _ctx.onUpdateInputValue && _ctx.onUpdateInputValue(...args))
              }, null, 40, _hoisted_8$c), [
                [_directive_model_text, _ctx.states.displayInputValue]
              ])
            ]),
            _ctx.filterable ? (openBlock(), createElementBlock("span", {
              key: 0,
              ref: "calculatorRef",
              "aria-hidden": "true",
              class: "el-select-v2__selected-item el-select-v2__input-calculator",
              textContent: toDisplayString(_ctx.states.displayInputValue)
            }, null, 8, _hoisted_9$c)) : createCommentVNode("v-if", true)
          ], 64)),
          _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("span", {
            key: 3,
            class: normalizeClass({
              "el-select-v2__placeholder": true,
              "is-transparent": _ctx.states.isComposing || (_ctx.placeholder && _ctx.multiple ? _ctx.modelValue.length === 0 : !_ctx.modelValue)
            })
          }, toDisplayString(_ctx.currentPlaceholder), 3)) : createCommentVNode("v-if", true),
          createElementVNode("span", _hoisted_10$9, [
            withDirectives(createElementVNode("i", {
              class: normalizeClass(["el-select-v2__caret", "el-input__icon", "el-icon-" + _ctx.iconClass])
            }, null, 2), [
              [vShow, !_ctx.showClearBtn]
            ]),
            _ctx.showClearBtn ? (openBlock(), createElementBlock("i", {
              key: 0,
              class: normalizeClass(`el-select-v2__caret el-input__icon ${_ctx.clearIcon}`),
              onClick: _cache[16] || (_cache[16] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["prevent", "stop"]))
            }, null, 2)) : createCommentVNode("v-if", true)
          ])
        ], 2)
      ]),
      default: withCtx(() => [
        createVNode(_component_el_select_menu, {
          ref: "menuRef",
          data: _ctx.filteredOptions,
          width: _ctx.popperSize,
          "hovering-index": _ctx.states.hoveringIndex
        }, {
          default: withCtx((scope) => [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(scope)))
          ]),
          empty: withCtx(() => [
            renderSlot(_ctx.$slots, "empty", {}, () => [
              createElementVNode("p", _hoisted_11$7, toDisplayString(_ctx.emptyText), 1)
            ])
          ]),
          _: 3
        }, 8, ["data", "width", "hovering-index"])
      ]),
      _: 3
    }, 8, ["visible", "append-to-body", "popper-class", "popper-options", "onBeforeEnter"])
  ], 34)), [
    [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
  ]);
}
script$3$2.render = render$2$3;
script$3$2.__file = "packages/components/select-v2/src/select.vue";
script$3$2.install = (app) => {
  app.component(script$3$2.name, script$3$2);
};
const _Select = script$3$2;
const ElSelectV2 = _Select;
var script$e = defineComponent({
  name: "ImgPlaceholder"
});
const _hoisted_1$D = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$x = /* @__PURE__ */ createElementVNode("path", { d: "M64 896V128h896v768H64z m64-128l192-192 116.352 116.352L640 448l256 307.2V192H128v576z m224-480a96 96 0 1 1-0.064 192.064A96 96 0 0 1 352 288z" }, null, -1);
const _hoisted_3$w = [
  _hoisted_2$x
];
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$D, _hoisted_3$w);
}
script$e.render = render$e;
script$e.__file = "packages/components/skeleton/src/image-placeholder.vue";
var script$1$9 = defineComponent({
  name: "ElSkeletonItem",
  components: {
    [script$e.name]: script$e
  },
  props: {
    variant: {
      type: String,
      default: "text"
    }
  }
});
function render$1$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_img_placeholder = resolveComponent("img-placeholder");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-skeleton__item", `el-skeleton__${_ctx.variant}`])
  }, [
    _ctx.variant === "image" ? (openBlock(), createBlock(_component_img_placeholder, { key: 0 })) : createCommentVNode("v-if", true)
  ], 2);
}
script$1$9.render = render$1$8;
script$1$9.__file = "packages/components/skeleton/src/item.vue";
var script$2$5 = defineComponent({
  name: "ElSkeleton",
  components: {
    [script$1$9.name]: script$1$9
  },
  props: {
    animated: {
      type: Boolean,
      default: false
    },
    count: {
      type: Number,
      default: 1
    },
    rows: {
      type: Number,
      default: 3
    },
    loading: {
      type: Boolean,
      default: true
    },
    throttle: {
      type: Number
    }
  },
  setup(props2) {
    const innerLoading = computed(() => {
      return props2.loading;
    });
    const uiLoading = useThrottleRender(innerLoading, props2.throttle);
    return {
      uiLoading
    };
  }
});
function render$2$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_skeleton_item = resolveComponent("el-skeleton-item");
  return _ctx.uiLoading ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    class: ["el-skeleton", _ctx.animated ? "is-animated" : ""]
  }, _ctx.$attrs), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.count, (i2) => {
      return openBlock(), createElementBlock(Fragment, { key: i2 }, [
        _ctx.loading ? renderSlot(_ctx.$slots, "template", { key: i2 }, () => [
          createVNode(_component_el_skeleton_item, {
            class: "is-first",
            variant: "p"
          }),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (item) => {
            return openBlock(), createBlock(_component_el_skeleton_item, {
              key: item,
              class: normalizeClass({
                "el-skeleton__paragraph": true,
                "is-last": item === _ctx.rows && _ctx.rows > 1
              }),
              variant: "p"
            }, null, 8, ["class"]);
          }), 128))
        ]) : createCommentVNode("v-if", true)
      ], 64);
    }), 128))
  ], 16)) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, _ctx.$attrs)));
}
script$2$5.render = render$2$2;
script$2$5.__file = "packages/components/skeleton/src/workprogress.vue";
script$2$5.install = (app) => {
  app.component(script$2$5.name, script$2$5);
  app.component(script$1$9.name, script$1$9);
};
script$2$5.SkeletonItem = script$1$9;
const _Skeleton = script$2$5;
const ElSkeleton = _Skeleton;
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const useTooltip = (props2, formatTooltip, showTooltip) => {
  const tooltip = ref(null);
  const tooltipVisible = ref(false);
  const enableFormat = computed(() => {
    return formatTooltip.value instanceof Function;
  });
  const formatValue = computed(() => {
    return enableFormat.value && formatTooltip.value(props2.modelValue) || props2.modelValue;
  });
  const displayTooltip = debounce_1(() => {
    showTooltip.value && (tooltipVisible.value = true);
  }, 50);
  const hideTooltip = debounce_1(() => {
    showTooltip.value && (tooltipVisible.value = false);
  }, 50);
  return {
    tooltip,
    tooltipVisible,
    formatValue,
    displayTooltip,
    hideTooltip
  };
};
const useSliderButton = (props2, initData, emit2) => {
  const {
    disabled,
    min: min2,
    max: max2,
    step,
    showTooltip,
    precision,
    sliderSize,
    formatTooltip,
    emitChange,
    resetSize,
    updateDragging
  } = inject("SliderProvider");
  const {
    tooltip,
    tooltipVisible,
    formatValue,
    displayTooltip,
    hideTooltip
  } = useTooltip(props2, formatTooltip, showTooltip);
  const currentPosition = computed(() => {
    return `${(props2.modelValue - min2.value) / (max2.value - min2.value) * 100}%`;
  });
  const wrapperStyle = computed(() => {
    return props2.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
  });
  const handleMouseEnter = () => {
    initData.hovering = true;
    displayTooltip();
  };
  const handleMouseLeave = () => {
    initData.hovering = false;
    if (!initData.dragging) {
      hideTooltip();
    }
  };
  const onButtonDown = (event2) => {
    if (disabled.value)
      return;
    event2.preventDefault();
    onDragStart2(event2);
    on$2(window, "mousemove", onDragging);
    on$2(window, "touchmove", onDragging);
    on$2(window, "mouseup", onDragEnd);
    on$2(window, "touchend", onDragEnd);
    on$2(window, "contextmenu", onDragEnd);
  };
  const onLeftKeyDown = () => {
    if (disabled.value)
      return;
    initData.newPosition = parseFloat(currentPosition.value) - step.value / (max2.value - min2.value) * 100;
    setPosition(initData.newPosition);
    emitChange();
  };
  const onRightKeyDown = () => {
    if (disabled.value)
      return;
    initData.newPosition = parseFloat(currentPosition.value) + step.value / (max2.value - min2.value) * 100;
    setPosition(initData.newPosition);
    emitChange();
  };
  const getClientXY = (event2) => {
    let clientX;
    let clientY;
    if (event2.type.startsWith("touch")) {
      clientY = event2.touches[0].clientY;
      clientX = event2.touches[0].clientX;
    } else {
      clientY = event2.clientY;
      clientX = event2.clientX;
    }
    return {
      clientX,
      clientY
    };
  };
  const onDragStart2 = (event2) => {
    initData.dragging = true;
    initData.isClick = true;
    const {
      clientX,
      clientY
    } = getClientXY(event2);
    if (props2.vertical) {
      initData.startY = clientY;
    } else {
      initData.startX = clientX;
    }
    initData.startPosition = parseFloat(currentPosition.value);
    initData.newPosition = initData.startPosition;
  };
  const onDragging = (event2) => {
    if (initData.dragging) {
      initData.isClick = false;
      displayTooltip();
      resetSize();
      let diff;
      const {
        clientX,
        clientY
      } = getClientXY(event2);
      if (props2.vertical) {
        initData.currentY = clientY;
        diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
      } else {
        initData.currentX = clientX;
        diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
      }
      initData.newPosition = initData.startPosition + diff;
      setPosition(initData.newPosition);
    }
  };
  const onDragEnd = () => {
    if (initData.dragging) {
      setTimeout(() => {
        initData.dragging = false;
        if (!initData.hovering) {
          hideTooltip();
        }
        if (!initData.isClick) {
          setPosition(initData.newPosition);
          emitChange();
        }
      }, 0);
      off$2(window, "mousemove", onDragging);
      off$2(window, "touchmove", onDragging);
      off$2(window, "mouseup", onDragEnd);
      off$2(window, "touchend", onDragEnd);
      off$2(window, "contextmenu", onDragEnd);
    }
  };
  const setPosition = (newPosition) => __async$3(void 0, null, function* () {
    if (newPosition === null || isNaN(newPosition))
      return;
    if (newPosition < 0) {
      newPosition = 0;
    } else if (newPosition > 100) {
      newPosition = 100;
    }
    const lengthPerStep = 100 / ((max2.value - min2.value) / step.value);
    const steps = Math.round(newPosition / lengthPerStep);
    let value2 = steps * lengthPerStep * (max2.value - min2.value) * 0.01 + min2.value;
    value2 = parseFloat(value2.toFixed(precision.value));
    emit2(UPDATE_MODEL_EVENT, value2);
    if (!initData.dragging && props2.modelValue !== initData.oldValue) {
      initData.oldValue = props2.modelValue;
    }
    yield nextTick();
    initData.dragging && displayTooltip();
    tooltip.value.updatePopper();
  });
  watch(() => initData.dragging, (val) => {
    updateDragging(val);
  });
  return {
    tooltip,
    tooltipVisible,
    showTooltip,
    wrapperStyle,
    formatValue,
    handleMouseEnter,
    handleMouseLeave,
    onButtonDown,
    onLeftKeyDown,
    onRightKeyDown,
    setPosition
  };
};
var script$d = defineComponent({
  name: "ElSliderButton",
  components: {
    ElTooltip: _Tooltip
  },
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    tooltipClass: {
      type: String,
      default: ""
    }
  },
  emits: [UPDATE_MODEL_EVENT],
  setup(props2, { emit: emit2 }) {
    const initData = reactive({
      hovering: false,
      dragging: false,
      isClick: false,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: props2.modelValue
    });
    const {
      tooltip,
      showTooltip,
      tooltipVisible,
      wrapperStyle,
      formatValue,
      handleMouseEnter,
      handleMouseLeave,
      onButtonDown,
      onLeftKeyDown,
      onRightKeyDown,
      setPosition
    } = useSliderButton(props2, initData, emit2);
    const { hovering, dragging } = toRefs(initData);
    return {
      tooltip,
      tooltipVisible,
      showTooltip,
      wrapperStyle,
      formatValue,
      handleMouseEnter,
      handleMouseLeave,
      onButtonDown,
      onLeftKeyDown,
      onRightKeyDown,
      setPosition,
      hovering,
      dragging
    };
  }
});
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createElementBlock("div", {
    ref: "button",
    class: normalizeClass(["el-slider__button-wrapper", { hover: _ctx.hovering, dragging: _ctx.dragging }]),
    style: normalizeStyle(_ctx.wrapperStyle),
    tabindex: "0",
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onMousedown: _cache[3] || (_cache[3] = (...args) => _ctx.onButtonDown && _ctx.onButtonDown(...args)),
    onTouchstart: _cache[4] || (_cache[4] = (...args) => _ctx.onButtonDown && _ctx.onButtonDown(...args)),
    onFocus: _cache[5] || (_cache[5] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onBlur: _cache[6] || (_cache[6] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onKeydown: [
      _cache[7] || (_cache[7] = withKeys((...args) => _ctx.onLeftKeyDown && _ctx.onLeftKeyDown(...args), ["left"])),
      _cache[8] || (_cache[8] = withKeys((...args) => _ctx.onRightKeyDown && _ctx.onRightKeyDown(...args), ["right"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.onLeftKeyDown && _ctx.onLeftKeyDown(...args), ["prevent"]), ["down"])),
      _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => _ctx.onRightKeyDown && _ctx.onRightKeyDown(...args), ["prevent"]), ["up"]))
    ]
  }, [
    createVNode(_component_el_tooltip, {
      ref: "tooltip",
      modelValue: _ctx.tooltipVisible,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.tooltipVisible = $event),
      placement: "top",
      "stop-popper-mouse-event": false,
      "popper-class": _ctx.tooltipClass,
      disabled: !_ctx.showTooltip,
      manual: ""
    }, {
      content: withCtx(() => [
        createElementVNode("span", null, toDisplayString(_ctx.formatValue), 1)
      ]),
      default: withCtx(() => [
        createElementVNode("div", {
          class: normalizeClass(["el-slider__button", { hover: _ctx.hovering, dragging: _ctx.dragging }])
        }, null, 2)
      ]),
      _: 1
    }, 8, ["modelValue", "popper-class", "disabled"])
  ], 38);
}
script$d.render = render$d;
script$d.__file = "packages/components/slider/src/button.vue";
var script$1$8 = defineComponent({
  name: "ElMarker",
  props: {
    mark: {
      type: [String, Object],
      default: () => void 0
    }
  },
  setup(props2) {
    const label = computed(() => {
      return typeof props2.mark === "string" ? props2.mark : props2.mark.label;
    });
    return {
      label
    };
  },
  render() {
    var _a;
    return h("div", {
      class: "el-slider__marks-text",
      style: (_a = this.mark) == null ? void 0 : _a.style
    }, this.label);
  }
});
script$1$8.__file = "packages/components/slider/src/marker.vue";
const useMarks = (props2) => {
  return computed(() => {
    if (!props2.marks) {
      return [];
    }
    const marksKeys = Object.keys(props2.marks);
    return marksKeys.map(parseFloat).sort((a, b) => a - b).filter((point) => point <= props2.max && point >= props2.min).map((point) => ({
      point,
      position: (point - props2.min) * 100 / (props2.max - props2.min),
      mark: props2.marks[point]
    }));
  });
};
var __async$1$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const useSlide = (props2, initData, emit2) => {
  const elForm = inject(elFormKey, {});
  const elFormItem = inject(elFormItemKey, {});
  const slider = ref(null);
  const firstButton = ref(null);
  const secondButton = ref(null);
  const buttonRefs = {
    firstButton,
    secondButton
  };
  const sliderDisabled = computed(() => {
    return props2.disabled || (elForm.disabled || false);
  });
  const minValue = computed(() => {
    return Math.min(initData.firstValue, initData.secondValue);
  });
  const maxValue = computed(() => {
    return Math.max(initData.firstValue, initData.secondValue);
  });
  const barSize = computed(() => {
    return props2.range ? `${100 * (maxValue.value - minValue.value) / (props2.max - props2.min)}%` : `${100 * (initData.firstValue - props2.min) / (props2.max - props2.min)}%`;
  });
  const barStart = computed(() => {
    return props2.range ? `${100 * (minValue.value - props2.min) / (props2.max - props2.min)}%` : "0%";
  });
  const runwayStyle = computed(() => {
    return props2.vertical ? { height: props2.height } : {};
  });
  const barStyle = computed(() => {
    return props2.vertical ? {
      height: barSize.value,
      bottom: barStart.value
    } : {
      width: barSize.value,
      left: barStart.value
    };
  });
  const resetSize = () => {
    if (slider.value) {
      initData.sliderSize = slider.value[`client${props2.vertical ? "Height" : "Width"}`];
    }
  };
  const setPosition = (percent) => {
    const targetValue = props2.min + percent * (props2.max - props2.min) / 100;
    if (!props2.range) {
      firstButton.value.setPosition(percent);
      return;
    }
    let buttonRefName;
    if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
      buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
    } else {
      buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
    }
    buttonRefs[buttonRefName].value.setPosition(percent);
  };
  const emitChange = () => __async$1$1(void 0, null, function* () {
    yield nextTick();
    emit2(CHANGE_EVENT, props2.range ? [minValue.value, maxValue.value] : props2.modelValue);
  });
  const onSliderClick = (event2) => {
    if (sliderDisabled.value || initData.dragging)
      return;
    resetSize();
    if (props2.vertical) {
      const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
      setPosition((sliderOffsetBottom - event2.clientY) / initData.sliderSize * 100);
    } else {
      const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
      setPosition((event2.clientX - sliderOffsetLeft) / initData.sliderSize * 100);
    }
    emitChange();
  };
  return {
    elFormItem,
    slider,
    firstButton,
    secondButton,
    sliderDisabled,
    minValue,
    maxValue,
    runwayStyle,
    barStyle,
    resetSize,
    setPosition,
    emitChange,
    onSliderClick
  };
};
const useStops = (props2, initData, minValue, maxValue) => {
  const stops = computed(() => {
    if (!props2.showStops || props2.min > props2.max)
      return [];
    if (props2.step === 0) {
      console.warn("[Element Warn][Slider]step should not be 0.");
      return [];
    }
    const stopCount = (props2.max - props2.min) / props2.step;
    const stepWidth = 100 * props2.step / (props2.max - props2.min);
    const result = Array.from({ length: stopCount - 1 }).map((_, index2) => (index2 + 1) * stepWidth);
    if (props2.range) {
      return result.filter((step) => {
        return step < 100 * (minValue.value - props2.min) / (props2.max - props2.min) || step > 100 * (maxValue.value - props2.min) / (props2.max - props2.min);
      });
    } else {
      return result.filter((step) => step > 100 * (initData.firstValue - props2.min) / (props2.max - props2.min));
    }
  });
  const getStopStyle = (position) => {
    return props2.vertical ? { "bottom": position + "%" } : { "left": position + "%" };
  };
  return {
    stops,
    getStopStyle
  };
};
var __defProp$7 = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value2) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
var __async$2$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var script$2$4 = defineComponent({
  name: "ElSlider",
  components: {
    ElInputNumber: _InputNumber,
    SliderButton: script$d,
    SliderMarker: script$1$8
  },
  props: {
    modelValue: {
      type: [Number, Array],
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    showInput: {
      type: Boolean,
      default: false
    },
    showInputControls: {
      type: Boolean,
      default: true
    },
    inputSize: {
      type: String,
      default: "small"
    },
    showStops: {
      type: Boolean,
      default: false
    },
    showTooltip: {
      type: Boolean,
      default: true
    },
    formatTooltip: {
      type: Function,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: false
    },
    range: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    height: {
      type: String,
      default: ""
    },
    debounce: {
      type: Number,
      default: 300
    },
    label: {
      type: String,
      default: void 0
    },
    tooltipClass: {
      type: String,
      default: void 0
    },
    marks: Object
  },
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, INPUT_EVENT],
  setup(props2, { emit: emit2 }) {
    const initData = reactive({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: false,
      sliderSize: 1
    });
    const {
      elFormItem,
      slider,
      firstButton,
      secondButton,
      sliderDisabled,
      minValue,
      maxValue,
      runwayStyle,
      barStyle,
      resetSize,
      emitChange,
      onSliderClick
    } = useSlide(props2, initData, emit2);
    const {
      stops,
      getStopStyle
    } = useStops(props2, initData, minValue, maxValue);
    const markList = useMarks(props2);
    useWatch(props2, initData, minValue, maxValue, emit2, elFormItem);
    const precision = computed(() => {
      let precisions = [props2.min, props2.max, props2.step].map((item) => {
        let decimal = ("" + item).split(".")[1];
        return decimal ? decimal.length : 0;
      });
      return Math.max.apply(null, precisions);
    });
    const { sliderWrapper } = useLifecycle(props2, initData, resetSize);
    const {
      firstValue,
      secondValue,
      oldValue,
      dragging,
      sliderSize
    } = toRefs(initData);
    const updateDragging = (val) => {
      initData.dragging = val;
    };
    provide("SliderProvider", __spreadProps$7(__spreadValues$7({}, toRefs(props2)), {
      sliderSize,
      disabled: sliderDisabled,
      precision,
      emitChange,
      resetSize,
      updateDragging
    }));
    return {
      firstValue,
      secondValue,
      oldValue,
      dragging,
      sliderSize,
      slider,
      firstButton,
      secondButton,
      sliderDisabled,
      runwayStyle,
      barStyle,
      emitChange,
      onSliderClick,
      getStopStyle,
      stops,
      markList,
      sliderWrapper
    };
  }
});
const useWatch = (props2, initData, minValue, maxValue, emit2, elFormItem) => {
  const _emit = (val) => {
    emit2(UPDATE_MODEL_EVENT, val);
    emit2(INPUT_EVENT, val);
  };
  const valueChanged = () => {
    if (props2.range) {
      return ![minValue.value, maxValue.value].every((item, index2) => item === initData.oldValue[index2]);
    } else {
      return props2.modelValue !== initData.oldValue;
    }
  };
  const setValues = () => {
    var _a, _b;
    if (props2.min > props2.max) {
      throwError("Slider", "min should not be greater than max.");
      return;
    }
    const val = props2.modelValue;
    if (props2.range && Array.isArray(val)) {
      if (val[1] < props2.min) {
        _emit([props2.min, props2.min]);
      } else if (val[0] > props2.max) {
        _emit([props2.max, props2.max]);
      } else if (val[0] < props2.min) {
        _emit([props2.min, val[1]]);
      } else if (val[1] > props2.max) {
        _emit([val[0], props2.max]);
      } else {
        initData.firstValue = val[0];
        initData.secondValue = val[1];
        if (valueChanged()) {
          (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", [minValue.value, maxValue.value]);
          initData.oldValue = val.slice();
        }
      }
    } else if (!props2.range && typeof val === "number" && !isNaN(val)) {
      if (val < props2.min) {
        _emit(props2.min);
      } else if (val > props2.max) {
        _emit(props2.max);
      } else {
        initData.firstValue = val;
        if (valueChanged()) {
          (_b = elFormItem.formItemMitt) == null ? void 0 : _b.emit("el.form.change", val);
          initData.oldValue = val;
        }
      }
    }
  };
  setValues();
  watch(() => initData.dragging, (val) => {
    if (!val) {
      setValues();
    }
  });
  watch(() => initData.firstValue, (val) => {
    if (props2.range) {
      _emit([minValue.value, maxValue.value]);
    } else {
      _emit(val);
    }
  });
  watch(() => initData.secondValue, () => {
    if (props2.range) {
      _emit([minValue.value, maxValue.value]);
    }
  });
  watch(() => props2.modelValue, (val, oldVal) => {
    if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index2) => item === oldVal[index2])) {
      return;
    }
    setValues();
  });
  watch(() => [props2.min, props2.max], () => {
    setValues();
  });
};
const useLifecycle = (props2, initData, resetSize) => {
  const sliderWrapper = ref(null);
  onMounted(() => __async$2$1(void 0, null, function* () {
    let valuetext;
    if (props2.range) {
      if (Array.isArray(props2.modelValue)) {
        initData.firstValue = Math.max(props2.min, props2.modelValue[0]);
        initData.secondValue = Math.min(props2.max, props2.modelValue[1]);
      } else {
        initData.firstValue = props2.min;
        initData.secondValue = props2.max;
      }
      initData.oldValue = [initData.firstValue, initData.secondValue];
      valuetext = `${initData.firstValue}-${initData.secondValue}`;
    } else {
      if (typeof props2.modelValue !== "number" || isNaN(props2.modelValue)) {
        initData.firstValue = props2.min;
      } else {
        initData.firstValue = Math.min(props2.max, Math.max(props2.min, props2.modelValue));
      }
      initData.oldValue = initData.firstValue;
      valuetext = initData.firstValue;
    }
    sliderWrapper.value.setAttribute("aria-valuetext", valuetext);
    sliderWrapper.value.setAttribute("aria-label", props2.label ? props2.label : `slider between ${props2.min} and ${props2.max}`);
    on$2(window, "resize", resetSize);
    yield nextTick();
    resetSize();
  }));
  onBeforeUnmount(() => {
    off$2(window, "resize", resetSize);
  });
  return {
    sliderWrapper
  };
};
const _hoisted_1$C = ["aria-valuemin", "aria-valuemax", "aria-orientation", "aria-disabled"];
const _hoisted_2$w = { key: 1 };
const _hoisted_3$v = { class: "el-slider__marks" };
function render$1$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = resolveComponent("el-input-number");
  const _component_slider_button = resolveComponent("slider-button");
  const _component_slider_marker = resolveComponent("slider-marker");
  return openBlock(), createElementBlock("div", {
    ref: "sliderWrapper",
    class: normalizeClass(["el-slider", { "is-vertical": _ctx.vertical, "el-slider--with-input": _ctx.showInput }]),
    role: "slider",
    "aria-valuemin": _ctx.min,
    "aria-valuemax": _ctx.max,
    "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
    "aria-disabled": _ctx.sliderDisabled
  }, [
    _ctx.showInput && !_ctx.range ? (openBlock(), createBlock(_component_el_input_number, {
      key: 0,
      ref: "input",
      modelValue: _ctx.firstValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.firstValue = $event),
      class: "el-slider__input",
      step: _ctx.step,
      disabled: _ctx.sliderDisabled,
      controls: _ctx.showInputControls,
      min: _ctx.min,
      max: _ctx.max,
      debounce: _ctx.debounce,
      size: _ctx.inputSize,
      onChange: _ctx.emitChange
    }, null, 8, ["modelValue", "step", "disabled", "controls", "min", "max", "debounce", "size", "onChange"])) : createCommentVNode("v-if", true),
    createElementVNode("div", {
      ref: "slider",
      class: normalizeClass(["el-slider__runway", { "show-input": _ctx.showInput && !_ctx.range, "disabled": _ctx.sliderDisabled }]),
      style: normalizeStyle(_ctx.runwayStyle),
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.onSliderClick && _ctx.onSliderClick(...args))
    }, [
      createElementVNode("div", {
        class: "el-slider__bar",
        style: normalizeStyle(_ctx.barStyle)
      }, null, 4),
      createVNode(_component_slider_button, {
        ref: "firstButton",
        modelValue: _ctx.firstValue,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.firstValue = $event),
        vertical: _ctx.vertical,
        "tooltip-class": _ctx.tooltipClass
      }, null, 8, ["modelValue", "vertical", "tooltip-class"]),
      _ctx.range ? (openBlock(), createBlock(_component_slider_button, {
        key: 0,
        ref: "secondButton",
        modelValue: _ctx.secondValue,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.secondValue = $event),
        vertical: _ctx.vertical,
        "tooltip-class": _ctx.tooltipClass
      }, null, 8, ["modelValue", "vertical", "tooltip-class"])) : createCommentVNode("v-if", true),
      _ctx.showStops ? (openBlock(), createElementBlock("div", _hoisted_2$w, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.stops, (item, key) => {
          return openBlock(), createElementBlock("div", {
            key,
            class: "el-slider__stop",
            style: normalizeStyle(_ctx.getStopStyle(item))
          }, null, 4);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      _ctx.markList.length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createElementVNode("div", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.markList, (item, key) => {
            return openBlock(), createElementBlock("div", {
              key,
              style: normalizeStyle(_ctx.getStopStyle(item.position)),
              class: "el-slider__stop el-slider__marks-stop"
            }, null, 4);
          }), 128))
        ]),
        createElementVNode("div", _hoisted_3$v, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.markList, (item, key) => {
            return openBlock(), createBlock(_component_slider_marker, {
              key,
              mark: item.mark,
              style: normalizeStyle(_ctx.getStopStyle(item.position))
            }, null, 8, ["mark", "style"]);
          }), 128))
        ])
      ], 64)) : createCommentVNode("v-if", true)
    ], 6)
  ], 10, _hoisted_1$C);
}
script$2$4.render = render$1$7;
script$2$4.__file = "packages/components/slider/src/workprogress.vue";
script$2$4.install = (app) => {
  app.component(script$2$4.name, script$2$4);
};
const _Slider = script$2$4;
const ElSlider = _Slider;
var script$c = defineComponent({
  props: {
    prefixCls: {
      type: String,
      default: "el-space"
    }
  },
  setup(props2) {
    return {
      classes: computed(() => `${props2.prefixCls}__item`)
    };
  }
});
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
script$c.render = render$c;
script$c.__file = "packages/components/space/src/item.vue";
const SizeMap = {
  mini: 4,
  small: 8,
  medium: 12,
  large: 16
};
const defaultProps$3 = {
  direction: {
    type: String,
    default: "horizontal"
  },
  class: {
    type: [String, Object, Array],
    default: ""
  },
  style: {
    type: [String, Array, Object]
  },
  alignment: {
    type: String,
    default: "center"
  },
  prefixCls: {
    type: String
  },
  spacer: {
    type: [Object, String, Number],
    default: null,
    validator: (val) => {
      return isVNode(val) || isNumber$1(val) || isString$1(val);
    }
  },
  wrap: {
    type: Boolean,
    default: false
  },
  fill: {
    type: Boolean,
    default: false
  },
  fillRatio: {
    type: Number,
    default: 100
  },
  size: {
    type: [String, Array, Number],
    validator: (val) => {
      return isValidComponentSize(val) || isNumber$1(val) || isArray$9(val);
    }
  }
};
function useSpace(props2) {
  const classes = computed(() => [
    "el-space",
    `el-space--${props2.direction}`,
    props2.class
  ]);
  const horizontalSize = ref(0);
  const verticalSize = ref(0);
  watch(() => [props2.size, props2.wrap, props2.direction, props2.fill], ([size = "small", wrap, dir, fill]) => {
    if (isArray$9(size)) {
      const [h2 = 0, v = 0] = size;
      horizontalSize.value = h2;
      verticalSize.value = v;
    } else {
      let val;
      if (isNumber$1(size)) {
        val = size;
      } else {
        val = SizeMap[size] || SizeMap.small;
      }
      if ((wrap || fill) && dir === "horizontal") {
        horizontalSize.value = verticalSize.value = val;
      } else {
        if (dir === "horizontal") {
          horizontalSize.value = val;
          verticalSize.value = 0;
        } else {
          verticalSize.value = val;
          horizontalSize.value = 0;
        }
      }
    }
  }, { immediate: true });
  const containerStyle = computed(() => {
    const wrapKls = props2.wrap || props2.fill ? { flexWrap: "wrap", marginBottom: `-${verticalSize.value}px` } : null;
    const alignment = {
      alignItems: props2.alignment
    };
    return [wrapKls, alignment, props2.style];
  });
  const itemStyle = computed(() => {
    const itemBaseStyle = {
      paddingBottom: `${verticalSize.value}px`,
      marginRight: `${horizontalSize.value}px`
    };
    const fillStyle = props2.fill ? { flexGrow: 1, minWidth: `${props2.fillRatio}%` } : null;
    return [itemBaseStyle, fillStyle];
  });
  return {
    classes,
    containerStyle,
    itemStyle
  };
}
var Space = defineComponent({
  name: "ElSpace",
  props: defaultProps$3,
  setup(props2) {
    return useSpace(props2);
  },
  render(ctx2) {
    const {
      classes,
      $slots,
      containerStyle,
      itemStyle,
      spacer,
      prefixCls,
      direction
    } = ctx2;
    const children = renderSlot($slots, "default", { key: 0 }, () => []);
    if (children.children.length === 0)
      return null;
    if (isArray$9(children.children)) {
      let extractedChildren = [];
      children.children.forEach((child, loopKey) => {
        if (isFragment(child)) {
          if (isArray$9(child.children)) {
            child.children.forEach((nested, key) => {
              extractedChildren.push(createVNode(script$c, {
                style: itemStyle,
                prefixCls,
                key: `nested-${key}`
              }, {
                default: () => [nested]
              }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
            });
          }
        } else if (isValidElementNode(child)) {
          extractedChildren.push(createVNode(script$c, {
            style: itemStyle,
            prefixCls,
            key: `LoopKey${loopKey}`
          }, {
            default: () => [child]
          }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
        }
      });
      if (spacer) {
        const len = extractedChildren.length - 1;
        extractedChildren = extractedChildren.reduce((acc, child, idx) => {
          return idx === len ? [...acc, child] : [
            ...acc,
            child,
            createVNode("span", { style: [itemStyle, direction === "vertical" ? "width: 100%" : null], key: idx }, [
              isVNode(spacer) ? spacer : createTextVNode(spacer, PatchFlags.TEXT)
            ], PatchFlags.STYLE)
          ];
        }, []);
      }
      return createVNode("div", {
        class: classes,
        style: containerStyle
      }, extractedChildren, PatchFlags.STYLE | PatchFlags.CLASS);
    }
    return children.children;
  }
});
const _Space = Space;
_Space.install = (app) => {
  app.component(_Space.name, _Space);
};
const ElSpace = _Space;
var script$b = defineComponent({
  name: "ElSteps",
  props: {
    space: {
      type: [Number, String],
      default: ""
    },
    active: {
      type: Number,
      default: 0
    },
    direction: {
      type: String,
      default: "horizontal",
      validator: (val) => ["horizontal", "vertical"].includes(val)
    },
    alignCenter: {
      type: Boolean,
      default: false
    },
    simple: {
      type: Boolean,
      default: false
    },
    finishStatus: {
      type: String,
      default: "finish",
      validator: (val) => ["wait", "process", "finish", "error", "success"].includes(val)
    },
    processStatus: {
      type: String,
      default: "process",
      validator: (val) => ["wait", "process", "finish", "error", "success"].includes(val)
    }
  },
  emits: [CHANGE_EVENT],
  setup(props2, { emit: emit2 }) {
    const steps = ref([]);
    watch(steps, () => {
      steps.value.forEach((instance, index2) => {
        instance.setIndex(index2);
      });
    });
    provide("ElSteps", { props: props2, steps });
    watch(() => props2.active, (newVal, oldVal) => {
      emit2(CHANGE_EVENT, newVal, oldVal);
    });
    return {
      steps
    };
  }
});
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-steps", _ctx.simple ? "el-steps--simple" : `el-steps--${_ctx.direction}`])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
script$b.render = render$b;
script$b.__file = "packages/components/steps/src/workprogress.vue";
var script$1$7 = defineComponent({
  name: "ElStep",
  props: {
    title: {
      type: String,
      default: ""
    },
    icon: {
      type: String,
      default: ""
    },
    description: {
      type: String,
      default: ""
    },
    status: {
      type: String,
      default: "",
      validator: (val) => ["", "wait", "process", "finish", "error", "success"].includes(val)
    }
  },
  setup(props2) {
    const index2 = ref(-1);
    const lineStyle = ref({});
    const internalStatus = ref("");
    const parent2 = inject("ElSteps");
    const currentInstance = getCurrentInstance();
    onMounted(() => {
      watch([() => parent2.props.active, () => parent2.props.processStatus, () => parent2.props.finishStatus], ([active]) => {
        updateStatus(active);
      }, { immediate: true });
    });
    onBeforeUnmount(() => {
      parent2.steps.value = parent2.steps.value.filter((instance) => instance.uid !== currentInstance.uid);
    });
    const currentStatus = computed(() => {
      return props2.status || internalStatus.value;
    });
    const prevStatus = computed(() => {
      const prevStep = parent2.steps.value[index2.value - 1];
      return prevStep ? prevStep.currentStatus : "wait";
    });
    const isCenter = computed(() => {
      return parent2.props.alignCenter;
    });
    const isVertical = computed(() => {
      return parent2.props.direction === "vertical";
    });
    const isSimple = computed(() => {
      return parent2.props.simple;
    });
    const stepsCount = computed(() => {
      return parent2.steps.value.length;
    });
    const isLast = computed(() => {
      var _a;
      return ((_a = parent2.steps.value[stepsCount.value - 1]) == null ? void 0 : _a.uid) === currentInstance.uid;
    });
    const space = computed(() => {
      return isSimple.value ? "" : parent2.props.space;
    });
    const style = computed(() => {
      const style2 = {
        flexBasis: typeof space.value === "number" ? `${space.value}px` : space.value ? space.value : 100 / (stepsCount.value - (isCenter.value ? 0 : 1)) + "%"
      };
      if (isVertical.value)
        return style2;
      if (isLast.value) {
        style2.maxWidth = 100 / stepsCount.value + "%";
      }
      return style2;
    });
    const setIndex = (val) => {
      index2.value = val;
    };
    const calcProgress = (status) => {
      let step = 100;
      const style2 = {};
      style2.transitionDelay = 150 * index2.value + "ms";
      if (status === parent2.props.processStatus) {
        step = 0;
      } else if (status === "wait") {
        step = 0;
        style2.transitionDelay = -150 * index2.value + "ms";
      }
      style2.borderWidth = step && !isSimple.value ? "1px" : 0;
      style2[parent2.props.direction === "vertical" ? "height" : "width"] = `${step}%`;
      lineStyle.value = style2;
    };
    const updateStatus = (activeIndex) => {
      if (activeIndex > index2.value) {
        internalStatus.value = parent2.props.finishStatus;
      } else if (activeIndex === index2.value && prevStatus.value !== "error") {
        internalStatus.value = parent2.props.processStatus;
      } else {
        internalStatus.value = "wait";
      }
      const prevChild = parent2.steps.value[stepsCount.value - 1];
      if (prevChild)
        prevChild.calcProgress(internalStatus.value);
    };
    const stepItemState = reactive({
      uid: computed(() => currentInstance.uid),
      currentStatus,
      setIndex,
      calcProgress
    });
    parent2.steps.value = [...parent2.steps.value, stepItemState];
    return {
      index: index2,
      lineStyle,
      currentStatus,
      isCenter,
      isVertical,
      isSimple,
      isLast,
      space,
      style,
      parent: parent2,
      setIndex,
      calcProgress,
      updateStatus
    };
  }
});
const _hoisted_1$B = { class: "el-step__line" };
const _hoisted_2$v = {
  key: 1,
  class: "el-step__icon-inner"
};
const _hoisted_3$u = { class: "el-step__main" };
const _hoisted_4$n = {
  key: 0,
  class: "el-step__arrow"
};
function render$1$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    style: normalizeStyle(_ctx.style),
    class: normalizeClass([
      "el-step",
      _ctx.isSimple ? "is-simple" : `is-${_ctx.parent.props.direction}`,
      _ctx.isLast && !_ctx.space && !_ctx.isCenter && "is-flex",
      _ctx.isCenter && !_ctx.isVertical && !_ctx.isSimple && "is-center"
    ])
  }, [
    createCommentVNode(" icon & line "),
    createElementVNode("div", {
      class: normalizeClass(["el-step__head", `is-${_ctx.currentStatus}`])
    }, [
      createElementVNode("div", _hoisted_1$B, [
        createElementVNode("i", {
          class: "el-step__line-inner",
          style: normalizeStyle(_ctx.lineStyle)
        }, null, 4)
      ]),
      createElementVNode("div", {
        class: normalizeClass(["el-step__icon", `is-${_ctx.icon ? "icon" : "text"}`])
      }, [
        _ctx.currentStatus !== "success" && _ctx.currentStatus !== "error" ? renderSlot(_ctx.$slots, "icon", { key: 0 }, () => [
          _ctx.icon ? (openBlock(), createElementBlock("i", {
            key: 0,
            class: normalizeClass(["el-step__icon-inner", _ctx.icon])
          }, null, 2)) : createCommentVNode("v-if", true),
          !_ctx.icon && !_ctx.isSimple ? (openBlock(), createElementBlock("div", _hoisted_2$v, toDisplayString(_ctx.index + 1), 1)) : createCommentVNode("v-if", true)
        ]) : (openBlock(), createElementBlock("i", {
          key: 1,
          class: normalizeClass(["el-step__icon-inner", "is-status", `el-icon-${_ctx.currentStatus === "success" ? "check" : "close"}`])
        }, null, 2))
      ], 2)
    ], 2),
    createCommentVNode(" title & description "),
    createElementVNode("div", _hoisted_3$u, [
      createElementVNode("div", {
        class: normalizeClass(["el-step__title", `is-${_ctx.currentStatus}`])
      }, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ])
      ], 2),
      _ctx.isSimple ? (openBlock(), createElementBlock("div", _hoisted_4$n)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["el-step__description", `is-${_ctx.currentStatus}`])
      }, [
        renderSlot(_ctx.$slots, "description", {}, () => [
          createTextVNode(toDisplayString(_ctx.description), 1)
        ])
      ], 2))
    ])
  ], 6);
}
script$1$7.render = render$1$6;
script$1$7.__file = "packages/components/steps/src/item.vue";
script$b.install = (app) => {
  app.component(script$b.name, script$b);
  app.component(script$1$7.name, script$1$7);
};
script$b.Step = script$1$7;
const _Steps = script$b;
const ElSteps = _Steps;
var script$a = defineComponent({
  name: "ElSwitch",
  props: {
    modelValue: {
      type: [Boolean, String, Number],
      default: false
    },
    value: {
      type: [Boolean, String, Number],
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 40
    },
    activeIconClass: {
      type: String,
      default: ""
    },
    inactiveIconClass: {
      type: String,
      default: ""
    },
    activeText: {
      type: String,
      default: ""
    },
    inactiveText: {
      type: String,
      default: ""
    },
    activeColor: {
      type: String,
      default: ""
    },
    inactiveColor: {
      type: String,
      default: ""
    },
    borderColor: {
      type: String,
      default: ""
    },
    activeValue: {
      type: [Boolean, String, Number],
      default: true
    },
    inactiveValue: {
      type: [Boolean, String, Number],
      default: false
    },
    name: {
      type: String,
      default: ""
    },
    validateEvent: {
      type: Boolean,
      default: true
    },
    id: String,
    loading: {
      type: Boolean,
      default: false
    },
    beforeChange: Function
  },
  emits: ["update:modelValue", "change", "input"],
  setup(props2, ctx2) {
    const elForm = inject(elFormKey, {});
    const elFormItem = inject(elFormItemKey, {});
    const isModelValue = ref(props2.modelValue !== false);
    const input2 = ref(null);
    const core = ref(null);
    const scope = "ElSwitch";
    watch(() => props2.modelValue, () => {
      isModelValue.value = true;
    });
    watch(() => props2.value, () => {
      isModelValue.value = false;
    });
    const actualValue = computed(() => {
      return isModelValue.value ? props2.modelValue : props2.value;
    });
    const checked = computed(() => {
      return actualValue.value === props2.activeValue;
    });
    if (!~[props2.activeValue, props2.inactiveValue].indexOf(actualValue.value)) {
      ctx2.emit("update:modelValue", props2.inactiveValue);
      ctx2.emit("change", props2.inactiveValue);
      ctx2.emit("input", props2.inactiveValue);
    }
    watch(checked, () => {
      var _a;
      input2.value.checked = checked.value;
      if (props2.activeColor || props2.inactiveColor) {
        setBackgroundColor();
      }
      if (props2.validateEvent) {
        (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", [actualValue.value]);
      }
    });
    const switchDisabled = computed(() => {
      return props2.disabled || props2.loading || (elForm || {}).disabled;
    });
    const handleChange = () => {
      const val = checked.value ? props2.inactiveValue : props2.activeValue;
      ctx2.emit("update:modelValue", val);
      ctx2.emit("change", val);
      ctx2.emit("input", val);
      nextTick(() => {
        input2.value.checked = checked.value;
      });
    };
    const switchValue = () => {
      if (switchDisabled.value)
        return;
      const { beforeChange } = props2;
      if (!beforeChange) {
        handleChange();
        return;
      }
      const shouldChange = beforeChange();
      const isExpectType = [isPromise(shouldChange), isBool(shouldChange)].some((i2) => i2);
      if (!isExpectType) {
        throwError(scope, "beforeChange must return type `Promise<boolean>` or `boolean`");
      }
      if (isPromise(shouldChange)) {
        shouldChange.then((result) => {
          if (result) {
            handleChange();
          }
        }).catch((e) => {
          {
            warn(scope, `some error occurred: ${e}`);
          }
        });
      } else if (shouldChange) {
        handleChange();
      }
    };
    const setBackgroundColor = () => {
      const newColor = checked.value ? props2.activeColor : props2.inactiveColor;
      const coreEl = core.value;
      if (props2.borderColor)
        coreEl.style.borderColor = props2.borderColor;
      else if (!props2.borderColor)
        coreEl.style.borderColor = newColor;
      coreEl.style.backgroundColor = newColor;
      coreEl.children[0].style.color = newColor;
    };
    const focus = () => {
      var _a, _b;
      (_b = (_a = input2.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    };
    onMounted(() => {
      if (props2.activeColor || props2.inactiveColor || props2.borderColor) {
        setBackgroundColor();
      }
      input2.value.checked = checked.value;
    });
    return {
      input: input2,
      core,
      switchDisabled,
      checked,
      handleChange,
      switchValue,
      focus
    };
  }
});
const _hoisted_1$A = ["aria-checked", "aria-disabled"];
const _hoisted_2$u = ["id", "name", "true-value", "false-value", "disabled"];
const _hoisted_3$t = ["aria-hidden"];
const _hoisted_4$m = { class: "el-switch__action" };
const _hoisted_5$i = {
  key: 0,
  class: "el-icon-loading"
};
const _hoisted_6$g = ["aria-hidden"];
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-switch", { "is-disabled": _ctx.switchDisabled, "is-checked": _ctx.checked }]),
    role: "switch",
    "aria-checked": _ctx.checked,
    "aria-disabled": _ctx.switchDisabled,
    onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.switchValue && _ctx.switchValue(...args), ["prevent"]))
  }, [
    createElementVNode("input", {
      id: _ctx.id,
      ref: "input",
      class: "el-switch__input",
      type: "checkbox",
      name: _ctx.name,
      "true-value": _ctx.activeValue,
      "false-value": _ctx.inactiveValue,
      disabled: _ctx.switchDisabled,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onKeydown: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.switchValue && _ctx.switchValue(...args), ["enter"]))
    }, null, 40, _hoisted_2$u),
    _ctx.inactiveIconClass || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(["el-switch__label", "el-switch__label--left", !_ctx.checked ? "is-active" : ""])
    }, [
      _ctx.inactiveIconClass ? (openBlock(), createElementBlock("i", {
        key: 0,
        class: normalizeClass([_ctx.inactiveIconClass])
      }, null, 2)) : createCommentVNode("v-if", true),
      !_ctx.inactiveIconClass && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
        key: 1,
        "aria-hidden": _ctx.checked
      }, toDisplayString(_ctx.inactiveText), 9, _hoisted_3$t)) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true),
    createElementVNode("span", {
      ref: "core",
      class: "el-switch__core",
      style: normalizeStyle({ "width": (_ctx.width || 40) + "px" })
    }, [
      createElementVNode("div", _hoisted_4$m, [
        _ctx.loading ? (openBlock(), createElementBlock("i", _hoisted_5$i)) : createCommentVNode("v-if", true)
      ])
    ], 4),
    _ctx.activeIconClass || _ctx.activeText ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass(["el-switch__label", "el-switch__label--right", _ctx.checked ? "is-active" : ""])
    }, [
      _ctx.activeIconClass ? (openBlock(), createElementBlock("i", {
        key: 0,
        class: normalizeClass([_ctx.activeIconClass])
      }, null, 2)) : createCommentVNode("v-if", true),
      !_ctx.activeIconClass && _ctx.activeText ? (openBlock(), createElementBlock("span", {
        key: 1,
        "aria-hidden": !_ctx.checked
      }, toDisplayString(_ctx.activeText), 9, _hoisted_6$g)) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$A);
}
script$a.render = render$a;
script$a.__file = "packages/components/switch/src/workprogress.vue";
script$a.install = (app) => {
  app.component(script$a.name, script$a);
};
const _Switch = script$a;
const ElSwitch = _Switch;
var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value2) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
const getCell = function(event2) {
  let cell = event2.target;
  while (cell && cell.tagName.toUpperCase() !== "HTML") {
    if (cell.tagName.toUpperCase() === "TD") {
      return cell;
    }
    cell = cell.parentNode;
  }
  return null;
};
const isObject$4 = function(obj) {
  return obj !== null && typeof obj === "object";
};
const orderBy = function(array3, sortKey, reverse, sortMethod, sortBy) {
  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
    return array3;
  }
  if (typeof reverse === "string") {
    reverse = reverse === "descending" ? -1 : 1;
  } else {
    reverse = reverse && reverse < 0 ? -1 : 1;
  }
  const getKey = sortMethod ? null : function(value2, index2) {
    if (sortBy) {
      if (!Array.isArray(sortBy)) {
        sortBy = [sortBy];
      }
      return sortBy.map(function(by) {
        if (typeof by === "string") {
          return getValueByPath(value2, by);
        } else {
          return by(value2, index2, array3);
        }
      });
    }
    if (sortKey !== "$key") {
      if (isObject$4(value2) && "$value" in value2)
        value2 = value2.$value;
    }
    return [isObject$4(value2) ? getValueByPath(value2, sortKey) : value2];
  };
  const compare = function(a, b) {
    if (sortMethod) {
      return sortMethod(a.value, b.value);
    }
    for (let i2 = 0, len = a.key.length; i2 < len; i2++) {
      if (a.key[i2] < b.key[i2]) {
        return -1;
      }
      if (a.key[i2] > b.key[i2]) {
        return 1;
      }
    }
    return 0;
  };
  return array3.map(function(value2, index2) {
    return {
      value: value2,
      index: index2,
      key: getKey ? getKey(value2, index2) : null
    };
  }).sort(function(a, b) {
    let order2 = compare(a, b);
    if (!order2) {
      order2 = a.index - b.index;
    }
    return order2 * +reverse;
  }).map((item) => item.value);
};
const getColumnById = function(table, columnId) {
  let column = null;
  table.columns.forEach(function(item) {
    if (item.id === columnId) {
      column = item;
    }
  });
  return column;
};
const getColumnByKey = function(table, columnKey) {
  let column = null;
  for (let i2 = 0; i2 < table.columns.length; i2++) {
    const item = table.columns[i2];
    if (item.columnKey === columnKey) {
      column = item;
      break;
    }
  }
  return column;
};
const getColumnByCell = function(table, cell) {
  const matches2 = (cell.className || "").match(/el-table_[^\s]+/gm);
  if (matches2) {
    return getColumnById(table, matches2[0]);
  }
  return null;
};
const getRowIdentity = (row, rowKey) => {
  if (!row)
    throw new Error("row is required when get row identity");
  if (typeof rowKey === "string") {
    if (rowKey.indexOf(".") < 0) {
      return row[rowKey] + "";
    }
    const key = rowKey.split(".");
    let current = row;
    for (let i2 = 0; i2 < key.length; i2++) {
      current = current[key[i2]];
    }
    return current + "";
  } else if (typeof rowKey === "function") {
    return rowKey.call(null, row);
  }
};
const getKeysMap = function(array3, rowKey) {
  const arrayMap = {};
  (array3 || []).forEach((row, index2) => {
    arrayMap[getRowIdentity(row, rowKey)] = { row, index: index2 };
  });
  return arrayMap;
};
function mergeOptions(defaults2, config2) {
  const options2 = {};
  let key;
  for (key in defaults2) {
    options2[key] = defaults2[key];
  }
  for (key in config2) {
    if (hasOwn(config2, key)) {
      const value2 = config2[key];
      if (typeof value2 !== "undefined") {
        options2[key] = value2;
      }
    }
  }
  return options2;
}
function parseWidth(width2) {
  if (width2 !== void 0) {
    width2 = parseInt(width2, 10);
    if (isNaN(width2)) {
      width2 = null;
    }
  }
  return +width2;
}
function parseMinWidth(minWidth) {
  if (typeof minWidth !== "undefined") {
    minWidth = parseWidth(minWidth);
    if (isNaN(minWidth)) {
      minWidth = 80;
    }
  }
  return minWidth;
}
function parseHeight(height) {
  if (typeof height === "number") {
    return height;
  }
  if (typeof height === "string") {
    if (/^\d+(?:px)?$/.test(height)) {
      return parseInt(height, 10);
    } else {
      return height;
    }
  }
  return null;
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
function toggleRowStatus(statusArr, row, newVal) {
  let changed = false;
  const index2 = statusArr.indexOf(row);
  const included = index2 !== -1;
  const addRow = () => {
    statusArr.push(row);
    changed = true;
  };
  const removeRow = () => {
    statusArr.splice(index2, 1);
    changed = true;
  };
  if (typeof newVal === "boolean") {
    if (newVal && !included) {
      addRow();
    } else if (!newVal && included) {
      removeRow();
    }
  } else {
    if (included) {
      removeRow();
    } else {
      addRow();
    }
  }
  return changed;
}
function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
  const isNil = (array3) => !(Array.isArray(array3) && array3.length);
  function _walker(parent2, children, level) {
    cb(parent2, children, level);
    children.forEach((item) => {
      if (item[lazyKey]) {
        cb(item, null, level + 1);
        return;
      }
      const children2 = item[childrenKey];
      if (!isNil(children2)) {
        _walker(item, children2, level + 1);
      }
    });
  }
  root2.forEach((item) => {
    if (item[lazyKey]) {
      cb(item, null, 0);
      return;
    }
    const children = item[childrenKey];
    if (!isNil(children)) {
      _walker(item, children, 0);
    }
  });
}
let removePopper;
function createTablePopper(trigger, popperContent, popperOptions2, tooltipEffect) {
  function renderContent() {
    const isLight = tooltipEffect === "light";
    const content2 = document.createElement("div");
    content2.className = `el-popper ${isLight ? "is-light" : "is-dark"}`;
    content2.innerHTML = popperContent;
    content2.style.zIndex = String(PopupManager$1.nextZIndex());
    document.body.appendChild(content2);
    return content2;
  }
  function renderArrow2() {
    const arrow22 = document.createElement("div");
    arrow22.className = "el-popper__arrow";
    arrow22.style.bottom = "-4px";
    return arrow22;
  }
  function showPopper() {
    popperInstance && popperInstance.update();
  }
  removePopper = function removePopper2() {
    try {
      popperInstance && popperInstance.destroy();
      content && document.body.removeChild(content);
      off$2(trigger, "mouseenter", showPopper);
      off$2(trigger, "mouseleave", removePopper2);
    } catch (e) {
    }
  };
  let popperInstance = null;
  const content = renderContent();
  const arrow2 = renderArrow2();
  content.appendChild(arrow2);
  popperInstance = createPopper(trigger, content, __spreadValues$6({
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, 8]
        }
      },
      {
        name: "arrow",
        options: {
          element: arrow2,
          padding: 10
        }
      }
    ]
  }, popperOptions2));
  on$2(trigger, "mouseenter", showPopper);
  on$2(trigger, "mouseleave", removePopper);
  return popperInstance;
}
function useExpand(watcherData) {
  const instance = getCurrentInstance();
  const defaultExpandAll = ref(false);
  const expandRows = ref([]);
  const updateExpandRows = () => {
    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;
    if (defaultExpandAll.value) {
      expandRows.value = data.slice();
    } else if (rowKey) {
      const expandRowsMap = getKeysMap(expandRows.value, rowKey);
      expandRows.value = data.reduce((prev, row) => {
        const rowId = getRowIdentity(row, rowKey);
        const rowInfo = expandRowsMap[rowId];
        if (rowInfo) {
          prev.push(row);
        }
        return prev;
      }, []);
    } else {
      expandRows.value = [];
    }
  };
  const toggleRowExpansion = (row, expanded) => {
    const changed = toggleRowStatus(expandRows.value, row, expanded);
    if (changed) {
      instance.emit("expand-change", row, expandRows.value.slice());
      instance.store.scheduleLayout();
    }
  };
  const setExpandRowKeys = (rowKeys) => {
    instance.store.assertRowKey();
    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;
    const keysMap = getKeysMap(data, rowKey);
    expandRows.value = rowKeys.reduce((prev, cur) => {
      const info = keysMap[cur];
      if (info) {
        prev.push(info.row);
      }
      return prev;
    }, []);
  };
  const isRowExpanded = (row) => {
    const rowKey = watcherData.rowKey.value;
    if (rowKey) {
      const expandMap = getKeysMap(expandRows.value, rowKey);
      return !!expandMap[getRowIdentity(row, rowKey)];
    }
    return expandRows.value.indexOf(row) !== -1;
  };
  return {
    updateExpandRows,
    toggleRowExpansion,
    setExpandRowKeys,
    isRowExpanded,
    states: {
      expandRows,
      defaultExpandAll
    }
  };
}
function useCurrent(watcherData) {
  const instance = getCurrentInstance();
  const _currentRowKey = ref(null);
  const currentRow = ref(null);
  const setCurrentRowKey = (key) => {
    instance.store.assertRowKey();
    _currentRowKey.value = key;
    setCurrentRowByKey(key);
  };
  const restoreCurrentRowKey = () => {
    _currentRowKey.value = null;
  };
  const setCurrentRowByKey = (key) => {
    const { data = [], rowKey } = watcherData;
    let _currentRow = null;
    if (rowKey.value) {
      _currentRow = arrayFind(unref(data), (item) => getRowIdentity(item, rowKey.value) === key);
    }
    currentRow.value = _currentRow;
  };
  const updateCurrentRow = (_currentRow) => {
    const oldCurrentRow = currentRow.value;
    if (_currentRow && _currentRow !== oldCurrentRow) {
      currentRow.value = _currentRow;
      instance.emit("current-change", currentRow.value, oldCurrentRow);
      return;
    }
    if (!_currentRow && oldCurrentRow) {
      currentRow.value = null;
      instance.emit("current-change", null, oldCurrentRow);
    }
  };
  const updateCurrentRowData = () => {
    const rowKey = watcherData.rowKey.value;
    const data = watcherData.data.value || [];
    const oldCurrentRow = currentRow.value;
    if (data.indexOf(oldCurrentRow) === -1 && oldCurrentRow) {
      if (rowKey) {
        const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
        setCurrentRowByKey(currentRowKey);
      } else {
        currentRow.value = null;
      }
      if (currentRow.value === null) {
        instance.emit("current-change", null, oldCurrentRow);
      }
    } else if (_currentRowKey.value) {
      setCurrentRowByKey(_currentRowKey.value);
      restoreCurrentRowKey();
    }
  };
  return {
    setCurrentRowKey,
    restoreCurrentRowKey,
    setCurrentRowByKey,
    updateCurrentRow,
    updateCurrentRowData,
    states: {
      _currentRowKey,
      currentRow
    }
  };
}
var __defProp$1$2 = Object.defineProperty;
var __getOwnPropSymbols$1$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$2 = (obj, key, value2) => key in obj ? __defProp$1$2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$2.call(b, prop))
      __defNormalProp$1$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$2)
    for (var prop of __getOwnPropSymbols$1$2(b)) {
      if (__propIsEnum$1$2.call(b, prop))
        __defNormalProp$1$2(a, prop, b[prop]);
    }
  return a;
};
function useTree(watcherData) {
  const expandRowKeys = ref([]);
  const treeData = ref({});
  const indent = ref(16);
  const lazy = ref(false);
  const lazyTreeNodeMap = ref({});
  const lazyColumnIdentifier = ref("hasChildren");
  const childrenColumnName = ref("children");
  const instance = getCurrentInstance();
  const normalizedData = computed(() => {
    if (!watcherData.rowKey.value)
      return {};
    const data = watcherData.data.value || [];
    return normalize(data);
  });
  const normalizedLazyNode = computed(() => {
    const rowKey = watcherData.rowKey.value;
    const keys2 = Object.keys(lazyTreeNodeMap.value);
    const res = {};
    if (!keys2.length)
      return res;
    keys2.forEach((key) => {
      if (lazyTreeNodeMap.value[key].length) {
        const item = { children: [] };
        lazyTreeNodeMap.value[key].forEach((row) => {
          const currentRowKey = getRowIdentity(row, rowKey);
          item.children.push(currentRowKey);
          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
            res[currentRowKey] = { children: [] };
          }
        });
        res[key] = item;
      }
    });
    return res;
  });
  const normalize = (data) => {
    const rowKey = watcherData.rowKey.value;
    const res = {};
    walkTreeNode(data, (parent2, children, level) => {
      const parentId = getRowIdentity(parent2, rowKey);
      if (Array.isArray(children)) {
        res[parentId] = {
          children: children.map((row) => getRowIdentity(row, rowKey)),
          level
        };
      } else if (lazy.value) {
        res[parentId] = {
          children: [],
          lazy: true,
          level
        };
      }
    }, childrenColumnName.value, lazyColumnIdentifier.value);
    return res;
  };
  const updateTreeData = () => {
    var _a, _b;
    const nested = normalizedData.value;
    const normalizedLazyNode_ = normalizedLazyNode.value;
    const keys2 = Object.keys(nested);
    const newTreeData = {};
    if (keys2.length) {
      const oldTreeData = unref(treeData);
      const defaultExpandAll = (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value;
      const rootLazyRowKeys = [];
      const getExpanded = (oldValue, key) => {
        const included = defaultExpandAll || expandRowKeys.value && expandRowKeys.value.indexOf(key) !== -1;
        return !!(oldValue && oldValue.expanded || included);
      };
      keys2.forEach((key) => {
        const oldValue = oldTreeData[key];
        const newValue = __spreadValues$1$2({}, nested[key]);
        newValue.expanded = getExpanded(oldValue, key);
        if (newValue.lazy) {
          const { loaded = false, loading = false } = oldValue || {};
          newValue.loaded = !!loaded;
          newValue.loading = !!loading;
          rootLazyRowKeys.push(key);
        }
        newTreeData[key] = newValue;
      });
      const lazyKeys = Object.keys(normalizedLazyNode_);
      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
        lazyKeys.forEach((key) => {
          const oldValue = oldTreeData[key];
          const lazyNodeChildren = normalizedLazyNode_[key].children;
          if (rootLazyRowKeys.indexOf(key) !== -1) {
            if (newTreeData[key].children.length !== 0) {
              throw new Error("[ElTable]children must be an empty array.");
            }
            newTreeData[key].children = lazyNodeChildren;
          } else {
            const { loaded = false, loading = false } = oldValue || {};
            newTreeData[key] = {
              lazy: true,
              loaded: !!loaded,
              loading: !!loading,
              expanded: getExpanded(oldValue, key),
              children: lazyNodeChildren,
              level: ""
            };
          }
        });
      }
    }
    treeData.value = newTreeData;
    (_b = instance.store) == null ? void 0 : _b.updateTableScrollY();
  };
  watch(() => normalizedData.value, updateTreeData);
  watch(() => normalizedLazyNode.value, updateTreeData);
  const updateTreeExpandKeys = (value2) => {
    expandRowKeys.value = value2;
    updateTreeData();
  };
  const toggleTreeExpansion = (row, expanded) => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id2 = getRowIdentity(row, rowKey);
    const data = id2 && treeData.value[id2];
    if (id2 && data && "expanded" in data) {
      const oldExpanded = data.expanded;
      expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
      treeData.value[id2].expanded = expanded;
      if (oldExpanded !== expanded) {
        instance.emit("expand-change", row, expanded);
      }
      instance.store.updateTableScrollY();
    }
  };
  const loadOrToggle = (row) => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id2 = getRowIdentity(row, rowKey);
    const data = treeData.value[id2];
    if (lazy.value && data && "loaded" in data && !data.loaded) {
      loadData(row, id2, data);
    } else {
      toggleTreeExpansion(row, void 0);
    }
  };
  const loadData = (row, key, treeNode) => {
    const { load } = instance.props;
    if (load && !treeData.value[key].loaded) {
      treeData.value[key].loading = true;
      load(row, treeNode, (data) => {
        if (!Array.isArray(data)) {
          throw new Error("[ElTable] data must be an array");
        }
        treeData.value[key].loading = false;
        treeData.value[key].loaded = true;
        treeData.value[key].expanded = true;
        if (data.length) {
          lazyTreeNodeMap.value[key] = data;
        }
        instance.emit("expand-change", row, true);
      });
    }
  };
  return {
    loadData,
    loadOrToggle,
    toggleTreeExpansion,
    updateTreeExpandKeys,
    updateTreeData,
    normalize,
    states: {
      expandRowKeys,
      treeData,
      indent,
      lazy,
      lazyTreeNodeMap,
      lazyColumnIdentifier,
      childrenColumnName
    }
  };
}
var __defProp$2$1 = Object.defineProperty;
var __getOwnPropSymbols$2$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$2$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$2$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2$1 = (obj, key, value2) => key in obj ? __defProp$2$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$2$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2$1.call(b, prop))
      __defNormalProp$2$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$2$1)
    for (var prop of __getOwnPropSymbols$2$1(b)) {
      if (__propIsEnum$2$1.call(b, prop))
        __defNormalProp$2$1(a, prop, b[prop]);
    }
  return a;
};
const sortData = (data, states) => {
  const sortingColumn = states.sortingColumn;
  if (!sortingColumn || typeof sortingColumn.sortable === "string") {
    return data;
  }
  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
};
const doFlattenColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.children) {
      result.push.apply(result, doFlattenColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};
function useWatcher() {
  const instance = getCurrentInstance();
  const rowKey = ref(null);
  const data = ref([]);
  const _data = ref([]);
  const isComplex = ref(false);
  const _columns = ref([]);
  const originColumns = ref([]);
  const columns = ref([]);
  const fixedColumns = ref([]);
  const rightFixedColumns = ref([]);
  const leafColumns = ref([]);
  const fixedLeafColumns = ref([]);
  const rightFixedLeafColumns = ref([]);
  const leafColumnsLength = ref(0);
  const fixedLeafColumnsLength = ref(0);
  const rightFixedLeafColumnsLength = ref(0);
  const isAllSelected = ref(false);
  const selection = ref([]);
  const reserveSelection = ref(false);
  const selectOnIndeterminate = ref(false);
  const selectable = ref(null);
  const filters = ref({});
  const filteredData = ref(null);
  const sortingColumn = ref(null);
  const sortProp = ref(null);
  const sortOrder = ref(null);
  const hoverRow = ref(null);
  watch(data, () => instance.state && scheduleLayout(false), {
    deep: true
  });
  const assertRowKey = () => {
    if (!rowKey.value)
      throw new Error("[ElTable] prop row-key is required");
  };
  const updateColumns = () => {
    fixedColumns.value = _columns.value.filter((column) => column.fixed === true || column.fixed === "left");
    rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
    if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
      _columns.value[0].fixed = true;
      fixedColumns.value.unshift(_columns.value[0]);
    }
    const notFixedColumns = _columns.value.filter((column) => !column.fixed);
    originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
    const leafColumns2 = doFlattenColumns(notFixedColumns);
    const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
    const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
    leafColumnsLength.value = leafColumns2.length;
    fixedLeafColumnsLength.value = fixedLeafColumns2.length;
    rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
    columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
    isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
  };
  const scheduleLayout = (needUpdateColumns, immediate = false) => {
    if (needUpdateColumns) {
      updateColumns();
    }
    if (immediate) {
      instance.state.doLayout();
    } else {
      instance.state.debouncedUpdateLayout();
    }
  };
  const isSelected = (row) => {
    return selection.value.indexOf(row) > -1;
  };
  const clearSelection = () => {
    isAllSelected.value = false;
    const oldSelection = selection.value;
    if (oldSelection.length) {
      selection.value = [];
      instance.emit("selection-change", []);
    }
  };
  const cleanSelection = () => {
    let deleted;
    if (rowKey.value) {
      deleted = [];
      const selectedMap = getKeysMap(selection.value, rowKey.value);
      const dataMap = getKeysMap(data.value, rowKey.value);
      for (const key in selectedMap) {
        if (hasOwn(selectedMap, key) && !dataMap[key]) {
          deleted.push(selectedMap[key].row);
        }
      }
    } else {
      deleted = selection.value.filter((item) => data.value.indexOf(item) === -1);
    }
    if (deleted.length) {
      const newSelection = selection.value.filter((item) => deleted.indexOf(item) === -1);
      selection.value = newSelection;
      instance.emit("selection-change", newSelection.slice());
    }
  };
  const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
    const changed = toggleRowStatus(selection.value, row, selected);
    if (changed) {
      const newSelection = (selection.value || []).slice();
      if (emitChange) {
        instance.emit("select", newSelection, row);
      }
      instance.emit("selection-change", newSelection);
    }
  };
  const _toggleAllSelection = () => {
    var _a, _b;
    const value2 = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
    isAllSelected.value = value2;
    let selectionChanged = false;
    let childrenCount = 0;
    const rowKey2 = (_b = (_a = instance == null ? void 0 : instance.store) == null ? void 0 : _a.states) == null ? void 0 : _b.rowKey.value;
    data.value.forEach((row, index2) => {
      const rowIndex = index2 + childrenCount;
      if (selectable.value) {
        if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value2)) {
          selectionChanged = true;
        }
      } else {
        if (toggleRowStatus(selection.value, row, value2)) {
          selectionChanged = true;
        }
      }
      childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
    });
    if (selectionChanged) {
      instance.emit("selection-change", selection.value ? selection.value.slice() : []);
    }
    instance.emit("select-all", selection.value);
  };
  const updateSelectionByRowKey = () => {
    const selectedMap = getKeysMap(selection.value, rowKey.value);
    data.value.forEach((row) => {
      const rowId = getRowIdentity(row, rowKey.value);
      const rowInfo = selectedMap[rowId];
      if (rowInfo) {
        selection.value[rowInfo.index] = row;
      }
    });
  };
  const updateAllSelected = () => {
    var _a, _b, _c;
    if (((_a = data.value) == null ? void 0 : _a.length) === 0) {
      isAllSelected.value = false;
      return;
    }
    let selectedMap;
    if (rowKey.value) {
      selectedMap = getKeysMap(selection.value, rowKey.value);
    }
    const isSelected2 = function(row) {
      if (selectedMap) {
        return !!selectedMap[getRowIdentity(row, rowKey.value)];
      } else {
        return selection.value.indexOf(row) !== -1;
      }
    };
    let isAllSelected_ = true;
    let selectedCount = 0;
    let childrenCount = 0;
    for (let i2 = 0, j = (data.value || []).length; i2 < j; i2++) {
      const keyProp = (_c = (_b = instance == null ? void 0 : instance.store) == null ? void 0 : _b.states) == null ? void 0 : _c.rowKey.value;
      const rowIndex = i2 + childrenCount;
      const item = data.value[i2];
      const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
      if (!isSelected2(item)) {
        if (!selectable.value || isRowSelectable) {
          isAllSelected_ = false;
          break;
        }
      } else {
        selectedCount++;
      }
      childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
    }
    if (selectedCount === 0)
      isAllSelected_ = false;
    isAllSelected.value = isAllSelected_;
  };
  const getChildrenCount = (rowKey2) => {
    var _a;
    if (!instance || !instance.store)
      return 0;
    const {
      treeData
    } = instance.store.states;
    let count = 0;
    const children = (_a = treeData.value[rowKey2]) == null ? void 0 : _a.children;
    if (children) {
      count += children.length;
      children.forEach((childKey) => {
        count += getChildrenCount(childKey);
      });
    }
    return count;
  };
  const updateFilters = (columns2, values) => {
    if (!Array.isArray(columns2)) {
      columns2 = [columns2];
    }
    const filters_ = {};
    columns2.forEach((col) => {
      filters.value[col.id] = values;
      filters_[col.columnKey || col.id] = values;
    });
    return filters_;
  };
  const updateSort = (column, prop, order2) => {
    if (sortingColumn.value && sortingColumn.value !== column) {
      sortingColumn.value.order = null;
    }
    sortingColumn.value = column;
    sortProp.value = prop;
    sortOrder.value = order2;
  };
  const execFilter = () => {
    let sourceData = unref(_data);
    Object.keys(filters.value).forEach((columnId) => {
      const values = filters.value[columnId];
      if (!values || values.length === 0)
        return;
      const column = getColumnById({
        columns: columns.value
      }, columnId);
      if (column && column.filterMethod) {
        sourceData = sourceData.filter((row) => {
          return values.some((value2) => column.filterMethod.call(null, value2, row, column));
        });
      }
    });
    filteredData.value = sourceData;
  };
  const execSort = () => {
    data.value = sortData(filteredData.value, {
      sortingColumn: sortingColumn.value,
      sortProp: sortProp.value,
      sortOrder: sortOrder.value
    });
  };
  const execQuery = (ignore = void 0) => {
    if (!(ignore && ignore.filter)) {
      execFilter();
    }
    execSort();
  };
  const clearFilter = (columnKeys) => {
    const {
      tableHeader,
      fixedTableHeader,
      rightFixedTableHeader
    } = instance.refs;
    let panels = {};
    if (tableHeader)
      panels = Object.assign(panels, tableHeader.filterPanels);
    if (fixedTableHeader)
      panels = Object.assign(panels, fixedTableHeader.filterPanels);
    if (rightFixedTableHeader)
      panels = Object.assign(panels, rightFixedTableHeader.filterPanels);
    const keys2 = Object.keys(panels);
    if (!keys2.length)
      return;
    if (typeof columnKeys === "string") {
      columnKeys = [columnKeys];
    }
    if (Array.isArray(columnKeys)) {
      const columns_ = columnKeys.map((key) => getColumnByKey({
        columns: columns.value
      }, key));
      keys2.forEach((key) => {
        const column = columns_.find((col) => col.id === key);
        if (column) {
          column.filteredValue = [];
        }
      });
      instance.store.commit("filterChange", {
        column: columns_,
        values: [],
        silent: true,
        multi: true
      });
    } else {
      keys2.forEach((key) => {
        const column = columns.value.find((col) => col.id === key);
        if (column) {
          column.filteredValue = [];
        }
      });
      filters.value = {};
      instance.store.commit("filterChange", {
        column: {},
        values: [],
        silent: true
      });
    }
  };
  const clearSort = () => {
    if (!sortingColumn.value)
      return;
    updateSort(null, null, null);
    instance.store.commit("changeSortCondition", {
      silent: true
    });
  };
  const {
    setExpandRowKeys,
    toggleRowExpansion,
    updateExpandRows,
    states: expandStates,
    isRowExpanded
  } = useExpand({
    data,
    rowKey
  });
  const {
    updateTreeExpandKeys,
    toggleTreeExpansion,
    loadOrToggle,
    states: treeStates
  } = useTree({
    data,
    rowKey
  });
  const {
    updateCurrentRowData,
    updateCurrentRow,
    setCurrentRowKey,
    states: currentData
  } = useCurrent({
    data,
    rowKey
  });
  const setExpandRowKeysAdapter = (val) => {
    setExpandRowKeys(val);
    updateTreeExpandKeys(val);
  };
  const toggleRowExpansionAdapter = (row, expanded) => {
    const hasExpandColumn = columns.value.some(({ type: type2 }) => type2 === "expand");
    if (hasExpandColumn) {
      toggleRowExpansion(row, expanded);
    } else {
      toggleTreeExpansion(row, expanded);
    }
  };
  return {
    assertRowKey,
    updateColumns,
    scheduleLayout,
    isSelected,
    clearSelection,
    cleanSelection,
    toggleRowSelection,
    _toggleAllSelection,
    toggleAllSelection: null,
    updateSelectionByRowKey,
    updateAllSelected,
    updateFilters,
    updateCurrentRow,
    updateSort,
    execFilter,
    execSort,
    execQuery,
    clearFilter,
    clearSort,
    toggleRowExpansion,
    setExpandRowKeysAdapter,
    setCurrentRowKey,
    toggleRowExpansionAdapter,
    isRowExpanded,
    updateExpandRows,
    updateCurrentRowData,
    loadOrToggle,
    states: __spreadValues$2$1(__spreadValues$2$1(__spreadValues$2$1({
      rowKey,
      data,
      _data,
      isComplex,
      _columns,
      originColumns,
      columns,
      fixedColumns,
      rightFixedColumns,
      leafColumns,
      fixedLeafColumns,
      rightFixedLeafColumns,
      leafColumnsLength,
      fixedLeafColumnsLength,
      rightFixedLeafColumnsLength,
      isAllSelected,
      selection,
      reserveSelection,
      selectOnIndeterminate,
      selectable,
      filters,
      filteredData,
      sortingColumn,
      sortProp,
      sortOrder,
      hoverRow
    }, expandStates), treeStates), currentData)
  };
}
var __defProp$3$1 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$3$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$3$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3$1 = (obj, key, value2) => key in obj ? __defProp$3$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$3$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3$1.call(b, prop))
      __defNormalProp$3$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$3$1)
    for (var prop of __getOwnPropSymbols$3$1(b)) {
      if (__propIsEnum$3$1.call(b, prop))
        __defNormalProp$3$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
function replaceColumn(array3, column) {
  return array3.map((item) => {
    var _a;
    if (item.id === column.id) {
      return column;
    } else if ((_a = item.children) == null ? void 0 : _a.length) {
      item.children = replaceColumn(item.children, column);
    }
    return item;
  });
}
function sortColumn(array3) {
  array3.forEach((item) => {
    var _a, _b;
    item.no = (_a = item.getColumnIndex) == null ? void 0 : _a.call(item);
    if ((_b = item.children) == null ? void 0 : _b.length) {
      sortColumn(item.children);
    }
  });
  array3.sort((cur, pre) => cur.no - pre.no);
}
function useStore() {
  const instance = getCurrentInstance();
  const watcher = useWatcher();
  const mutations = {
    setData(states, data) {
      const dataInstanceChanged = unref(states.data) !== data;
      states.data.value = data;
      states._data.value = data;
      instance.store.execQuery();
      instance.store.updateCurrentRowData();
      instance.store.updateExpandRows();
      if (unref(states.reserveSelection)) {
        instance.store.assertRowKey();
        instance.store.updateSelectionByRowKey();
      } else {
        if (dataInstanceChanged) {
          instance.store.clearSelection();
        } else {
          instance.store.cleanSelection();
        }
      }
      instance.store.updateAllSelected();
      if (instance.$ready) {
        instance.store.scheduleLayout();
      }
    },
    insertColumn(states, column, parent2) {
      const array3 = unref(states._columns);
      let newColumns = [];
      if (!parent2) {
        array3.push(column);
        newColumns = array3;
      } else {
        if (parent2 && !parent2.children) {
          parent2.children = [];
        }
        parent2.children.push(column);
        newColumns = replaceColumn(array3, parent2);
      }
      sortColumn(newColumns);
      states._columns.value = newColumns;
      if (column.type === "selection") {
        states.selectable.value = column.selectable;
        states.reserveSelection.value = column.reserveSelection;
      }
      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },
    removeColumn(states, column, parent2) {
      const array3 = unref(states._columns) || [];
      if (parent2) {
        parent2.children.splice(parent2.children.findIndex((item) => item.id === column.id), 1);
        if (parent2.children.length === 0) {
          delete parent2.children;
        }
        states._columns.value = replaceColumn(array3, parent2);
      } else {
        const index2 = array3.indexOf(column);
        if (index2 > -1) {
          array3.splice(index2, 1);
          states._columns.value = array3;
        }
      }
      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },
    sort(states, options2) {
      const { prop, order: order2, init } = options2;
      if (prop) {
        const column = arrayFind(unref(states.columns), (column2) => column2.property === prop);
        if (column) {
          column.order = order2;
          instance.store.updateSort(column, prop, order2);
          instance.store.commit("changeSortCondition", { init });
        }
      }
    },
    changeSortCondition(states, options2) {
      const { sortingColumn: column, sortProp: prop, sortOrder: order2 } = states;
      if (unref(order2) === null) {
        states.sortingColumn.value = null;
        states.sortProp.value = null;
      }
      const ingore = { filter: true };
      instance.store.execQuery(ingore);
      if (!options2 || !(options2.silent || options2.init)) {
        instance.emit("sort-change", {
          column: unref(column),
          prop: unref(prop),
          order: unref(order2)
        });
      }
      instance.store.updateTableScrollY();
    },
    filterChange(_states, options2) {
      const { column, values, silent } = options2;
      const newFilters = instance.store.updateFilters(column, values);
      instance.store.execQuery();
      if (!silent) {
        instance.emit("filter-change", newFilters);
      }
      instance.store.updateTableScrollY();
    },
    toggleAllSelection() {
      instance.store.toggleAllSelection();
    },
    rowSelectedChanged(_states, row) {
      instance.store.toggleRowSelection(row);
      instance.store.updateAllSelected();
    },
    setHoverRow(states, row) {
      states.hoverRow.value = row;
    },
    setCurrentRow(_states, row) {
      instance.store.updateCurrentRow(row);
    }
  };
  const commit = function(name2, ...args) {
    const mutations2 = instance.store.mutations;
    if (mutations2[name2]) {
      mutations2[name2].apply(instance, [instance.store.states].concat(args));
    } else {
      throw new Error(`Action not found: ${name2}`);
    }
  };
  const updateTableScrollY = function() {
    nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
  };
  return __spreadProps$6(__spreadValues$3$1({}, watcher), {
    mutations,
    commit,
    updateTableScrollY
  });
}
const InitialStateMap = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};
function createStore(table, props2) {
  if (!table) {
    throw new Error("Table is required.");
  }
  const store = useStore();
  store.toggleAllSelection = debounce_1(store._toggleAllSelection, 10);
  Object.keys(InitialStateMap).forEach((key) => {
    handleValue(getArrKeysValue(props2, key), key, store);
  });
  proxyTableProps(store, props2);
  return store;
}
function proxyTableProps(store, props2) {
  Object.keys(InitialStateMap).forEach((key) => {
    watch(() => getArrKeysValue(props2, key), (value2) => {
      handleValue(value2, key, store);
    });
  });
}
function handleValue(value2, propsKey, store) {
  let newVal = value2;
  let storeKey = InitialStateMap[propsKey];
  if (typeof InitialStateMap[propsKey] === "object") {
    storeKey = storeKey.key;
    newVal = newVal || InitialStateMap[propsKey].default;
  }
  store.states[storeKey].value = newVal;
}
function getArrKeysValue(props2, keys2) {
  if (keys2.includes(".")) {
    const keyList = keys2.split(".");
    let value2 = props2;
    keyList.forEach((key) => {
      value2 = value2[key];
    });
    return value2;
  } else {
    return props2[keys2];
  }
}
class TableLayout {
  constructor(options2) {
    this.observers = [];
    this.table = null;
    this.store = null;
    this.columns = [];
    this.fit = true;
    this.showHeader = true;
    this.height = ref(null);
    this.scrollX = ref(false);
    this.scrollY = ref(false);
    this.bodyWidth = ref(null);
    this.fixedWidth = ref(null);
    this.rightFixedWidth = ref(null);
    this.tableHeight = ref(null);
    this.headerHeight = ref(44);
    this.appendHeight = ref(0);
    this.footerHeight = ref(44);
    this.viewportHeight = ref(null);
    this.bodyHeight = ref(null);
    this.fixedBodyHeight = ref(null);
    this.gutterWidth = scrollbarWidth();
    for (const name2 in options2) {
      if (hasOwn(options2, name2)) {
        if (isRef(this[name2])) {
          this[name2].value = options2[name2];
        } else {
          this[name2] = options2[name2];
        }
      }
    }
    if (!this.table) {
      throw new Error("table is required for Table Layout");
    }
    if (!this.store) {
      throw new Error("store is required for Table Layout");
    }
  }
  updateScrollY() {
    const height = this.height.value;
    if (height === null)
      return false;
    const bodyWrapper = this.table.refs.bodyWrapper;
    if (this.table.vnode.el && bodyWrapper) {
      let scrollY = true;
      const prevScrollY = this.scrollY.value;
      if (this.bodyHeight.value === null) {
        scrollY = false;
      } else {
        const body = bodyWrapper.querySelector(".el-table__body");
        scrollY = body.offsetHeight > this.bodyHeight.value;
      }
      this.scrollY.value = scrollY;
      return prevScrollY !== scrollY;
    }
    return false;
  }
  setHeight(value2, prop = "height") {
    if (isServer)
      return;
    const el = this.table.vnode.el;
    value2 = parseHeight(value2);
    this.height.value = Number(value2);
    if (!el && (value2 || value2 === 0))
      return nextTick(() => this.setHeight(value2, prop));
    if (typeof value2 === "number") {
      el.style[prop] = value2 + "px";
      this.updateElsHeight();
    } else if (typeof value2 === "string") {
      el.style[prop] = value2;
      this.updateElsHeight();
    }
  }
  setMaxHeight(value2) {
    this.setHeight(value2, "max-height");
  }
  getFlattenColumns() {
    const flattenColumns = [];
    const columns = this.table.store.states.columns.value;
    columns.forEach((column) => {
      if (column.isColumnGroup) {
        flattenColumns.push.apply(flattenColumns, column.columns);
      } else {
        flattenColumns.push(column);
      }
    });
    return flattenColumns;
  }
  updateElsHeight() {
    if (!this.table.$ready)
      return nextTick(() => this.updateElsHeight());
    const { headerWrapper, appendWrapper, footerWrapper } = this.table.refs;
    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;
    if (this.showHeader && !headerWrapper)
      return;
    const headerTrElm = headerWrapper ? headerWrapper.querySelector(".el-table__header tr") : null;
    const noneHeader = this.headerDisplayNone(headerTrElm);
    const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapper.offsetHeight;
    if (this.showHeader && !noneHeader && headerWrapper.offsetWidth > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) {
      return nextTick(() => this.updateElsHeight());
    }
    const tableHeight = this.tableHeight.value = this.table.vnode.el.clientHeight;
    const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;
    if (this.height.value !== null) {
      this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
    }
    this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;
    this.viewportHeight.value = this.scrollX.value ? tableHeight - this.gutterWidth : tableHeight;
    this.updateScrollY();
    this.notifyObservers("scrollable");
  }
  headerDisplayNone(elm) {
    if (!elm)
      return true;
    let headerChild = elm;
    while (headerChild.tagName !== "DIV") {
      if (getComputedStyle(headerChild).display === "none") {
        return true;
      }
      headerChild = headerChild.parentElement;
    }
    return false;
  }
  updateColumnsWidth() {
    if (isServer)
      return;
    const fit = this.fit;
    const bodyWidth = this.table.vnode.el.clientWidth;
    let bodyMinWidth = 0;
    const flattenColumns = this.getFlattenColumns();
    const flexColumns = flattenColumns.filter((column) => typeof column.width !== "number");
    flattenColumns.forEach((column) => {
      if (typeof column.width === "number" && column.realWidth)
        column.realWidth = null;
    });
    if (flexColumns.length > 0 && fit) {
      flattenColumns.forEach((column) => {
        bodyMinWidth += Number(column.width || column.minWidth || 80);
      });
      const scrollYWidth = this.scrollY.value ? this.gutterWidth : 0;
      if (bodyMinWidth <= bodyWidth - scrollYWidth) {
        this.scrollX.value = false;
        const totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;
        if (flexColumns.length === 1) {
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
        } else {
          const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
          let noneFirstWidth = 0;
          flexColumns.forEach((column, index2) => {
            if (index2 === 0)
              return;
            const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
            noneFirstWidth += flexWidth;
            column.realWidth = Number(column.minWidth || 80) + flexWidth;
          });
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
        }
      } else {
        this.scrollX.value = true;
        flexColumns.forEach(function(column) {
          column.realWidth = Number(column.minWidth);
        });
      }
      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
      this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else {
      flattenColumns.forEach((column) => {
        if (!column.width && !column.minWidth) {
          column.realWidth = 80;
        } else {
          column.realWidth = Number(column.width || column.minWidth);
        }
        bodyMinWidth += column.realWidth;
      });
      this.scrollX.value = bodyMinWidth > bodyWidth;
      this.bodyWidth.value = bodyMinWidth;
    }
    const fixedColumns = this.store.states.fixedColumns.value;
    if (fixedColumns.length > 0) {
      let fixedWidth = 0;
      fixedColumns.forEach(function(column) {
        fixedWidth += Number(column.realWidth || column.width);
      });
      this.fixedWidth.value = fixedWidth;
    }
    const rightFixedColumns = this.store.states.rightFixedColumns.value;
    if (rightFixedColumns.length > 0) {
      let rightFixedWidth = 0;
      rightFixedColumns.forEach(function(column) {
        rightFixedWidth += Number(column.realWidth || column.width);
      });
      this.rightFixedWidth.value = rightFixedWidth;
    }
    this.notifyObservers("columns");
  }
  addObserver(observer) {
    this.observers.push(observer);
  }
  removeObserver(observer) {
    const index2 = this.observers.indexOf(observer);
    if (index2 !== -1) {
      this.observers.splice(index2, 1);
    }
  }
  notifyObservers(event2) {
    const observers2 = this.observers;
    observers2.forEach((observer) => {
      var _a, _b;
      switch (event2) {
        case "columns":
          (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);
          break;
        case "scrollable":
          (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${event2}.`);
      }
    });
  }
}
const { CheckboxGroup: ElCheckboxGroup } = _Checkbox;
var script$9 = defineComponent({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: _Checkbox,
    ElCheckboxGroup,
    ElScrollbar: _Scrollbar,
    ElPopper: ElPopper$1
  },
  directives: { ClickOutside: ClickOutside$1 },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const { t } = useLocaleInject();
    const parent2 = instance.parent;
    if (!parent2.filterPanels.value[props2.column.id]) {
      parent2.filterPanels.value[props2.column.id] = instance;
    }
    const tooltipVisible = ref(false);
    const tooltip = ref(null);
    const filters = computed(() => {
      return props2.column && props2.column.filters;
    });
    const filterValue = computed({
      get: () => (props2.column.filteredValue || [])[0],
      set: (value2) => {
        if (filteredValue.value) {
          if (typeof value2 !== "undefined" && value2 !== null) {
            filteredValue.value.splice(0, 1, value2);
          } else {
            filteredValue.value.splice(0, 1);
          }
        }
      }
    });
    const filteredValue = computed({
      get() {
        if (props2.column) {
          return props2.column.filteredValue || [];
        }
        return [];
      },
      set(value2) {
        if (props2.column) {
          props2.upDataColumn("filteredValue", value2);
        }
      }
    });
    const multiple = computed(() => {
      if (props2.column) {
        return props2.column.filterMultiple;
      }
      return true;
    });
    const isActive = (filter) => {
      return filter.value === filterValue.value;
    };
    const hidden = () => {
      tooltipVisible.value = false;
    };
    const showFilterPanel = (e) => {
      e.stopPropagation();
      tooltipVisible.value = !tooltipVisible.value;
    };
    const hideFilterPanel = () => {
      tooltipVisible.value = false;
    };
    const handleConfirm = () => {
      confirmFilter(filteredValue.value);
      hidden();
    };
    const handleReset = () => {
      filteredValue.value = [];
      confirmFilter(filteredValue.value);
      hidden();
    };
    const handleSelect = (_filterValue) => {
      filterValue.value = _filterValue;
      if (typeof _filterValue !== "undefined" && _filterValue !== null) {
        confirmFilter(filteredValue.value);
      } else {
        confirmFilter([]);
      }
      hidden();
    };
    const confirmFilter = (filteredValue2) => {
      props2.store.commit("filterChange", {
        column: props2.column,
        values: filteredValue2
      });
      props2.store.updateAllSelected();
    };
    watch(tooltipVisible, (value2) => {
      if (props2.column) {
        props2.upDataColumn("filterOpened", value2);
      }
    }, {
      immediate: true
    });
    const popperPaneRef = computed(() => {
      var _a;
      return (_a = tooltip.value) == null ? void 0 : _a.popperRef;
    });
    return {
      tooltipVisible,
      multiple,
      filteredValue,
      filterValue,
      filters,
      handleConfirm,
      handleReset,
      handleSelect,
      isActive,
      t,
      showFilterPanel,
      hideFilterPanel,
      popperPaneRef,
      tooltip
    };
  }
});
const _hoisted_1$z = { key: 0 };
const _hoisted_2$t = { class: "el-table-filter__content" };
const _hoisted_3$s = { class: "el-table-filter__bottom" };
const _hoisted_4$l = ["disabled"];
const _hoisted_5$h = {
  key: 1,
  class: "el-table-filter__list"
};
const _hoisted_6$f = ["label", "onClick"];
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_popper = resolveComponent("el-popper");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "tooltip",
    visible: _ctx.tooltipVisible,
    "onUpdate:visible": _cache[5] || (_cache[5] = ($event) => _ctx.tooltipVisible = $event),
    offset: 0,
    placement: _ctx.placement,
    "show-arrow": false,
    "stop-popper-mouse-event": false,
    effect: "light",
    pure: "",
    "manual-mode": "",
    "popper-class": "el-table-filter",
    "append-to-body": ""
  }, {
    default: withCtx(() => [
      _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$z, [
        createElementVNode("div", _hoisted_2$t, [
          createVNode(_component_el_scrollbar, { "wrap-class": "el-table-filter__wrap" }, {
            default: withCtx(() => [
              createVNode(_component_el_checkbox_group, {
                modelValue: _ctx.filteredValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                class: "el-table-filter__checkbox-group"
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
                    return openBlock(), createBlock(_component_el_checkbox, {
                      key: filter.value,
                      label: filter.value
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(filter.text), 1)
                      ]),
                      _: 2
                    }, 1032, ["label"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            _: 1
          })
        ]),
        createElementVNode("div", _hoisted_3$s, [
          createElementVNode("button", {
            class: normalizeClass({ "is-disabled": _ctx.filteredValue.length === 0 }),
            disabled: _ctx.filteredValue.length === 0,
            type: "button",
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
          }, toDisplayString(_ctx.t("el.table.confirmFilter")), 11, _hoisted_4$l),
          createElementVNode("button", {
            type: "button",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
          }, toDisplayString(_ctx.t("el.table.resetFilter")), 1)
        ])
      ])) : (openBlock(), createElementBlock("ul", _hoisted_5$h, [
        createElementVNode("li", {
          class: normalizeClass([{
            "is-active": _ctx.filterValue === void 0 || _ctx.filterValue === null
          }, "el-table-filter__list-item"]),
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
        }, toDisplayString(_ctx.t("el.table.clearFilter")), 3),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter) => {
          return openBlock(), createElementBlock("li", {
            key: filter.value,
            class: normalizeClass([{ "is-active": _ctx.isActive(filter) }, "el-table-filter__list-item"]),
            label: filter.value,
            onClick: ($event) => _ctx.handleSelect(filter.value)
          }, toDisplayString(filter.text), 11, _hoisted_6$f);
        }), 128))
      ]))
    ]),
    trigger: withCtx(() => [
      withDirectives(createElementVNode("span", {
        class: "el-table__column-filter-trigger el-none-outline",
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
      }, [
        createElementVNode("i", {
          class: normalizeClass([
            "el-icon-arrow-down",
            _ctx.column.filterOpened ? "el-icon-arrow-up" : ""
          ])
        }, null, 2)
      ], 512), [
        [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement"]);
}
script$9.render = render$9;
script$9.__file = "packages/components/table/src/filter-panel.vue";
function useLayoutObserver(root2) {
  const instance = getCurrentInstance();
  onBeforeMount(() => {
    tableLayout.value.addObserver(instance);
  });
  onMounted(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  onUpdated(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  onUnmounted(() => {
    tableLayout.value.removeObserver(instance);
  });
  const tableLayout = computed(() => {
    const layout = root2.layout;
    if (!layout) {
      throw new Error("Can not find table layout.");
    }
    return layout;
  });
  const onColumnsChange = (layout) => {
    var _a;
    const cols = ((_a = root2.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col")) || [];
    if (!cols.length)
      return;
    const flattenColumns = layout.getFlattenColumns();
    const columnsMap = {};
    flattenColumns.forEach((column) => {
      columnsMap[column.id] = column;
    });
    for (let i2 = 0, j = cols.length; i2 < j; i2++) {
      const col = cols[i2];
      const name2 = col.getAttribute("name");
      const column = columnsMap[name2];
      if (column) {
        col.setAttribute("width", column.realWidth || column.width);
      }
    }
  };
  const onScrollableChange = (layout) => {
    const cols = root2.vnode.el.querySelectorAll("colgroup > col[name=gutter]");
    for (let i2 = 0, j = cols.length; i2 < j; i2++) {
      const col = cols[i2];
      col.setAttribute("width", layout.scrollY.value ? layout.gutterWidth : "0");
    }
    const ths = root2.vnode.el.querySelectorAll("th.gutter");
    for (let i2 = 0, j = ths.length; i2 < j; i2++) {
      const th = ths[i2];
      th.style.width = layout.scrollY.value ? layout.gutterWidth + "px" : "0";
      th.style.display = layout.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: tableLayout.value,
    onColumnsChange,
    onScrollableChange
  };
}
function useEvent(props2, emit2) {
  const instance = getCurrentInstance();
  const parent2 = instance.parent;
  const handleFilterClick = (event2) => {
    event2.stopPropagation();
    return;
  };
  const handleHeaderClick = (event2, column) => {
    if (!column.filters && column.sortable) {
      handleSortClick(event2, column, false);
    } else if (column.filterable && !column.sortable) {
      handleFilterClick(event2);
    }
    parent2.emit("header-click", column, event2);
  };
  const handleHeaderContextMenu = (event2, column) => {
    parent2.emit("header-contextmenu", column, event2);
  };
  const draggingColumn = ref(null);
  const dragging = ref(false);
  const dragState = ref({});
  const handleMouseDown = (event2, column) => {
    if (isServer)
      return;
    if (column.children && column.children.length > 0)
      return;
    if (draggingColumn.value && props2.border) {
      dragging.value = true;
      const table = parent2;
      emit2("set-drag-visible", true);
      const tableEl = table.vnode.el;
      const tableLeft = tableEl.getBoundingClientRect().left;
      const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
      const columnRect = columnEl.getBoundingClientRect();
      const minLeft = columnRect.left - tableLeft + 30;
      addClass$1(columnEl, "noclick");
      dragState.value = {
        startMouseLeft: event2.clientX,
        startLeft: columnRect.right - tableLeft,
        startColumnLeft: columnRect.left - tableLeft,
        tableLeft
      };
      const resizeProxy = table.refs.resizeProxy;
      resizeProxy.style.left = dragState.value.startLeft + "px";
      document.onselectstart = function() {
        return false;
      };
      document.ondragstart = function() {
        return false;
      };
      const handleMouseMove2 = (event22) => {
        const deltaLeft = event22.clientX - dragState.value.startMouseLeft;
        const proxyLeft = dragState.value.startLeft + deltaLeft;
        resizeProxy.style.left = Math.max(minLeft, proxyLeft) + "px";
      };
      const handleMouseUp = () => {
        if (dragging.value) {
          const { startColumnLeft, startLeft } = dragState.value;
          const finalLeft = parseInt(resizeProxy.style.left, 10);
          const columnWidth = finalLeft - startColumnLeft;
          column.width = column.realWidth = columnWidth;
          table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event2);
          props2.store.scheduleLayout(false, true);
          document.body.style.cursor = "";
          dragging.value = false;
          draggingColumn.value = null;
          dragState.value = {};
          emit2("set-drag-visible", false);
        }
        document.removeEventListener("mousemove", handleMouseMove2);
        document.removeEventListener("mouseup", handleMouseUp);
        document.onselectstart = null;
        document.ondragstart = null;
        setTimeout(function() {
          removeClass(columnEl, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", handleMouseMove2);
      document.addEventListener("mouseup", handleMouseUp);
    }
  };
  const handleMouseMove = (event2, column) => {
    if (column.children && column.children.length > 0)
      return;
    let target = event2.target;
    while (target && target.tagName !== "TH") {
      target = target.parentNode;
    }
    if (!column || !column.resizable)
      return;
    if (!dragging.value && props2.border) {
      const rect = target.getBoundingClientRect();
      const bodyStyle = document.body.style;
      if (rect.width > 12 && rect.right - event2.pageX < 8) {
        bodyStyle.cursor = "col-resize";
        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "col-resize";
        }
        draggingColumn.value = column;
      } else if (!dragging.value) {
        bodyStyle.cursor = "";
        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "pointer";
        }
        draggingColumn.value = null;
      }
    }
  };
  const handleMouseOut = () => {
    if (isServer)
      return;
    document.body.style.cursor = "";
  };
  const toggleOrder = ({ order: order2, sortOrders }) => {
    if (order2 === "")
      return sortOrders[0];
    const index2 = sortOrders.indexOf(order2 || null);
    return sortOrders[index2 > sortOrders.length - 2 ? 0 : index2 + 1];
  };
  const handleSortClick = (event2, column, givenOrder) => {
    event2.stopPropagation();
    const order2 = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
    let target = event2.target;
    while (target && target.tagName !== "TH") {
      target = target.parentNode;
    }
    if (target && target.tagName === "TH") {
      if (hasClass(target, "noclick")) {
        removeClass(target, "noclick");
        return;
      }
    }
    if (!column.sortable)
      return;
    const states = props2.store.states;
    let sortProp = states.sortProp.value;
    let sortOrder;
    const sortingColumn = states.sortingColumn.value;
    if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
      if (sortingColumn) {
        sortingColumn.order = null;
      }
      states.sortingColumn.value = column;
      sortProp = column.property;
    }
    if (!order2) {
      sortOrder = column.order = null;
    } else {
      sortOrder = column.order = order2;
    }
    states.sortProp.value = sortProp;
    states.sortOrder.value = sortOrder;
    parent2.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick,
    handleHeaderContextMenu,
    handleMouseDown,
    handleMouseMove,
    handleMouseOut,
    handleSortClick,
    handleFilterClick
  };
}
function useStyle(props2) {
  const instance = getCurrentInstance();
  const parent2 = instance.parent;
  const storeData = parent2.store.states;
  const isCellHidden = (index2, columns) => {
    let start2 = 0;
    for (let i2 = 0; i2 < index2; i2++) {
      start2 += columns[i2].colSpan;
    }
    const after = start2 + columns[index2].colSpan - 1;
    if (props2.fixed === "left") {
      return after >= storeData.fixedLeafColumnsLength.value;
    } else if (props2.fixed === "right") {
      return start2 < storeData.columns.value.length - storeData.rightFixedLeafColumnsLength.value;
    } else {
      return after < storeData.fixedLeafColumnsLength.value || start2 >= storeData.columns.value.length - storeData.rightFixedLeafColumnsLength.value;
    }
  };
  const getHeaderRowStyle = (rowIndex) => {
    const headerRowStyle = parent2.props.headerRowStyle;
    if (typeof headerRowStyle === "function") {
      return headerRowStyle.call(null, { rowIndex });
    }
    return headerRowStyle;
  };
  const getHeaderRowClass = (rowIndex) => {
    const classes = [];
    const headerRowClassName = parent2.props.headerRowClassName;
    if (typeof headerRowClassName === "string") {
      classes.push(headerRowClassName);
    } else if (typeof headerRowClassName === "function") {
      classes.push(headerRowClassName.call(null, { rowIndex }));
    }
    return classes.join(" ");
  };
  const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
    const headerCellStyle = parent2.props.headerCellStyle;
    if (typeof headerCellStyle === "function") {
      return headerCellStyle.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }
    return headerCellStyle;
  };
  const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
    const classes = [
      column.id,
      column.order,
      column.headerAlign,
      column.className,
      column.labelClassName
    ];
    if (rowIndex === 0 && isCellHidden(columnIndex, row)) {
      classes.push("is-hidden");
    }
    if (!column.children) {
      classes.push("is-leaf");
    }
    if (column.sortable) {
      classes.push("is-sortable");
    }
    const headerCellClassName = parent2.props.headerCellClassName;
    if (typeof headerCellClassName === "string") {
      classes.push(headerCellClassName);
    } else if (typeof headerCellClassName === "function") {
      classes.push(headerCellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }
    classes.push("el-table__cell");
    return classes.join(" ");
  };
  return {
    getHeaderRowStyle,
    getHeaderRowClass,
    getHeaderCellStyle,
    getHeaderCellClass
  };
}
const getAllColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.children) {
      result.push(column);
      result.push.apply(result, getAllColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};
const convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent2) => {
    if (parent2) {
      column.level = parent2.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children) {
      let colSpan = 0;
      column.children.forEach((subColumn) => {
        traverse(subColumn, column);
        colSpan += subColumn.colSpan;
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column.level = 1;
    traverse(column, void 0);
  });
  const rows = [];
  for (let i2 = 0; i2 < maxLevel; i2++) {
    rows.push([]);
  }
  const allColumns = getAllColumns(originColumns);
  allColumns.forEach((column) => {
    if (!column.children) {
      column.rowSpan = maxLevel - column.level + 1;
    } else {
      column.rowSpan = 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function useUtils(props2) {
  const instance = getCurrentInstance();
  const parent2 = instance.parent;
  const columnRows = computed(() => {
    return convertToRows(props2.store.states.originColumns.value);
  });
  const isGroup = computed(() => {
    const result = columnRows.value.length > 1;
    if (result)
      parent2.state.isGroup.value = true;
    return result;
  });
  const toggleAllSelection = (event2) => {
    event2.stopPropagation();
    parent2.store.commit("toggleAllSelection");
  };
  return {
    isGroup,
    toggleAllSelection,
    columnRows
  };
}
function hGutter() {
  return h("col", {
    name: "gutter"
  });
}
function hColgroup(columns, hasGutter = false) {
  return h("colgroup", {}, [
    ...columns.map((column) => h("col", {
      name: column.id,
      key: column.id
    })),
    hasGutter && hGutter()
  ]);
}
var TableHeader = defineComponent({
  name: "ElTableHeader",
  components: {
    ElCheckbox: _Checkbox
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },
  setup(props2, { emit: emit2 }) {
    const instance = getCurrentInstance();
    const parent2 = instance.parent;
    const storeData = parent2.store.states;
    const filterPanels = ref({});
    const {
      tableLayout,
      onColumnsChange,
      onScrollableChange
    } = useLayoutObserver(parent2);
    const hasGutter = computed(() => {
      return !props2.fixed && tableLayout.gutterWidth;
    });
    onMounted(() => {
      nextTick(() => {
        const { prop, order: order2 } = props2.defaultSort;
        const init = true;
        parent2.store.commit("sort", { prop, order: order2, init });
      });
    });
    const {
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick
    } = useEvent(props2, emit2);
    const {
      getHeaderRowStyle,
      getHeaderRowClass,
      getHeaderCellStyle,
      getHeaderCellClass
    } = useStyle(props2);
    const { isGroup, toggleAllSelection, columnRows } = useUtils(props2);
    instance.state = {
      onColumnsChange,
      onScrollableChange
    };
    instance.filterPanels = filterPanels;
    return {
      columns: storeData.columns,
      filterPanels,
      hasGutter,
      onColumnsChange,
      onScrollableChange,
      columnRows,
      getHeaderRowClass,
      getHeaderRowStyle,
      getHeaderCellClass,
      getHeaderCellStyle,
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick,
      isGroup,
      toggleAllSelection
    };
  },
  render() {
    return h("table", {
      border: "0",
      cellpadding: "0",
      cellspacing: "0",
      class: "el-table__header"
    }, [
      hColgroup(this.columns, this.hasGutter),
      h("thead", {
        class: { "is-group": this.isGroup, "has-gutter": this.hasGutter }
      }, this.columnRows.map((subColumns, rowIndex) => h("tr", {
        class: this.getHeaderRowClass(rowIndex),
        key: rowIndex,
        style: this.getHeaderRowStyle(rowIndex)
      }, subColumns.map((column, cellIndex) => h("th", {
        class: this.getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
        colspan: column.colSpan,
        key: `${column.id}-thead`,
        rowSpan: column.rowSpan,
        style: this.getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
        onClick: ($event) => this.handleHeaderClick($event, column),
        onContextmenu: ($event) => this.handleHeaderContextMenu($event, column),
        onMousedown: ($event) => this.handleMouseDown($event, column),
        onMousemove: ($event) => this.handleMouseMove($event, column),
        onMouseout: this.handleMouseOut
      }, [
        h("div", {
          class: [
            "cell",
            column.filteredValue && column.filteredValue.length > 0 ? "highlight" : "",
            column.labelClassName
          ]
        }, [
          column.renderHeader ? column.renderHeader({
            column,
            $index: cellIndex,
            store: this.store,
            _self: this.$parent
          }) : column.label,
          column.sortable && h("span", {
            onClick: ($event) => this.handleSortClick($event, column),
            class: "caret-wrapper"
          }, [
            h("i", {
              onClick: ($event) => this.handleSortClick($event, column, "ascending"),
              class: "sort-caret ascending"
            }),
            h("i", {
              onClick: ($event) => this.handleSortClick($event, column, "descending"),
              class: "sort-caret descending"
            })
          ]),
          column.filterable && h(script$9, {
            store: this.$parent.store,
            placement: column.filterPlacement || "bottom-start",
            column,
            upDataColumn: (key, value2) => {
              column[key] = value2;
            }
          })
        ])
      ])))))
    ]);
  }
});
function useEvents(props2) {
  const instance = getCurrentInstance();
  const parent2 = instance.parent;
  const tooltipContent = ref("");
  const tooltipTrigger = ref(h("div"));
  const handleEvent2 = (event2, row, name2) => {
    const table = parent2;
    const cell = getCell(event2);
    let column;
    if (cell) {
      column = getColumnByCell({
        columns: props2.store.states.columns.value
      }, cell);
      if (column) {
        table.emit(`cell-${name2}`, row, column, cell, event2);
      }
    }
    table.emit(`row-${name2}`, row, column, event2);
  };
  const handleDoubleClick = (event2, row) => {
    handleEvent2(event2, row, "dblclick");
  };
  const handleClick = (event2, row) => {
    props2.store.commit("setCurrentRow", row);
    handleEvent2(event2, row, "click");
  };
  const handleContextMenu = (event2, row) => {
    handleEvent2(event2, row, "contextmenu");
  };
  const handleMouseEnter = debounce_1(function(index2) {
    props2.store.commit("setHoverRow", index2);
  }, 30);
  const handleMouseLeave = debounce_1(function() {
    props2.store.commit("setHoverRow", null);
  }, 30);
  const handleCellMouseEnter = (event2, row) => {
    const table = parent2;
    const cell = getCell(event2);
    if (cell) {
      const column = getColumnByCell({
        columns: props2.store.states.columns.value
      }, cell);
      const hoverState = table.hoverState = { cell, column, row };
      table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event2);
    }
    const cellChild = event2.target.querySelector(".cell");
    if (!(hasClass(cellChild, "el-tooltip") && cellChild.childNodes.length)) {
      return;
    }
    const range2 = document.createRange();
    range2.setStart(cellChild, 0);
    range2.setEnd(cellChild, cellChild.childNodes.length);
    const rangeWidth = range2.getBoundingClientRect().width;
    const padding = (parseInt(getStyle(cellChild, "paddingLeft"), 10) || 0) + (parseInt(getStyle(cellChild, "paddingRight"), 10) || 0);
    if (rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) {
      createTablePopper(cell, cell.innerText || cell.textContent, {
        placement: "top",
        strategy: "fixed"
      }, row.tooltipEffect);
    }
  };
  const handleCellMouseLeave = (event2) => {
    const cell = getCell(event2);
    if (!cell)
      return;
    const oldHoverState = parent2.hoverState;
    parent2.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event2);
  };
  return {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  };
}
function useStyles(props2) {
  const instance = getCurrentInstance();
  const parent2 = instance.parent;
  const isColumnHidden = (index2) => {
    if (props2.fixed === "left") {
      return index2 >= props2.store.states.fixedLeafColumnsLength.value;
    } else if (props2.fixed === "right") {
      return index2 < props2.store.states.columns.value.length - props2.store.states.rightFixedLeafColumnsLength.value;
    } else {
      return index2 < props2.store.states.fixedLeafColumnsLength.value || index2 >= props2.store.states.columns.value.length - props2.store.states.rightFixedLeafColumnsLength.value;
    }
  };
  const getRowStyle = (row, rowIndex) => {
    const rowStyle = parent2.props.rowStyle;
    if (typeof rowStyle === "function") {
      return rowStyle.call(null, {
        row,
        rowIndex
      });
    }
    return rowStyle || null;
  };
  const getRowClass = (row, rowIndex) => {
    const classes = ["el-table__row"];
    if (parent2.props.highlightCurrentRow && row === props2.store.states.currentRow.value) {
      classes.push("current-row");
    }
    if (props2.stripe && rowIndex % 2 === 1) {
      classes.push("el-table__row--striped");
    }
    const rowClassName = parent2.props.rowClassName;
    if (typeof rowClassName === "string") {
      classes.push(rowClassName);
    } else if (typeof rowClassName === "function") {
      classes.push(rowClassName.call(null, {
        row,
        rowIndex
      }));
    }
    if (props2.store.states.expandRows.value.indexOf(row) > -1) {
      classes.push("expanded");
    }
    return classes;
  };
  const getCellStyle = (rowIndex, columnIndex, row, column) => {
    const cellStyle = parent2.props.cellStyle;
    if (typeof cellStyle === "function") {
      return cellStyle.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }
    return cellStyle;
  };
  const getCellClass = (rowIndex, columnIndex, row, column) => {
    const classes = [column.id, column.align, column.className];
    if (isColumnHidden(columnIndex)) {
      classes.push("is-hidden");
    }
    const cellClassName = parent2.props.cellClassName;
    if (typeof cellClassName === "string") {
      classes.push(cellClassName);
    } else if (typeof cellClassName === "function") {
      classes.push(cellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }
    classes.push("el-table__cell");
    return classes.join(" ");
  };
  const getSpan = (row, column, rowIndex, columnIndex) => {
    let rowspan = 1;
    let colspan = 1;
    const fn2 = parent2.props.spanMethod;
    if (typeof fn2 === "function") {
      const result = fn2({
        row,
        column,
        rowIndex,
        columnIndex
      });
      if (Array.isArray(result)) {
        rowspan = result[0];
        colspan = result[1];
      } else if (typeof result === "object") {
        rowspan = result.rowspan;
        colspan = result.colspan;
      }
    }
    return { rowspan, colspan };
  };
  const getColspanRealWidth = (columns, colspan, index2) => {
    if (colspan < 1) {
      return columns[index2].realWidth;
    }
    const widthArr = columns.map(({ realWidth, width: width2 }) => realWidth || width2).slice(index2, index2 + colspan);
    return Number(widthArr.reduce((acc, width2) => Number(acc) + Number(width2), -1));
  };
  return {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth,
    isColumnHidden
  };
}
var __defProp$4$1 = Object.defineProperty;
var __defProps$1$1 = Object.defineProperties;
var __getOwnPropDescs$1$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$4$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$4$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4$1 = (obj, key, value2) => key in obj ? __defProp$4$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$4$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4$1.call(b, prop))
      __defNormalProp$4$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$4$1)
    for (var prop of __getOwnPropSymbols$4$1(b)) {
      if (__propIsEnum$4$1.call(b, prop))
        __defNormalProp$4$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1$1 = (a, b) => __defProps$1$1(a, __getOwnPropDescs$1$1(b));
function useRender(props2) {
  const instance = getCurrentInstance();
  const parent2 = instance.parent;
  const {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  } = useEvents(props2);
  const {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth
  } = useStyles(props2);
  const firstDefaultColumnIndex = computed(() => {
    return arrayFindIndex(props2.store.states.columns.value, ({ type: type2 }) => type2 === "default");
  });
  const getKeyOfRow = (row, index2) => {
    const rowKey = parent2.props.rowKey;
    if (rowKey) {
      return getRowIdentity(row, rowKey);
    }
    return index2;
  };
  const rowRender = (row, $index, treeRowData) => {
    const { tooltipEffect, store } = props2;
    const { indent, columns } = store.states;
    const rowClasses = getRowClass(row, $index);
    let display = true;
    if (treeRowData) {
      rowClasses.push("el-table__row--level-" + treeRowData.level);
      display = treeRowData.display;
    }
    const displayStyle = display ? null : {
      display: "none"
    };
    return h("tr", {
      style: [displayStyle, getRowStyle(row, $index)],
      class: rowClasses,
      key: getKeyOfRow(row, $index),
      onDblclick: ($event) => handleDoubleClick($event, row),
      onClick: ($event) => handleClick($event, row),
      onContextmenu: ($event) => handleContextMenu($event, row),
      onMouseenter: () => handleMouseEnter($index),
      onMouseleave: handleMouseLeave
    }, columns.value.map((column, cellIndex) => {
      const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
      if (!rowspan || !colspan) {
        return null;
      }
      const columnData = __spreadValues$4$1({}, column);
      columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
      const data = {
        store: props2.store,
        _self: props2.context || parent2,
        column: columnData,
        row,
        $index
      };
      if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
        data.treeNode = {
          indent: treeRowData.level * indent.value,
          level: treeRowData.level
        };
        if (typeof treeRowData.expanded === "boolean") {
          data.treeNode.expanded = treeRowData.expanded;
          if ("loading" in treeRowData) {
            data.treeNode.loading = treeRowData.loading;
          }
          if ("noLazyChildren" in treeRowData) {
            data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
          }
        }
      }
      const baseKey = `${$index},${cellIndex}`;
      const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
      return h("td", {
        style: getCellStyle($index, cellIndex, row, column),
        class: getCellClass($index, cellIndex, row, column),
        key: `${patchKey}${baseKey}`,
        rowspan,
        colspan,
        onMouseenter: ($event) => handleCellMouseEnter($event, __spreadProps$1$1(__spreadValues$4$1({}, row), { tooltipEffect })),
        onMouseleave: handleCellMouseLeave
      }, [column.renderCell(data)]);
    }));
  };
  const wrappedRowRender = (row, $index) => {
    const store = props2.store;
    const { isRowExpanded, assertRowKey } = store;
    const {
      treeData,
      lazyTreeNodeMap,
      childrenColumnName,
      rowKey
    } = store.states;
    const hasExpandColumn = store.states.columns.value.some(({ type: type2 }) => type2 === "expand");
    if (hasExpandColumn && isRowExpanded(row)) {
      const renderExpanded = parent2.renderExpanded;
      const tr = rowRender(row, $index, void 0);
      if (!renderExpanded) {
        console.error("[Element Error]renderExpanded is required.");
        return tr;
      }
      return [[
        tr,
        h("tr", {
          key: "expanded-row__" + tr.key
        }, [
          h("td", {
            colspan: store.states.columns.value.length,
            class: "el-table__cell el-table__expanded-cell"
          }, [renderExpanded({ row, $index, store })])
        ])
      ]];
    } else if (Object.keys(treeData.value).length) {
      assertRowKey();
      const key = getRowIdentity(row, rowKey.value);
      let cur = treeData.value[key];
      let treeRowData = null;
      if (cur) {
        treeRowData = {
          expanded: cur.expanded,
          level: cur.level,
          display: true
        };
        if (typeof cur.lazy === "boolean") {
          if (typeof cur.loaded === "boolean" && cur.loaded) {
            treeRowData.noLazyChildren = !(cur.children && cur.children.length);
          }
          treeRowData.loading = cur.loading;
        }
      }
      const tmp = [rowRender(row, $index, treeRowData)];
      if (cur) {
        let i2 = 0;
        const traverse = (children, parent22) => {
          if (!(children && children.length && parent22))
            return;
          children.forEach((node) => {
            const innerTreeRowData = {
              display: parent22.display && parent22.expanded,
              level: parent22.level + 1,
              expanded: false,
              noLazyChildren: false,
              loading: false
            };
            const childKey = getRowIdentity(node, rowKey.value);
            if (childKey === void 0 || childKey === null) {
              throw new Error("for nested data item, row-key is required.");
            }
            cur = __spreadValues$4$1({}, treeData.value[childKey]);
            if (cur) {
              innerTreeRowData.expanded = cur.expanded;
              cur.level = cur.level || innerTreeRowData.level;
              cur.display = !!(cur.expanded && innerTreeRowData.display);
              if (typeof cur.lazy === "boolean") {
                if (typeof cur.loaded === "boolean" && cur.loaded) {
                  innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                innerTreeRowData.loading = cur.loading;
              }
            }
            i2++;
            tmp.push(rowRender(node, $index + i2, innerTreeRowData));
            if (cur) {
              const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
              traverse(nodes2, cur);
            }
          });
        };
        cur.display = true;
        const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
        traverse(nodes, cur);
      }
      return tmp;
    } else {
      return rowRender(row, $index, void 0);
    }
  };
  return {
    wrappedRowRender,
    tooltipContent,
    tooltipTrigger
  };
}
const defaultProps = {
  store: {
    required: true,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var TableBody = defineComponent({
  name: "ElTableBody",
  props: defaultProps,
  setup(props2) {
    const instance = getCurrentInstance();
    const parent2 = instance.parent;
    const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender(props2);
    const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent2);
    watch(props2.store.states.hoverRow, (newVal, oldVal) => {
      if (!props2.store.states.isComplex.value || isServer)
        return;
      let raf = window.requestAnimationFrame;
      if (!raf) {
        raf = (fn2) => window.setTimeout(fn2, 16);
      }
      raf(() => {
        const rows = instance.vnode.el.querySelectorAll(".el-table__row");
        const oldRow = rows[oldVal];
        const newRow = rows[newVal];
        if (oldRow) {
          removeClass(oldRow, "hover-row");
        }
        if (newRow) {
          addClass$1(newRow, "hover-row");
        }
      });
    });
    onUnmounted(() => {
      var _a;
      (_a = removePopper) == null ? void 0 : _a();
    });
    onUpdated(() => {
      var _a;
      (_a = removePopper) == null ? void 0 : _a();
    });
    return {
      onColumnsChange,
      onScrollableChange,
      wrappedRowRender,
      tooltipContent,
      tooltipTrigger
    };
  },
  render() {
    const data = this.store.states.data.value || [];
    return h("table", {
      class: "el-table__body",
      cellspacing: "0",
      cellpadding: "0",
      border: "0"
    }, [
      hColgroup(this.store.states.columns.value),
      h("tbody", {}, [
        data.reduce((acc, row) => {
          return acc.concat(this.wrappedRowRender(row, acc.length));
        }, [])
      ])
    ]);
  }
});
function useMapState() {
  const instance = getCurrentInstance();
  const table = instance.parent;
  const store = table.store;
  const leftFixedLeafCount = computed(() => {
    return store.states.fixedLeafColumnsLength.value;
  });
  const rightFixedLeafCount = computed(() => {
    return store.states.rightFixedColumns.value.length;
  });
  const columnsCount = computed(() => {
    return store.states.columns.value.length;
  });
  const leftFixedCount = computed(() => {
    return store.states.fixedColumns.value.length;
  });
  const rightFixedCount = computed(() => {
    return store.states.rightFixedColumns.value.length;
  });
  return {
    leftFixedLeafCount,
    rightFixedLeafCount,
    columnsCount,
    leftFixedCount,
    rightFixedCount,
    columns: store.states.columns
  };
}
function useStyle$1(props2) {
  const instance = getCurrentInstance();
  const table = instance.parent;
  const store = table.store;
  const {
    leftFixedLeafCount,
    rightFixedLeafCount,
    columnsCount,
    leftFixedCount,
    rightFixedCount,
    columns
  } = useMapState();
  const hasGutter = computed(() => {
    return !props2.fixed && table.layout.gutterWidth;
  });
  const isCellHidden = (index2, columns2, column) => {
    if (props2.fixed || props2.fixed === "left") {
      return index2 >= leftFixedLeafCount.value;
    } else if (props2.fixed === "right") {
      let before = 0;
      for (let i2 = 0; i2 < index2; i2++) {
        before += columns2[i2].colSpan;
      }
      return before < columnsCount.value - rightFixedLeafCount.value;
    } else if (!props2.fixed && column.fixed) {
      return true;
    } else {
      return index2 < leftFixedCount.value || index2 >= columnsCount.value - rightFixedCount.value;
    }
  };
  const getRowClasses = (column, cellIndex) => {
    const classes = [column.id, column.align, column.labelClassName];
    if (column.className) {
      classes.push(column.className);
    }
    if (isCellHidden(cellIndex, store.states.columns.value, column)) {
      classes.push("is-hidden");
    }
    if (!column.children) {
      classes.push("is-leaf");
    }
    return classes;
  };
  return {
    hasGutter,
    getRowClasses,
    columns
  };
}
var TableFooter = defineComponent({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },
  setup(props2) {
    const { hasGutter, getRowClasses, columns } = useStyle$1(props2);
    return {
      getRowClasses,
      hasGutter,
      columns
    };
  },
  render() {
    let sums = [];
    if (this.summaryMethod) {
      sums = this.summaryMethod({
        columns: this.columns,
        data: this.store.states.data.value
      });
    } else {
      this.columns.forEach((column, index2) => {
        if (index2 === 0) {
          sums[index2] = this.sumText;
          return;
        }
        const values = this.store.states.data.value.map((item) => Number(item[column.property]));
        const precisions = [];
        let notNumber = true;
        values.forEach((value2) => {
          if (!isNaN(value2)) {
            notNumber = false;
            const decimal = ("" + value2).split(".")[1];
            precisions.push(decimal ? decimal.length : 0);
          }
        });
        const precision = Math.max.apply(null, precisions);
        if (!notNumber) {
          sums[index2] = values.reduce((prev, curr) => {
            const value2 = Number(curr);
            if (!isNaN(value2)) {
              return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
            } else {
              return prev;
            }
          }, 0);
        } else {
          sums[index2] = "";
        }
      });
    }
    return h("table", {
      class: "el-table__footer",
      cellspacing: "0",
      cellpadding: "0",
      border: "0"
    }, [
      hColgroup(this.columns, this.hasGutter),
      h("tbody", {
        class: [{ "has-gutter": this.hasGutter }]
      }, [
        h("tr", {}, [
          ...this.columns.map((column, cellIndex) => h("td", {
            key: cellIndex,
            colspan: column.colSpan,
            rowspan: column.rowSpan,
            class: [...this.getRowClasses(column, cellIndex), "el-table__cell"]
          }, [
            h("div", {
              class: ["cell", column.labelClassName]
            }, [sums[cellIndex]])
          ])),
          this.hasGutter && hGutter()
        ])
      ])
    ]);
  }
});
function useUtils$1(store) {
  const setCurrentRow = (row) => {
    store.commit("setCurrentRow", row);
  };
  const toggleRowSelection = (row, selected) => {
    store.toggleRowSelection(row, selected, false);
    store.updateAllSelected();
  };
  const clearSelection = () => {
    store.clearSelection();
  };
  const clearFilter = (columnKeys) => {
    store.clearFilter(columnKeys);
  };
  const toggleAllSelection = () => {
    store.commit("toggleAllSelection");
  };
  const toggleRowExpansion = (row, expanded) => {
    store.toggleRowExpansionAdapter(row, expanded);
  };
  const clearSort = () => {
    store.clearSort();
  };
  const sort2 = (prop, order2) => {
    store.commit("sort", { prop, order: order2 });
  };
  return {
    setCurrentRow,
    toggleRowSelection,
    clearSelection,
    clearFilter,
    toggleAllSelection,
    toggleRowExpansion,
    clearSort,
    sort: sort2
  };
}
function useStyle$2(props2, layout, store, table) {
  const $ELEMENT2 = useGlobalConfig();
  const isHidden = ref(false);
  const renderExpanded = ref(null);
  const resizeProxyVisible = ref(false);
  const setDragVisible = (visible2) => {
    resizeProxyVisible.value = visible2;
  };
  const resizeState = ref({
    width: null,
    height: null
  });
  const isGroup = ref(false);
  watchEffect(() => {
    layout.setHeight(props2.height);
  });
  watchEffect(() => {
    layout.setMaxHeight(props2.maxHeight);
  });
  watch(() => [props2.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
    if (!unref(rowKey))
      return;
    store.setCurrentRowKey(currentRowKey + "");
  }, {
    immediate: true
  });
  watch(() => props2.data, (data) => {
    table.store.commit("setData", data);
  }, {
    immediate: true,
    deep: true
  });
  watchEffect(() => {
    if (props2.expandRowKeys) {
      store.setExpandRowKeysAdapter(props2.expandRowKeys);
    }
  });
  const handleMouseLeave = () => {
    table.store.commit("setHoverRow", null);
    if (table.hoverState)
      table.hoverState = null;
  };
  const handleHeaderFooterMousewheel = (event2, data) => {
    const { pixelX, pixelY } = data;
    if (Math.abs(pixelX) >= Math.abs(pixelY)) {
      table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
    }
  };
  const shouldUpdateHeight = computed(() => {
    return props2.height || props2.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
  });
  const doLayout = () => {
    if (shouldUpdateHeight.value) {
      layout.updateElsHeight();
    }
    layout.updateColumnsWidth();
    syncPostion();
  };
  onMounted(() => {
    setScrollClass("is-scrolling-left");
    bindEvents();
    store.updateColumns();
    doLayout();
    resizeState.value = {
      width: table.vnode.el.offsetWidth,
      height: table.vnode.el.offsetHeight
    };
    store.states.columns.value.forEach((column) => {
      if (column.filteredValue && column.filteredValue.length) {
        table.store.commit("filterChange", {
          column,
          values: column.filteredValue,
          silent: true
        });
      }
    });
    table.$ready = true;
  });
  const setScrollClassByEl = (el, className) => {
    if (!el)
      return;
    const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
    classList.push(layout.scrollX.value ? className : "is-scrolling-none");
    el.className = classList.join(" ");
  };
  const setScrollClass = (className) => {
    const { bodyWrapper } = table.refs;
    setScrollClassByEl(bodyWrapper, className);
  };
  const syncPostion = throttle_1(function() {
    if (!table.refs.bodyWrapper)
      return;
    const {
      scrollLeft,
      scrollTop,
      offsetWidth,
      scrollWidth
    } = table.refs.bodyWrapper;
    const {
      headerWrapper,
      footerWrapper,
      fixedBodyWrapper,
      rightFixedBodyWrapper
    } = table.refs;
    if (headerWrapper)
      headerWrapper.scrollLeft = scrollLeft;
    if (footerWrapper)
      footerWrapper.scrollLeft = scrollLeft;
    if (fixedBodyWrapper)
      fixedBodyWrapper.scrollTop = scrollTop;
    if (rightFixedBodyWrapper)
      rightFixedBodyWrapper.scrollTop = scrollTop;
    const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
    if (scrollLeft >= maxScrollLeftPosition) {
      setScrollClass("is-scrolling-right");
    } else if (scrollLeft === 0) {
      setScrollClass("is-scrolling-left");
    } else {
      setScrollClass("is-scrolling-middle");
    }
  }, 10);
  const bindEvents = () => {
    window.addEventListener("resize", doLayout);
    table.refs.bodyWrapper.addEventListener("scroll", syncPostion, {
      passive: true
    });
    if (props2.fit) {
      addResizeListener(table.vnode.el, resizeListener);
    }
  };
  onUnmounted(() => {
    unbindEvents();
  });
  const unbindEvents = () => {
    var _a;
    (_a = table.refs.bodyWrapper) == null ? void 0 : _a.removeEventListener("scroll", syncPostion, true);
    window.removeEventListener("resize", doLayout);
    if (props2.fit) {
      removeResizeListener(table.vnode.el, resizeListener);
    }
  };
  const resizeListener = () => {
    if (!table.$ready)
      return;
    let shouldUpdateLayout = false;
    const el = table.vnode.el;
    const { width: oldWidth, height: oldHeight } = resizeState.value;
    const width2 = el.offsetWidth;
    if (oldWidth !== width2) {
      shouldUpdateLayout = true;
    }
    const height = el.offsetHeight;
    if ((props2.height || shouldUpdateHeight.value) && oldHeight !== height) {
      shouldUpdateLayout = true;
    }
    if (shouldUpdateLayout) {
      resizeState.value = {
        width: width2,
        height
      };
      doLayout();
    }
  };
  const tableSize = computed(() => {
    return props2.size || $ELEMENT2.size;
  });
  const bodyWidth = computed(() => {
    const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout;
    return bodyWidth_.value ? bodyWidth_.value - (scrollY.value ? gutterWidth : 0) + "px" : "";
  });
  const bodyHeight = computed(() => {
    const headerHeight = layout.headerHeight.value || 0;
    const bodyHeight2 = layout.bodyHeight.value;
    const footerHeight = layout.footerHeight.value || 0;
    if (props2.height) {
      return {
        height: bodyHeight2 ? bodyHeight2 + "px" : ""
      };
    } else if (props2.maxHeight) {
      const maxHeight = parseHeight(props2.maxHeight);
      if (typeof maxHeight === "number") {
        return {
          "max-height": maxHeight - footerHeight - (props2.showHeader ? headerHeight : 0) + "px"
        };
      }
    }
    return {};
  });
  const emptyBlockStyle = computed(() => {
    if (props2.data && props2.data.length)
      return null;
    let height = "100%";
    if (layout.appendHeight.value) {
      height = `calc(100% - ${layout.appendHeight.value}px)`;
    }
    return {
      width: bodyWidth.value,
      height
    };
  });
  const handleFixedMousewheel = (event2, data) => {
    const bodyWrapper = table.refs.bodyWrapper;
    if (Math.abs(data.spinY) > 0) {
      const currentScrollTop = bodyWrapper.scrollTop;
      if (data.pixelY < 0 && currentScrollTop !== 0) {
        event2.preventDefault();
      }
      if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
        event2.preventDefault();
      }
      bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
    } else {
      bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
    }
  };
  const fixedHeight = computed(() => {
    if (props2.maxHeight) {
      if (props2.showSummary) {
        return {
          bottom: 0
        };
      }
      return {
        bottom: layout.scrollX.value && props2.data.length ? layout.gutterWidth + "px" : ""
      };
    } else {
      if (props2.showSummary) {
        return {
          height: layout.tableHeight.value ? layout.tableHeight.value + "px" : ""
        };
      }
      return {
        height: layout.viewportHeight.value ? layout.viewportHeight.value + "px" : ""
      };
    }
  });
  const fixedBodyHeight = computed(() => {
    if (props2.height) {
      return {
        height: layout.fixedBodyHeight.value ? layout.fixedBodyHeight.value + "px" : ""
      };
    } else if (props2.maxHeight) {
      let maxHeight = parseHeight(props2.maxHeight);
      if (typeof maxHeight === "number") {
        maxHeight = layout.scrollX.value ? maxHeight - layout.gutterWidth : maxHeight;
        if (props2.showHeader) {
          maxHeight -= layout.headerHeight.value;
        }
        maxHeight -= layout.footerHeight.value;
        return {
          "max-height": maxHeight + "px"
        };
      }
    }
    return {};
  });
  return {
    isHidden,
    renderExpanded,
    setDragVisible,
    isGroup,
    handleMouseLeave,
    handleHeaderFooterMousewheel,
    tableSize,
    bodyHeight,
    emptyBlockStyle,
    handleFixedMousewheel,
    fixedHeight,
    fixedBodyHeight,
    resizeProxyVisible,
    bodyWidth,
    resizeState,
    doLayout
  };
}
var defaultProps$1 = {
  data: {
    type: Array,
    default: () => {
      return [];
    }
  },
  size: String,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: true
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: true
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: true
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => {
      return {
        hasChildren: "hasChildren",
        children: "children"
      };
    }
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  }
};
let tableIdSeed = 1;
var script$1$6 = defineComponent({
  name: "ElTable",
  directives: {
    Mousewheel: Mousewheel$1
  },
  components: {
    TableHeader,
    TableBody,
    TableFooter
  },
  props: defaultProps$1,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(props2) {
    const { t } = useLocaleInject();
    let table = getCurrentInstance();
    const store = createStore(table, props2);
    table.store = store;
    const layout = new TableLayout({
      store: table.store,
      table,
      fit: props2.fit,
      showHeader: props2.showHeader
    });
    table.layout = layout;
    const isEmpty2 = computed(() => (store.states.data.value || []).length === 0);
    const {
      setCurrentRow,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      sort: sort2
    } = useUtils$1(store);
    const {
      isHidden,
      renderExpanded,
      setDragVisible,
      isGroup,
      handleMouseLeave,
      handleHeaderFooterMousewheel,
      tableSize,
      bodyHeight,
      emptyBlockStyle,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      resizeProxyVisible,
      bodyWidth,
      resizeState,
      doLayout
    } = useStyle$2(props2, layout, store, table);
    const debouncedUpdateLayout = debounce_1(doLayout, 50);
    const tableId = "el-table_" + tableIdSeed++;
    table.tableId = tableId;
    table.state = {
      isGroup,
      resizeState,
      doLayout,
      debouncedUpdateLayout
    };
    return {
      layout,
      store,
      handleHeaderFooterMousewheel,
      handleMouseLeave,
      tableId,
      tableSize,
      isHidden,
      isEmpty: isEmpty2,
      renderExpanded,
      resizeProxyVisible,
      resizeState,
      isGroup,
      bodyWidth,
      bodyHeight,
      emptyBlockStyle,
      debouncedUpdateLayout,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      setCurrentRow,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      doLayout,
      sort: sort2,
      t,
      setDragVisible,
      context: table
    };
  }
});
const _hoisted_1$1$4 = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
const _hoisted_2$1$3 = {
  key: 0,
  ref: "headerWrapper",
  class: "el-table__header-wrapper"
};
const _hoisted_3$1$3 = { class: "el-table__empty-text" };
const _hoisted_4$1$1 = {
  key: 1,
  ref: "appendWrapper",
  class: "el-table__append-wrapper"
};
const _hoisted_5$1$1 = {
  key: 1,
  ref: "footerWrapper",
  class: "el-table__footer-wrapper"
};
const _hoisted_6$1$1 = {
  key: 0,
  ref: "fixedHeaderWrapper",
  class: "el-table__fixed-header-wrapper"
};
const _hoisted_7$c = {
  key: 1,
  ref: "fixedFooterWrapper",
  class: "el-table__fixed-footer-wrapper"
};
const _hoisted_8$b = {
  key: 0,
  ref: "rightFixedHeaderWrapper",
  class: "el-table__fixed-header-wrapper"
};
const _hoisted_9$b = {
  key: 1,
  ref: "rightFixedFooterWrapper",
  class: "el-table__fixed-footer-wrapper"
};
const _hoisted_10$8 = {
  ref: "resizeProxy",
  class: "el-table__column-resize-proxy"
};
function render$1$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_table_header = resolveComponent("table-header");
  const _component_table_body = resolveComponent("table-body");
  const _component_table_footer = resolveComponent("table-footer");
  const _directive_mousewheel = resolveDirective("mousewheel");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      {
        "el-table--fit": _ctx.fit,
        "el-table--striped": _ctx.stripe,
        "el-table--border": _ctx.border || _ctx.isGroup,
        "el-table--hidden": _ctx.isHidden,
        "el-table--group": _ctx.isGroup,
        "el-table--fluid-height": _ctx.maxHeight,
        "el-table--scrollable-x": _ctx.layout.scrollX.value,
        "el-table--scrollable-y": _ctx.layout.scrollY.value,
        "el-table--enable-row-hover": !_ctx.store.states.isComplex.value,
        "el-table--enable-row-transition": (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100
      },
      _ctx.tableSize ? `el-table--${_ctx.tableSize}` : "",
      _ctx.className,
      "el-table"
    ]),
    style: normalizeStyle(_ctx.style),
    onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.handleMouseLeave())
  }, [
    createElementVNode("div", _hoisted_1$1$4, [
      renderSlot(_ctx.$slots, "default")
    ], 512),
    _ctx.showHeader ? withDirectives((openBlock(), createElementBlock("div", _hoisted_2$1$3, [
      createVNode(_component_table_header, {
        ref: "tableHeader",
        border: _ctx.border,
        "default-sort": _ctx.defaultSort,
        store: _ctx.store,
        style: normalizeStyle({
          width: _ctx.layout.bodyWidth.value ? _ctx.layout.bodyWidth.value + "px" : ""
        }),
        onSetDragVisible: _ctx.setDragVisible
      }, null, 8, ["border", "default-sort", "store", "style", "onSetDragVisible"])
    ], 512)), [
      [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
    ]) : createCommentVNode("v-if", true),
    createElementVNode("div", {
      ref: "bodyWrapper",
      style: normalizeStyle([_ctx.bodyHeight]),
      class: "el-table__body-wrapper"
    }, [
      createVNode(_component_table_body, {
        context: _ctx.context,
        highlight: _ctx.highlightCurrentRow,
        "row-class-name": _ctx.rowClassName,
        "tooltip-effect": _ctx.tooltipEffect,
        "row-style": _ctx.rowStyle,
        store: _ctx.store,
        stripe: _ctx.stripe,
        style: normalizeStyle({
          width: _ctx.bodyWidth
        })
      }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe", "style"]),
      _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "emptyBlock",
        style: normalizeStyle(_ctx.emptyBlockStyle),
        class: "el-table__empty-block"
      }, [
        createElementVNode("span", _hoisted_3$1$3, [
          renderSlot(_ctx.$slots, "empty", {}, () => [
            createTextVNode(toDisplayString(_ctx.emptyText || _ctx.t("el.table.emptyText")), 1)
          ])
        ])
      ], 4)) : createCommentVNode("v-if", true),
      _ctx.$slots.append ? (openBlock(), createElementBlock("div", _hoisted_4$1$1, [
        renderSlot(_ctx.$slots, "append")
      ], 512)) : createCommentVNode("v-if", true)
    ], 4),
    _ctx.showSummary ? withDirectives((openBlock(), createElementBlock("div", _hoisted_5$1$1, [
      createVNode(_component_table_footer, {
        border: _ctx.border,
        "default-sort": _ctx.defaultSort,
        store: _ctx.store,
        style: normalizeStyle({
          width: _ctx.layout.bodyWidth.value ? _ctx.layout.bodyWidth.value + "px" : ""
        }),
        "sum-text": _ctx.sumText || _ctx.t("el.table.sumText"),
        "summary-method": _ctx.summaryMethod
      }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])
    ], 512)), [
      [vShow, !_ctx.isEmpty],
      [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
    ]) : createCommentVNode("v-if", true),
    _ctx.store.states.fixedColumns.value.length > 0 ? withDirectives((openBlock(), createElementBlock("div", {
      key: 2,
      ref: "fixedWrapper",
      style: normalizeStyle([
        {
          width: _ctx.layout.fixedWidth.value ? _ctx.layout.fixedWidth.value + "px" : ""
        },
        _ctx.fixedHeight
      ]),
      class: "el-table__fixed"
    }, [
      _ctx.showHeader ? (openBlock(), createElementBlock("div", _hoisted_6$1$1, [
        createVNode(_component_table_header, {
          ref: "fixedTableHeader",
          border: _ctx.border,
          store: _ctx.store,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "left",
          onSetDragVisible: _ctx.setDragVisible
        }, null, 8, ["border", "store", "style", "onSetDragVisible"])
      ], 512)) : createCommentVNode("v-if", true),
      createElementVNode("div", {
        ref: "fixedBodyWrapper",
        style: normalizeStyle([
          {
            top: _ctx.layout.headerHeight.value + "px"
          },
          _ctx.fixedBodyHeight
        ]),
        class: "el-table__fixed-body-wrapper"
      }, [
        createVNode(_component_table_body, {
          highlight: _ctx.highlightCurrentRow,
          "row-class-name": _ctx.rowClassName,
          "tooltip-effect": _ctx.tooltipEffect,
          "row-style": _ctx.rowStyle,
          store: _ctx.store,
          stripe: _ctx.stripe,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "left"
        }, null, 8, ["highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe", "style"]),
        _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle({ height: _ctx.layout.appendHeight.value + "px" }),
          class: "el-table__append-gutter"
        }, null, 4)) : createCommentVNode("v-if", true)
      ], 4),
      _ctx.showSummary ? withDirectives((openBlock(), createElementBlock("div", _hoisted_7$c, [
        createVNode(_component_table_footer, {
          border: _ctx.border,
          store: _ctx.store,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          "sum-text": _ctx.sumText || _ctx.t("el.table.sumText"),
          "summary-method": _ctx.summaryMethod,
          fixed: "left"
        }, null, 8, ["border", "store", "style", "sum-text", "summary-method"])
      ], 512)), [
        [vShow, !_ctx.isEmpty]
      ]) : createCommentVNode("v-if", true)
    ], 4)), [
      [_directive_mousewheel, _ctx.handleFixedMousewheel]
    ]) : createCommentVNode("v-if", true),
    _ctx.store.states.rightFixedColumns.value.length > 0 ? withDirectives((openBlock(), createElementBlock("div", {
      key: 3,
      ref: "rightFixedWrapper",
      style: normalizeStyle([
        {
          width: _ctx.layout.rightFixedWidth.value ? _ctx.layout.rightFixedWidth.value + "px" : "",
          right: _ctx.layout.scrollY.value ? (_ctx.border ? _ctx.layout.gutterWidth : _ctx.layout.gutterWidth || 0) + "px" : ""
        },
        _ctx.fixedHeight
      ]),
      class: "el-table__fixed-right"
    }, [
      _ctx.showHeader ? (openBlock(), createElementBlock("div", _hoisted_8$b, [
        createVNode(_component_table_header, {
          ref: "rightFixedTableHeader",
          border: _ctx.border,
          store: _ctx.store,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "right",
          onSetDragVisible: _ctx.setDragVisible
        }, null, 8, ["border", "store", "style", "onSetDragVisible"])
      ], 512)) : createCommentVNode("v-if", true),
      createElementVNode("div", {
        ref: "rightFixedBodyWrapper",
        style: normalizeStyle([{ top: _ctx.layout.headerHeight.value + "px" }, _ctx.fixedBodyHeight]),
        class: "el-table__fixed-body-wrapper"
      }, [
        createVNode(_component_table_body, {
          highlight: _ctx.highlightCurrentRow,
          "row-class-name": _ctx.rowClassName,
          "tooltip-effect": _ctx.tooltipEffect,
          "row-style": _ctx.rowStyle,
          store: _ctx.store,
          stripe: _ctx.stripe,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          fixed: "right"
        }, null, 8, ["highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe", "style"]),
        _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle({ height: _ctx.layout.appendHeight.value + "px" }),
          class: "el-table__append-gutter"
        }, null, 4)) : createCommentVNode("v-if", true)
      ], 4),
      _ctx.showSummary ? withDirectives((openBlock(), createElementBlock("div", _hoisted_9$b, [
        createVNode(_component_table_footer, {
          border: _ctx.border,
          store: _ctx.store,
          style: normalizeStyle({
            width: _ctx.bodyWidth
          }),
          "sum-text": _ctx.sumText || _ctx.t("el.table.sumText"),
          "summary-method": _ctx.summaryMethod,
          fixed: "right"
        }, null, 8, ["border", "store", "style", "sum-text", "summary-method"])
      ], 512)), [
        [vShow, !_ctx.isEmpty]
      ]) : createCommentVNode("v-if", true)
    ], 4)), [
      [_directive_mousewheel, _ctx.handleFixedMousewheel]
    ]) : createCommentVNode("v-if", true),
    _ctx.store.states.rightFixedColumns.value.length > 0 ? (openBlock(), createElementBlock("div", {
      key: 4,
      ref: "rightFixedPatch",
      style: normalizeStyle({
        width: _ctx.layout.scrollY.value ? _ctx.layout.gutterWidth + "px" : "0",
        height: _ctx.layout.headerHeight.value + "px"
      }),
      class: "el-table__fixed-right-patch"
    }, null, 4)) : createCommentVNode("v-if", true),
    withDirectives(createElementVNode("div", _hoisted_10$8, null, 512), [
      [vShow, _ctx.resizeProxyVisible]
    ])
  ], 38);
}
script$1$6.render = render$1$5;
script$1$6.__file = "packages/components/table/src/table.vue";
const cellStarts = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: "",
    className: "el-table-column--selection"
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
};
const cellForced = {
  selection: {
    renderHeader: function({ store }) {
      function isDisabled() {
        return store.states.data.value && store.states.data.value.length === 0;
      }
      return h(_Checkbox, {
        disabled: isDisabled(),
        indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
        "onUpdate:modelValue": store.toggleAllSelection,
        modelValue: store.states.isAllSelected.value
      });
    },
    renderCell: function({
      row,
      column,
      store,
      $index
    }) {
      return h(_Checkbox, {
        disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
        onChange: () => {
          store.commit("rowSelectedChanged", row);
        },
        onClick: (event2) => event2.stopPropagation(),
        modelValue: store.isSelected(row)
      });
    },
    sortable: false,
    resizable: false
  },
  index: {
    renderHeader: function({ column }) {
      return column.label || "#";
    },
    renderCell: function({
      column,
      $index
    }) {
      let i2 = $index + 1;
      const index2 = column.index;
      if (typeof index2 === "number") {
        i2 = $index + index2;
      } else if (typeof index2 === "function") {
        i2 = index2($index);
      }
      return h("div", {}, [i2]);
    },
    sortable: false
  },
  expand: {
    renderHeader: function({ column }) {
      return column.label || "";
    },
    renderCell: function({ row, store }) {
      const classes = ["el-table__expand-icon"];
      if (store.states.expandRows.value.indexOf(row) > -1) {
        classes.push("el-table__expand-icon--expanded");
      }
      const callback = function(e) {
        e.stopPropagation();
        store.toggleRowExpansion(row);
      };
      return h("div", {
        class: classes,
        onClick: callback
      }, [
        h("i", {
          class: "el-icon el-icon-arrow-right"
        })
      ]);
    },
    sortable: false,
    resizable: false,
    className: "el-table__expand-column"
  }
};
function defaultRenderCell({
  row,
  column,
  $index
}) {
  var _a;
  const property = column.property;
  const value2 = property && getPropByPath(row, property, false).v;
  if (column && column.formatter) {
    return column.formatter(row, column, value2, $index);
  }
  return ((_a = value2 == null ? void 0 : value2.toString) == null ? void 0 : _a.call(value2)) || "";
}
function treeCellPrefix({
  row,
  treeNode,
  store
}) {
  if (!treeNode)
    return null;
  const ele = [];
  const callback = function(e) {
    e.stopPropagation();
    store.loadOrToggle(row);
  };
  if (treeNode.indent) {
    ele.push(h("span", {
      class: "el-table__indent",
      style: { "padding-left": treeNode.indent + "px" }
    }));
  }
  if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
    const expandClasses = [
      "el-table__expand-icon",
      treeNode.expanded ? "el-table__expand-icon--expanded" : ""
    ];
    let iconClasses = ["el-icon-arrow-right"];
    if (treeNode.loading) {
      iconClasses = ["el-icon-loading"];
    }
    ele.push(h("div", {
      class: expandClasses,
      onClick: callback
    }, [
      h("i", {
        class: iconClasses
      })
    ]));
  } else {
    ele.push(h("span", {
      class: "el-table__placeholder"
    }));
  }
  return ele;
}
function useWatcher$1(owner, props_) {
  const instance = getCurrentInstance();
  const registerComplexWatchers = () => {
    const props2 = ["fixed"];
    const aliases = {
      realWidth: "width",
      realMinWidth: "minWidth"
    };
    const allAliases = props2.reduce((prev, cur) => {
      prev[cur] = cur;
      return prev;
    }, aliases);
    Object.keys(allAliases).forEach((key) => {
      const columnKey = aliases[key];
      if (hasOwn(props_, columnKey)) {
        watch(() => props_[columnKey], (newVal) => {
          let value2 = newVal;
          if (columnKey === "width" && key === "realWidth") {
            value2 = parseWidth(newVal);
          }
          if (columnKey === "minWidth" && key === "realMinWidth") {
            value2 = parseMinWidth(newVal);
          }
          instance.columnConfig.value[columnKey] = value2;
          instance.columnConfig.value[key] = value2;
          const updateColumns = columnKey === "fixed";
          owner.value.store.scheduleLayout(updateColumns);
        });
      }
    });
  };
  const registerNormalWatchers = () => {
    const props2 = [
      "label",
      "filters",
      "filterMultiple",
      "sortable",
      "index",
      "formatter",
      "className",
      "labelClassName",
      "showOverflowTooltip"
    ];
    const aliases = {
      property: "prop",
      align: "realAlign",
      headerAlign: "realHeaderAlign"
    };
    const allAliases = props2.reduce((prev, cur) => {
      prev[cur] = cur;
      return prev;
    }, aliases);
    Object.keys(allAliases).forEach((key) => {
      const columnKey = aliases[key];
      if (hasOwn(props_, columnKey)) {
        watch(() => props_[columnKey], (newVal) => {
          instance.columnConfig.value[key] = newVal;
        });
      }
    });
  };
  return {
    registerComplexWatchers,
    registerNormalWatchers
  };
}
function useRender$1(props2, slots, owner) {
  const instance = getCurrentInstance();
  const columnId = ref("");
  const isSubColumn = ref(false);
  const realAlign = ref();
  const realHeaderAlign = ref();
  watchEffect(() => {
    realAlign.value = !!props2.align ? "is-" + props2.align : null;
    realAlign.value;
  });
  watchEffect(() => {
    realHeaderAlign.value = !!props2.headerAlign ? "is-" + props2.headerAlign : realAlign.value;
    realHeaderAlign.value;
  });
  const columnOrTableParent = computed(() => {
    let parent2 = instance.vnode.vParent || instance.parent;
    while (parent2 && !parent2.tableId && !parent2.columnId) {
      parent2 = parent2.vnode.vParent || parent2.parent;
    }
    return parent2;
  });
  const realWidth = ref(parseWidth(props2.width));
  const realMinWidth = ref(parseMinWidth(props2.minWidth));
  const setColumnWidth = (column) => {
    if (realWidth.value)
      column.width = realWidth.value;
    if (realMinWidth.value) {
      column.minWidth = realMinWidth.value;
    }
    if (!column.minWidth) {
      column.minWidth = 80;
    }
    column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
    return column;
  };
  const setColumnForcedProps = (column) => {
    const type2 = column.type;
    const source2 = cellForced[type2] || {};
    Object.keys(source2).forEach((prop) => {
      const value2 = source2[prop];
      if (value2 !== void 0) {
        column[prop] = prop === "className" ? `${column[prop]} ${value2}` : value2;
      }
    });
    return column;
  };
  const checkSubColumn = (children) => {
    if (children instanceof Array) {
      children.forEach((child) => check(child));
    } else {
      check(children);
    }
    function check(item) {
      var _a;
      if (((_a = item == null ? void 0 : item.type) == null ? void 0 : _a.name) === "ElTableColumn") {
        item.vParent = instance;
      }
    }
  };
  const setColumnRenders = (column) => {
    if (props2.renderHeader) {
      console.warn("[Element Warn][TableColumn]Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.");
    } else if (column.type !== "selection") {
      column.renderHeader = (scope) => {
        instance.columnConfig.value["label"];
        const renderHeader = slots.header;
        return renderHeader ? renderHeader(scope) : column.label;
      };
    }
    let originRenderCell = column.renderCell;
    if (column.type === "expand") {
      column.renderCell = (data) => h("div", {
        class: "cell"
      }, [originRenderCell(data)]);
      owner.value.renderExpanded = (data) => {
        return slots.default ? slots.default(data) : slots.default;
      };
    } else {
      originRenderCell = originRenderCell || defaultRenderCell;
      column.renderCell = (data) => {
        let children = null;
        if (slots.default) {
          children = slots.default(data);
        } else {
          children = originRenderCell(data);
        }
        const prefix = treeCellPrefix(data);
        const props22 = {
          class: "cell",
          style: {}
        };
        if (column.showOverflowTooltip) {
          props22.class += " el-tooltip";
          props22.style = {
            width: (data.column.realWidth || Number(data.column.width)) - 1 + "px"
          };
        }
        checkSubColumn(children);
        return h("div", props22, [prefix, children]);
      };
    }
    return column;
  };
  const getPropsData = (...propsKey) => {
    return propsKey.reduce((prev, cur) => {
      if (Array.isArray(cur)) {
        cur.forEach((key) => {
          prev[key] = props2[key];
        });
      }
      return prev;
    }, {});
  };
  const getColumnElIndex = (children, child) => {
    return [].indexOf.call(children, child);
  };
  return {
    columnId,
    realAlign,
    isSubColumn,
    realHeaderAlign,
    columnOrTableParent,
    setColumnWidth,
    setColumnForcedProps,
    setColumnRenders,
    getPropsData,
    getColumnElIndex
  };
}
var defaultProps$2 = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: false
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: true
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showTooltipWhenOverflow: Boolean,
  showOverflowTooltip: Boolean,
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: true
  },
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => {
      return ["ascending", "descending", null];
    },
    validator: (val) => {
      return val.every((order2) => ["ascending", "descending", null].indexOf(order2) > -1);
    }
  }
};
var __defProp$5$1 = Object.defineProperty;
var __defProps$2$1 = Object.defineProperties;
var __getOwnPropDescs$2$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$5$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$5$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5$1 = (obj, key, value2) => key in obj ? __defProp$5$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$5$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5$1.call(b, prop))
      __defNormalProp$5$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$5$1)
    for (var prop of __getOwnPropSymbols$5$1(b)) {
      if (__propIsEnum$5$1.call(b, prop))
        __defNormalProp$5$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2$1 = (a, b) => __defProps$2$1(a, __getOwnPropDescs$2$1(b));
let columnIdSeed = 1;
var ElTableColumn = defineComponent({
  name: "ElTableColumn",
  components: {
    ElCheckbox: _Checkbox
  },
  props: defaultProps$2,
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const columnConfig = ref({});
    const owner = computed(() => {
      let parent22 = instance.parent;
      while (parent22 && !parent22.tableId) {
        parent22 = parent22.parent;
      }
      return parent22;
    });
    const { registerNormalWatchers, registerComplexWatchers } = useWatcher$1(owner, props2);
    const {
      columnId,
      isSubColumn,
      realHeaderAlign,
      columnOrTableParent,
      setColumnWidth,
      setColumnForcedProps,
      setColumnRenders,
      getPropsData,
      getColumnElIndex,
      realAlign
    } = useRender$1(props2, slots, owner);
    const parent2 = columnOrTableParent.value;
    columnId.value = (parent2.tableId || parent2.columnId) + "_column_" + columnIdSeed++;
    onBeforeMount(() => {
      isSubColumn.value = owner.value !== parent2;
      const type2 = props2.type || "default";
      const sortable = props2.sortable === "" ? true : props2.sortable;
      const defaults2 = __spreadProps$2$1(__spreadValues$5$1({}, cellStarts[type2]), {
        id: columnId.value,
        type: type2,
        property: props2.prop || props2.property,
        align: realAlign,
        headerAlign: realHeaderAlign,
        showOverflowTooltip: props2.showOverflowTooltip || props2.showTooltipWhenOverflow,
        filterable: props2.filters || props2.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        isColumnGroup: false,
        filterOpened: false,
        sortable,
        index: props2.index,
        rawColumnKey: instance.vnode.key
      });
      const basicProps = [
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ];
      const sortProps = ["sortMethod", "sortBy", "sortOrders"];
      const selectProps = ["selectable", "reserveSelection"];
      const filterProps = [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement"
      ];
      let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
      column = mergeOptions(defaults2, column);
      const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
      column = chains(column);
      columnConfig.value = column;
      registerNormalWatchers();
      registerComplexWatchers();
    });
    onMounted(() => {
      var _a;
      const parent22 = columnOrTableParent.value;
      const children = isSubColumn.value ? parent22.vnode.el.children : (_a = parent22.refs.hiddenColumns) == null ? void 0 : _a.children;
      const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
      columnConfig.value.getColumnIndex = getColumnIndex;
      const columnIndex = getColumnIndex();
      columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent22.columnConfig.value : null);
    });
    onBeforeUnmount(() => {
      owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null);
    });
    instance.columnId = columnId.value;
    instance.columnConfig = columnConfig;
    return;
  },
  render() {
    var _a, _b, _c;
    let children = [];
    try {
      const renderDefault = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
        row: {},
        column: {},
        $index: -1
      });
      if (renderDefault instanceof Array) {
        for (const childNode of renderDefault) {
          if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn") {
            children.push(childNode);
          } else if (childNode.type === Fragment && childNode.children instanceof Array) {
            children.push(...childNode.children);
          }
        }
      }
    } catch (e) {
      children = [];
    }
    return h("div", children);
  }
});
script$1$6.install = (app) => {
  app.component(script$1$6.name, script$1$6);
  app.component(ElTableColumn.name, ElTableColumn);
};
script$1$6.TableColumn = ElTableColumn;
const _Table = script$1$6;
const ElTable = _Table;
var script$8 = defineComponent({
  name: "ElTabBar",
  directives: {
    Resize: Resize$1
  },
  props: {
    tabs: {
      type: Array,
      default: () => []
    }
  },
  setup(props2) {
    const rootTabs = inject("rootTabs");
    if (!rootTabs) {
      throw new Error(`ElTabBar must use with ElTabs`);
    }
    const instance = getCurrentInstance();
    const getBarStyle = () => {
      let style = {};
      let offset2 = 0;
      let tabSize = 0;
      const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
      const sizeDir = sizeName === "width" ? "x" : "y";
      props2.tabs.every((tab) => {
        var _a;
        let $el = (_a = instance.parent.refs) == null ? void 0 : _a[`tab-${tab.paneName}`];
        if (!$el) {
          return false;
        }
        if (!tab.active) {
          return true;
        } else {
          tabSize = $el[`client${capitalize(sizeName)}`];
          const position = sizeDir === "x" ? "left" : "top";
          offset2 = $el.getBoundingClientRect()[position] - $el.parentElement.getBoundingClientRect()[position];
          const tabStyles = window.getComputedStyle($el);
          if (sizeName === "width") {
            if (props2.tabs.length > 1) {
              tabSize -= parseFloat(tabStyles.paddingLeft) + parseFloat(tabStyles.paddingRight);
            }
            offset2 += parseFloat(tabStyles.paddingLeft);
          }
          return false;
        }
      });
      const transform = `translate${capitalize(sizeDir)}(${offset2}px)`;
      style[sizeName] = `${tabSize}px`;
      style.transform = transform;
      style.msTransform = transform;
      style.webkitTransform = transform;
      return style;
    };
    const barStyle = ref(getBarStyle());
    const update = () => {
      barStyle.value = getBarStyle();
    };
    watch(() => props2.tabs, () => {
      nextTick(() => {
        update();
      });
    });
    return {
      rootTabs,
      barStyle,
      update
    };
  }
});
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_resize = resolveDirective("resize");
  return withDirectives((openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-tabs__active-bar", `is-${_ctx.rootTabs.props.tabPosition}`]),
    style: normalizeStyle(_ctx.barStyle)
  }, null, 6)), [
    [_directive_resize, _ctx.update]
  ]);
}
script$8.render = render$8;
script$8.__file = "packages/components/tabs/src/tab-bar.vue";
var script$1$5 = defineComponent({
  name: "ElTabNav",
  components: {
    TabBar: script$8
  },
  props: {
    panes: {
      type: Array,
      default: () => []
    },
    currentName: {
      type: String,
      default: ""
    },
    editable: Boolean,
    onTabClick: {
      type: Function,
      default: NOOP
    },
    onTabRemove: {
      type: Function,
      default: NOOP
    },
    type: {
      type: String,
      default: ""
    },
    stretch: Boolean
  },
  setup() {
    const rootTabs = inject("rootTabs");
    if (!rootTabs) {
      throwError("[ElTabNav]", `ElTabNav must be nested inside ElTabs`);
    }
    const scrollable = ref(false);
    const navOffset = ref(0);
    const isFocus = ref(false);
    const focusable = ref(true);
    const navScroll$ = ref(null);
    const nav$ = ref(null);
    const el$ = ref(null);
    const sizeName = computed(() => {
      return ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
    });
    const navStyle = computed(() => {
      const dir = sizeName.value === "width" ? "X" : "Y";
      return {
        transform: `translate${dir}(-${navOffset.value}px)`
      };
    });
    const scrollPrev = () => {
      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
      const currentOffset = navOffset.value;
      if (!currentOffset)
        return;
      let newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
      navOffset.value = newOffset;
    };
    const scrollNext = () => {
      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
      const currentOffset = navOffset.value;
      if (navSize - currentOffset <= containerSize)
        return;
      let newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
      navOffset.value = newOffset;
    };
    const scrollToActiveTab = () => {
      if (!scrollable.value)
        return;
      const nav = nav$.value;
      const activeTab = el$.value.querySelector(".is-active");
      if (!activeTab)
        return;
      const navScroll = navScroll$.value;
      const isHorizontal2 = ["top", "bottom"].includes(rootTabs.props.tabPosition);
      const activeTabBounding = activeTab.getBoundingClientRect();
      const navScrollBounding = navScroll.getBoundingClientRect();
      const maxOffset = isHorizontal2 ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
      const currentOffset = navOffset.value;
      let newOffset = currentOffset;
      if (isHorizontal2) {
        if (activeTabBounding.left < navScrollBounding.left) {
          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
        }
        if (activeTabBounding.right > navScrollBounding.right) {
          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
        }
      } else {
        if (activeTabBounding.top < navScrollBounding.top) {
          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
        }
        if (activeTabBounding.bottom > navScrollBounding.bottom) {
          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
        }
      }
      newOffset = Math.max(newOffset, 0);
      navOffset.value = Math.min(newOffset, maxOffset);
    };
    const update = () => {
      if (!nav$.value)
        return;
      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
      const currentOffset = navOffset.value;
      if (containerSize < navSize) {
        const currentOffset2 = navOffset.value;
        scrollable.value = scrollable.value || {};
        scrollable.value.prev = currentOffset2;
        scrollable.value.next = currentOffset2 + containerSize < navSize;
        if (navSize - currentOffset2 < containerSize) {
          navOffset.value = navSize - containerSize;
        }
      } else {
        scrollable.value = false;
        if (currentOffset > 0) {
          navOffset.value = 0;
        }
      }
    };
    const changeTab = (e) => {
      const code = e.code;
      let nextIndex;
      let currentIndex, tabList;
      const { up, down, left: left2, right: right2 } = EVENT_CODE;
      if ([up, down, left2, right2].indexOf(code) !== -1) {
        tabList = e.currentTarget.querySelectorAll("[role=tab]");
        currentIndex = Array.prototype.indexOf.call(tabList, e.target);
      } else {
        return;
      }
      if (code === left2 || code === up) {
        if (currentIndex === 0) {
          nextIndex = tabList.length - 1;
        } else {
          nextIndex = currentIndex - 1;
        }
      } else {
        if (currentIndex < tabList.length - 1) {
          nextIndex = currentIndex + 1;
        } else {
          nextIndex = 0;
        }
      }
      tabList[nextIndex].focus();
      tabList[nextIndex].click();
      setFocus();
    };
    const setFocus = () => {
      if (focusable.value) {
        isFocus.value = true;
      }
    };
    const removeFocus = () => {
      isFocus.value = false;
    };
    const visibilityChangeHandler = () => {
      const visibility = document.visibilityState;
      if (visibility === "hidden") {
        focusable.value = false;
      } else if (visibility === "visible") {
        setTimeout(() => {
          focusable.value = true;
        }, 50);
      }
    };
    const windowBlurHandler = () => {
      focusable.value = false;
    };
    const windowFocusHandler = () => {
      setTimeout(() => {
        focusable.value = true;
      }, 50);
    };
    onUpdated(() => {
      update();
    });
    onMounted(() => {
      addResizeListener(el$.value, update);
      on$2(document, "visibilitychange", visibilityChangeHandler);
      on$2(window, "blur", windowBlurHandler);
      on$2(window, "focus", windowFocusHandler);
      setTimeout(() => {
        scrollToActiveTab();
      }, 0);
    });
    onBeforeUnmount(() => {
      if (el$.value) {
        removeResizeListener(el$.value, update);
      }
      off$2(document, "visibilitychange", visibilityChangeHandler);
      off$2(window, "blur", windowBlurHandler);
      off$2(window, "focus", windowFocusHandler);
    });
    return {
      rootTabs,
      scrollable,
      navOffset,
      isFocus,
      focusable,
      navScroll$,
      nav$,
      el$,
      sizeName,
      navStyle,
      scrollPrev,
      scrollNext,
      scrollToActiveTab,
      update,
      changeTab,
      setFocus,
      removeFocus,
      visibilityChangeHandler,
      windowBlurHandler,
      windowFocusHandler
    };
  },
  render() {
    const {
      type: type2,
      panes,
      editable,
      stretch,
      onTabClick,
      onTabRemove,
      navStyle,
      scrollable,
      scrollNext,
      scrollPrev,
      changeTab,
      setFocus,
      removeFocus,
      rootTabs,
      isFocus
    } = this;
    const scrollBtn = scrollable ? [
      h("span", {
        class: [
          "el-tabs__nav-prev",
          scrollable.prev ? "" : "is-disabled"
        ],
        onClick: scrollPrev
      }, [h("i", { class: "el-icon-arrow-left" })]),
      h("span", {
        class: [
          "el-tabs__nav-next",
          scrollable.next ? "" : "is-disabled"
        ],
        onClick: scrollNext
      }, [h("i", { class: "el-icon-arrow-right" })])
    ] : null;
    const tabs = panes.map((pane, index2) => {
      var _a, _b;
      let tabName = pane.props.name || pane.index || `${index2}`;
      const closable = pane.isClosable || editable;
      pane.index = `${index2}`;
      const btnClose = closable ? h("span", {
        class: "el-icon-close",
        onClick: (ev) => {
          onTabRemove(pane, ev);
        }
      }) : null;
      const tabLabelContent = ((_b = (_a = pane.instance.slots).label) == null ? void 0 : _b.call(_a)) || pane.props.label;
      const tabindex = pane.active ? 0 : -1;
      return h("div", {
        class: {
          "el-tabs__item": true,
          [`is-${rootTabs.props.tabPosition}`]: true,
          "is-active": pane.active,
          "is-disabled": pane.props.disabled,
          "is-closable": closable,
          "is-focus": isFocus
        },
        id: `tab-${tabName}`,
        key: `tab-${tabName}`,
        "aria-controls": `pane-${tabName}`,
        role: "tab",
        "aria-selected": pane.active,
        ref: `tab-${tabName}`,
        tabindex,
        onFocus: () => {
          setFocus();
        },
        onBlur: () => {
          removeFocus();
        },
        onClick: (ev) => {
          removeFocus();
          onTabClick(pane, tabName, ev);
        },
        onKeydown: (ev) => {
          if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
            onTabRemove(pane, ev);
          }
        }
      }, [tabLabelContent, btnClose]);
    });
    return h("div", {
      ref: "el$",
      class: [
        "el-tabs__nav-wrap",
        scrollable ? "is-scrollable" : "",
        `is-${rootTabs.props.tabPosition}`
      ]
    }, [
      scrollBtn,
      h("div", {
        class: "el-tabs__nav-scroll",
        ref: "navScroll$"
      }, [
        h("div", {
          class: [
            "el-tabs__nav",
            `is-${rootTabs.props.tabPosition}`,
            stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "is-stretch" : ""
          ],
          ref: "nav$",
          style: navStyle,
          role: "tablist",
          onKeydown: changeTab
        }, [
          !type2 ? h(script$8, {
            tabs: panes
          }) : null,
          tabs
        ])
      ])
    ]);
  }
});
script$1$5.__file = "packages/components/tabs/src/tab-nav.vue";
var Tabs = defineComponent({
  name: "ElTabs",
  components: { TabNav: script$1$5 },
  props: {
    type: {
      type: String,
      default: ""
    },
    activeName: {
      type: String,
      default: ""
    },
    closable: Boolean,
    addable: Boolean,
    modelValue: {
      type: String,
      default: ""
    },
    editable: Boolean,
    tabPosition: {
      type: String,
      default: "top"
    },
    beforeLeave: {
      type: Function,
      default: null
    },
    stretch: Boolean
  },
  emits: [
    "tab-click",
    "edit",
    "tab-remove",
    "tab-add",
    "input",
    "update:modelValue"
  ],
  setup(props2, ctx2) {
    const nav$ = ref(null);
    const currentName = ref(props2.modelValue || props2.activeName || "0");
    const panes = ref([]);
    const instance = getCurrentInstance();
    const paneStatesMap = {};
    provide("rootTabs", {
      props: props2,
      currentName
    });
    provide("updatePaneState", (pane) => {
      paneStatesMap[pane.uid] = pane;
    });
    watch(() => props2.activeName, (modelValue) => {
      setCurrentName(modelValue);
    });
    watch(() => props2.modelValue, (modelValue) => {
      setCurrentName(modelValue);
    });
    watch(currentName, () => {
      if (nav$.value) {
        nextTick(() => {
          nav$.value.$nextTick(() => {
            nav$.value.scrollToActiveTab();
          });
        });
      }
      setPaneInstances(true);
    });
    const getPaneInstanceFromSlot = (vnode, paneInstanceList = []) => {
      Array.from(vnode.children || []).forEach((node) => {
        let type2 = node.type;
        type2 = type2.name || type2;
        if (type2 === "ElTabPane" && node.component) {
          paneInstanceList.push(node.component);
        } else if (type2 === Fragment || type2 === "template") {
          getPaneInstanceFromSlot(node, paneInstanceList);
        }
      });
      return paneInstanceList;
    };
    const setPaneInstances = (isForceUpdate = false) => {
      if (ctx2.slots.default) {
        const children = instance.subTree.children;
        const content = Array.from(children).find(({ props: props22 }) => {
          return props22.class === "el-tabs__content";
        });
        if (!content)
          return;
        const paneInstanceList = getPaneInstanceFromSlot(content).map((paneComponent) => {
          return paneStatesMap[paneComponent.uid];
        });
        const panesChanged = !(paneInstanceList.length === panes.value.length && paneInstanceList.every((pane, index2) => pane.uid === panes.value[index2].uid));
        if (isForceUpdate || panesChanged) {
          panes.value = paneInstanceList;
        }
      } else if (panes.value.length !== 0) {
        panes.value = [];
      }
    };
    const changeCurrentName = (value2) => {
      currentName.value = value2;
      ctx2.emit("input", value2);
      ctx2.emit("update:modelValue", value2);
    };
    const setCurrentName = (value2) => {
      if (currentName.value === value2)
        return;
      const beforeLeave = props2.beforeLeave;
      const before = beforeLeave && beforeLeave(value2, currentName.value);
      if (before && isPromise(before)) {
        before.then(() => {
          var _a, _b;
          changeCurrentName(value2);
          (_b = (_a = nav$.value).removeFocus) == null ? void 0 : _b.call(_a);
        }, () => {
        });
      } else if (before !== false) {
        changeCurrentName(value2);
      }
    };
    const handleTabClick = (tab, tabName, event2) => {
      if (tab.props.disabled)
        return;
      setCurrentName(tabName);
      ctx2.emit("tab-click", tab, event2);
    };
    const handleTabRemove = (pane, ev) => {
      if (pane.props.disabled)
        return;
      ev.stopPropagation();
      ctx2.emit("edit", pane.props.name, "remove");
      ctx2.emit("tab-remove", pane.props.name);
    };
    const handleTabAdd = () => {
      ctx2.emit("edit", null, "add");
      ctx2.emit("tab-add");
    };
    onUpdated(() => {
      setPaneInstances();
    });
    onMounted(() => {
      setPaneInstances();
    });
    return {
      nav$,
      handleTabClick,
      handleTabRemove,
      handleTabAdd,
      currentName,
      panes
    };
  },
  render() {
    var _a;
    const {
      type: type2,
      handleTabClick,
      handleTabRemove,
      handleTabAdd,
      currentName,
      panes,
      editable,
      addable,
      tabPosition,
      stretch
    } = this;
    const newButton = editable || addable ? h("span", {
      class: "el-tabs__new-tab",
      tabindex: "0",
      onClick: handleTabAdd,
      onKeydown: (ev) => {
        if (ev.code === EVENT_CODE.enter) {
          handleTabAdd();
        }
      }
    }, [h("i", { class: "el-icon-plus" })]) : null;
    const header = h("div", {
      class: ["el-tabs__header", `is-${tabPosition}`]
    }, [
      newButton,
      h(script$1$5, {
        currentName,
        editable,
        type: type2,
        panes,
        stretch,
        ref: "nav$",
        onTabClick: handleTabClick,
        onTabRemove: handleTabRemove
      })
    ]);
    const panels = h("div", {
      class: "el-tabs__content"
    }, (_a = this.$slots) == null ? void 0 : _a.default());
    return h("div", {
      class: {
        "el-tabs": true,
        "el-tabs--card": type2 === "card",
        [`el-tabs--${tabPosition}`]: true,
        "el-tabs--border-card": type2 === "border-card"
      }
    }, tabPosition !== "bottom" ? [header, panels] : [panels, header]);
  }
});
var script$2$3 = defineComponent({
  name: "ElTabPane",
  props: {
    label: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    closable: Boolean,
    disabled: Boolean,
    lazy: Boolean
  },
  setup(props2) {
    const index2 = ref(null);
    const loaded = ref(false);
    const rootTabs = inject("rootTabs");
    const updatePaneState = inject("updatePaneState");
    if (!rootTabs || !updatePaneState) {
      throw new Error(`ElTabPane must use with ElTabs`);
    }
    const isClosable = computed(() => {
      return props2.closable || rootTabs.props.closable;
    });
    const active = computed(() => {
      const active2 = rootTabs.currentName.value === (props2.name || index2.value);
      if (active2) {
        loaded.value = true;
      }
      return active2;
    });
    const paneName = computed(() => {
      return props2.name || index2.value;
    });
    const shouldBeRender = computed(() => {
      return !props2.lazy || loaded.value || active.value;
    });
    const instance = getCurrentInstance();
    updatePaneState({
      uid: instance.uid,
      instance,
      props: props2,
      paneName,
      active,
      index: index2,
      isClosable
    });
    return {
      index: index2,
      loaded,
      isClosable,
      active,
      paneName,
      shouldBeRender
    };
  }
});
const _hoisted_1$y = ["id", "aria-hidden", "aria-labelledby"];
function render$1$4(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.shouldBeRender ? withDirectives((openBlock(), createElementBlock("div", {
    key: 0,
    id: `pane-${_ctx.paneName}`,
    class: "el-tab-pane",
    role: "tabpanel",
    "aria-hidden": !_ctx.active,
    "aria-labelledby": `tab-${_ctx.paneName}`
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 8, _hoisted_1$y)), [
    [vShow, _ctx.active]
  ]) : createCommentVNode("v-if", true);
}
script$2$3.render = render$1$4;
script$2$3.__file = "packages/components/tabs/src/tab-pane.vue";
Tabs.install = (app) => {
  app.component(Tabs.name, Tabs);
  app.component(script$2$3.name, script$2$3);
};
Tabs.TabPane = script$2$3;
const _Tabs = Tabs;
const ElTabs = _Tabs;
const { Option: ElOption } = _Select$1;
const parseTime = (time) => {
  const values = (time || "").split(":");
  if (values.length >= 2) {
    const hours = parseInt(values[0], 10);
    const minutes = parseInt(values[1], 10);
    return {
      hours,
      minutes
    };
  }
  return null;
};
const compareTime = (time1, time2) => {
  const value1 = parseTime(time1);
  const value2 = parseTime(time2);
  const minutes1 = value1.minutes + value1.hours * 60;
  const minutes2 = value2.minutes + value2.hours * 60;
  if (minutes1 === minutes2) {
    return 0;
  }
  return minutes1 > minutes2 ? 1 : -1;
};
const formatTime = (time) => {
  return (time.hours < 10 ? "0" + time.hours : time.hours) + ":" + (time.minutes < 10 ? "0" + time.minutes : time.minutes);
};
const nextTime = (time, step) => {
  const timeValue = parseTime(time);
  const stepValue = parseTime(step);
  const next = {
    hours: timeValue.hours,
    minutes: timeValue.minutes
  };
  next.minutes += stepValue.minutes;
  next.hours += stepValue.hours;
  next.hours += Math.floor(next.minutes / 60);
  next.minutes = next.minutes % 60;
  return formatTime(next);
};
var script$7 = defineComponent({
  name: "ElTimeSelect",
  components: { ElSelect: _Select$1, ElOption },
  model: {
    prop: "value",
    event: "change"
  },
  props: {
    modelValue: String,
    disabled: {
      type: Boolean,
      default: false
    },
    editable: {
      type: Boolean,
      default: true
    },
    clearable: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: "",
      validator: (value2) => !value2 || ["medium", "small", "mini"].indexOf(value2) !== -1
    },
    placeholder: {
      type: String,
      default: ""
    },
    start: {
      type: String,
      default: "09:00"
    },
    end: {
      type: String,
      default: "18:00"
    },
    step: {
      type: String,
      default: "00:30"
    },
    minTime: {
      type: String,
      default: ""
    },
    maxTime: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    prefixIcon: {
      type: String,
      default: "el-icon-time"
    },
    clearIcon: {
      type: String,
      default: "el-icon-circle-close"
    }
  },
  emits: ["change", "blur", "focus", "update:modelValue"],
  setup(props2) {
    const select = ref(null);
    const value2 = computed(() => props2.modelValue);
    const items = computed(() => {
      const result = [];
      if (props2.start && props2.end && props2.step) {
        let current = props2.start;
        while (compareTime(current, props2.end) <= 0) {
          result.push({
            value: current,
            disabled: compareTime(current, props2.minTime || "-1:-1") <= 0 || compareTime(current, props2.maxTime || "100:100") >= 0
          });
          current = nextTime(current, props2.step);
        }
      }
      return result;
    });
    const blur = () => {
      var _a, _b;
      (_b = (_a = select.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
    };
    const focus = () => {
      var _a, _b;
      (_b = (_a = select.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    };
    return {
      select,
      value: value2,
      items,
      blur,
      focus
    };
  }
});
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = resolveComponent("el-option");
  const _component_el_select = resolveComponent("el-select");
  return openBlock(), createBlock(_component_el_select, {
    ref: "select",
    "model-value": _ctx.value,
    disabled: _ctx.disabled,
    clearable: _ctx.clearable,
    "clear-icon": _ctx.clearIcon,
    size: _ctx.size,
    placeholder: _ctx.placeholder,
    "default-first-option": "",
    filterable: _ctx.editable,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = (event2) => _ctx.$emit("update:modelValue", event2)),
    onChange: _cache[1] || (_cache[1] = (event2) => _ctx.$emit("change", event2)),
    onBlur: _cache[2] || (_cache[2] = (event2) => _ctx.$emit("blur", event2)),
    onFocus: _cache[3] || (_cache[3] = (event2) => _ctx.$emit("focus", event2))
  }, {
    prefix: withCtx(() => [
      createElementVNode("i", {
        class: normalizeClass(`el-input__icon ${_ctx.prefixIcon}`)
      }, null, 2)
    ]),
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item) => {
        return openBlock(), createBlock(_component_el_option, {
          key: item.value,
          label: item.value,
          value: item.value,
          disabled: item.disabled
        }, null, 8, ["label", "value", "disabled"]);
      }), 128))
    ]),
    _: 1
  }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "placeholder", "filterable"]);
}
script$7.render = render$7;
script$7.__file = "packages/components/time-select/src/time-select.vue";
script$7.install = (app) => {
  app.component(script$7.name, script$7);
};
const _TimeSelect = script$7;
const ElTimeSelect = _TimeSelect;
var script$6 = defineComponent({
  name: "ElTimeline",
  setup(_, ctx2) {
    provide("timeline", ctx2);
    return () => {
      var _a, _b;
      return h("ul", {
        class: { "el-timeline": true }
      }, (_b = (_a = ctx2.slots).default) == null ? void 0 : _b.call(_a));
    };
  }
});
script$6.__file = "packages/components/timeline/src/workprogress.vue";
var script$1$4 = defineComponent({
  name: "ElTimelineItem",
  props: {
    timestamp: {
      type: String,
      default: ""
    },
    hideTimestamp: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: "bottom"
    },
    type: {
      type: String,
      default: ""
    },
    color: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      default: "normal"
    },
    icon: {
      type: String,
      default: ""
    }
  },
  setup() {
    inject("timeline");
  }
});
const _hoisted_1$x = { class: "el-timeline-item" };
const _hoisted_2$s = /* @__PURE__ */ createElementVNode("div", { class: "el-timeline-item__tail" }, null, -1);
const _hoisted_3$r = {
  key: 1,
  class: "el-timeline-item__dot"
};
const _hoisted_4$k = { class: "el-timeline-item__wrapper" };
const _hoisted_5$g = {
  key: 0,
  class: "el-timeline-item__timestamp is-top"
};
const _hoisted_6$e = { class: "el-timeline-item__content" };
const _hoisted_7$b = {
  key: 1,
  class: "el-timeline-item__timestamp is-bottom"
};
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", _hoisted_1$x, [
    _hoisted_2$s,
    !_ctx.$slots.dot ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["el-timeline-item__node", [
        `el-timeline-item__node--${_ctx.size || ""}`,
        `el-timeline-item__node--${_ctx.type || ""}`
      ]]),
      style: normalizeStyle({
        backgroundColor: _ctx.color
      })
    }, [
      _ctx.icon ? (openBlock(), createElementBlock("i", {
        key: 0,
        class: normalizeClass(["el-timeline-item__icon", _ctx.icon])
      }, null, 2)) : createCommentVNode("v-if", true)
    ], 6)) : createCommentVNode("v-if", true),
    _ctx.$slots.dot ? (openBlock(), createElementBlock("div", _hoisted_3$r, [
      renderSlot(_ctx.$slots, "dot")
    ])) : createCommentVNode("v-if", true),
    createElementVNode("div", _hoisted_4$k, [
      !_ctx.hideTimestamp && _ctx.placement === "top" ? (openBlock(), createElementBlock("div", _hoisted_5$g, toDisplayString(_ctx.timestamp), 1)) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_6$e, [
        renderSlot(_ctx.$slots, "default")
      ]),
      !_ctx.hideTimestamp && _ctx.placement === "bottom" ? (openBlock(), createElementBlock("div", _hoisted_7$b, toDisplayString(_ctx.timestamp), 1)) : createCommentVNode("v-if", true)
    ])
  ]);
}
script$1$4.render = render$6;
script$1$4.__file = "packages/components/timeline/src/item.vue";
script$6.install = (app) => {
  app.component(script$6.name, script$6);
  app.component(script$1$4.name, script$1$4);
};
script$6.TimelineItem = script$1$4;
const _Timeline = script$6;
const ElTimeline = _Timeline;
const CHECKED_CHANGE_EVENT = "checked-change";
const useCheckProps = {
  data: {
    type: Array,
    default() {
      return [];
    }
  },
  optionRender: Function,
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: Object,
  filterMethod: Function,
  defaultChecked: Array,
  props: Object
};
const useCheck = (props2, panelState) => {
  const { emit: emit2 } = getCurrentInstance();
  const labelProp = computed(() => props2.props.label || "label");
  const keyProp = computed(() => props2.props.key || "key");
  const disabledProp = computed(() => props2.props.disabled || "disabled");
  const filteredData = computed(() => {
    return props2.data.filter((item) => {
      if (typeof props2.filterMethod === "function") {
        return props2.filterMethod(panelState.query, item);
      } else {
        const label = item[labelProp.value] || item[keyProp.value].toString();
        return label.toLowerCase().includes(panelState.query.toLowerCase());
      }
    });
  });
  const checkableData = computed(() => {
    return filteredData.value.filter((item) => !item[disabledProp.value]);
  });
  const checkedSummary = computed(() => {
    const checkedLength = panelState.checked.length;
    const dataLength = props2.data.length;
    const { noChecked, hasChecked } = props2.format;
    if (noChecked && hasChecked) {
      return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength.toString()).replace(/\${total}/g, dataLength.toString()) : noChecked.replace(/\${total}/g, dataLength.toString());
    } else {
      return `${checkedLength}/${dataLength}`;
    }
  });
  const isIndeterminate = computed(() => {
    const checkedLength = panelState.checked.length;
    return checkedLength > 0 && checkedLength < checkableData.value.length;
  });
  const updateAllChecked = () => {
    const checkableDataKeys = checkableData.value.map((item) => item[keyProp.value]);
    panelState.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every((item) => panelState.checked.includes(item));
  };
  const handleAllCheckedChange = (value2) => {
    panelState.checked = value2 ? checkableData.value.map((item) => item[keyProp.value]) : [];
  };
  watch(() => panelState.checked, (val, oldVal) => {
    updateAllChecked();
    if (panelState.checkChangeByUser) {
      const movedKeys = val.concat(oldVal).filter((v) => !val.includes(v) || !oldVal.includes(v));
      emit2(CHECKED_CHANGE_EVENT, val, movedKeys);
    } else {
      emit2(CHECKED_CHANGE_EVENT, val);
      panelState.checkChangeByUser = true;
    }
  });
  watch(checkableData, () => {
    updateAllChecked();
  });
  watch(() => props2.data, () => {
    const checked = [];
    const filteredDataKeys = filteredData.value.map((item) => item[keyProp.value]);
    panelState.checked.forEach((item) => {
      if (filteredDataKeys.includes(item)) {
        checked.push(item);
      }
    });
    panelState.checkChangeByUser = false;
    panelState.checked = checked;
  });
  watch(() => props2.defaultChecked, (val, oldVal) => {
    if (oldVal && val.length === oldVal.length && val.every((item) => oldVal.includes(item)))
      return;
    const checked = [];
    const checkableDataKeys = checkableData.value.map((item) => item[keyProp.value]);
    val.forEach((item) => {
      if (checkableDataKeys.includes(item)) {
        checked.push(item);
      }
    });
    panelState.checkChangeByUser = false;
    panelState.checked = checked;
  }, {
    immediate: true
  });
  return {
    labelProp,
    keyProp,
    disabledProp,
    filteredData,
    checkableData,
    checkedSummary,
    isIndeterminate,
    updateAllChecked,
    handleAllCheckedChange
  };
};
var script$5 = defineComponent({
  name: "ElTransferPanel",
  components: {
    ElCheckboxGroup: ElCheckboxGroup$1,
    ElCheckbox,
    ElInput: ElInput$1,
    OptionContent: ({ option: option2 }) => option2
  },
  props: useCheckProps,
  emits: [CHECKED_CHANGE_EVENT],
  setup(props2, { slots }) {
    const { t } = useLocaleInject();
    const panelState = reactive({
      checked: [],
      allChecked: false,
      query: "",
      inputHover: false,
      checkChangeByUser: true
    });
    const {
      labelProp,
      keyProp,
      disabledProp,
      filteredData,
      checkedSummary,
      isIndeterminate,
      handleAllCheckedChange
    } = useCheck(props2, panelState);
    const hasNoMatch = computed(() => {
      return panelState.query.length > 0 && filteredData.value.length === 0;
    });
    const inputIcon = computed(() => {
      return panelState.query.length > 0 && panelState.inputHover ? "circle-close" : "search";
    });
    const hasFooter = computed(() => !!slots.default()[0].children.length);
    const clearQuery = () => {
      if (inputIcon.value === "circle-close") {
        panelState.query = "";
      }
    };
    const {
      checked,
      allChecked,
      query,
      inputHover,
      checkChangeByUser
    } = toRefs(panelState);
    return {
      labelProp,
      keyProp,
      disabledProp,
      filteredData,
      checkedSummary,
      isIndeterminate,
      handleAllCheckedChange,
      checked,
      allChecked,
      query,
      inputHover,
      checkChangeByUser,
      hasNoMatch,
      inputIcon,
      hasFooter,
      clearQuery,
      t
    };
  }
});
const _hoisted_1$w = { class: "el-transfer-panel" };
const _hoisted_2$r = { class: "el-transfer-panel__header" };
const _hoisted_3$q = {
  key: 0,
  class: "el-transfer-panel__footer"
};
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_input = resolveComponent("el-input");
  const _component_option_content = resolveComponent("option-content");
  const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
  return openBlock(), createElementBlock("div", _hoisted_1$w, [
    createElementVNode("p", _hoisted_2$r, [
      createVNode(_component_el_checkbox, {
        modelValue: _ctx.allChecked,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.allChecked = $event),
        indeterminate: _ctx.isIndeterminate,
        onChange: _ctx.handleAllCheckedChange
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.title) + " ", 1),
          createElementVNode("span", null, toDisplayString(_ctx.checkedSummary), 1)
        ]),
        _: 1
      }, 8, ["modelValue", "indeterminate", "onChange"])
    ]),
    createElementVNode("div", {
      class: normalizeClass(["el-transfer-panel__body", _ctx.hasFooter ? "is-with-footer" : ""])
    }, [
      _ctx.filterable ? (openBlock(), createBlock(_component_el_input, {
        key: 0,
        modelValue: _ctx.query,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.query = $event),
        class: "el-transfer-panel__filter",
        size: "small",
        placeholder: _ctx.placeholder,
        onMouseenter: _cache[3] || (_cache[3] = ($event) => _ctx.inputHover = true),
        onMouseleave: _cache[4] || (_cache[4] = ($event) => _ctx.inputHover = false)
      }, {
        prefix: withCtx(() => [
          createElementVNode("i", {
            class: normalizeClass(["el-input__icon", "el-icon-" + _ctx.inputIcon]),
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.clearQuery && _ctx.clearQuery(...args))
          }, null, 2)
        ]),
        _: 1
      }, 8, ["modelValue", "placeholder"])) : createCommentVNode("v-if", true),
      withDirectives(createVNode(_component_el_checkbox_group, {
        modelValue: _ctx.checked,
        "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.checked = $event),
        class: normalizeClass([{ "is-filterable": _ctx.filterable }, "el-transfer-panel__list"])
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filteredData, (item) => {
            return openBlock(), createBlock(_component_el_checkbox, {
              key: item[_ctx.keyProp],
              class: "el-transfer-panel__item",
              label: item[_ctx.keyProp],
              disabled: item[_ctx.disabledProp]
            }, {
              default: withCtx(() => [
                createVNode(_component_option_content, {
                  option: _ctx.optionRender(item)
                }, null, 8, ["option"])
              ]),
              _: 2
            }, 1032, ["label", "disabled"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["modelValue", "class"]), [
        [vShow, !_ctx.hasNoMatch && _ctx.data.length > 0]
      ]),
      withDirectives(createElementVNode("p", { class: "el-transfer-panel__empty" }, toDisplayString(_ctx.hasNoMatch ? _ctx.t("el.transfer.noMatch") : _ctx.t("el.transfer.noData")), 513), [
        [vShow, _ctx.hasNoMatch || _ctx.data.length === 0]
      ])
    ], 2),
    _ctx.hasFooter ? (openBlock(), createElementBlock("p", _hoisted_3$q, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("v-if", true)
  ]);
}
script$5.render = render$5;
script$5.__file = "packages/components/transfer/src/transfer-panel.vue";
const useComputedData = (props2) => {
  const propsKey = computed(() => props2.props.key);
  const dataObj = computed(() => {
    return props2.data.reduce((o, cur) => (o[cur[propsKey.value]] = cur) && o, {});
  });
  const sourceData = computed(() => {
    return props2.data.filter((item) => !props2.modelValue.includes(item[propsKey.value]));
  });
  const targetData = computed(() => {
    if (props2.targetOrder === "original") {
      return props2.data.filter((item) => props2.modelValue.includes(item[propsKey.value]));
    } else {
      return props2.modelValue.reduce((arr, cur) => {
        const val = dataObj.value[cur];
        if (val) {
          arr.push(val);
        }
        return arr;
      }, []);
    }
  });
  return {
    propsKey,
    sourceData,
    targetData
  };
};
const LEFT_CHECK_CHANGE_EVENT = "left-check-change";
const RIGHT_CHECK_CHANGE_EVENT = "right-check-change";
const useCheckedChange = (checkedState, emit2) => {
  const onSourceCheckedChange = (val, movedKeys) => {
    checkedState.leftChecked = val;
    if (movedKeys === void 0)
      return;
    emit2(LEFT_CHECK_CHANGE_EVENT, val, movedKeys);
  };
  const onTargetCheckedChange = (val, movedKeys) => {
    checkedState.rightChecked = val;
    if (movedKeys === void 0)
      return;
    emit2(RIGHT_CHECK_CHANGE_EVENT, val, movedKeys);
  };
  return {
    onSourceCheckedChange,
    onTargetCheckedChange
  };
};
const useMove = (props2, checkedState, propsKey, emit2) => {
  const _emit = (value2, type2, checked) => {
    emit2(UPDATE_MODEL_EVENT, value2);
    emit2(CHANGE_EVENT, value2, type2, checked);
  };
  const addToLeft = () => {
    const currentValue = props2.modelValue.slice();
    checkedState.rightChecked.forEach((item) => {
      const index2 = currentValue.indexOf(item);
      if (index2 > -1) {
        currentValue.splice(index2, 1);
      }
    });
    _emit(currentValue, "left", checkedState.rightChecked);
  };
  const addToRight = () => {
    let currentValue = props2.modelValue.slice();
    const itemsToBeMoved = props2.data.filter((item) => {
      const itemKey = item[propsKey.value];
      return checkedState.leftChecked.includes(itemKey) && !props2.modelValue.includes(itemKey);
    }).map((item) => item[propsKey.value]);
    currentValue = props2.targetOrder === "unshift" ? itemsToBeMoved.concat(currentValue) : currentValue.concat(itemsToBeMoved);
    _emit(currentValue, "right", checkedState.leftChecked);
  };
  return {
    addToLeft,
    addToRight
  };
};
var __defProp$5 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value2) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
var script$1$3 = defineComponent({
  name: "ElTransfer",
  components: {
    TransferPanel: script$5,
    ElButton: _Button
  },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    titles: {
      type: Array,
      default: () => []
    },
    buttonTexts: {
      type: Array,
      default: () => []
    },
    filterPlaceholder: {
      type: String,
      default: ""
    },
    filterMethod: Function,
    leftDefaultChecked: {
      type: Array,
      default: () => []
    },
    rightDefaultChecked: {
      type: Array,
      default: () => []
    },
    renderContent: Function,
    modelValue: {
      type: Array,
      default: () => []
    },
    format: {
      type: Object,
      default: () => ({})
    },
    filterable: {
      type: Boolean,
      default: false
    },
    props: {
      type: Object,
      default: () => ({
        label: "label",
        key: "key",
        disabled: "disabled"
      })
    },
    targetOrder: {
      type: String,
      default: "original",
      validator: (val) => {
        return ["original", "push", "unshift"].includes(val);
      }
    }
  },
  emits: [
    UPDATE_MODEL_EVENT,
    CHANGE_EVENT,
    LEFT_CHECK_CHANGE_EVENT,
    RIGHT_CHECK_CHANGE_EVENT
  ],
  setup(props2, { emit: emit2, slots }) {
    const { t } = useLocaleInject();
    const elFormItem = inject(elFormItemKey, {});
    const checkedState = reactive({
      leftChecked: [],
      rightChecked: []
    });
    const {
      propsKey,
      sourceData,
      targetData
    } = useComputedData(props2);
    const {
      onSourceCheckedChange,
      onTargetCheckedChange
    } = useCheckedChange(checkedState, emit2);
    const {
      addToLeft,
      addToRight
    } = useMove(props2, checkedState, propsKey, emit2);
    const leftPanel = ref(null);
    const rightPanel = ref(null);
    const clearQuery = (which) => {
      if (which === "left") {
        leftPanel.value.query = "";
      } else if (which === "right") {
        rightPanel.value.query = "";
      }
    };
    const hasButtonTexts = computed(() => props2.buttonTexts.length === 2);
    const leftPanelTitle = computed(() => props2.titles[0] || t("el.transfer.titles.0"));
    const rightPanelTitle = computed(() => props2.titles[1] || t("el.transfer.titles.1"));
    const panelFilterPlaceholder = computed(() => props2.filterPlaceholder || t("el.transfer.filterPlaceholder"));
    watch(() => props2.modelValue, (val) => {
      var _a;
      (_a = elFormItem.formItemMitt) == null ? void 0 : _a.emit("el.form.change", val);
    });
    const optionRender = computed(() => (option2) => {
      if (props2.renderContent)
        return props2.renderContent(h, option2);
      if (slots.default)
        return slots.default({ option: option2 });
      return h("span", option2[props2.props.label] || option2[props2.props.key]);
    });
    return __spreadProps$5(__spreadValues$5({
      sourceData,
      targetData,
      onSourceCheckedChange,
      onTargetCheckedChange,
      addToLeft,
      addToRight
    }, toRefs(checkedState)), {
      hasButtonTexts,
      leftPanelTitle,
      rightPanelTitle,
      panelFilterPlaceholder,
      clearQuery,
      optionRender
    });
  }
});
const _hoisted_1$1$3 = { class: "el-transfer" };
const _hoisted_2$1$2 = { class: "el-transfer__buttons" };
const _hoisted_3$1$2 = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-arrow-left" }, null, -1);
const _hoisted_4$j = { key: 0 };
const _hoisted_5$f = { key: 0 };
const _hoisted_6$d = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-arrow-right" }, null, -1);
function render$1$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_transfer_panel = resolveComponent("transfer-panel");
  const _component_el_button = resolveComponent("el-button");
  return openBlock(), createElementBlock("div", _hoisted_1$1$3, [
    createVNode(_component_transfer_panel, {
      ref: "leftPanel",
      data: _ctx.sourceData,
      "option-render": _ctx.optionRender,
      placeholder: _ctx.panelFilterPlaceholder,
      title: _ctx.leftPanelTitle,
      filterable: _ctx.filterable,
      format: _ctx.format,
      "filter-method": _ctx.filterMethod,
      "default-checked": _ctx.leftDefaultChecked,
      props: _ctx.props,
      onCheckedChange: _ctx.onSourceCheckedChange
    }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "left-footer")
      ]),
      _: 3
    }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
    createElementVNode("div", _hoisted_2$1$2, [
      createVNode(_component_el_button, {
        type: "primary",
        class: normalizeClass(["el-transfer__button", _ctx.hasButtonTexts ? "is-with-texts" : ""]),
        disabled: _ctx.rightChecked.length === 0,
        onClick: _ctx.addToLeft
      }, {
        default: withCtx(() => [
          _hoisted_3$1$2,
          _ctx.buttonTexts[0] !== void 0 ? (openBlock(), createElementBlock("span", _hoisted_4$j, toDisplayString(_ctx.buttonTexts[0]), 1)) : createCommentVNode("v-if", true)
        ]),
        _: 1
      }, 8, ["class", "disabled", "onClick"]),
      createVNode(_component_el_button, {
        type: "primary",
        class: normalizeClass(["el-transfer__button", _ctx.hasButtonTexts ? "is-with-texts" : ""]),
        disabled: _ctx.leftChecked.length === 0,
        onClick: _ctx.addToRight
      }, {
        default: withCtx(() => [
          _ctx.buttonTexts[1] !== void 0 ? (openBlock(), createElementBlock("span", _hoisted_5$f, toDisplayString(_ctx.buttonTexts[1]), 1)) : createCommentVNode("v-if", true),
          _hoisted_6$d
        ]),
        _: 1
      }, 8, ["class", "disabled", "onClick"])
    ]),
    createVNode(_component_transfer_panel, {
      ref: "rightPanel",
      data: _ctx.targetData,
      "option-render": _ctx.optionRender,
      placeholder: _ctx.panelFilterPlaceholder,
      filterable: _ctx.filterable,
      format: _ctx.format,
      "filter-method": _ctx.filterMethod,
      title: _ctx.rightPanelTitle,
      "default-checked": _ctx.rightDefaultChecked,
      props: _ctx.props,
      onCheckedChange: _ctx.onTargetCheckedChange
    }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "right-footer")
      ]),
      _: 3
    }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
  ]);
}
script$1$3.render = render$1$3;
script$1$3.__file = "packages/components/transfer/src/workprogress.vue";
script$1$3.install = (app) => {
  app.component(script$1$3.name, script$1$3);
};
const _Transfer = script$1$3;
const ElTransfer = _Transfer;
const NODE_KEY = "$treeNodeId";
const markNodeData = function(node, data) {
  if (!data || data[NODE_KEY])
    return;
  Object.defineProperty(data, NODE_KEY, {
    value: node.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
};
const getNodeKey = function(key, data) {
  if (!key)
    return data[NODE_KEY];
  return data[key];
};
const getChildState = (node) => {
  let all2 = true;
  let none = true;
  let allWithoutDisable = true;
  for (let i2 = 0, j = node.length; i2 < j; i2++) {
    const n = node[i2];
    if (n.checked !== true || n.indeterminate) {
      all2 = false;
      if (!n.disabled) {
        allWithoutDisable = false;
      }
    }
    if (n.checked !== false || n.indeterminate) {
      none = false;
    }
  }
  return { all: all2, none, allWithoutDisable, half: !all2 && !none };
};
const reInitChecked = function(node) {
  if (node.childNodes.length === 0)
    return;
  const { all: all2, none, half } = getChildState(node.childNodes);
  if (all2) {
    node.checked = true;
    node.indeterminate = false;
  } else if (half) {
    node.checked = false;
    node.indeterminate = true;
  } else if (none) {
    node.checked = false;
    node.indeterminate = false;
  }
  const parent2 = node.parent;
  if (!parent2 || parent2.level === 0)
    return;
  if (!node.store.checkStrictly) {
    reInitChecked(parent2);
  }
};
const getPropertyFromData = function(node, prop) {
  const props2 = node.store.props;
  const data = node.data || {};
  const config2 = props2[prop];
  if (typeof config2 === "function") {
    return config2(data, node);
  } else if (typeof config2 === "string") {
    return data[config2];
  } else if (typeof config2 === "undefined") {
    const dataProp = data[prop];
    return dataProp === void 0 ? "" : dataProp;
  }
};
let nodeIdSeed = 0;
class Node {
  constructor(options2) {
    this.id = nodeIdSeed++;
    this.text = null;
    this.checked = false;
    this.indeterminate = false;
    this.data = null;
    this.expanded = false;
    this.parent = null;
    this.visible = true;
    this.isCurrent = false;
    this.canFocus = false;
    for (const name2 in options2) {
      if (hasOwn(options2, name2)) {
        this[name2] = options2[name2];
      }
    }
    this.level = 0;
    this.loaded = false;
    this.childNodes = [];
    this.loading = false;
    if (this.parent) {
      this.level = this.parent.level + 1;
    }
  }
  initialize() {
    const store = this.store;
    if (!store) {
      throw new Error("[Node]store is required!");
    }
    store.registerNode(this);
    const props2 = store.props;
    if (props2 && typeof props2.isLeaf !== "undefined") {
      const isLeaf2 = getPropertyFromData(this, "isLeaf");
      if (typeof isLeaf2 === "boolean") {
        this.isLeafByUser = isLeaf2;
      }
    }
    if (store.lazy !== true && this.data) {
      this.setData(this.data);
      if (store.defaultExpandAll) {
        this.expanded = true;
        this.canFocus = true;
      }
    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
      this.expand();
    }
    if (!Array.isArray(this.data)) {
      markNodeData(this, this.data);
    }
    if (!this.data)
      return;
    const defaultExpandedKeys = store.defaultExpandedKeys;
    const key = store.key;
    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {
      this.expand(null, store.autoExpandParent);
    }
    if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {
      store.currentNode = this;
      store.currentNode.isCurrent = true;
    }
    if (store.lazy) {
      store._initDefaultCheckedNode(this);
    }
    this.updateLeafState();
    if (this.parent && (this.level === 1 || this.parent.expanded === true))
      this.canFocus = true;
  }
  setData(data) {
    if (!Array.isArray(data)) {
      markNodeData(this, data);
    }
    this.data = data;
    this.childNodes = [];
    let children;
    if (this.level === 0 && this.data instanceof Array) {
      children = this.data;
    } else {
      children = getPropertyFromData(this, "children") || [];
    }
    for (let i2 = 0, j = children.length; i2 < j; i2++) {
      this.insertChild({ data: children[i2] });
    }
  }
  get label() {
    return getPropertyFromData(this, "label");
  }
  get key() {
    const nodeKey = this.store.key;
    if (this.data)
      return this.data[nodeKey];
    return null;
  }
  get disabled() {
    return getPropertyFromData(this, "disabled");
  }
  get nextSibling() {
    const parent2 = this.parent;
    if (parent2) {
      const index2 = parent2.childNodes.indexOf(this);
      if (index2 > -1) {
        return parent2.childNodes[index2 + 1];
      }
    }
    return null;
  }
  get previousSibling() {
    const parent2 = this.parent;
    if (parent2) {
      const index2 = parent2.childNodes.indexOf(this);
      if (index2 > -1) {
        return index2 > 0 ? parent2.childNodes[index2 - 1] : null;
      }
    }
    return null;
  }
  contains(target, deep = true) {
    return (this.childNodes || []).some((child) => child === target || deep && child.contains(target));
  }
  remove() {
    const parent2 = this.parent;
    if (parent2) {
      parent2.removeChild(this);
    }
  }
  insertChild(child, index2, batch) {
    if (!child)
      throw new Error("insertChild error: child is required.");
    if (!(child instanceof Node)) {
      if (!batch) {
        const children = this.getChildren(true);
        if (children.indexOf(child.data) === -1) {
          if (typeof index2 === "undefined" || index2 < 0) {
            children.push(child.data);
          } else {
            children.splice(index2, 0, child.data);
          }
        }
      }
      Object.assign(child, {
        parent: this,
        store: this.store
      });
      child = reactive(new Node(child));
      if (child instanceof Node) {
        child.initialize();
      }
    }
    child.level = this.level + 1;
    if (typeof index2 === "undefined" || index2 < 0) {
      this.childNodes.push(child);
    } else {
      this.childNodes.splice(index2, 0, child);
    }
    this.updateLeafState();
  }
  insertBefore(child, ref2) {
    let index2;
    if (ref2) {
      index2 = this.childNodes.indexOf(ref2);
    }
    this.insertChild(child, index2);
  }
  insertAfter(child, ref2) {
    let index2;
    if (ref2) {
      index2 = this.childNodes.indexOf(ref2);
      if (index2 !== -1)
        index2 += 1;
    }
    this.insertChild(child, index2);
  }
  removeChild(child) {
    const children = this.getChildren() || [];
    const dataIndex = children.indexOf(child.data);
    if (dataIndex > -1) {
      children.splice(dataIndex, 1);
    }
    const index2 = this.childNodes.indexOf(child);
    if (index2 > -1) {
      this.store && this.store.deregisterNode(child);
      child.parent = null;
      this.childNodes.splice(index2, 1);
    }
    this.updateLeafState();
  }
  removeChildByData(data) {
    let targetNode = null;
    for (let i2 = 0; i2 < this.childNodes.length; i2++) {
      if (this.childNodes[i2].data === data) {
        targetNode = this.childNodes[i2];
        break;
      }
    }
    if (targetNode) {
      this.removeChild(targetNode);
    }
  }
  expand(callback, expandParent) {
    const done = () => {
      if (expandParent) {
        let parent2 = this.parent;
        while (parent2.level > 0) {
          parent2.expanded = true;
          parent2 = parent2.parent;
        }
      }
      this.expanded = true;
      if (callback)
        callback();
      this.childNodes.forEach((item) => {
        item.canFocus = true;
      });
    };
    if (this.shouldLoadData()) {
      this.loadData((data) => {
        if (Array.isArray(data)) {
          if (this.checked) {
            this.setChecked(true, true);
          } else if (!this.store.checkStrictly) {
            reInitChecked(this);
          }
          done();
        }
      });
    } else {
      done();
    }
  }
  doCreateChildren(array3, defaultProps2 = {}) {
    array3.forEach((item) => {
      this.insertChild(Object.assign({ data: item }, defaultProps2), void 0, true);
    });
  }
  collapse() {
    this.expanded = false;
    this.childNodes.forEach((item) => {
      item.canFocus = false;
    });
  }
  shouldLoadData() {
    return this.store.lazy === true && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== "undefined") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const childNodes = this.childNodes;
    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
      this.isLeaf = !childNodes || childNodes.length === 0;
      return;
    }
    this.isLeaf = false;
  }
  setChecked(value2, deep, recursion, passValue) {
    this.indeterminate = value2 === "half";
    this.checked = value2 === true;
    if (this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: all2, allWithoutDisable } = getChildState(this.childNodes);
      if (!this.isLeaf && (!all2 && allWithoutDisable)) {
        this.checked = false;
        value2 = false;
      }
      const handleDescendants = () => {
        if (deep) {
          const childNodes = this.childNodes;
          for (let i2 = 0, j = childNodes.length; i2 < j; i2++) {
            const child = childNodes[i2];
            passValue = passValue || value2 !== false;
            const isCheck = child.disabled ? child.checked : passValue;
            child.setChecked(isCheck, deep, true, passValue);
          }
          const { half, all: all22 } = getChildState(childNodes);
          if (!all22) {
            this.checked = all22;
            this.indeterminate = half;
          }
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          handleDescendants();
          reInitChecked(this);
        }, {
          checked: value2 !== false
        });
        return;
      } else {
        handleDescendants();
      }
    }
    const parent2 = this.parent;
    if (!parent2 || parent2.level === 0)
      return;
    if (!recursion) {
      reInitChecked(parent2);
    }
  }
  getChildren(forceInit = false) {
    if (this.level === 0)
      return this.data;
    const data = this.data;
    if (!data)
      return null;
    const props2 = this.store.props;
    let children = "children";
    if (props2) {
      children = props2.children || "children";
    }
    if (data[children] === void 0) {
      data[children] = null;
    }
    if (forceInit && !data[children]) {
      data[children] = [];
    }
    return data[children];
  }
  updateChildren() {
    const newData = this.getChildren() || [];
    const oldData = this.childNodes.map((node) => node.data);
    const newDataMap = {};
    const newNodes = [];
    newData.forEach((item, index2) => {
      const key = item[NODE_KEY];
      const isNodeExists = !!key && oldData.findIndex((data) => data[NODE_KEY] === key) >= 0;
      if (isNodeExists) {
        newDataMap[key] = { index: index2, data: item };
      } else {
        newNodes.push({ index: index2, data: item });
      }
    });
    if (!this.store.lazy) {
      oldData.forEach((item) => {
        if (!newDataMap[item[NODE_KEY]])
          this.removeChildByData(item);
      });
    }
    newNodes.forEach(({ index: index2, data }) => {
      this.insertChild({ data }, index2);
    });
    this.updateLeafState();
  }
  loadData(callback, defaultProps2 = {}) {
    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps2).length)) {
      this.loading = true;
      const resolve = (children) => {
        this.loaded = true;
        this.loading = false;
        this.childNodes = [];
        this.doCreateChildren(children, defaultProps2);
        this.updateLeafState();
        if (callback) {
          callback.call(this, children);
        }
      };
      this.store.load(this, resolve);
    } else {
      if (callback) {
        callback.call(this);
      }
    }
  }
}
class TreeStore {
  constructor(options2) {
    this.currentNode = null;
    this.currentNodeKey = null;
    for (const option2 in options2) {
      if (hasOwn(options2, option2)) {
        this[option2] = options2[option2];
      }
    }
    this.nodesMap = {};
  }
  initialize() {
    this.root = new Node({
      data: this.data,
      store: this
    });
    this.root.initialize();
    if (this.lazy && this.load) {
      const loadFn = this.load;
      loadFn(this.root, (data) => {
        this.root.doCreateChildren(data);
        this._initDefaultCheckedNodes();
      });
    } else {
      this._initDefaultCheckedNodes();
    }
  }
  filter(value2) {
    const filterNodeMethod = this.filterNodeMethod;
    const lazy = this.lazy;
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        child.visible = filterNodeMethod.call(child, value2, child.data, child);
        traverse(child);
      });
      if (!node.visible && childNodes.length) {
        let allHidden = true;
        allHidden = !childNodes.some((child) => child.visible);
        if (node.root) {
          node.root.visible = allHidden === false;
        } else {
          node.visible = allHidden === false;
        }
      }
      if (!value2)
        return;
      if (node.visible && !node.isLeaf && !lazy)
        node.expand();
    };
    traverse(this);
  }
  setData(newVal) {
    const instanceChanged = newVal !== this.root.data;
    if (instanceChanged) {
      this.root.setData(newVal);
      this._initDefaultCheckedNodes();
    } else {
      this.root.updateChildren();
    }
  }
  getNode(data) {
    if (data instanceof Node)
      return data;
    const key = typeof data !== "object" ? data : getNodeKey(this.key, data);
    return this.nodesMap[key] || null;
  }
  insertBefore(data, refData) {
    const refNode = this.getNode(refData);
    refNode.parent.insertBefore({ data }, refNode);
  }
  insertAfter(data, refData) {
    const refNode = this.getNode(refData);
    refNode.parent.insertAfter({ data }, refNode);
  }
  remove(data) {
    const node = this.getNode(data);
    if (node && node.parent) {
      if (node === this.currentNode) {
        this.currentNode = null;
      }
      node.parent.removeChild(node);
    }
  }
  append(data, parentData) {
    const parentNode = parentData ? this.getNode(parentData) : this.root;
    if (parentNode) {
      parentNode.insertChild({ data });
    }
  }
  _initDefaultCheckedNodes() {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    const nodesMap = this.nodesMap;
    defaultCheckedKeys.forEach((checkedKey) => {
      const node = nodesMap[checkedKey];
      if (node) {
        node.setChecked(true, !this.checkStrictly);
      }
    });
  }
  _initDefaultCheckedNode(node) {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    if (defaultCheckedKeys.indexOf(node.key) !== -1) {
      node.setChecked(true, !this.checkStrictly);
    }
  }
  setDefaultCheckedKey(newVal) {
    if (newVal !== this.defaultCheckedKeys) {
      this.defaultCheckedKeys = newVal;
      this._initDefaultCheckedNodes();
    }
  }
  registerNode(node) {
    const key = this.key;
    if (!node || !node.data)
      return;
    if (!key) {
      this.nodesMap[node.id] = node;
    } else {
      const nodeKey = node.key;
      if (nodeKey !== void 0)
        this.nodesMap[node.key] = node;
    }
  }
  deregisterNode(node) {
    const key = this.key;
    if (!key || !node || !node.data)
      return;
    node.childNodes.forEach((child) => {
      this.deregisterNode(child);
    });
    delete this.nodesMap[node.key];
  }
  getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
    const checkedNodes = [];
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
          checkedNodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return checkedNodes;
  }
  getCheckedKeys(leafOnly = false) {
    return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const nodes = [];
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        if (child.indeterminate) {
          nodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return nodes;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((data) => (data || {})[this.key]);
  }
  _getAllNodes() {
    const allNodes = [];
    const nodesMap = this.nodesMap;
    for (const nodeKey in nodesMap) {
      if (hasOwn(nodesMap, nodeKey)) {
        allNodes.push(nodesMap[nodeKey]);
      }
    }
    return allNodes;
  }
  updateChildren(key, data) {
    const node = this.nodesMap[key];
    if (!node)
      return;
    const childNodes = node.childNodes;
    for (let i2 = childNodes.length - 1; i2 >= 0; i2--) {
      const child = childNodes[i2];
      this.remove(child.data);
    }
    for (let i2 = 0, j = data.length; i2 < j; i2++) {
      const child = data[i2];
      this.append(child, node.data);
    }
  }
  _setCheckedKeys(key, leafOnly = false, checkedKeys) {
    const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level);
    const cache = Object.create(null);
    const keys2 = Object.keys(checkedKeys);
    allNodes.forEach((node) => node.setChecked(false, false));
    for (let i2 = 0, j = allNodes.length; i2 < j; i2++) {
      const node = allNodes[i2];
      const nodeKey = node.data[key].toString();
      const checked = keys2.indexOf(nodeKey) > -1;
      if (!checked) {
        if (node.checked && !cache[nodeKey]) {
          node.setChecked(false, false);
        }
        continue;
      }
      let parent2 = node.parent;
      while (parent2 && parent2.level > 0) {
        cache[parent2.data[key]] = true;
        parent2 = parent2.parent;
      }
      if (node.isLeaf || this.checkStrictly) {
        node.setChecked(true, false);
        continue;
      }
      node.setChecked(true, true);
      if (leafOnly) {
        node.setChecked(false, false);
        const traverse = function(node2) {
          const childNodes = node2.childNodes;
          childNodes.forEach((child) => {
            if (!child.isLeaf) {
              child.setChecked(false, false);
            }
            traverse(child);
          });
        };
        traverse(node);
      }
    }
  }
  setCheckedNodes(array3, leafOnly = false) {
    const key = this.key;
    const checkedKeys = {};
    array3.forEach((item) => {
      checkedKeys[(item || {})[key]] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys);
  }
  setCheckedKeys(keys2, leafOnly = false) {
    this.defaultCheckedKeys = keys2;
    const key = this.key;
    const checkedKeys = {};
    keys2.forEach((key2) => {
      checkedKeys[key2] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys);
  }
  setDefaultExpandedKeys(keys2) {
    keys2 = keys2 || [];
    this.defaultExpandedKeys = keys2;
    keys2.forEach((key) => {
      const node = this.getNode(key);
      if (node)
        node.expand(null, this.autoExpandParent);
    });
  }
  setChecked(data, checked, deep) {
    const node = this.getNode(data);
    if (node) {
      node.setChecked(!!checked, deep);
    }
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(currentNode) {
    const prevCurrentNode = this.currentNode;
    if (prevCurrentNode) {
      prevCurrentNode.isCurrent = false;
    }
    this.currentNode = currentNode;
    this.currentNode.isCurrent = true;
  }
  setUserCurrentNode(node, shouldAutoExpandParent = true) {
    const key = node[this.key];
    const currNode = this.nodesMap[key];
    this.setCurrentNode(currNode);
    if (shouldAutoExpandParent && this.currentNode.level > 1) {
      this.currentNode.parent.expand(null, true);
    }
  }
  setCurrentNodeKey(key, shouldAutoExpandParent = true) {
    if (key === null || key === void 0) {
      this.currentNode && (this.currentNode.isCurrent = false);
      this.currentNode = null;
      return;
    }
    const node = this.getNode(key);
    if (node) {
      this.setCurrentNode(node);
      if (shouldAutoExpandParent && this.currentNode.level > 1) {
        this.currentNode.parent.expand(null, true);
      }
    }
  }
}
var script$4 = defineComponent({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: true
    },
    renderContent: Function
  },
  setup(props2) {
    const nodeInstance = inject("NodeInstance");
    const tree = inject("RootTree");
    return () => {
      const node = props2.node;
      const { data, store } = node;
      return props2.renderContent ? props2.renderContent(h, { _self: nodeInstance, node, data, store }) : tree.ctx.slots.default ? tree.ctx.slots.default({ node, data }) : h("span", { class: "el-tree-node__label" }, [node.label]);
    };
  }
});
script$4.__file = "packages/components/tree/src/tree-node-content.vue";
function useNodeExpandEventBroadcast(props2) {
  const parentNodeMap = inject("TreeNodeMap", null);
  const currentNodeMap = {
    treeNodeExpand: (node) => {
      if (props2.node !== node) {
        props2.node.collapse();
      }
    },
    children: []
  };
  if (parentNodeMap) {
    parentNodeMap.children.push(currentNodeMap);
  }
  provide("TreeNodeMap", currentNodeMap);
  return {
    broadcastExpanded: (node) => {
      if (!props2.accordion)
        return;
      for (const childNode of currentNodeMap.children) {
        childNode.treeNodeExpand(node);
      }
    }
  };
}
function useDragNodeHandler({ props: props2, ctx: ctx2, el$, dropIndicator$, store }) {
  const emitter = mitt();
  provide("DragNodeEmitter", emitter);
  const dragState = ref({
    showDropIndicator: false,
    draggingNode: null,
    dropNode: null,
    allowDrop: true,
    dropType: null
  });
  emitter.on("tree-node-drag-start", ({ event: event2, treeNode }) => {
    if (typeof props2.allowDrag === "function" && !props2.allowDrag(treeNode.node)) {
      event2.preventDefault();
      return false;
    }
    event2.dataTransfer.effectAllowed = "move";
    try {
      event2.dataTransfer.setData("text/plain", "");
    } catch (e) {
    }
    dragState.value.draggingNode = treeNode;
    ctx2.emit("node-drag-start", treeNode.node, event2);
  });
  emitter.on("tree-node-drag-over", ({ event: event2, treeNode }) => {
    const dropNode = treeNode;
    const oldDropNode = dragState.value.dropNode;
    if (oldDropNode && oldDropNode !== dropNode) {
      removeClass(oldDropNode.$el, "is-drop-inner");
    }
    const draggingNode = dragState.value.draggingNode;
    if (!draggingNode || !dropNode)
      return;
    let dropPrev = true;
    let dropInner = true;
    let dropNext = true;
    let userAllowDropInner = true;
    if (typeof props2.allowDrop === "function") {
      dropPrev = props2.allowDrop(draggingNode.node, dropNode.node, "prev");
      userAllowDropInner = dropInner = props2.allowDrop(draggingNode.node, dropNode.node, "inner");
      dropNext = props2.allowDrop(draggingNode.node, dropNode.node, "next");
    }
    event2.dataTransfer.dropEffect = dropInner ? "move" : "none";
    if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
      if (oldDropNode) {
        ctx2.emit("node-drag-leave", draggingNode.node, oldDropNode.node, event2);
      }
      ctx2.emit("node-drag-enter", draggingNode.node, dropNode.node, event2);
    }
    if (dropPrev || dropInner || dropNext) {
      dragState.value.dropNode = dropNode;
    }
    if (dropNode.node.nextSibling === draggingNode.node) {
      dropNext = false;
    }
    if (dropNode.node.previousSibling === draggingNode.node) {
      dropPrev = false;
    }
    if (dropNode.node.contains(draggingNode.node, false)) {
      dropInner = false;
    }
    if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
      dropPrev = false;
      dropInner = false;
      dropNext = false;
    }
    const targetPosition = dropNode.$el.getBoundingClientRect();
    const treePosition = el$.value.getBoundingClientRect();
    let dropType;
    const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
    const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
    let indicatorTop = -9999;
    const distance = event2.clientY - targetPosition.top;
    if (distance < targetPosition.height * prevPercent) {
      dropType = "before";
    } else if (distance > targetPosition.height * nextPercent) {
      dropType = "after";
    } else if (dropInner) {
      dropType = "inner";
    } else {
      dropType = "none";
    }
    const iconPosition = dropNode.$el.querySelector(".el-tree-node__expand-icon").getBoundingClientRect();
    const dropIndicator = dropIndicator$.value;
    if (dropType === "before") {
      indicatorTop = iconPosition.top - treePosition.top;
    } else if (dropType === "after") {
      indicatorTop = iconPosition.bottom - treePosition.top;
    }
    dropIndicator.style.top = indicatorTop + "px";
    dropIndicator.style.left = iconPosition.right - treePosition.left + "px";
    if (dropType === "inner") {
      addClass$1(dropNode.$el, "is-drop-inner");
    } else {
      removeClass(dropNode.$el, "is-drop-inner");
    }
    dragState.value.showDropIndicator = dropType === "before" || dropType === "after";
    dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;
    dragState.value.dropType = dropType;
    ctx2.emit("node-drag-over", draggingNode.node, dropNode.node, event2);
  });
  emitter.on("tree-node-drag-end", (event2) => {
    const { draggingNode, dropType, dropNode } = dragState.value;
    event2.preventDefault();
    event2.dataTransfer.dropEffect = "move";
    if (draggingNode && dropNode) {
      const draggingNodeCopy = { data: draggingNode.node.data };
      if (dropType !== "none") {
        draggingNode.node.remove();
      }
      if (dropType === "before") {
        dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
      } else if (dropType === "after") {
        dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
      } else if (dropType === "inner") {
        dropNode.node.insertChild(draggingNodeCopy);
      }
      if (dropType !== "none") {
        store.value.registerNode(draggingNodeCopy);
      }
      removeClass(dropNode.$el, "is-drop-inner");
      ctx2.emit("node-drag-end", draggingNode.node, dropNode.node, dropType, event2);
      if (dropType !== "none") {
        ctx2.emit("node-drop", draggingNode.node, dropNode.node, dropType, event2);
      }
    }
    if (draggingNode && !dropNode) {
      ctx2.emit("node-drag-end", draggingNode.node, null, dropType, event2);
    }
    dragState.value.showDropIndicator = false;
    dragState.value.draggingNode = null;
    dragState.value.dropNode = null;
    dragState.value.allowDrop = true;
  });
  return {
    dragState
  };
}
function useDragNodeEmitter() {
  const emitter = inject("DragNodeEmitter");
  return {
    emitter
  };
}
var script$1$2 = defineComponent({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: ElCollapseTransition$1,
    ElCheckbox: _Checkbox,
    NodeContent: script$4
  },
  props: {
    node: {
      type: Node,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: false
    }
  },
  emits: ["node-expand"],
  setup(props2, ctx2) {
    const { broadcastExpanded } = useNodeExpandEventBroadcast(props2);
    const tree = inject("RootTree");
    const expanded = ref(false);
    const childNodeRendered = ref(false);
    const oldChecked = ref(null);
    const oldIndeterminate = ref(null);
    const node$ = ref(null);
    const { emitter } = useDragNodeEmitter();
    const instance = getCurrentInstance();
    provide("NodeInstance", instance);
    if (!tree) {
      console.warn("Can not find node's tree.");
    }
    if (props2.node.expanded) {
      expanded.value = true;
      childNodeRendered.value = true;
    }
    const childrenKey = tree.props["children"] || "children";
    watch(() => {
      const children = props2.node.data[childrenKey];
      return children && [...children];
    }, () => {
      props2.node.updateChildren();
    });
    watch(() => props2.node.indeterminate, (val) => {
      handleSelectChange(props2.node.checked, val);
    });
    watch(() => props2.node.checked, (val) => {
      handleSelectChange(val, props2.node.indeterminate);
    });
    watch(() => props2.node.expanded, (val) => {
      nextTick(() => expanded.value = val);
      if (val) {
        childNodeRendered.value = true;
      }
    });
    const getNodeKey$1 = (node) => {
      return getNodeKey(tree.props.nodeKey, node.data);
    };
    const handleSelectChange = (checked, indeterminate) => {
      if (oldChecked.value !== checked || oldIndeterminate.value !== indeterminate) {
        tree.ctx.emit("check-change", props2.node.data, checked, indeterminate);
      }
      oldChecked.value = checked;
      oldIndeterminate.value = indeterminate;
    };
    const handleClick = () => {
      const store = tree.store.value;
      store.setCurrentNode(props2.node);
      tree.ctx.emit("current-change", store.currentNode ? store.currentNode.data : null, store.currentNode);
      tree.currentNode.value = props2.node;
      if (tree.props.expandOnClickNode) {
        handleExpandIconClick();
      }
      if (tree.props.checkOnClickNode && !props2.node.disabled) {
        handleCheckChange(null, {
          target: { checked: !props2.node.checked }
        });
      }
      tree.ctx.emit("node-click", props2.node.data, props2.node, instance);
    };
    const handleContextMenu = (event2) => {
      if (tree.instance.vnode.props["onNodeContextmenu"]) {
        event2.stopPropagation();
        event2.preventDefault();
      }
      tree.ctx.emit("node-contextmenu", event2, props2.node.data, props2.node, instance);
    };
    const handleExpandIconClick = () => {
      if (props2.node.isLeaf)
        return;
      if (expanded.value) {
        tree.ctx.emit("node-collapse", props2.node.data, props2.node, instance);
        props2.node.collapse();
      } else {
        props2.node.expand();
        ctx2.emit("node-expand", props2.node.data, props2.node, instance);
      }
    };
    const handleCheckChange = (value2, ev) => {
      props2.node.setChecked(ev.target.checked, !tree.props.checkStrictly);
      nextTick(() => {
        const store = tree.store.value;
        tree.ctx.emit("check", props2.node.data, {
          checkedNodes: store.getCheckedNodes(),
          checkedKeys: store.getCheckedKeys(),
          halfCheckedNodes: store.getHalfCheckedNodes(),
          halfCheckedKeys: store.getHalfCheckedKeys()
        });
      });
    };
    const handleChildNodeExpand = (nodeData, node, instance2) => {
      broadcastExpanded(node);
      tree.ctx.emit("node-expand", nodeData, node, instance2);
    };
    const handleDragStart = (event2) => {
      if (!tree.props.draggable)
        return;
      emitter.emit("tree-node-drag-start", { event: event2, treeNode: props2 });
    };
    const handleDragOver = (event2) => {
      if (!tree.props.draggable)
        return;
      emitter.emit("tree-node-drag-over", { event: event2, treeNode: { $el: node$.value, node: props2.node } });
      event2.preventDefault();
    };
    const handleDrop = (event2) => {
      event2.preventDefault();
    };
    const handleDragEnd = (event2) => {
      if (!tree.props.draggable)
        return;
      emitter.emit("tree-node-drag-end", event2);
    };
    return {
      node$,
      tree,
      expanded,
      childNodeRendered,
      oldChecked,
      oldIndeterminate,
      emitter,
      getNodeKey: getNodeKey$1,
      handleSelectChange,
      handleClick,
      handleContextMenu,
      handleExpandIconClick,
      handleCheckChange,
      handleChildNodeExpand,
      handleDragStart,
      handleDragOver,
      handleDrop,
      handleDragEnd
    };
  }
});
const _hoisted_1$v = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"];
const _hoisted_2$q = {
  key: 1,
  class: "el-tree-node__loading-icon el-icon-loading"
};
const _hoisted_3$p = ["aria-expanded"];
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_node_content = resolveComponent("node-content");
  const _component_el_tree_node = resolveComponent("el-tree-node");
  const _component_el_collapse_transition = resolveComponent("el-collapse-transition");
  return withDirectives((openBlock(), createElementBlock("div", {
    ref: "node$",
    class: normalizeClass(["el-tree-node", {
      "is-expanded": _ctx.expanded,
      "is-current": _ctx.node.isCurrent,
      "is-hidden": !_ctx.node.visible,
      "is-focusable": !_ctx.node.disabled,
      "is-checked": !_ctx.node.disabled && _ctx.node.checked
    }]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": _ctx.expanded,
    "aria-disabled": _ctx.node.disabled,
    "aria-checked": _ctx.node.checked,
    draggable: _ctx.tree.props.draggable,
    "data-key": _ctx.getNodeKey(_ctx.node),
    onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"])),
    onContextmenu: _cache[3] || (_cache[3] = (...args) => _ctx.handleContextMenu && _ctx.handleContextMenu(...args)),
    onDragstart: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
    onDragover: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args), ["stop"])),
    onDragend: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args), ["stop"])),
    onDrop: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.handleDrop && _ctx.handleDrop(...args), ["stop"]))
  }, [
    createElementVNode("div", {
      class: "el-tree-node__content",
      style: normalizeStyle({ "padding-left": (_ctx.node.level - 1) * _ctx.tree.props.indent + "px" })
    }, [
      createElementVNode("span", {
        class: normalizeClass([
          {
            "is-leaf": _ctx.node.isLeaf,
            expanded: !_ctx.node.isLeaf && _ctx.expanded
          },
          "el-tree-node__expand-icon",
          _ctx.tree.props.iconClass ? _ctx.tree.props.iconClass : "el-icon-caret-right"
        ]),
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleExpandIconClick && _ctx.handleExpandIconClick(...args), ["stop"]))
      }, null, 2),
      _ctx.showCheckbox ? (openBlock(), createBlock(_component_el_checkbox, {
        key: 0,
        "model-value": _ctx.node.checked,
        indeterminate: _ctx.node.indeterminate,
        disabled: !!_ctx.node.disabled,
        onClick: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["stop"])),
        onChange: _ctx.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : createCommentVNode("v-if", true),
      _ctx.node.loading ? (openBlock(), createElementBlock("span", _hoisted_2$q)) : createCommentVNode("v-if", true),
      createVNode(_component_node_content, {
        node: _ctx.node,
        "render-content": _ctx.renderContent
      }, null, 8, ["node", "render-content"])
    ], 4),
    createVNode(_component_el_collapse_transition, null, {
      default: withCtx(() => [
        !_ctx.renderAfterExpand || _ctx.childNodeRendered ? withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          class: "el-tree-node__children",
          role: "group",
          "aria-expanded": _ctx.expanded
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.node.childNodes, (child) => {
            return openBlock(), createBlock(_component_el_tree_node, {
              key: _ctx.getNodeKey(child),
              "render-content": _ctx.renderContent,
              "render-after-expand": _ctx.renderAfterExpand,
              "show-checkbox": _ctx.showCheckbox,
              node: child,
              onNodeExpand: _ctx.handleChildNodeExpand
            }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "onNodeExpand"]);
          }), 128))
        ], 8, _hoisted_3$p)), [
          [vShow, _ctx.expanded]
        ]) : createCommentVNode("v-if", true)
      ]),
      _: 1
    })
  ], 42, _hoisted_1$v)), [
    [vShow, _ctx.node.visible]
  ]);
}
script$1$2.render = render$4;
script$1$2.__file = "packages/components/tree/src/tree-node.vue";
function useKeydown({ el$ }, store) {
  const treeItems = ref([]);
  const checkboxItems = ref([]);
  onMounted(() => {
    initTabIndex();
    on$2(el$.value, "keydown", handleKeydown);
  });
  onBeforeUnmount(() => {
    off$2(el$.value, "keydown", handleKeydown);
  });
  onUpdated(() => {
    treeItems.value = Array.from(el$.value.querySelectorAll("[role=treeitem]"));
    checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
  });
  watch(checkboxItems, (val) => {
    val.forEach((checkbox) => {
      checkbox.setAttribute("tabindex", "-1");
    });
  });
  const handleKeydown = (ev) => {
    const currentItem = ev.target;
    if (currentItem.className.indexOf("el-tree-node") === -1)
      return;
    const code = ev.code;
    treeItems.value = Array.from(el$.value.querySelectorAll(".is-focusable[role=treeitem]"));
    const currentIndex = treeItems.value.indexOf(currentItem);
    let nextIndex;
    if ([EVENT_CODE.up, EVENT_CODE.down].indexOf(code) > -1) {
      ev.preventDefault();
      if (code === EVENT_CODE.up) {
        nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.value.length - 1;
        const startIndex = nextIndex;
        while (true) {
          if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
            break;
          nextIndex--;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex < 0) {
            nextIndex = treeItems.value.length - 1;
          }
        }
      } else {
        nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.value.length - 1 ? currentIndex + 1 : 0;
        const startIndex = nextIndex;
        while (true) {
          if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
            break;
          nextIndex++;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex >= treeItems.value.length) {
            nextIndex = 0;
          }
        }
      }
      nextIndex !== -1 && treeItems.value[nextIndex].focus();
    }
    if ([EVENT_CODE.left, EVENT_CODE.right].indexOf(code) > -1) {
      ev.preventDefault();
      currentItem.click();
    }
    const hasInput = currentItem.querySelector('[type="checkbox"]');
    if ([EVENT_CODE.enter, EVENT_CODE.space].indexOf(code) > -1 && hasInput) {
      ev.preventDefault();
      hasInput.click();
    }
  };
  const initTabIndex = () => {
    var _a;
    treeItems.value = Array.from(el$.value.querySelectorAll(".is-focusable[role=treeitem]"));
    checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
    const checkedItem = el$.value.querySelectorAll(".is-checked[role=treeitem]");
    if (checkedItem.length) {
      checkedItem[0].setAttribute("tabindex", "0");
      return;
    }
    (_a = treeItems.value[0]) == null ? void 0 : _a.setAttribute("tabindex", "0");
  };
}
var script$2$2 = defineComponent({
  name: "ElTree",
  components: { ElTreeNode: script$1$2 },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: true
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: false
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: false
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    iconClass: String
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(props2, ctx2) {
    const { t } = useLocaleInject();
    const store = ref(new TreeStore({
      key: props2.nodeKey,
      data: props2.data,
      lazy: props2.lazy,
      props: props2.props,
      load: props2.load,
      currentNodeKey: props2.currentNodeKey,
      checkStrictly: props2.checkStrictly,
      checkDescendants: props2.checkDescendants,
      defaultCheckedKeys: props2.defaultCheckedKeys,
      defaultExpandedKeys: props2.defaultExpandedKeys,
      autoExpandParent: props2.autoExpandParent,
      defaultExpandAll: props2.defaultExpandAll,
      filterNodeMethod: props2.filterNodeMethod
    }));
    store.value.initialize();
    const root2 = ref(store.value.root);
    const currentNode = ref(null);
    const el$ = ref(null);
    const dropIndicator$ = ref(null);
    const { broadcastExpanded } = useNodeExpandEventBroadcast(props2);
    const { dragState } = useDragNodeHandler({
      props: props2,
      ctx: ctx2,
      el$,
      dropIndicator$,
      store
    });
    useKeydown({ el$ }, store);
    const isEmpty2 = computed(() => {
      const { childNodes } = root2.value;
      return !childNodes || childNodes.length === 0 || childNodes.every(({ visible: visible2 }) => !visible2);
    });
    watch(() => props2.defaultCheckedKeys, (newVal) => {
      store.value.setDefaultCheckedKey(newVal);
    });
    watch(() => props2.defaultExpandedKeys, (newVal) => {
      store.value.defaultExpandedKeys = newVal;
      store.value.setDefaultExpandedKeys(newVal);
    });
    watch(() => props2.data, (newVal) => {
      store.value.setData(newVal);
    }, { deep: true });
    watch(() => props2.checkStrictly, (newVal) => {
      store.value.checkStrictly = newVal;
    });
    const filter = (value2) => {
      if (!props2.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      store.value.filter(value2);
    };
    const getNodeKey$1 = (node) => {
      return getNodeKey(props2.nodeKey, node.data);
    };
    const getNodePath = (data) => {
      if (!props2.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const node = store.value.getNode(data);
      if (!node)
        return [];
      const path = [node.data];
      let parent2 = node.parent;
      while (parent2 && parent2 !== root2.value) {
        path.push(parent2.data);
        parent2 = parent2.parent;
      }
      return path.reverse();
    };
    const getCheckedNodes = (leafOnly, includeHalfChecked) => {
      return store.value.getCheckedNodes(leafOnly, includeHalfChecked);
    };
    const getCheckedKeys = (leafOnly) => {
      return store.value.getCheckedKeys(leafOnly);
    };
    const getCurrentNode = () => {
      const currentNode2 = store.value.getCurrentNode();
      return currentNode2 ? currentNode2.data : null;
    };
    const getCurrentKey = () => {
      if (!props2.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const currentNode2 = getCurrentNode();
      return currentNode2 ? currentNode2[props2.nodeKey] : null;
    };
    const setCheckedNodes = (nodes, leafOnly) => {
      if (!props2.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      store.value.setCheckedNodes(nodes, leafOnly);
    };
    const setCheckedKeys = (keys2, leafOnly) => {
      if (!props2.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      store.value.setCheckedKeys(keys2, leafOnly);
    };
    const setChecked = (data, checked, deep) => {
      store.value.setChecked(data, checked, deep);
    };
    const getHalfCheckedNodes = () => {
      return store.value.getHalfCheckedNodes();
    };
    const getHalfCheckedKeys = () => {
      return store.value.getHalfCheckedKeys();
    };
    const setCurrentNode = (node, shouldAutoExpandParent = true) => {
      if (!props2.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      store.value.setUserCurrentNode(node, shouldAutoExpandParent);
    };
    const setCurrentKey = (key, shouldAutoExpandParent = true) => {
      if (!props2.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      store.value.setCurrentNodeKey(key, shouldAutoExpandParent);
    };
    const getNode = (data) => {
      return store.value.getNode(data);
    };
    const remove = (data) => {
      store.value.remove(data);
    };
    const append = (data, parentNode) => {
      store.value.append(data, parentNode);
    };
    const insertBefore = (data, refNode) => {
      store.value.insertBefore(data, refNode);
    };
    const insertAfter = (data, refNode) => {
      store.value.insertAfter(data, refNode);
    };
    const handleNodeExpand = (nodeData, node, instance) => {
      broadcastExpanded(node);
      ctx2.emit("node-expand", nodeData, node, instance);
    };
    const updateKeyChildren = (key, data) => {
      if (!props2.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      store.value.updateChildren(key, data);
    };
    provide("RootTree", {
      ctx: ctx2,
      props: props2,
      store,
      root: root2,
      currentNode,
      instance: getCurrentInstance()
    });
    return {
      store,
      root: root2,
      currentNode,
      dragState,
      el$,
      dropIndicator$,
      isEmpty: isEmpty2,
      filter,
      getNodeKey: getNodeKey$1,
      getNodePath,
      getCheckedNodes,
      getCheckedKeys,
      getCurrentNode,
      getCurrentKey,
      setCheckedNodes,
      setCheckedKeys,
      setChecked,
      getHalfCheckedNodes,
      getHalfCheckedKeys,
      setCurrentNode,
      setCurrentKey,
      t,
      getNode,
      remove,
      append,
      insertBefore,
      insertAfter,
      handleNodeExpand,
      updateKeyChildren
    };
  }
});
const _hoisted_1$1$2 = {
  key: 0,
  class: "el-tree__empty-block"
};
const _hoisted_2$1$1 = { class: "el-tree__empty-text" };
const _hoisted_3$1$1 = {
  ref: "dropIndicator$",
  class: "el-tree__drop-indicator"
};
function render$1$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tree_node = resolveComponent("el-tree-node");
  return openBlock(), createElementBlock("div", {
    ref: "el$",
    class: normalizeClass(["el-tree", {
      "el-tree--highlight-current": _ctx.highlightCurrent,
      "is-dragging": !!_ctx.dragState.draggingNode,
      "is-drop-not-allow": !_ctx.dragState.allowDrop,
      "is-drop-inner": _ctx.dragState.dropType === "inner"
    }]),
    role: "tree"
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.root.childNodes, (child) => {
      return openBlock(), createBlock(_component_el_tree_node, {
        key: _ctx.getNodeKey(child),
        node: child,
        props: _ctx.props,
        accordion: _ctx.accordion,
        "render-after-expand": _ctx.renderAfterExpand,
        "show-checkbox": _ctx.showCheckbox,
        "render-content": _ctx.renderContent,
        onNodeExpand: _ctx.handleNodeExpand
      }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]);
    }), 128)),
    _ctx.isEmpty ? (openBlock(), createElementBlock("div", _hoisted_1$1$2, [
      createElementVNode("span", _hoisted_2$1$1, toDisplayString(_ctx.emptyText || _ctx.t("el.tree.emptyText")), 1)
    ])) : createCommentVNode("v-if", true),
    withDirectives(createElementVNode("div", _hoisted_3$1$1, null, 512), [
      [vShow, _ctx.dragState.showDropIndicator]
    ])
  ], 2);
}
script$2$2.render = render$1$2;
script$2$2.__file = "packages/components/tree/src/tree.vue";
script$2$2.install = (app) => {
  app.component(script$2$2.name, script$2$2);
};
const _Tree = script$2$2;
const ElTree = _Tree;
function arrayEach$1(array3, iteratee) {
  var index2 = -1, length = array3 == null ? 0 : array3.length;
  while (++index2 < length) {
    if (iteratee(array3[index2], index2, array3) === false) {
      break;
    }
  }
  return array3;
}
var _arrayEach = arrayEach$1;
var defineProperty = _defineProperty$1;
function baseAssignValue$2(object3, key, value2) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object3, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object3[key] = value2;
  }
}
var _baseAssignValue = baseAssignValue$2;
var baseAssignValue$1 = _baseAssignValue, eq = eq_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function assignValue$2(object3, key, value2) {
  var objValue = object3[key];
  if (!(hasOwnProperty$2.call(object3, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object3)) {
    baseAssignValue$1(object3, key, value2);
  }
}
var _assignValue = assignValue$2;
var assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$4(source2, props2, object3, customizer) {
  var isNew = !object3;
  object3 || (object3 = {});
  var index2 = -1, length = props2.length;
  while (++index2 < length) {
    var key = props2[index2];
    var newValue = customizer ? customizer(object3[key], source2[key], key, object3, source2) : void 0;
    if (newValue === void 0) {
      newValue = source2[key];
    }
    if (isNew) {
      baseAssignValue(object3, key, newValue);
    } else {
      assignValue$1(object3, key, newValue);
    }
  }
  return object3;
}
var _copyObject = copyObject$4;
var copyObject$3 = _copyObject, keys$1 = keys_1;
function baseAssign$1(object3, source2) {
  return object3 && copyObject$3(source2, keys$1(source2), object3);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object3) {
  var result = [];
  if (object3 != null) {
    for (var key in Object(object3)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$3 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseKeysIn$1(object3) {
  if (!isObject$3(object3)) {
    return nativeKeysIn(object3);
  }
  var isProto = isPrototype$1(object3), result = [];
  for (var key in object3) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$1.call(object3, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;
function keysIn$3(object3) {
  return isArrayLike(object3) ? arrayLikeKeys(object3, true) : baseKeysIn(object3);
}
var keysIn_1 = keysIn$3;
var copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object3, source2) {
  return object3 && copyObject$2(source2, keysIn$2(source2), object3);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
function copyArray$1(source2, array3) {
  var index2 = -1, length = source2.length;
  array3 || (array3 = Array(length));
  while (++index2 < length) {
    array3[index2] = source2[index2];
  }
  return array3;
}
var _copyArray = copyArray$1;
var copyObject$1 = _copyObject, getSymbols$1 = _getSymbols;
function copySymbols$1(source2, object3) {
  return copyObject$1(source2, getSymbols$1(source2), object3);
}
var _copySymbols = copySymbols$1;
var overArg = _overArg;
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
var arrayPush = _arrayPush, getPrototype$1 = _getPrototype, getSymbols = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object3) {
  var result = [];
  while (object3) {
    arrayPush(result, getSymbols(object3));
    object3 = getPrototype$1(object3);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source2, object3) {
  return copyObject(source2, getSymbolsIn$1(source2), object3);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$1(object3) {
  return baseGetAllKeys(object3, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray$1(array3) {
  var length = array3.length, result = new array3.constructor(length);
  if (length && typeof array3[0] == "string" && hasOwnProperty.call(array3, "index")) {
    result.index = array3.index;
    result.input = array3.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp3) {
  var result = new regexp3.constructor(regexp3.source, reFlags.exec(regexp3));
  result.lastIndex = regexp3.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$1 = _Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object3, tag, isDeep) {
  var Ctor = object3.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object3);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object3);
    case dataViewTag$1:
      return cloneDataView(object3, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object3, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object3);
    case regexpTag$1:
      return cloneRegExp(object3);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object3);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$2 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object3() {
  }
  return function(proto) {
    if (!isObject$2(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object3.prototype = proto;
    var result = new object3();
    object3.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate, getPrototype = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(object3) {
  return typeof object3.constructor == "function" && !isPrototype(object3) ? baseCreate(getPrototype(object3)) : {};
}
var _initCloneObject = initCloneObject$1;
var getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value2) {
  return isObjectLike$1(value2) && getTag$2(value2) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag, isObjectLike = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value2) {
  return isObjectLike(value2) && getTag$1(value2) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$3 = isArray_1, isBuffer$2 = isBuffer$5.exports, isMap = isMap_1, isObject$1 = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$1(value2, bitmask, customizer, key, object3, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object3 ? customizer(value2, key, object3, stack) : customizer(value2);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$1(value2)) {
    return value2;
  }
  var isArr = isArray$3(value2);
  if (isArr) {
    result = initCloneArray(value2);
    if (!isDeep) {
      return copyArray(value2, result);
    }
  } else {
    var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$2(value2)) {
      return cloneBuffer(value2, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object3) {
      result = isFlat || isFunc ? {} : initCloneObject(value2);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value2, baseAssignIn(result, value2)) : copySymbols(value2, baseAssign(result, value2));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object3 ? value2 : {};
      }
      result = initCloneByTag(value2, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value2);
  if (stacked) {
    return stacked;
  }
  stack.set(value2, result);
  if (isSet(value2)) {
    value2.forEach(function(subValue) {
      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value2, stack));
    });
  } else if (isMap(value2)) {
    value2.forEach(function(subValue, key2) {
      result.set(key2, baseClone$1(subValue, bitmask, customizer, key2, value2, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props2 = isArr ? void 0 : keysFunc(value2);
  arrayEach(props2 || value2, function(subValue, key2) {
    if (props2) {
      key2 = subValue;
      subValue = value2[key2];
    }
    assignValue(result, key2, baseClone$1(subValue, bitmask, customizer, key2, value2, stack));
  });
  return result;
}
var _baseClone = baseClone$1;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value2) {
  return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
function getError(action, option2, xhr2) {
  let msg;
  if (xhr2.response) {
    msg = `${xhr2.response.error || xhr2.response}`;
  } else if (xhr2.responseText) {
    msg = `${xhr2.responseText}`;
  } else {
    msg = `fail to post ${action} ${xhr2.status}`;
  }
  const err = new Error(msg);
  err.status = xhr2.status;
  err.method = "post";
  err.url = action;
  return err;
}
function getBody(xhr2) {
  const text = xhr2.responseText || xhr2.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}
function upload(option2) {
  if (typeof XMLHttpRequest === "undefined") {
    return;
  }
  const xhr2 = new XMLHttpRequest();
  const action = option2.action;
  if (xhr2.upload) {
    xhr2.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }
      option2.onProgress(e);
    };
  }
  const formData = new FormData();
  if (option2.data) {
    Object.keys(option2.data).forEach((key) => {
      formData.append(key, option2.data[key]);
    });
  }
  formData.append(option2.filename, option2.file, option2.file.name);
  xhr2.onerror = function error() {
    option2.onError(getError(action, option2, xhr2));
  };
  xhr2.onload = function onload() {
    if (xhr2.status < 200 || xhr2.status >= 300) {
      return option2.onError(getError(action, option2, xhr2));
    }
    option2.onSuccess(getBody(xhr2));
  };
  xhr2.open("post", action, true);
  if (option2.withCredentials && "withCredentials" in xhr2) {
    xhr2.withCredentials = true;
  }
  const headers = option2.headers || {};
  for (const item in headers) {
    if (hasOwn(headers, item) && headers[item] !== null) {
      xhr2.setRequestHeader(item, headers[item]);
    }
  }
  xhr2.send(formData);
  return xhr2;
}
var script$3 = defineComponent({
  name: "ElUploadList",
  components: { ElProgress: _Progress },
  props: {
    files: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    handlePreview: {
      type: Function,
      default: () => NOOP
    },
    listType: {
      type: String,
      default: "text"
    }
  },
  emits: ["remove"],
  setup(props2, { emit: emit2 }) {
    const { t } = useLocaleInject();
    const parsePercentage = (val) => {
      return parseInt(val, 10);
    };
    const handleClick = (file) => {
      props2.handlePreview(file);
    };
    const onFileClicked = (e) => {
      e.target.focus();
    };
    const handleRemove = (e, file) => {
      emit2("remove", file);
    };
    return {
      focusing: ref(false),
      parsePercentage,
      handleClick,
      handleRemove,
      onFileClicked,
      t
    };
  }
});
const _hoisted_1$u = ["onKeydown"];
const _hoisted_2$p = ["src"];
const _hoisted_3$o = ["onClick"];
const _hoisted_4$i = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-document" }, null, -1);
const _hoisted_5$e = { class: "el-upload-list__item-status-label" };
const _hoisted_6$c = ["onClick"];
const _hoisted_7$a = {
  key: 2,
  class: "el-icon-close-tip"
};
const _hoisted_8$a = {
  key: 4,
  class: "el-upload-list__item-actions"
};
const _hoisted_9$a = ["onClick"];
const _hoisted_10$7 = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-zoom-in" }, null, -1);
const _hoisted_11$6 = [
  _hoisted_10$7
];
const _hoisted_12$6 = ["onClick"];
const _hoisted_13$5 = /* @__PURE__ */ createElementVNode("i", { class: "el-icon-delete" }, null, -1);
const _hoisted_14$4 = [
  _hoisted_13$5
];
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_progress = resolveComponent("el-progress");
  return openBlock(), createBlock(TransitionGroup, {
    tag: "ul",
    class: normalizeClass([
      "el-upload-list",
      "el-upload-list--" + _ctx.listType,
      { "is-disabled": _ctx.disabled }
    ]),
    name: "el-list"
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file) => {
        return openBlock(), createElementBlock("li", {
          key: file.uid || file,
          class: normalizeClass(["el-upload-list__item", "is-" + file.status, _ctx.focusing ? "focusing" : ""]),
          tabindex: "0",
          onKeydown: withKeys(($event) => !_ctx.disabled && _ctx.handleRemove($event, file), ["delete"]),
          onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.focusing = true),
          onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.focusing = false),
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onFileClicked && _ctx.onFileClicked(...args))
        }, [
          renderSlot(_ctx.$slots, "default", { file }, () => [
            file.status !== "uploading" && ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createElementBlock("img", {
              key: 0,
              class: "el-upload-list__item-thumbnail",
              src: file.url,
              alt: ""
            }, null, 8, _hoisted_2$p)) : createCommentVNode("v-if", true),
            createElementVNode("a", {
              class: "el-upload-list__item-name",
              onClick: ($event) => _ctx.handleClick(file)
            }, [
              _hoisted_4$i,
              createTextVNode(toDisplayString(file.name), 1)
            ], 8, _hoisted_3$o),
            createElementVNode("label", _hoisted_5$e, [
              createElementVNode("i", {
                class: normalizeClass({
                  "el-icon-upload-success": true,
                  "el-icon-circle-check": _ctx.listType === "text",
                  "el-icon-check": ["picture-card", "picture"].includes(_ctx.listType)
                })
              }, null, 2)
            ]),
            !_ctx.disabled ? (openBlock(), createElementBlock("i", {
              key: 1,
              class: "el-icon-close",
              onClick: ($event) => _ctx.handleRemove($event, file)
            }, null, 8, _hoisted_6$c)) : createCommentVNode("v-if", true),
            createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
            createCommentVNode(" This is a bug which needs to be fixed "),
            createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
            !_ctx.disabled ? (openBlock(), createElementBlock("i", _hoisted_7$a, toDisplayString(_ctx.t("el.upload.deleteTip")), 1)) : createCommentVNode("v-if", true),
            file.status === "uploading" ? (openBlock(), createBlock(_component_el_progress, {
              key: 3,
              type: _ctx.listType === "picture-card" ? "circle" : "line",
              "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
              percentage: _ctx.parsePercentage(file.percentage)
            }, null, 8, ["type", "stroke-width", "percentage"])) : createCommentVNode("v-if", true),
            _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", _hoisted_8$a, [
              createElementVNode("span", {
                class: "el-upload-list__item-preview",
                onClick: ($event) => _ctx.handlePreview(file)
              }, _hoisted_11$6, 8, _hoisted_9$a),
              !_ctx.disabled ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: "el-upload-list__item-delete",
                onClick: ($event) => _ctx.handleRemove($event, file)
              }, _hoisted_14$4, 8, _hoisted_12$6)) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true)
          ])
        ], 42, _hoisted_1$u);
      }), 128))
    ]),
    _: 3
  }, 8, ["class"]);
}
script$3.render = render$3;
script$3.__file = "packages/components/upload/src/upload-list.vue";
var script$1$1 = defineComponent({
  name: "ElUploadDrag",
  props: {
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["file"],
  setup(props2, { emit: emit2 }) {
    const uploader = inject("uploader", {});
    const dragover = ref(false);
    function onDrop2(e) {
      if (props2.disabled || !uploader)
        return;
      const accept = uploader.accept;
      dragover.value = false;
      if (!accept) {
        emit2("file", e.dataTransfer.files);
        return;
      }
      emit2("file", Array.from(e.dataTransfer.files).filter((file) => {
        const { type: type2, name: name2 } = file;
        const extension = name2.indexOf(".") > -1 ? `.${name2.split(".").pop()}` : "";
        const baseType = type2.replace(/\/.*$/, "");
        return accept.split(",").map((type22) => type22.trim()).filter((type22) => type22).some((acceptedType) => {
          if (acceptedType.startsWith(".")) {
            return extension === acceptedType;
          }
          if (/\/\*$/.test(acceptedType)) {
            return baseType === acceptedType.replace(/\/\*$/, "");
          }
          if (/^[^\/]+\/[^\/]+$/.test(acceptedType)) {
            return type2 === acceptedType;
          }
          return false;
        });
      }));
    }
    function onDragover() {
      if (!props2.disabled)
        dragover.value = true;
    }
    return {
      dragover,
      onDrop: onDrop2,
      onDragover
    };
  }
});
function render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass({
      "el-upload-dragger": true,
      "is-dragover": _ctx.dragover
    }),
    onDrop: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.onDrop && _ctx.onDrop(...args), ["prevent"])),
    onDragover: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.onDragover && _ctx.onDragover(...args), ["prevent"])),
    onDragleave: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.dragover = false, ["prevent"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34);
}
script$1$1.render = render$1$1;
script$1$1.__file = "packages/components/upload/src/upload-dragger.vue";
var script$2$1 = defineComponent({
  components: {
    UploadDragger: script$1$1
  },
  props: {
    type: {
      type: String,
      default: ""
    },
    action: {
      type: String,
      required: true
    },
    name: {
      type: String,
      default: "file"
    },
    data: {
      type: Object,
      default: () => null
    },
    headers: {
      type: Object,
      default: () => null
    },
    withCredentials: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: null
    },
    accept: {
      type: String,
      default: ""
    },
    onStart: {
      type: Function,
      default: NOOP
    },
    onProgress: {
      type: Function,
      default: NOOP
    },
    onSuccess: {
      type: Function,
      default: NOOP
    },
    onError: {
      type: Function,
      default: NOOP
    },
    beforeUpload: {
      type: Function,
      default: NOOP
    },
    drag: {
      type: Boolean,
      default: false
    },
    onPreview: {
      type: Function,
      default: NOOP
    },
    onRemove: {
      type: Function,
      default: NOOP
    },
    fileList: {
      type: Array,
      default: () => []
    },
    autoUpload: {
      type: Boolean,
      default: true
    },
    listType: {
      type: String,
      default: "text"
    },
    httpRequest: {
      type: Function,
      default: () => upload
    },
    disabled: Boolean,
    limit: {
      type: Number,
      default: null
    },
    onExceed: {
      type: Function,
      default: NOOP
    }
  },
  setup(props2) {
    const reqs = ref({});
    const mouseover = ref(false);
    const inputRef = ref(null);
    function uploadFiles(files) {
      if (props2.limit && props2.fileList.length + files.length > props2.limit) {
        props2.onExceed(files, props2.fileList);
        return;
      }
      let postFiles = Array.from(files);
      if (!props2.multiple) {
        postFiles = postFiles.slice(0, 1);
      }
      if (postFiles.length === 0) {
        return;
      }
      postFiles.forEach((rawFile) => {
        props2.onStart(rawFile);
        if (props2.autoUpload)
          upload2(rawFile);
      });
    }
    function upload2(rawFile) {
      inputRef.value.value = null;
      if (!props2.beforeUpload) {
        return post(rawFile);
      }
      const before = props2.beforeUpload(rawFile);
      if (before instanceof Promise) {
        before.then((processedFile) => {
          const fileType = Object.prototype.toString.call(processedFile);
          if (fileType === "[object File]" || fileType === "[object Blob]") {
            if (fileType === "[object Blob]") {
              processedFile = new File([processedFile], rawFile.name, {
                type: rawFile.type
              });
            }
            for (const p in rawFile) {
              if (hasOwn(rawFile, p)) {
                processedFile[p] = rawFile[p];
              }
            }
            post(processedFile);
          } else {
            post(rawFile);
          }
        }).catch(() => {
          props2.onRemove(null, rawFile);
        });
      } else if (before !== false) {
        post(rawFile);
      } else {
        props2.onRemove(null, rawFile);
      }
    }
    function abort(file) {
      const _reqs = reqs.value;
      if (file) {
        let uid2 = file;
        if (file.uid)
          uid2 = file.uid;
        if (_reqs[uid2]) {
          _reqs[uid2].abort();
        }
      } else {
        Object.keys(_reqs).forEach((uid2) => {
          if (_reqs[uid2])
            _reqs[uid2].abort();
          delete _reqs[uid2];
        });
      }
    }
    function post(rawFile) {
      const { uid: uid2 } = rawFile;
      const options2 = {
        headers: props2.headers,
        withCredentials: props2.withCredentials,
        file: rawFile,
        data: props2.data,
        filename: props2.name,
        action: props2.action,
        onProgress: (e) => {
          props2.onProgress(e, rawFile);
        },
        onSuccess: (res) => {
          props2.onSuccess(res, rawFile);
          delete reqs.value[uid2];
        },
        onError: (err) => {
          props2.onError(err, rawFile);
          delete reqs.value[uid2];
        }
      };
      const req = props2.httpRequest(options2);
      reqs.value[uid2] = req;
      if (req instanceof Promise) {
        req.then(options2.onSuccess, options2.onError);
      }
    }
    function handleChange(e) {
      const files = e.target.files;
      if (!files)
        return;
      uploadFiles(files);
    }
    function handleClick() {
      if (!props2.disabled) {
        inputRef.value.value = null;
        inputRef.value.click();
      }
    }
    function handleKeydown() {
      handleClick();
    }
    return {
      reqs,
      mouseover,
      inputRef,
      abort,
      post,
      handleChange,
      handleClick,
      handleKeydown,
      upload: upload2,
      uploadFiles
    };
  }
});
const _hoisted_1$1$1 = ["name", "multiple", "accept"];
function render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_upload_dragger = resolveComponent("upload-dragger");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-upload", `el-upload--${_ctx.listType}`]),
    tabindex: "0",
    onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onKeydown: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args), ["self"]), ["enter", "space"]))
  }, [
    _ctx.drag ? (openBlock(), createBlock(_component_upload_dragger, {
      key: 0,
      disabled: _ctx.disabled,
      onFile: _ctx.uploadFiles
    }, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    }, 8, ["disabled", "onFile"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
    createElementVNode("input", {
      ref: "inputRef",
      class: "el-upload__input",
      type: "file",
      name: _ctx.name,
      multiple: _ctx.multiple,
      accept: _ctx.accept,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
    }, null, 40, _hoisted_1$1$1)
  ], 34);
}
script$2$1.render = render$2$1;
script$2$1.__file = "packages/components/upload/src/upload.vue";
var __defProp$4 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value2) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
function getFile(rawFile, uploadFiles) {
  return uploadFiles.find((file) => file.uid === rawFile.uid);
}
function genUid(seed2) {
  return Date.now() + seed2;
}
var useHandlers = (props2) => {
  const uploadFiles = ref([]);
  const uploadRef = ref(null);
  let tempIndex = 1;
  function abort(file) {
    uploadRef.value.abort(file);
  }
  function clearFiles() {
    uploadFiles.value = [];
  }
  function handleError(err, rawFile) {
    const file = getFile(rawFile, uploadFiles.value);
    file.status = "fail";
    uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
    props2.onError(err, file, uploadFiles.value);
    props2.onChange(file, uploadFiles.value);
  }
  function handleProgress(ev, rawFile) {
    const file = getFile(rawFile, uploadFiles.value);
    props2.onProgress(ev, file, uploadFiles.value);
    file.status = "uploading";
    file.percentage = ev.percent || 0;
  }
  function handleSuccess(res, rawFile) {
    const file = getFile(rawFile, uploadFiles.value);
    if (file) {
      file.status = "success";
      file.response = res;
      props2.onSuccess(res, file, uploadFiles.value);
      props2.onChange(file, uploadFiles.value);
    }
  }
  function handleStart(rawFile) {
    const uid2 = genUid(tempIndex++);
    rawFile.uid = uid2;
    const file = {
      name: rawFile.name,
      percentage: 0,
      status: "ready",
      size: rawFile.size,
      raw: rawFile,
      uid: uid2
    };
    if (props2.listType === "picture-card" || props2.listType === "picture") {
      try {
        file.url = URL.createObjectURL(rawFile);
      } catch (err) {
        console.error("[Element Error][Upload]", err);
        props2.onError(err, file, uploadFiles.value);
      }
    }
    uploadFiles.value.push(file);
    props2.onChange(file, uploadFiles.value);
  }
  function handleRemove(file, raw) {
    if (raw) {
      file = getFile(raw, uploadFiles.value);
    }
    const doRemove = () => {
      abort(file);
      const fileList = uploadFiles.value;
      fileList.splice(fileList.indexOf(file), 1);
      props2.onRemove(file, fileList);
    };
    if (!props2.beforeRemove) {
      doRemove();
    } else if (typeof props2.beforeRemove === "function") {
      const before = props2.beforeRemove(file, uploadFiles.value);
      if (before instanceof Promise) {
        before.then(() => {
          doRemove();
        }).catch(NOOP);
      } else if (before !== false) {
        doRemove();
      }
    }
  }
  function submit() {
    uploadFiles.value.filter((file) => file.status === "ready").forEach((file) => {
      uploadRef.value.upload(file.raw);
    });
  }
  watch(() => props2.listType, (val) => {
    if (val === "picture-card" || val === "picture") {
      uploadFiles.value = uploadFiles.value.map((file) => {
        if (!file.url && file.raw) {
          try {
            file.url = URL.createObjectURL(file.raw);
          } catch (err) {
            props2.onError(err, file, uploadFiles.value);
          }
        }
        return file;
      });
    }
  });
  watch(() => props2.fileList, (fileList) => {
    uploadFiles.value = fileList.map((file) => {
      const cloneFile = cloneDeep_1(file);
      return __spreadProps$4(__spreadValues$4({}, cloneFile), {
        uid: file.uid || genUid(tempIndex++),
        status: file.status || "success"
      });
    });
  }, {
    immediate: true,
    deep: true
  });
  return {
    abort,
    clearFiles,
    handleError,
    handleProgress,
    handleStart,
    handleSuccess,
    handleRemove,
    submit,
    uploadFiles,
    uploadRef
  };
};
var script$3$1 = defineComponent({
  name: "ElUpload",
  components: {
    Upload: script$2$1,
    UploadList: script$3
  },
  props: {
    action: {
      type: String,
      required: true
    },
    headers: {
      type: Object,
      default: () => ({})
    },
    data: {
      type: Object,
      default: () => ({})
    },
    multiple: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      default: "file"
    },
    drag: {
      type: Boolean,
      default: false
    },
    withCredentials: Boolean,
    showFileList: {
      type: Boolean,
      default: true
    },
    accept: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "select"
    },
    beforeUpload: {
      type: Function,
      default: NOOP
    },
    beforeRemove: {
      type: Function,
      default: NOOP
    },
    onRemove: {
      type: Function,
      default: NOOP
    },
    onChange: {
      type: Function,
      default: NOOP
    },
    onPreview: {
      type: Function,
      default: NOOP
    },
    onSuccess: {
      type: Function,
      default: NOOP
    },
    onProgress: {
      type: Function,
      default: NOOP
    },
    onError: {
      type: Function,
      default: NOOP
    },
    fileList: {
      type: Array,
      default: () => {
        return [];
      }
    },
    autoUpload: {
      type: Boolean,
      default: true
    },
    listType: {
      type: String,
      default: "text"
    },
    httpRequest: {
      type: Function,
      default: upload
    },
    disabled: Boolean,
    limit: {
      type: Number,
      default: null
    },
    onExceed: {
      type: Function,
      default: () => NOOP
    }
  },
  setup(props2) {
    const elForm = inject(elFormKey, {});
    const uploadDisabled = computed(() => {
      return props2.disabled || elForm.disabled;
    });
    const {
      abort,
      clearFiles,
      handleError,
      handleProgress,
      handleStart,
      handleSuccess,
      handleRemove,
      submit,
      uploadRef,
      uploadFiles
    } = useHandlers(props2);
    provide("uploader", getCurrentInstance());
    onBeforeUnmount(() => {
      uploadFiles.value.forEach((file) => {
        if (file.url && file.url.indexOf("blob:") === 0) {
          URL.revokeObjectURL(file.url);
        }
      });
    });
    return {
      abort,
      dragOver: ref(false),
      draging: ref(false),
      handleError,
      handleProgress,
      handleRemove,
      handleStart,
      handleSuccess,
      uploadDisabled,
      uploadFiles,
      uploadRef,
      submit,
      clearFiles
    };
  },
  render() {
    var _a, _b;
    let uploadList;
    if (this.showFileList) {
      uploadList = h(script$3, {
        disabled: this.uploadDisabled,
        listType: this.listType,
        files: this.uploadFiles,
        onRemove: this.handleRemove,
        handlePreview: this.onPreview
      }, this.$slots.file ? {
        default: (props2) => {
          return this.$slots.file({
            file: props2.file
          });
        }
      } : null);
    } else {
      uploadList = null;
    }
    const uploadData = {
      type: this.type,
      drag: this.drag,
      action: this.action,
      multiple: this.multiple,
      "before-upload": this.beforeUpload,
      "with-credentials": this.withCredentials,
      headers: this.headers,
      name: this.name,
      data: this.data,
      accept: this.accept,
      fileList: this.uploadFiles,
      autoUpload: this.autoUpload,
      listType: this.listType,
      disabled: this.uploadDisabled,
      limit: this.limit,
      "on-exceed": this.onExceed,
      "on-start": this.handleStart,
      "on-progress": this.handleProgress,
      "on-success": this.handleSuccess,
      "on-error": this.handleError,
      "on-preview": this.onPreview,
      "on-remove": this.handleRemove,
      "http-request": this.httpRequest,
      ref: "uploadRef"
    };
    const trigger = this.$slots.trigger || this.$slots.default;
    const uploadComponent = h(script$2$1, uploadData, {
      default: () => trigger == null ? void 0 : trigger()
    });
    return h("div", [
      this.listType === "picture-card" ? uploadList : null,
      this.$slots.trigger ? [uploadComponent, this.$slots.default()] : uploadComponent,
      (_b = (_a = this.$slots).tip) == null ? void 0 : _b.call(_a),
      this.listType !== "picture-card" ? uploadList : null
    ]);
  }
});
script$3$1.__file = "packages/components/upload/src/workprogress.vue";
script$3$1.install = (app) => {
  app.component(script$3$1.name, script$3$1);
};
const _Upload = script$3$1;
const ElUpload = _Upload;
var component = [
  ElAffix,
  ElAlert,
  ElAutocomplete,
  ElAvatar,
  ElBacktop,
  ElBadge,
  ElBreadcrumb,
  ElButton,
  ElCalendar,
  ElCard,
  ElCarousel,
  ElCascader,
  ElCascaderPanel,
  ElCheckTag,
  ElCheckbox,
  ElCol$1,
  ElCollapse,
  ElCollapseTransition,
  ElColorPicker,
  ElConfigProvider,
  ElContainer,
  ElDatePicker,
  ElDescriptions,
  ElDialog,
  ElDivider,
  ElDrawer,
  ElDropdown,
  ElEmpty,
  ElForm,
  ElIcon,
  ElImage,
  ElImageViewer,
  ElInput,
  ElInputNumber,
  ElLink,
  ElMenu,
  ElPageHeader,
  ElPagination,
  ElPopconfirm,
  ElPopover,
  ElPopper,
  ElProgress,
  ElRadio,
  ElRate,
  ElResult,
  ElRow,
  ElScrollbar,
  ElSelect,
  ElSelectV2,
  ElSkeleton,
  ElSlider,
  ElSpace,
  ElSteps,
  ElSwitch,
  ElTable,
  ElTabs,
  ElTag,
  ElTimePicker,
  ElTimeSelect,
  ElTimeline,
  ElTooltip,
  ElTransfer,
  ElTree,
  ElUpload
];
var Components = component;
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const SCOPE = "ElInfiniteScroll";
const CHECK_INTERVAL = 50;
const DEFAULT_DELAY = 200;
const DEFAULT_DISTANCE = 0;
const attributes = {
  delay: {
    type: Number,
    default: DEFAULT_DELAY
  },
  distance: {
    type: Number,
    default: DEFAULT_DISTANCE
  },
  disabled: {
    type: Boolean,
    default: false
  },
  immediate: {
    type: Boolean,
    default: true
  }
};
const getScrollOptions = (el, instance) => {
  return entries(attributes).reduce((acm, [name2, option2]) => {
    var _a, _b;
    const { type: type2, default: defaultValue2 } = option2;
    const attrVal = el.getAttribute(`infinite-scroll-${name2}`);
    let value2 = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue2;
    value2 = value2 === "false" ? false : value2;
    value2 = type2(value2);
    acm[name2] = Number.isNaN(value2) ? defaultValue2 : value2;
    return acm;
  }, {});
};
const destroyObserver = (el) => {
  const { observer } = el[SCOPE];
  if (observer) {
    observer.disconnect();
    delete el[SCOPE].observer;
  }
};
const handleScroll = (el, cb) => {
  const {
    container,
    containerEl,
    instance,
    observer,
    lastScrollTop
  } = el[SCOPE];
  const { disabled, distance } = getScrollOptions(el, instance);
  const { clientHeight, scrollHeight, scrollTop } = containerEl;
  const delta = scrollTop - lastScrollTop;
  el[SCOPE].lastScrollTop = scrollTop;
  if (observer || disabled || delta < 0)
    return;
  let shouldTrigger = false;
  if (container === el) {
    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;
  } else {
    const { clientTop, scrollHeight: height } = el;
    const offsetTop = getOffsetTopDistance(el, containerEl);
    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;
  }
  if (shouldTrigger) {
    cb.call(instance);
  }
};
function checkFull(el, cb) {
  const { containerEl, instance } = el[SCOPE];
  const { disabled } = getScrollOptions(el, instance);
  if (disabled)
    return;
  if (containerEl.scrollHeight <= containerEl.clientHeight) {
    cb.call(instance);
  } else {
    destroyObserver(el);
  }
}
const InfiniteScroll = {
  mounted(el, binding) {
    return __async$2(this, null, function* () {
      const { instance, value: cb } = binding;
      if (!isFunction$4(cb)) {
        throwError(SCOPE, "'v-infinite-scroll' binding value must be a function");
      }
      yield nextTick();
      const { delay, immediate } = getScrollOptions(el, instance);
      const container = getScrollContainer(el, true);
      const containerEl = container === window ? document.documentElement : container;
      const onScroll = throttle_1(handleScroll.bind(null, el, cb), delay);
      if (!container)
        return;
      el[SCOPE] = {
        instance,
        container,
        containerEl,
        delay,
        cb,
        onScroll,
        lastScrollTop: containerEl.scrollTop
      };
      if (immediate) {
        const observer = new MutationObserver(throttle_1(checkFull.bind(null, el, cb), CHECK_INTERVAL));
        el[SCOPE].observer = observer;
        observer.observe(el, { childList: true, subtree: true });
        checkFull(el, cb);
      }
      container.addEventListener("scroll", onScroll);
    });
  },
  unmounted(el) {
    const { container, onScroll } = el[SCOPE];
    container == null ? void 0 : container.removeEventListener("scroll", onScroll);
    destroyObserver(el);
  }
};
const _InfiniteScroll = InfiniteScroll;
_InfiniteScroll.install = (app) => {
  app.directive("InfiniteScroll", _InfiniteScroll);
};
const ElInfiniteScroll = _InfiniteScroll;
var __defProp$3 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value2) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
function createLoadingComponent({
  options: options2,
  globalLoadingOption: globalLoadingOption2
}) {
  let vm = null;
  let afterLeaveTimer = null;
  const afterLeaveFlag = ref(false);
  const data = reactive(__spreadProps$3(__spreadValues$3({}, options2), {
    originalPosition: "",
    originalOverflow: "",
    visible: false
  }));
  function setText(text) {
    data.text = text;
  }
  function destroySelf() {
    const target = data.parent;
    if (!target.vLoadingAddClassList) {
      let loadingNumber = target.getAttribute("loading-number");
      loadingNumber = Number.parseInt(loadingNumber) - 1;
      if (!loadingNumber) {
        removeClass(target, "el-loading-parent--relative");
        target.removeAttribute("loading-number");
      } else {
        target.setAttribute("loading-number", loadingNumber.toString());
      }
      removeClass(target, "el-loading-parent--hidden");
    }
    if (vm.el && vm.el.parentNode) {
      vm.el.parentNode.removeChild(vm.el);
    }
  }
  function close2() {
    const target = data.parent;
    target.vLoadingAddClassList = null;
    if (data.fullscreen) {
      globalLoadingOption2.fullscreenLoading = void 0;
    }
    afterLeaveFlag.value = true;
    clearTimeout(afterLeaveTimer);
    afterLeaveTimer = window.setTimeout(() => {
      if (afterLeaveFlag.value) {
        afterLeaveFlag.value = false;
        destroySelf();
      }
    }, 400);
    data.visible = false;
  }
  function handleAfterLeave() {
    if (!afterLeaveFlag.value)
      return;
    afterLeaveFlag.value = false;
    destroySelf();
  }
  const componentSetupConfig = __spreadProps$3(__spreadValues$3({}, toRefs(data)), {
    setText,
    close: close2,
    handleAfterLeave
  });
  const elLoadingComponent = {
    name: "ElLoading",
    setup() {
      return componentSetupConfig;
    },
    render() {
      const spinner = h("svg", __spreadValues$3({
        class: "circular",
        viewBox: this.svgViewBox ? this.svgViewBox : "25 25 50 50"
      }, this.svg ? { innerHTML: this.svg } : {}), [
        h("circle", { class: "path", cx: "50", cy: "50", r: "20", fill: "none" })
      ]);
      const noSpinner = h("i", { class: this.spinner });
      const spinnerText = h("p", { class: "el-loading-text" }, [this.text]);
      return h(Transition, {
        name: "el-loading-fade",
        onAfterLeave: this.handleAfterLeave
      }, {
        default: withCtx(() => [withDirectives(createVNode("div", {
          style: {
            backgroundColor: this.background || ""
          },
          class: [
            "el-loading-mask",
            this.customClass,
            this.fullscreen ? "is-fullscreen" : ""
          ]
        }, [
          h("div", {
            class: "el-loading-spinner"
          }, [
            !this.spinner ? spinner : noSpinner,
            this.text ? spinnerText : null
          ])
        ]), [[vShow, this.visible]])])
      });
    }
  };
  vm = createVNode(elLoadingComponent);
  render$Z(vm, document.createElement("div"));
  return __spreadProps$3(__spreadValues$3({}, componentSetupConfig), {
    vm,
    get $el() {
      return vm.el;
    }
  });
}
var __defProp$1$1 = Object.defineProperty;
var __getOwnPropSymbols$1$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$1 = (obj, key, value2) => key in obj ? __defProp$1$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$1.call(b, prop))
      __defNormalProp$1$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$1)
    for (var prop of __getOwnPropSymbols$1$1(b)) {
      if (__propIsEnum$1$1.call(b, prop))
        __defNormalProp$1$1(a, prop, b[prop]);
    }
  return a;
};
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const defaults$8 = {
  parent: null,
  background: "",
  svg: null,
  svgViewBox: null,
  spinner: false,
  text: null,
  fullscreen: true,
  body: false,
  lock: false,
  customClass: ""
};
const globalLoadingOption = {
  fullscreenLoading: null
};
const addStyle = (options2, parent2, instance) => __async$1(void 0, null, function* () {
  const maskStyle = {};
  if (options2.fullscreen) {
    instance.originalPosition.value = getStyle(document.body, "position");
    instance.originalOverflow.value = getStyle(document.body, "overflow");
    maskStyle.zIndex = String(PopupManager$1.nextZIndex());
  } else if (options2.body) {
    instance.originalPosition.value = getStyle(document.body, "position");
    yield nextTick();
    ["top", "left"].forEach((property) => {
      const scroll = property === "top" ? "scrollTop" : "scrollLeft";
      maskStyle[property] = options2.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - parseInt(getStyle(document.body, `margin-${property}`), 10) + "px";
    });
    ["height", "width"].forEach((property) => {
      maskStyle[property] = options2.target.getBoundingClientRect()[property] + "px";
    });
  } else {
    instance.originalPosition.value = getStyle(parent2, "position");
  }
  Object.keys(maskStyle).forEach((property) => {
    instance.$el.style[property] = maskStyle[property];
  });
});
const addClassList = (options2, parent2, instance) => {
  if (instance.originalPosition.value !== "absolute" && instance.originalPosition.value !== "fixed") {
    addClass$1(parent2, "el-loading-parent--relative");
  } else {
    removeClass(parent2, "el-loading-parent--relative");
  }
  if (options2.fullscreen && options2.lock) {
    addClass$1(parent2, "el-loading-parent--hidden");
  } else {
    removeClass(parent2, "el-loading-parent--hidden");
  }
};
const Loading = function(options2 = {}) {
  if (isServer)
    return;
  options2 = __spreadValues$1$1(__spreadValues$1$1({}, defaults$8), options2);
  if (typeof options2.target === "string") {
    options2.target = document.querySelector(options2.target);
  }
  options2.target = options2.target || document.body;
  if (options2.target !== document.body) {
    options2.fullscreen = false;
  } else {
    options2.body = true;
  }
  if (options2.fullscreen && globalLoadingOption.fullscreenLoading) {
    globalLoadingOption.fullscreenLoading.close();
  }
  const parent2 = options2.body ? document.body : options2.target;
  options2.parent = parent2;
  const instance = createLoadingComponent({
    options: options2,
    globalLoadingOption
  });
  addStyle(options2, parent2, instance);
  addClassList(options2, parent2, instance);
  options2.parent.vLoadingAddClassList = () => {
    addClassList(options2, parent2, instance);
  };
  let loadingNumber = parent2.getAttribute("loading-number");
  if (!loadingNumber) {
    loadingNumber = 1;
  } else {
    loadingNumber = Number.parseInt(loadingNumber) + 1;
  }
  parent2.setAttribute("loading-number", loadingNumber.toString());
  parent2.appendChild(instance.$el);
  nextTick().then(() => {
    instance.visible.value = hasOwn(options2, "visible") ? options2.visible : true;
  });
  if (options2.fullscreen) {
    globalLoadingOption.fullscreenLoading = instance;
  }
  return instance;
};
const createInstance$1 = (el, binding) => {
  const textExr = el.getAttribute("element-loading-text");
  const spinnerExr = el.getAttribute("element-loading-spinner");
  const svgExr = el.getAttribute("element-loading-svg");
  const svgViewBoxExr = el.getAttribute("element-loading-svg-view-box");
  const backgroundExr = el.getAttribute("element-loading-background");
  const customClassExr = el.getAttribute("element-loading-custom-class");
  const vm = binding.instance;
  el.instance = Loading({
    text: vm && vm[textExr] || textExr,
    svg: vm && vm[svgExr] || svgExr,
    svgViewBox: vm && vm[svgViewBoxExr] || svgViewBoxExr,
    spinner: vm && vm[spinnerExr] || spinnerExr,
    background: vm && vm[backgroundExr] || backgroundExr,
    customClass: vm && vm[customClassExr] || customClassExr,
    fullscreen: !!binding.modifiers.fullscreen,
    target: !!binding.modifiers.fullscreen ? null : el,
    body: !!binding.modifiers.body,
    visible: true,
    lock: !!binding.modifiers.lock
  });
};
const vLoading = {
  mounted(el, binding) {
    if (!!binding.value) {
      createInstance$1(el, binding);
    }
  },
  updated(el, binding) {
    const instance = el.instance;
    if (binding.oldValue !== binding.value) {
      if (binding.value) {
        createInstance$1(el, binding);
      } else {
        instance.close();
      }
    }
  },
  unmounted(el) {
    var _a;
    (_a = el == null ? void 0 : el.instance) == null ? void 0 : _a.close();
  }
};
const ElLoading = {
  install(app) {
    app.directive("loading", vLoading);
    app.config.globalProperties.$loading = Loading;
  },
  directive: vLoading,
  service: Loading
};
const TypeMap$2 = {
  success: "success",
  info: "info",
  warning: "warning",
  error: "error"
};
var script$2 = defineComponent({
  name: "ElMessage",
  props: {
    customClass: { type: String, default: "" },
    center: { type: Boolean, default: false },
    dangerouslyUseHTMLString: { type: Boolean, default: false },
    duration: { type: Number, default: 3e3 },
    iconClass: { type: String, default: "" },
    id: { type: String, default: "" },
    message: {
      type: [String, Object],
      default: ""
    },
    onClose: {
      type: Function,
      required: true
    },
    showClose: { type: Boolean, default: false },
    type: { type: String, default: "info" },
    offset: { type: Number, default: 20 },
    zIndex: { type: Number, default: 0 }
  },
  emits: ["destroy"],
  setup(props2) {
    const typeClass = computed(() => {
      const type2 = !props2.iconClass && props2.type;
      return type2 && TypeMap$2[type2] ? `el-icon-${TypeMap$2[type2]}` : "";
    });
    const customStyle = computed(() => {
      return {
        top: `${props2.offset}px`,
        zIndex: props2.zIndex
      };
    });
    const visible2 = ref(false);
    let timer = null;
    function startTimer() {
      if (props2.duration > 0) {
        timer = setTimeout(() => {
          if (visible2.value) {
            close2();
          }
        }, props2.duration);
      }
    }
    function clearTimer2() {
      clearTimeout(timer);
      timer = null;
    }
    function close2() {
      visible2.value = false;
    }
    function keydown({ code }) {
      if (code === EVENT_CODE.esc) {
        if (visible2.value) {
          close2();
        }
      } else {
        startTimer();
      }
    }
    onMounted(() => {
      startTimer();
      visible2.value = true;
      on$2(document, "keydown", keydown);
    });
    onBeforeUnmount(() => {
      off$2(document, "keydown", keydown);
    });
    return {
      typeClass,
      customStyle,
      visible: visible2,
      close: close2,
      clearTimer: clearTimer2,
      startTimer
    };
  }
});
const _hoisted_1$t = ["id"];
const _hoisted_2$o = {
  key: 0,
  class: "el-message__content"
};
const _hoisted_3$n = ["innerHTML"];
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "el-message-fade",
    onBeforeLeave: _ctx.onClose,
    onAfterLeave: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("destroy"))
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        id: _ctx.id,
        class: normalizeClass([
          "el-message",
          _ctx.type && !_ctx.iconClass ? `el-message--${_ctx.type}` : "",
          _ctx.center ? "is-center" : "",
          _ctx.showClose ? "is-closable" : "",
          _ctx.customClass
        ]),
        style: normalizeStyle(_ctx.customStyle),
        role: "alert",
        onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.startTimer && _ctx.startTimer(...args))
      }, [
        _ctx.type || _ctx.iconClass ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass(["el-message__icon", _ctx.typeClass, _ctx.iconClass])
        }, null, 2)) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default", {}, () => [
          !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", _hoisted_2$o, toDisplayString(_ctx.message), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
            createCommentVNode("  eslint-disable-next-line "),
            createElementVNode("p", {
              class: "el-message__content",
              innerHTML: _ctx.message
            }, null, 8, _hoisted_3$n)
          ], 2112))
        ]),
        _ctx.showClose ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: "el-message__closeBtn el-icon-close",
          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.close && _ctx.close(...args), ["stop"]))
        })) : createCommentVNode("v-if", true)
      ], 46, _hoisted_1$t), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  }, 8, ["onBeforeLeave"]);
}
script$2.render = render$2;
script$2.__file = "packages/components/message/src/workprogress.vue";
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value2) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const instances = [];
let seed$1 = 1;
const Message$1 = function(opts = {}) {
  if (isServer)
    return;
  if (typeof opts === "string") {
    opts = {
      message: opts
    };
  }
  let options2 = opts;
  let verticalOffset = opts.offset || 20;
  instances.forEach(({ vm: vm2 }) => {
    verticalOffset += (vm2.el.offsetHeight || 0) + 16;
  });
  verticalOffset += 16;
  const id2 = "message_" + seed$1++;
  const userOnClose = options2.onClose;
  options2 = __spreadProps$2(__spreadValues$2({}, options2), {
    onClose: () => {
      close$1(id2, userOnClose);
    },
    offset: verticalOffset,
    id: id2,
    zIndex: PopupManager$1.nextZIndex()
  });
  const container = document.createElement("div");
  container.className = `container_${id2}`;
  const message2 = options2.message;
  const vm = createVNode(script$2, options2, isVNode(options2.message) ? { default: () => message2 } : null);
  vm.props.onDestroy = () => {
    render$Z(null, container);
  };
  render$Z(vm, container);
  instances.push({ vm });
  document.body.appendChild(container.firstElementChild);
  return {
    close: () => vm.component.proxy.visible = false
  };
};
function close$1(id2, userOnClose) {
  const idx = instances.findIndex(({ vm: vm2 }) => {
    const { id: _id } = vm2.component.props;
    return id2 === _id;
  });
  if (idx === -1) {
    return;
  }
  const { vm } = instances[idx];
  if (!vm)
    return;
  userOnClose == null ? void 0 : userOnClose(vm);
  const removedHeight = vm.el.offsetHeight;
  instances.splice(idx, 1);
  const len = instances.length;
  if (len < 1)
    return;
  for (let i2 = idx; i2 < len; i2++) {
    const pos = parseInt(instances[i2].vm.el.style["top"], 10) - removedHeight - 16;
    instances[i2].vm.component.props.offset = pos;
  }
}
function closeAll$1() {
  for (let i2 = instances.length - 1; i2 >= 0; i2--) {
    const instance = instances[i2].vm.component;
    instance.ctx.close();
  }
}
["success", "warning", "info", "error"].forEach((type2) => {
  Message$1[type2] = (options2) => {
    if (typeof options2 === "string") {
      options2 = {
        message: options2,
        type: type2
      };
    } else {
      options2.type = type2;
    }
    return Message$1(options2);
  };
});
Message$1.closeAll = closeAll$1;
const _Message = Message$1;
_Message.install = (app) => {
  app.config.globalProperties.$message = _Message;
};
const ElMessage = _Message;
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value2) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const TypeMap$1 = {
  success: "success",
  info: "info",
  warning: "warning",
  error: "error"
};
var script$1 = defineComponent({
  name: "ElMessageBox",
  directives: {
    TrapFocus: TrapFocus$1
  },
  components: {
    ElButton: _Button,
    ElInput: ElInput$1,
    ElOverlay: script$A
  },
  inheritAttrs: false,
  props: {
    buttonSize: {
      type: String,
      validator: isValidComponentSize
    },
    modal: {
      type: Boolean,
      default: true
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    closeOnHashChange: {
      type: Boolean,
      default: true
    },
    center: Boolean,
    roundButton: {
      default: false,
      type: Boolean
    },
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(props2, { emit: emit2 }) {
    const { t } = useLocaleInject();
    const visible2 = ref(false);
    const state = reactive({
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      customClass: "",
      dangerouslyUseHTMLString: false,
      distinguishCancelAndClose: false,
      iconClass: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: null,
      inputValidator: null,
      inputErrorMessage: "",
      message: null,
      modalFade: true,
      modalClass: "",
      showCancelButton: false,
      showConfirmButton: true,
      type: "",
      title: void 0,
      showInput: false,
      action: "",
      confirmButtonLoading: false,
      cancelButtonLoading: false,
      confirmButtonDisabled: false,
      editorErrorMessage: "",
      validateError: false,
      zIndex: PopupManager$1.nextZIndex()
    });
    const icon = computed(() => state.iconClass || (state.type && TypeMap$1[state.type] ? `el-icon-${TypeMap$1[state.type]}` : ""));
    const hasMessage = computed(() => !!state.message);
    const inputRef = ref(null);
    const confirmRef = ref(null);
    const confirmButtonClasses = computed(() => `el-button--primary ${state.confirmButtonClass}`);
    watch(() => state.inputValue, (val) => __async(this, null, function* () {
      yield nextTick();
      if (props2.boxType === "prompt" && val !== null) {
        validate2();
      }
    }), { immediate: true });
    watch(() => visible2.value, (val) => {
      if (val) {
        if (props2.boxType === "alert" || props2.boxType === "confirm") {
          nextTick().then(() => {
            var _a, _b, _c;
            (_c = (_b = (_a = confirmRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.focus) == null ? void 0 : _c.call(_b);
          });
        }
        state.zIndex = PopupManager$1.nextZIndex();
      }
      if (props2.boxType !== "prompt")
        return;
      if (val) {
        nextTick().then(() => {
          if (inputRef.value && inputRef.value.$el) {
            getInputElement().focus();
          }
        });
      } else {
        state.editorErrorMessage = "";
        state.validateError = false;
      }
    });
    onMounted(() => __async(this, null, function* () {
      yield nextTick();
      if (props2.closeOnHashChange) {
        on$2(window, "hashchange", doClose);
      }
    }));
    onBeforeUnmount(() => {
      if (props2.closeOnHashChange) {
        off$2(window, "hashchange", doClose);
      }
    });
    function doClose() {
      if (!visible2.value)
        return;
      visible2.value = false;
      nextTick(() => {
        if (state.action)
          emit2("action", state.action);
      });
    }
    const handleWrapperClick = () => {
      if (props2.closeOnClickModal) {
        handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
      }
    };
    const handleInputEnter = () => {
      if (state.inputType !== "textarea") {
        return handleAction("confirm");
      }
    };
    const handleAction = (action) => {
      var _a;
      if (props2.boxType === "prompt" && action === "confirm" && !validate2()) {
        return;
      }
      state.action = action;
      if (state.beforeClose) {
        (_a = state.beforeClose) == null ? void 0 : _a.call(state, action, state, doClose);
      } else {
        doClose();
      }
    };
    const validate2 = () => {
      if (props2.boxType === "prompt") {
        const inputPattern = state.inputPattern;
        if (inputPattern && !inputPattern.test(state.inputValue || "")) {
          state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
          state.validateError = true;
          return false;
        }
        const inputValidator = state.inputValidator;
        if (typeof inputValidator === "function") {
          const validateResult = inputValidator(state.inputValue);
          if (validateResult === false) {
            state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
            state.validateError = true;
            return false;
          }
          if (typeof validateResult === "string") {
            state.editorErrorMessage = validateResult;
            state.validateError = true;
            return false;
          }
        }
      }
      state.editorErrorMessage = "";
      state.validateError = false;
      return true;
    };
    const getInputElement = () => {
      const inputRefs = inputRef.value.$refs;
      return inputRefs.input || inputRefs.textarea;
    };
    const handleClose = () => {
      handleAction("close");
    };
    if (props2.closeOnPressEscape) {
      useModal({
        handleClose
      }, visible2);
    } else {
      usePreventGlobal(visible2, "keydown", (e) => e.code === EVENT_CODE.esc);
    }
    if (props2.lockScroll) {
      useLockScreen(visible2);
    }
    useRestoreActive(visible2);
    return __spreadProps$1(__spreadValues$1({}, toRefs(state)), {
      visible: visible2,
      hasMessage,
      icon,
      confirmButtonClasses,
      inputRef,
      confirmRef,
      doClose,
      handleClose,
      handleWrapperClick,
      handleInputEnter,
      handleAction,
      t
    });
  }
});
const _hoisted_1$s = ["aria-label"];
const _hoisted_2$n = {
  key: 0,
  class: "el-message-box__header"
};
const _hoisted_3$m = { class: "el-message-box__title" };
const _hoisted_4$h = /* @__PURE__ */ createElementVNode("i", { class: "el-message-box__close el-icon-close" }, null, -1);
const _hoisted_5$d = [
  _hoisted_4$h
];
const _hoisted_6$b = { class: "el-message-box__content" };
const _hoisted_7$9 = { class: "el-message-box__container" };
const _hoisted_8$9 = {
  key: 1,
  class: "el-message-box__message"
};
const _hoisted_9$9 = { key: 0 };
const _hoisted_10$6 = ["innerHTML"];
const _hoisted_11$5 = { class: "el-message-box__input" };
const _hoisted_12$5 = { class: "el-message-box__btns" };
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_overlay = resolveComponent("el-overlay");
  const _directive_trap_focus = resolveDirective("trap-focus");
  return openBlock(), createBlock(Transition, {
    name: "fade-in-linear",
    onAfterLeave: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("vanish"))
  }, {
    default: withCtx(() => [
      withDirectives(createVNode(_component_el_overlay, {
        "z-index": _ctx.zIndex,
        "overlay-class": ["is-message-box", _ctx.modalClass],
        mask: _ctx.modal,
        onClick: withModifiers(_ctx.handleWrapperClick, ["self"])
      }, {
        default: withCtx(() => [
          withDirectives(createElementVNode("div", {
            ref: "root",
            "aria-label": _ctx.title || "dialog",
            "aria-modal": "true",
            class: normalizeClass([
              "el-message-box",
              _ctx.customClass,
              { "el-message-box--center": _ctx.center }
            ])
          }, [
            _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", _hoisted_2$n, [
              createElementVNode("div", _hoisted_3$m, [
                _ctx.icon && _ctx.center ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["el-message-box__status", _ctx.icon])
                }, null, 2)) : createCommentVNode("v-if", true),
                createElementVNode("span", null, toDisplayString(_ctx.title), 1)
              ]),
              _ctx.showClose ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                class: "el-message-box__headerbtn",
                "aria-label": "Close",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
              }, _hoisted_5$d, 32)) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true),
            createElementVNode("div", _hoisted_6$b, [
              createElementVNode("div", _hoisted_7$9, [
                _ctx.icon && !_ctx.center && _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["el-message-box__status", _ctx.icon])
                }, null, 2)) : createCommentVNode("v-if", true),
                _ctx.hasMessage ? (openBlock(), createElementBlock("div", _hoisted_8$9, [
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", _hoisted_9$9, toDisplayString(_ctx.message), 1)) : (openBlock(), createElementBlock("p", {
                      key: 1,
                      innerHTML: _ctx.message
                    }, null, 8, _hoisted_10$6))
                  ])
                ])) : createCommentVNode("v-if", true)
              ]),
              withDirectives(createElementVNode("div", _hoisted_11$5, [
                createVNode(_component_el_input, {
                  ref: "inputRef",
                  modelValue: _ctx.inputValue,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                  type: _ctx.inputType,
                  placeholder: _ctx.inputPlaceholder,
                  class: normalizeClass({ invalid: _ctx.validateError }),
                  onKeydown: withKeys(withModifiers(_ctx.handleInputEnter, ["prevent"]), ["enter"])
                }, null, 8, ["modelValue", "type", "placeholder", "class", "onKeydown"]),
                createElementVNode("div", {
                  class: "el-message-box__errormsg",
                  style: normalizeStyle({
                    visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                  })
                }, toDisplayString(_ctx.editorErrorMessage), 5)
              ], 512), [
                [vShow, _ctx.showInput]
              ])
            ]),
            createElementVNode("div", _hoisted_12$5, [
              _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                key: 0,
                loading: _ctx.cancelButtonLoading,
                class: normalizeClass([_ctx.cancelButtonClass]),
                round: _ctx.roundButton,
                size: _ctx.buttonSize || "small",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                ]),
                _: 1
              }, 8, ["loading", "class", "round", "size"])) : createCommentVNode("v-if", true),
              withDirectives(createVNode(_component_el_button, {
                ref: "confirmRef",
                loading: _ctx.confirmButtonLoading,
                class: normalizeClass([_ctx.confirmButtonClasses]),
                round: _ctx.roundButton,
                disabled: _ctx.confirmButtonDisabled,
                size: _ctx.buttonSize || "small",
                onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                ]),
                _: 1
              }, 8, ["loading", "class", "round", "disabled", "size"]), [
                [vShow, _ctx.showConfirmButton]
              ])
            ])
          ], 10, _hoisted_1$s), [
            [_directive_trap_focus]
          ])
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask", "onClick"]), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  });
}
script$1.render = render$1;
script$1.__file = "packages/components/message-box/src/workprogress.vue";
const messageInstance = new Map();
const initInstance = (props2, container) => {
  const vnode = h(script$1, props2);
  render$Z(vnode, container);
  document.body.appendChild(container.firstElementChild);
  return vnode.component;
};
const genContainer = () => {
  return document.createElement("div");
};
const showMessage = (options2) => {
  const container = genContainer();
  options2.onVanish = () => {
    render$Z(null, container);
    messageInstance.delete(vm);
  };
  options2.onAction = (action) => {
    const currentMsg = messageInstance.get(vm);
    let resolve;
    if (options2.showInput) {
      resolve = { value: vm.inputValue, action };
    } else {
      resolve = action;
    }
    if (options2.callback) {
      options2.callback(resolve, instance.proxy);
    } else {
      if (action === "cancel" || action === "close") {
        if (options2.distinguishCancelAndClose && action !== "cancel") {
          currentMsg.reject("close");
        } else {
          currentMsg.reject("cancel");
        }
      } else {
        currentMsg.resolve(resolve);
      }
    }
  };
  const instance = initInstance(options2, container);
  const vm = instance.proxy;
  for (const prop in options2) {
    if (hasOwn(options2, prop) && !hasOwn(vm.$props, prop)) {
      vm[prop] = options2[prop];
    }
  }
  watch(() => vm.message, (newVal, oldVal) => {
    if (isVNode(newVal)) {
      instance.slots.default = () => [newVal];
    } else if (isVNode(oldVal) && !isVNode(newVal)) {
      delete instance.slots.default;
    }
  }, {
    immediate: true
  });
  vm.visible = true;
  return vm;
};
function MessageBox(options2) {
  if (isServer)
    return;
  let callback;
  if (isString$1(options2) || isVNode(options2)) {
    options2 = {
      message: options2
    };
  } else {
    callback = options2.callback;
  }
  return new Promise((resolve, reject) => {
    const vm = showMessage(options2);
    messageInstance.set(vm, {
      options: options2,
      callback,
      resolve,
      reject
    });
  });
}
MessageBox.alert = (message2, title, options2) => {
  if (typeof title === "object") {
    options2 = title;
    title = "";
  } else if (title === void 0) {
    title = "";
  }
  return MessageBox(Object.assign({
    title,
    message: message2,
    type: "",
    closeOnPressEscape: false,
    closeOnClickModal: false
  }, options2, {
    boxType: "alert"
  }));
};
MessageBox.confirm = (message2, title, options2) => {
  if (typeof title === "object") {
    options2 = title;
    title = "";
  } else if (title === void 0) {
    title = "";
  }
  return MessageBox(Object.assign({
    title,
    message: message2,
    type: "",
    showCancelButton: true
  }, options2, {
    boxType: "confirm"
  }));
};
MessageBox.prompt = (message2, title, options2) => {
  if (typeof title === "object") {
    options2 = title;
    title = "";
  } else if (title === void 0) {
    title = "";
  }
  return MessageBox(Object.assign({
    title,
    message: message2,
    showCancelButton: true,
    showInput: true,
    type: ""
  }, options2, {
    boxType: "prompt"
  }));
};
MessageBox.close = () => {
  messageInstance.forEach((_, vm) => {
    vm.doClose();
  });
  messageInstance.clear();
};
const _MessageBox = MessageBox;
_MessageBox.install = (app) => {
  app.config.globalProperties.$msgbox = _MessageBox;
  app.config.globalProperties.$messageBox = _MessageBox;
  app.config.globalProperties.$alert = _MessageBox.alert;
  app.config.globalProperties.$confirm = _MessageBox.confirm;
  app.config.globalProperties.$prompt = _MessageBox.prompt;
};
const ElMessageBox = _MessageBox;
const TypeMap = {
  success: "success",
  info: "info",
  warning: "warning",
  error: "error"
};
var script = defineComponent({
  name: "ElNotification",
  props: {
    customClass: { type: String, default: "" },
    dangerouslyUseHTMLString: { type: Boolean, default: false },
    duration: { type: Number, default: 4500 },
    iconClass: { type: String, default: "" },
    id: { type: String, default: "" },
    message: {
      type: [String, Object],
      default: ""
    },
    offset: { type: Number, default: 0 },
    onClick: {
      type: Function,
      default: () => void 0
    },
    onClose: {
      type: Function,
      required: true
    },
    position: {
      type: String,
      default: "top-right"
    },
    showClose: { type: Boolean, default: true },
    title: { type: String, default: "" },
    type: { type: String, default: "" },
    zIndex: { type: Number, default: 0 }
  },
  emits: ["destroy"],
  setup(props2) {
    const visible2 = ref(false);
    let timer = null;
    const typeClass = computed(() => {
      const type2 = props2.type;
      return type2 && TypeMap[type2] ? `el-icon-${TypeMap[type2]}` : "";
    });
    const horizontalClass = computed(() => {
      return props2.position.indexOf("right") > 1 ? "right" : "left";
    });
    const verticalProperty = computed(() => {
      return props2.position.startsWith("top") ? "top" : "bottom";
    });
    const positionStyle = computed(() => {
      return {
        [verticalProperty.value]: `${props2.offset}px`,
        "z-index": props2.zIndex
      };
    });
    function startTimer() {
      if (props2.duration > 0) {
        timer = setTimeout(() => {
          if (visible2.value) {
            close2();
          }
        }, props2.duration);
      }
    }
    function clearTimer2() {
      clearTimeout(timer);
      timer = null;
    }
    function close2() {
      visible2.value = false;
    }
    function onKeydown({ code }) {
      if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
        clearTimer2();
      } else if (code === EVENT_CODE.esc) {
        if (visible2.value) {
          close2();
        }
      } else {
        startTimer();
      }
    }
    onMounted(() => {
      startTimer();
      visible2.value = true;
      on$2(document, "keydown", onKeydown);
    });
    onBeforeUnmount(() => {
      off$2(document, "keydown", onKeydown);
    });
    return {
      horizontalClass,
      typeClass,
      positionStyle,
      visible: visible2,
      close: close2,
      clearTimer: clearTimer2,
      startTimer
    };
  }
});
const _hoisted_1$r = ["id"];
const _hoisted_2$m = ["textContent"];
const _hoisted_3$l = { key: 0 };
const _hoisted_4$g = ["innerHTML"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "el-notification-fade",
    onBeforeLeave: _ctx.onClose,
    onAfterLeave: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("destroy"))
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        id: _ctx.id,
        class: normalizeClass(["el-notification", _ctx.customClass, _ctx.horizontalClass]),
        style: normalizeStyle(_ctx.positionStyle),
        role: "alert",
        onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.startTimer && _ctx.startTimer(...args)),
        onClick: _cache[3] || (_cache[3] = (...args) => _ctx.onClick && _ctx.onClick(...args))
      }, [
        _ctx.type || _ctx.iconClass ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: normalizeClass(["el-notification__icon", [_ctx.typeClass, _ctx.iconClass]])
        }, null, 2)) : createCommentVNode("v-if", true),
        createElementVNode("div", {
          class: normalizeClass(["el-notification__group", { "is-with-icon": _ctx.typeClass || _ctx.iconClass }])
        }, [
          createElementVNode("h2", {
            class: "el-notification__title",
            textContent: toDisplayString(_ctx.title)
          }, null, 8, _hoisted_2$m),
          withDirectives(createElementVNode("div", {
            class: "el-notification__content",
            style: normalizeStyle(!!_ctx.title ? null : "margin: 0")
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", _hoisted_3$l, toDisplayString(_ctx.message), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" Caution here, message could've been compromized, nerver use user's input as message "),
                createCommentVNode(" eslint-disable-next-line "),
                createElementVNode("p", { innerHTML: _ctx.message }, null, 8, _hoisted_4$g)
              ], 2112))
            ])
          ], 4), [
            [vShow, _ctx.message]
          ]),
          _ctx.showClose ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "el-notification__closeBtn el-icon-close",
            onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.close && _ctx.close(...args), ["stop"]))
          })) : createCommentVNode("v-if", true)
        ], 2)
      ], 46, _hoisted_1$r), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  }, 8, ["onBeforeLeave"]);
}
script.render = render;
script.__file = "packages/components/notification/src/workprogress.vue";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const notifications = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
};
const GAP_SIZE = 16;
let seed = 1;
const Notification = function(options2 = {}) {
  if (isServer)
    return;
  const position = options2.position || "top-right";
  let verticalOffset = options2.offset || 0;
  notifications[position].forEach(({ vm: vm2 }) => {
    verticalOffset += (vm2.el.offsetHeight || 0) + GAP_SIZE;
  });
  verticalOffset += GAP_SIZE;
  const id2 = "notification_" + seed++;
  const userOnClose = options2.onClose;
  options2 = __spreadProps(__spreadValues({}, options2), {
    onClose: () => {
      close(id2, position, userOnClose);
    },
    offset: verticalOffset,
    id: id2,
    zIndex: PopupManager$1.nextZIndex()
  });
  const container = document.createElement("div");
  const vm = createVNode(script, options2, isVNode(options2.message) ? {
    default: () => options2.message
  } : null);
  vm.props.onDestroy = () => {
    render$Z(null, container);
  };
  render$Z(vm, container);
  notifications[position].push({ vm });
  document.body.appendChild(container.firstElementChild);
  return {
    close: () => {
      vm.component.proxy.visible = false;
    }
  };
};
["success", "warning", "info", "error"].forEach((type2) => {
  Object.assign(Notification, {
    [type2]: (options2 = {}) => {
      if (typeof options2 === "string" || isVNode(options2)) {
        options2 = {
          message: options2
        };
      }
      options2.type = type2;
      return Notification(options2);
    }
  });
});
function close(id2, position, userOnClose) {
  const orientedNotifications = notifications[position];
  const idx = orientedNotifications.findIndex(({ vm: vm2 }) => vm2.component.props.id === id2);
  if (idx === -1)
    return;
  const { vm } = orientedNotifications[idx];
  if (!vm)
    return;
  userOnClose == null ? void 0 : userOnClose(vm);
  const removedHeight = vm.el.offsetHeight;
  const verticalPos = position.split("-")[0];
  orientedNotifications.splice(idx, 1);
  const len = orientedNotifications.length;
  if (len < 1)
    return;
  for (let i2 = idx; i2 < len; i2++) {
    const { el, component: component2 } = orientedNotifications[i2].vm;
    const pos = parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
    component2.props.offset = pos;
  }
}
function closeAll() {
  for (const key in notifications) {
    const orientedNotifications = notifications[key];
    orientedNotifications.forEach(({ vm }) => {
      vm.component.proxy.visible = false;
    });
  }
}
Notification.closeAll = closeAll;
const _Notify = Notification;
_Notify.install = (app) => {
  app.config.globalProperties.$notify = _Notify;
};
const ElNotification = _Notify;
var plugin = [
  ElInfiniteScroll,
  ElLoading,
  ElMessage,
  ElMessageBox,
  ElNotification,
  ElPopoverDirective
];
var Plugins = plugin;
var defaults$7 = makeInstaller$1([
  ...Components,
  ...Plugins
]);
var Element$1 = defaults$7;
var zhCn$1 = { exports: {} };
(function(module, exports) {
  !function(e, _) {
    module.exports = _(dayjs_min.exports);
  }(commonjsGlobal, function(e) {
    function _(e2) {
      return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var t = _(e), d = { name: "zh-cn", weekdays: "\u661F\u671F\u65E5_\u661F\u671F\u4E00_\u661F\u671F\u4E8C_\u661F\u671F\u4E09_\u661F\u671F\u56DB_\u661F\u671F\u4E94_\u661F\u671F\u516D".split("_"), weekdaysShort: "\u5468\u65E5_\u5468\u4E00_\u5468\u4E8C_\u5468\u4E09_\u5468\u56DB_\u5468\u4E94_\u5468\u516D".split("_"), weekdaysMin: "\u65E5_\u4E00_\u4E8C_\u4E09_\u56DB_\u4E94_\u516D".split("_"), months: "\u4E00\u6708_\u4E8C\u6708_\u4E09\u6708_\u56DB\u6708_\u4E94\u6708_\u516D\u6708_\u4E03\u6708_\u516B\u6708_\u4E5D\u6708_\u5341\u6708_\u5341\u4E00\u6708_\u5341\u4E8C\u6708".split("_"), monthsShort: "1\u6708_2\u6708_3\u6708_4\u6708_5\u6708_6\u6708_7\u6708_8\u6708_9\u6708_10\u6708_11\u6708_12\u6708".split("_"), ordinal: function(e2, _2) {
      switch (_2) {
        case "W":
          return e2 + "\u5468";
        default:
          return e2 + "\u65E5";
      }
    }, weekStart: 1, yearStart: 4, formats: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY\u5E74M\u6708D\u65E5", LLL: "YYYY\u5E74M\u6708D\u65E5Ah\u70B9mm\u5206", LLLL: "YYYY\u5E74M\u6708D\u65E5ddddAh\u70B9mm\u5206", l: "YYYY/M/D", ll: "YYYY\u5E74M\u6708D\u65E5", lll: "YYYY\u5E74M\u6708D\u65E5 HH:mm", llll: "YYYY\u5E74M\u6708D\u65E5dddd HH:mm" }, relativeTime: { future: "%s\u5185", past: "%s\u524D", s: "\u51E0\u79D2", m: "1 \u5206\u949F", mm: "%d \u5206\u949F", h: "1 \u5C0F\u65F6", hh: "%d \u5C0F\u65F6", d: "1 \u5929", dd: "%d \u5929", M: "1 \u4E2A\u6708", MM: "%d \u4E2A\u6708", y: "1 \u5E74", yy: "%d \u5E74" }, meridiem: function(e2, _2) {
      var t2 = 100 * e2 + _2;
      return t2 < 600 ? "\u51CC\u6668" : t2 < 900 ? "\u65E9\u4E0A" : t2 < 1100 ? "\u4E0A\u5348" : t2 < 1300 ? "\u4E2D\u5348" : t2 < 1800 ? "\u4E0B\u5348" : "\u665A\u4E0A";
    } };
    return t.default.locale(d, null, true), d;
  });
})(zhCn$1);
var zhCn = {};
Object.defineProperty(zhCn, "__esModule", { value: true });
var _default = zhCn.default = {
  name: "zh-cn",
  el: {
    colorpicker: {
      confirm: "\u786E\u5B9A",
      clear: "\u6E05\u7A7A"
    },
    datepicker: {
      now: "\u6B64\u523B",
      today: "\u4ECA\u5929",
      cancel: "\u53D6\u6D88",
      clear: "\u6E05\u7A7A",
      confirm: "\u786E\u5B9A",
      selectDate: "\u9009\u62E9\u65E5\u671F",
      selectTime: "\u9009\u62E9\u65F6\u95F4",
      startDate: "\u5F00\u59CB\u65E5\u671F",
      startTime: "\u5F00\u59CB\u65F6\u95F4",
      endDate: "\u7ED3\u675F\u65E5\u671F",
      endTime: "\u7ED3\u675F\u65F6\u95F4",
      prevYear: "\u524D\u4E00\u5E74",
      nextYear: "\u540E\u4E00\u5E74",
      prevMonth: "\u4E0A\u4E2A\u6708",
      nextMonth: "\u4E0B\u4E2A\u6708",
      year: "\u5E74",
      month1: "1 \u6708",
      month2: "2 \u6708",
      month3: "3 \u6708",
      month4: "4 \u6708",
      month5: "5 \u6708",
      month6: "6 \u6708",
      month7: "7 \u6708",
      month8: "8 \u6708",
      month9: "9 \u6708",
      month10: "10 \u6708",
      month11: "11 \u6708",
      month12: "12 \u6708",
      weeks: {
        sun: "\u65E5",
        mon: "\u4E00",
        tue: "\u4E8C",
        wed: "\u4E09",
        thu: "\u56DB",
        fri: "\u4E94",
        sat: "\u516D"
      },
      months: {
        jan: "\u4E00\u6708",
        feb: "\u4E8C\u6708",
        mar: "\u4E09\u6708",
        apr: "\u56DB\u6708",
        may: "\u4E94\u6708",
        jun: "\u516D\u6708",
        jul: "\u4E03\u6708",
        aug: "\u516B\u6708",
        sep: "\u4E5D\u6708",
        oct: "\u5341\u6708",
        nov: "\u5341\u4E00\u6708",
        dec: "\u5341\u4E8C\u6708"
      }
    },
    select: {
      loading: "\u52A0\u8F7D\u4E2D",
      noMatch: "\u65E0\u5339\u914D\u6570\u636E",
      noData: "\u65E0\u6570\u636E",
      placeholder: "\u8BF7\u9009\u62E9"
    },
    cascader: {
      noMatch: "\u65E0\u5339\u914D\u6570\u636E",
      loading: "\u52A0\u8F7D\u4E2D",
      placeholder: "\u8BF7\u9009\u62E9",
      noData: "\u6682\u65E0\u6570\u636E"
    },
    pagination: {
      goto: "\u524D\u5F80",
      pagesize: "\u6761/\u9875",
      total: "\u5171 {total} \u6761",
      pageClassifier: "\u9875",
      deprecationWarning: "\u4F60\u4F7F\u7528\u4E86\u4E00\u4E9B\u5DF2\u88AB\u5E9F\u5F03\u7684\u7528\u6CD5\uFF0C\u8BF7\u53C2\u8003 el-pagination \u7684\u5B98\u65B9\u6587\u6863"
    },
    messagebox: {
      title: "\u63D0\u793A",
      confirm: "\u786E\u5B9A",
      cancel: "\u53D6\u6D88",
      error: "\u8F93\u5165\u7684\u6570\u636E\u4E0D\u5408\u6CD5!"
    },
    upload: {
      deleteTip: "\u6309 delete \u952E\u53EF\u5220\u9664",
      delete: "\u5220\u9664",
      preview: "\u67E5\u770B\u56FE\u7247",
      continue: "\u7EE7\u7EED\u4E0A\u4F20"
    },
    table: {
      emptyText: "\u6682\u65E0\u6570\u636E",
      confirmFilter: "\u7B5B\u9009",
      resetFilter: "\u91CD\u7F6E",
      clearFilter: "\u5168\u90E8",
      sumText: "\u5408\u8BA1"
    },
    tree: {
      emptyText: "\u6682\u65E0\u6570\u636E"
    },
    transfer: {
      noMatch: "\u65E0\u5339\u914D\u6570\u636E",
      noData: "\u65E0\u6570\u636E",
      titles: ["\u5217\u8868 1", "\u5217\u8868 2"],
      filterPlaceholder: "\u8BF7\u8F93\u5165\u641C\u7D22\u5185\u5BB9",
      noCheckedFormat: "\u5171 {total} \u9879",
      hasCheckedFormat: "\u5DF2\u9009 {checked}/{total} \u9879"
    },
    image: {
      error: "\u52A0\u8F7D\u5931\u8D25"
    },
    pageHeader: {
      title: "\u8FD4\u56DE"
    },
    popconfirm: {
      confirmButtonText: "\u786E\u5B9A",
      cancelButtonText: "\u53D6\u6D88"
    }
  }
};
var ElementUI = {
  Element: Element$1,
  install(app) {
    app.use(Element$1, { locale: _default });
  }
};
const setConfig = (option2) => {
};
let userAgent$1 = navigator.userAgent;
let platform = navigator.platform;
let gecko = /gecko\/\d/i.test(userAgent$1);
let ie_upto10 = /MSIE \d/.test(userAgent$1);
let ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent$1);
let edge = /Edge\/(\d+)/.exec(userAgent$1);
let ie = ie_upto10 || ie_11up || edge;
let ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
let webkit = !edge && /WebKit\//.test(userAgent$1);
let qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent$1);
let chrome = !edge && /Chrome\//.test(userAgent$1);
let presto = /Opera\//.test(userAgent$1);
let safari = /Apple Computer/.test(navigator.vendor);
let mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent$1);
let phantom = /PhantomJS/.test(userAgent$1);
let ios = safari && (/Mobile\/\w+/.test(userAgent$1) || navigator.maxTouchPoints > 2);
let android = /Android/.test(userAgent$1);
let mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent$1);
let mac = ios || /Mac/.test(platform);
let chromeOS = /\bCrOS\b/.test(userAgent$1);
let windows = /win/i.test(platform);
let presto_version = presto && userAgent$1.match(/Version\/(\d*\.\d*)/);
if (presto_version)
  presto_version = Number(presto_version[1]);
if (presto_version && presto_version >= 15) {
  presto = false;
  webkit = true;
}
let flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
let captureRightClick = gecko || ie && ie_version >= 9;
function classTest(cls) {
  return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
}
let rmClass = function(node, cls) {
  let current = node.className;
  let match = classTest(cls).exec(current);
  if (match) {
    let after = current.slice(match.index + match[0].length);
    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
  }
};
function removeChildren(e) {
  for (let count = e.childNodes.length; count > 0; --count)
    e.removeChild(e.firstChild);
  return e;
}
function removeChildrenAndAdd(parent2, e) {
  return removeChildren(parent2).appendChild(e);
}
function elt(tag, content, className, style) {
  let e = document.createElement(tag);
  if (className)
    e.className = className;
  if (style)
    e.style.cssText = style;
  if (typeof content == "string")
    e.appendChild(document.createTextNode(content));
  else if (content)
    for (let i2 = 0; i2 < content.length; ++i2)
      e.appendChild(content[i2]);
  return e;
}
function eltP(tag, content, className, style) {
  let e = elt(tag, content, className, style);
  e.setAttribute("role", "presentation");
  return e;
}
let range;
if (document.createRange)
  range = function(node, start2, end2, endNode) {
    let r = document.createRange();
    r.setEnd(endNode || node, end2);
    r.setStart(node, start2);
    return r;
  };
else
  range = function(node, start2, end2) {
    let r = document.body.createTextRange();
    try {
      r.moveToElementText(node.parentNode);
    } catch (e) {
      return r;
    }
    r.collapse(true);
    r.moveEnd("character", end2);
    r.moveStart("character", start2);
    return r;
  };
function contains(parent2, child) {
  if (child.nodeType == 3)
    child = child.parentNode;
  if (parent2.contains)
    return parent2.contains(child);
  do {
    if (child.nodeType == 11)
      child = child.host;
    if (child == parent2)
      return true;
  } while (child = child.parentNode);
}
function activeElt() {
  let activeElement;
  try {
    activeElement = document.activeElement;
  } catch (e) {
    activeElement = document.body || null;
  }
  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
    activeElement = activeElement.shadowRoot.activeElement;
  return activeElement;
}
function addClass(node, cls) {
  let current = node.className;
  if (!classTest(cls).test(current))
    node.className += (current ? " " : "") + cls;
}
function joinClasses(a, b) {
  let as = a.split(" ");
  for (let i2 = 0; i2 < as.length; i2++)
    if (as[i2] && !classTest(as[i2]).test(b))
      b += " " + as[i2];
  return b;
}
let selectInput = function(node) {
  node.select();
};
if (ios)
  selectInput = function(node) {
    node.selectionStart = 0;
    node.selectionEnd = node.value.length;
  };
else if (ie)
  selectInput = function(node) {
    try {
      node.select();
    } catch (_e) {
    }
  };
function bind$3(f) {
  let args = Array.prototype.slice.call(arguments, 1);
  return function() {
    return f.apply(null, args);
  };
}
function copyObj(obj, target, overwrite) {
  if (!target)
    target = {};
  for (let prop in obj)
    if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
      target[prop] = obj[prop];
  return target;
}
function countColumn(string2, end2, tabSize, startIndex, startValue) {
  if (end2 == null) {
    end2 = string2.search(/[^\s\u00a0]/);
    if (end2 == -1)
      end2 = string2.length;
  }
  for (let i2 = startIndex || 0, n = startValue || 0; ; ) {
    let nextTab = string2.indexOf("	", i2);
    if (nextTab < 0 || nextTab >= end2)
      return n + (end2 - i2);
    n += nextTab - i2;
    n += tabSize - n % tabSize;
    i2 = nextTab + 1;
  }
}
class Delayed {
  constructor() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind$3(this.onTimeout, this);
  }
  onTimeout(self2) {
    self2.id = 0;
    if (self2.time <= +new Date()) {
      self2.f();
    } else {
      setTimeout(self2.handler, self2.time - +new Date());
    }
  }
  set(ms, f) {
    this.f = f;
    const time = +new Date() + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  }
}
function indexOf(array3, elt2) {
  for (let i2 = 0; i2 < array3.length; ++i2)
    if (array3[i2] == elt2)
      return i2;
  return -1;
}
let scrollerGap = 50;
let Pass = { toString: function() {
  return "CodeMirror.Pass";
} };
let sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
function findColumn(string2, goal, tabSize) {
  for (let pos = 0, col = 0; ; ) {
    let nextTab = string2.indexOf("	", pos);
    if (nextTab == -1)
      nextTab = string2.length;
    let skipped = nextTab - pos;
    if (nextTab == string2.length || col + skipped >= goal)
      return pos + Math.min(skipped, goal - col);
    col += nextTab - pos;
    col += tabSize - col % tabSize;
    pos = nextTab + 1;
    if (col >= goal)
      return pos;
  }
}
let spaceStrs = [""];
function spaceStr(n) {
  while (spaceStrs.length <= n)
    spaceStrs.push(lst(spaceStrs) + " ");
  return spaceStrs[n];
}
function lst(arr) {
  return arr[arr.length - 1];
}
function map(array3, f) {
  let out = [];
  for (let i2 = 0; i2 < array3.length; i2++)
    out[i2] = f(array3[i2], i2);
  return out;
}
function insertSorted(array3, value2, score) {
  let pos = 0, priority = score(value2);
  while (pos < array3.length && score(array3[pos]) <= priority)
    pos++;
  array3.splice(pos, 0, value2);
}
function nothing() {
}
function createObj(base, props2) {
  let inst;
  if (Object.create) {
    inst = Object.create(base);
  } else {
    nothing.prototype = base;
    inst = new nothing();
  }
  if (props2)
    copyObj(props2, inst);
  return inst;
}
let nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
function isWordCharBasic(ch) {
  return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
}
function isWordChar(ch, helper) {
  if (!helper)
    return isWordCharBasic(ch);
  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch))
    return true;
  return helper.test(ch);
}
function isEmpty(obj) {
  for (let n in obj)
    if (obj.hasOwnProperty(n) && obj[n])
      return false;
  return true;
}
let extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
function isExtendingChar(ch) {
  return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
}
function skipExtendingChars(str, pos, dir) {
  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos)))
    pos += dir;
  return pos;
}
function findFirst(pred, from, to) {
  let dir = from > to ? -1 : 1;
  for (; ; ) {
    if (from == to)
      return from;
    let midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
    if (mid == from)
      return pred(mid) ? from : to;
    if (pred(mid))
      to = mid;
    else
      from = mid + dir;
  }
}
function iterateBidiSections(order2, from, to, f) {
  if (!order2)
    return f(from, to, "ltr", 0);
  let found = false;
  for (let i2 = 0; i2 < order2.length; ++i2) {
    let part = order2[i2];
    if (part.from < to && part.to > from || from == to && part.to == from) {
      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
      found = true;
    }
  }
  if (!found)
    f(from, to, "ltr");
}
let bidiOther = null;
function getBidiPartAt(order2, ch, sticky) {
  let found;
  bidiOther = null;
  for (let i2 = 0; i2 < order2.length; ++i2) {
    let cur = order2[i2];
    if (cur.from < ch && cur.to > ch)
      return i2;
    if (cur.to == ch) {
      if (cur.from != cur.to && sticky == "before")
        found = i2;
      else
        bidiOther = i2;
    }
    if (cur.from == ch) {
      if (cur.from != cur.to && sticky != "before")
        found = i2;
      else
        bidiOther = i2;
    }
  }
  return found != null ? found : bidiOther;
}
let bidiOrdering = function() {
  let lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
  let arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
  function charType(code) {
    if (code <= 247)
      return lowTypes.charAt(code);
    else if (1424 <= code && code <= 1524)
      return "R";
    else if (1536 <= code && code <= 1785)
      return arabicTypes.charAt(code - 1536);
    else if (1774 <= code && code <= 2220)
      return "r";
    else if (8192 <= code && code <= 8203)
      return "w";
    else if (code == 8204)
      return "b";
    else
      return "L";
  }
  let bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  let isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
  function BidiSpan(level, from, to) {
    this.level = level;
    this.from = from;
    this.to = to;
  }
  return function(str, direction) {
    let outerType = direction == "ltr" ? "L" : "R";
    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str))
      return false;
    let len = str.length, types2 = [];
    for (let i2 = 0; i2 < len; ++i2)
      types2.push(charType(str.charCodeAt(i2)));
    for (let i2 = 0, prev = outerType; i2 < len; ++i2) {
      let type2 = types2[i2];
      if (type2 == "m")
        types2[i2] = prev;
      else
        prev = type2;
    }
    for (let i2 = 0, cur = outerType; i2 < len; ++i2) {
      let type2 = types2[i2];
      if (type2 == "1" && cur == "r")
        types2[i2] = "n";
      else if (isStrong.test(type2)) {
        cur = type2;
        if (type2 == "r")
          types2[i2] = "R";
      }
    }
    for (let i2 = 1, prev = types2[0]; i2 < len - 1; ++i2) {
      let type2 = types2[i2];
      if (type2 == "+" && prev == "1" && types2[i2 + 1] == "1")
        types2[i2] = "1";
      else if (type2 == "," && prev == types2[i2 + 1] && (prev == "1" || prev == "n"))
        types2[i2] = prev;
      prev = type2;
    }
    for (let i2 = 0; i2 < len; ++i2) {
      let type2 = types2[i2];
      if (type2 == ",")
        types2[i2] = "N";
      else if (type2 == "%") {
        let end2;
        for (end2 = i2 + 1; end2 < len && types2[end2] == "%"; ++end2) {
        }
        let replace2 = i2 && types2[i2 - 1] == "!" || end2 < len && types2[end2] == "1" ? "1" : "N";
        for (let j = i2; j < end2; ++j)
          types2[j] = replace2;
        i2 = end2 - 1;
      }
    }
    for (let i2 = 0, cur = outerType; i2 < len; ++i2) {
      let type2 = types2[i2];
      if (cur == "L" && type2 == "1")
        types2[i2] = "L";
      else if (isStrong.test(type2))
        cur = type2;
    }
    for (let i2 = 0; i2 < len; ++i2) {
      if (isNeutral.test(types2[i2])) {
        let end2;
        for (end2 = i2 + 1; end2 < len && isNeutral.test(types2[end2]); ++end2) {
        }
        let before = (i2 ? types2[i2 - 1] : outerType) == "L";
        let after = (end2 < len ? types2[end2] : outerType) == "L";
        let replace2 = before == after ? before ? "L" : "R" : outerType;
        for (let j = i2; j < end2; ++j)
          types2[j] = replace2;
        i2 = end2 - 1;
      }
    }
    let order2 = [], m;
    for (let i2 = 0; i2 < len; ) {
      if (countsAsLeft.test(types2[i2])) {
        let start2 = i2;
        for (++i2; i2 < len && countsAsLeft.test(types2[i2]); ++i2) {
        }
        order2.push(new BidiSpan(0, start2, i2));
      } else {
        let pos = i2, at = order2.length, isRTL2 = direction == "rtl" ? 1 : 0;
        for (++i2; i2 < len && types2[i2] != "L"; ++i2) {
        }
        for (let j = pos; j < i2; ) {
          if (countsAsNum.test(types2[j])) {
            if (pos < j) {
              order2.splice(at, 0, new BidiSpan(1, pos, j));
              at += isRTL2;
            }
            let nstart = j;
            for (++j; j < i2 && countsAsNum.test(types2[j]); ++j) {
            }
            order2.splice(at, 0, new BidiSpan(2, nstart, j));
            at += isRTL2;
            pos = j;
          } else
            ++j;
        }
        if (pos < i2)
          order2.splice(at, 0, new BidiSpan(1, pos, i2));
      }
    }
    if (direction == "ltr") {
      if (order2[0].level == 1 && (m = str.match(/^\s+/))) {
        order2[0].from = m[0].length;
        order2.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order2).level == 1 && (m = str.match(/\s+$/))) {
        lst(order2).to -= m[0].length;
        order2.push(new BidiSpan(0, len - m[0].length, len));
      }
    }
    return direction == "rtl" ? order2.reverse() : order2;
  };
}();
function getOrder(line, direction) {
  let order2 = line.order;
  if (order2 == null)
    order2 = line.order = bidiOrdering(line.text, direction);
  return order2;
}
const noHandlers = [];
let on$1 = function(emitter, type2, f) {
  if (emitter.addEventListener) {
    emitter.addEventListener(type2, f, false);
  } else if (emitter.attachEvent) {
    emitter.attachEvent("on" + type2, f);
  } else {
    let map2 = emitter._handlers || (emitter._handlers = {});
    map2[type2] = (map2[type2] || noHandlers).concat(f);
  }
};
function getHandlers(emitter, type2) {
  return emitter._handlers && emitter._handlers[type2] || noHandlers;
}
function off$1(emitter, type2, f) {
  if (emitter.removeEventListener) {
    emitter.removeEventListener(type2, f, false);
  } else if (emitter.detachEvent) {
    emitter.detachEvent("on" + type2, f);
  } else {
    let map2 = emitter._handlers, arr = map2 && map2[type2];
    if (arr) {
      let index2 = indexOf(arr, f);
      if (index2 > -1)
        map2[type2] = arr.slice(0, index2).concat(arr.slice(index2 + 1));
    }
  }
}
function signal(emitter, type2) {
  let handlers = getHandlers(emitter, type2);
  if (!handlers.length)
    return;
  let args = Array.prototype.slice.call(arguments, 2);
  for (let i2 = 0; i2 < handlers.length; ++i2)
    handlers[i2].apply(null, args);
}
function signalDOMEvent(cm, e, override) {
  if (typeof e == "string")
    e = { type: e, preventDefault: function() {
      this.defaultPrevented = true;
    } };
  signal(cm, override || e.type, cm, e);
  return e_defaultPrevented(e) || e.codemirrorIgnore;
}
function signalCursorActivity(cm) {
  let arr = cm._handlers && cm._handlers.cursorActivity;
  if (!arr)
    return;
  let set2 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
  for (let i2 = 0; i2 < arr.length; ++i2)
    if (indexOf(set2, arr[i2]) == -1)
      set2.push(arr[i2]);
}
function hasHandler(emitter, type2) {
  return getHandlers(emitter, type2).length > 0;
}
function eventMixin(ctor) {
  ctor.prototype.on = function(type2, f) {
    on$1(this, type2, f);
  };
  ctor.prototype.off = function(type2, f) {
    off$1(this, type2, f);
  };
}
function e_preventDefault(e) {
  if (e.preventDefault)
    e.preventDefault();
  else
    e.returnValue = false;
}
function e_stopPropagation(e) {
  if (e.stopPropagation)
    e.stopPropagation();
  else
    e.cancelBubble = true;
}
function e_defaultPrevented(e) {
  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
}
function e_stop(e) {
  e_preventDefault(e);
  e_stopPropagation(e);
}
function e_target(e) {
  return e.target || e.srcElement;
}
function e_button(e) {
  let b = e.which;
  if (b == null) {
    if (e.button & 1)
      b = 1;
    else if (e.button & 2)
      b = 3;
    else if (e.button & 4)
      b = 2;
  }
  if (mac && e.ctrlKey && b == 1)
    b = 3;
  return b;
}
let dragAndDrop = function() {
  if (ie && ie_version < 9)
    return false;
  let div = elt("div");
  return "draggable" in div || "dragDrop" in div;
}();
let zwspSupported;
function zeroWidthElement(measure) {
  if (zwspSupported == null) {
    let test = elt("span", "\u200B");
    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
    if (measure.firstChild.offsetHeight != 0)
      zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
  }
  let node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
  node.setAttribute("cm-text", "");
  return node;
}
let badBidiRects;
function hasBadBidiRects(measure) {
  if (badBidiRects != null)
    return badBidiRects;
  let txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
  let r0 = range(txt, 0, 1).getBoundingClientRect();
  let r1 = range(txt, 1, 2).getBoundingClientRect();
  removeChildren(measure);
  if (!r0 || r0.left == r0.right)
    return false;
  return badBidiRects = r1.right - r0.right < 3;
}
let splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? (string2) => {
  let pos = 0, result = [], l = string2.length;
  while (pos <= l) {
    let nl = string2.indexOf("\n", pos);
    if (nl == -1)
      nl = string2.length;
    let line = string2.slice(pos, string2.charAt(nl - 1) == "\r" ? nl - 1 : nl);
    let rt = line.indexOf("\r");
    if (rt != -1) {
      result.push(line.slice(0, rt));
      pos += rt + 1;
    } else {
      result.push(line);
      pos = nl + 1;
    }
  }
  return result;
} : (string2) => string2.split(/\r\n?|\n/);
let hasSelection = window.getSelection ? (te) => {
  try {
    return te.selectionStart != te.selectionEnd;
  } catch (e) {
    return false;
  }
} : (te) => {
  let range2;
  try {
    range2 = te.ownerDocument.selection.createRange();
  } catch (e) {
  }
  if (!range2 || range2.parentElement() != te)
    return false;
  return range2.compareEndPoints("StartToEnd", range2) != 0;
};
let hasCopyEvent = (() => {
  let e = elt("div");
  if ("oncopy" in e)
    return true;
  e.setAttribute("oncopy", "return;");
  return typeof e.oncopy == "function";
})();
let badZoomedRects = null;
function hasBadZoomedRects(measure) {
  if (badZoomedRects != null)
    return badZoomedRects;
  let node = removeChildrenAndAdd(measure, elt("span", "x"));
  let normal = node.getBoundingClientRect();
  let fromRange = range(node, 0, 1).getBoundingClientRect();
  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
}
let modes = {}, mimeModes = {};
function defineMode(name2, mode) {
  if (arguments.length > 2)
    mode.dependencies = Array.prototype.slice.call(arguments, 2);
  modes[name2] = mode;
}
function defineMIME(mime, spec) {
  mimeModes[mime] = spec;
}
function resolveMode(spec) {
  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
    spec = mimeModes[spec];
  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
    let found = mimeModes[spec.name];
    if (typeof found == "string")
      found = { name: found };
    spec = createObj(found, spec);
    spec.name = found.name;
  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
    return resolveMode("application/xml");
  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
    return resolveMode("application/json");
  }
  if (typeof spec == "string")
    return { name: spec };
  else
    return spec || { name: "null" };
}
function getMode(options2, spec) {
  spec = resolveMode(spec);
  let mfactory = modes[spec.name];
  if (!mfactory)
    return getMode(options2, "text/plain");
  let modeObj = mfactory(options2, spec);
  if (modeExtensions.hasOwnProperty(spec.name)) {
    let exts = modeExtensions[spec.name];
    for (let prop in exts) {
      if (!exts.hasOwnProperty(prop))
        continue;
      if (modeObj.hasOwnProperty(prop))
        modeObj["_" + prop] = modeObj[prop];
      modeObj[prop] = exts[prop];
    }
  }
  modeObj.name = spec.name;
  if (spec.helperType)
    modeObj.helperType = spec.helperType;
  if (spec.modeProps)
    for (let prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];
  return modeObj;
}
let modeExtensions = {};
function extendMode(mode, properties) {
  let exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
  copyObj(properties, exts);
}
function copyState(mode, state) {
  if (state === true)
    return state;
  if (mode.copyState)
    return mode.copyState(state);
  let nstate = {};
  for (let n in state) {
    let val = state[n];
    if (val instanceof Array)
      val = val.concat([]);
    nstate[n] = val;
  }
  return nstate;
}
function innerMode(mode, state) {
  let info;
  while (mode.innerMode) {
    info = mode.innerMode(state);
    if (!info || info.mode == mode)
      break;
    state = info.state;
    mode = info.mode;
  }
  return info || { mode, state };
}
function startState(mode, a1, a2) {
  return mode.startState ? mode.startState(a1, a2) : true;
}
class StringStream {
  constructor(string2, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string2;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  }
  eol() {
    return this.pos >= this.string.length;
  }
  sol() {
    return this.pos == this.lineStart;
  }
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  eat(match) {
    let ch = this.string.charAt(this.pos);
    let ok;
    if (typeof match == "string")
      ok = ch == match;
    else
      ok = ch && (match.test ? match.test(ch) : match(ch));
    if (ok) {
      ++this.pos;
      return ch;
    }
  }
  eatWhile(match) {
    let start2 = this.pos;
    while (this.eat(match)) {
    }
    return this.pos > start2;
  }
  eatSpace() {
    let start2 = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
      ++this.pos;
    return this.pos > start2;
  }
  skipToEnd() {
    this.pos = this.string.length;
  }
  skipTo(ch) {
    let found = this.string.indexOf(ch, this.pos);
    if (found > -1) {
      this.pos = found;
      return true;
    }
  }
  backUp(n) {
    this.pos -= n;
  }
  column() {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  }
  indentation() {
    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  }
  match(pattern2, consume, caseInsensitive) {
    if (typeof pattern2 == "string") {
      let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
      let substr = this.string.substr(this.pos, pattern2.length);
      if (cased(substr) == cased(pattern2)) {
        if (consume !== false)
          this.pos += pattern2.length;
        return true;
      }
    } else {
      let match = this.string.slice(this.pos).match(pattern2);
      if (match && match.index > 0)
        return null;
      if (match && consume !== false)
        this.pos += match[0].length;
      return match;
    }
  }
  current() {
    return this.string.slice(this.start, this.pos);
  }
  hideFirstChars(n, inner) {
    this.lineStart += n;
    try {
      return inner();
    } finally {
      this.lineStart -= n;
    }
  }
  lookAhead(n) {
    let oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n);
  }
  baseToken() {
    let oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos);
  }
}
function getLine(doc, n) {
  n -= doc.first;
  if (n < 0 || n >= doc.size)
    throw new Error("There is no line " + (n + doc.first) + " in the document.");
  let chunk = doc;
  while (!chunk.lines) {
    for (let i2 = 0; ; ++i2) {
      let child = chunk.children[i2], sz = child.chunkSize();
      if (n < sz) {
        chunk = child;
        break;
      }
      n -= sz;
    }
  }
  return chunk.lines[n];
}
function getBetween(doc, start2, end2) {
  let out = [], n = start2.line;
  doc.iter(start2.line, end2.line + 1, (line) => {
    let text = line.text;
    if (n == end2.line)
      text = text.slice(0, end2.ch);
    if (n == start2.line)
      text = text.slice(start2.ch);
    out.push(text);
    ++n;
  });
  return out;
}
function getLines(doc, from, to) {
  let out = [];
  doc.iter(from, to, (line) => {
    out.push(line.text);
  });
  return out;
}
function updateLineHeight(line, height) {
  let diff = height - line.height;
  if (diff)
    for (let n = line; n; n = n.parent)
      n.height += diff;
}
function lineNo(line) {
  if (line.parent == null)
    return null;
  let cur = line.parent, no = indexOf(cur.lines, line);
  for (let chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
    for (let i2 = 0; ; ++i2) {
      if (chunk.children[i2] == cur)
        break;
      no += chunk.children[i2].chunkSize();
    }
  }
  return no + cur.first;
}
function lineAtHeight(chunk, h2) {
  let n = chunk.first;
  outer:
    do {
      for (let i3 = 0; i3 < chunk.children.length; ++i3) {
        let child = chunk.children[i3], ch = child.height;
        if (h2 < ch) {
          chunk = child;
          continue outer;
        }
        h2 -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
  let i2 = 0;
  for (; i2 < chunk.lines.length; ++i2) {
    let line = chunk.lines[i2], lh = line.height;
    if (h2 < lh)
      break;
    h2 -= lh;
  }
  return n + i2;
}
function isLine(doc, l) {
  return l >= doc.first && l < doc.first + doc.size;
}
function lineNumberFor(options2, i2) {
  return String(options2.lineNumberFormatter(i2 + options2.firstLineNumber));
}
function Pos(line, ch, sticky = null) {
  if (!(this instanceof Pos))
    return new Pos(line, ch, sticky);
  this.line = line;
  this.ch = ch;
  this.sticky = sticky;
}
function cmp(a, b) {
  return a.line - b.line || a.ch - b.ch;
}
function equalCursorPos(a, b) {
  return a.sticky == b.sticky && cmp(a, b) == 0;
}
function copyPos(x) {
  return Pos(x.line, x.ch);
}
function maxPos(a, b) {
  return cmp(a, b) < 0 ? b : a;
}
function minPos(a, b) {
  return cmp(a, b) < 0 ? a : b;
}
function clipLine(doc, n) {
  return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
}
function clipPos(doc, pos) {
  if (pos.line < doc.first)
    return Pos(doc.first, 0);
  let last = doc.first + doc.size - 1;
  if (pos.line > last)
    return Pos(last, getLine(doc, last).text.length);
  return clipToLen(pos, getLine(doc, pos.line).text.length);
}
function clipToLen(pos, linelen) {
  let ch = pos.ch;
  if (ch == null || ch > linelen)
    return Pos(pos.line, linelen);
  else if (ch < 0)
    return Pos(pos.line, 0);
  else
    return pos;
}
function clipPosArray(doc, array3) {
  let out = [];
  for (let i2 = 0; i2 < array3.length; i2++)
    out[i2] = clipPos(doc, array3[i2]);
  return out;
}
class SavedContext {
  constructor(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  }
}
class Context {
  constructor(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  }
  lookAhead(n) {
    let line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead)
      this.maxLookAhead = n;
    return line;
  }
  baseToken(n) {
    if (!this.baseTokens)
      return null;
    while (this.baseTokens[this.baseTokenPos] <= n)
      this.baseTokenPos += 2;
    let type2 = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: type2 && type2.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - n
    };
  }
  nextLine() {
    this.line++;
    if (this.maxLookAhead > 0)
      this.maxLookAhead--;
  }
  static fromSaved(doc, saved, line) {
    if (saved instanceof SavedContext)
      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
    else
      return new Context(doc, copyState(doc.mode, saved), line);
  }
  save(copy) {
    let state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
  }
}
function highlightLine(cm, line, context, forceToEnd) {
  let st = [cm.state.modeGen], lineClasses = {};
  runMode(cm, line.text, cm.doc.mode, context, (end2, style) => st.push(end2, style), lineClasses, forceToEnd);
  let state = context.state;
  for (let o = 0; o < cm.state.overlays.length; ++o) {
    context.baseTokens = st;
    let overlay = cm.state.overlays[o], i2 = 1, at = 0;
    context.state = true;
    runMode(cm, line.text, overlay.mode, context, (end2, style) => {
      let start2 = i2;
      while (at < end2) {
        let i_end = st[i2];
        if (i_end > end2)
          st.splice(i2, 1, end2, st[i2 + 1], i_end);
        i2 += 2;
        at = Math.min(end2, i_end);
      }
      if (!style)
        return;
      if (overlay.opaque) {
        st.splice(start2, i2 - start2, end2, "overlay " + style);
        i2 = start2 + 2;
      } else {
        for (; start2 < i2; start2 += 2) {
          let cur = st[start2 + 1];
          st[start2 + 1] = (cur ? cur + " " : "") + "overlay " + style;
        }
      }
    }, lineClasses);
    context.state = state;
    context.baseTokens = null;
    context.baseTokenPos = 1;
  }
  return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
}
function getLineStyles(cm, line, updateFrontier) {
  if (!line.styles || line.styles[0] != cm.state.modeGen) {
    let context = getContextBefore(cm, lineNo(line));
    let resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
    let result = highlightLine(cm, line, context);
    if (resetState)
      context.state = resetState;
    line.stateAfter = context.save(!resetState);
    line.styles = result.styles;
    if (result.classes)
      line.styleClasses = result.classes;
    else if (line.styleClasses)
      line.styleClasses = null;
    if (updateFrontier === cm.doc.highlightFrontier)
      cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
  }
  return line.styles;
}
function getContextBefore(cm, n, precise) {
  let doc = cm.doc, display = cm.display;
  if (!doc.mode.startState)
    return new Context(doc, true, n);
  let start2 = findStartLine(cm, n, precise);
  let saved = start2 > doc.first && getLine(doc, start2 - 1).stateAfter;
  let context = saved ? Context.fromSaved(doc, saved, start2) : new Context(doc, startState(doc.mode), start2);
  doc.iter(start2, n, (line) => {
    processLine(cm, line.text, context);
    let pos = context.line;
    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
    context.nextLine();
  });
  if (precise)
    doc.modeFrontier = context.line;
  return context;
}
function processLine(cm, text, context, startAt) {
  let mode = cm.doc.mode;
  let stream = new StringStream(text, cm.options.tabSize, context);
  stream.start = stream.pos = startAt || 0;
  if (text == "")
    callBlankLine(mode, context.state);
  while (!stream.eol()) {
    readToken(mode, stream, context.state);
    stream.start = stream.pos;
  }
}
function callBlankLine(mode, state) {
  if (mode.blankLine)
    return mode.blankLine(state);
  if (!mode.innerMode)
    return;
  let inner = innerMode(mode, state);
  if (inner.mode.blankLine)
    return inner.mode.blankLine(inner.state);
}
function readToken(mode, stream, state, inner) {
  for (let i2 = 0; i2 < 10; i2++) {
    if (inner)
      inner[0] = innerMode(mode, state).mode;
    let style = mode.token(stream, state);
    if (stream.pos > stream.start)
      return style;
  }
  throw new Error("Mode " + mode.name + " failed to advance stream.");
}
class Token {
  constructor(stream, type2, state) {
    this.start = stream.start;
    this.end = stream.pos;
    this.string = stream.current();
    this.type = type2 || null;
    this.state = state;
  }
}
function takeToken(cm, pos, precise, asArray) {
  let doc = cm.doc, mode = doc.mode, style;
  pos = clipPos(doc, pos);
  let line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
  let stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
  if (asArray)
    tokens = [];
  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
    stream.start = stream.pos;
    style = readToken(mode, stream, context.state);
    if (asArray)
      tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
  }
  return asArray ? tokens : new Token(stream, style, context.state);
}
function extractLineClasses(type2, output) {
  if (type2)
    for (; ; ) {
      let lineClass = type2.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass)
        break;
      type2 = type2.slice(0, lineClass.index) + type2.slice(lineClass.index + lineClass[0].length);
      let prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
  return type2;
}
function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
  let flattenSpans = mode.flattenSpans;
  if (flattenSpans == null)
    flattenSpans = cm.options.flattenSpans;
  let curStart = 0, curStyle = null;
  let stream = new StringStream(text, cm.options.tabSize, context), style;
  let inner = cm.options.addModeClass && [null];
  if (text == "")
    extractLineClasses(callBlankLine(mode, context.state), lineClasses);
  while (!stream.eol()) {
    if (stream.pos > cm.options.maxHighlightLength) {
      flattenSpans = false;
      if (forceToEnd)
        processLine(cm, text, context, stream.pos);
      stream.pos = text.length;
      style = null;
    } else {
      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
    }
    if (inner) {
      let mName = inner[0].name;
      if (mName)
        style = "m-" + (style ? mName + " " + style : mName);
    }
    if (!flattenSpans || curStyle != style) {
      while (curStart < stream.start) {
        curStart = Math.min(stream.start, curStart + 5e3);
        f(curStart, curStyle);
      }
      curStyle = style;
    }
    stream.start = stream.pos;
  }
  while (curStart < stream.pos) {
    let pos = Math.min(stream.pos, curStart + 5e3);
    f(pos, curStyle);
    curStart = pos;
  }
}
function findStartLine(cm, n, precise) {
  let minindent, minline, doc = cm.doc;
  let lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
  for (let search = n; search > lim; --search) {
    if (search <= doc.first)
      return doc.first;
    let line = getLine(doc, search - 1), after = line.stateAfter;
    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
      return search;
    let indented = countColumn(line.text, null, cm.options.tabSize);
    if (minline == null || minindent > indented) {
      minline = search - 1;
      minindent = indented;
    }
  }
  return minline;
}
function retreatFrontier(doc, n) {
  doc.modeFrontier = Math.min(doc.modeFrontier, n);
  if (doc.highlightFrontier < n - 10)
    return;
  let start2 = doc.first;
  for (let line = n - 1; line > start2; line--) {
    let saved = getLine(doc, line).stateAfter;
    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
      start2 = line + 1;
      break;
    }
  }
  doc.highlightFrontier = Math.min(doc.highlightFrontier, start2);
}
let sawReadOnlySpans = false, sawCollapsedSpans = false;
function seeReadOnlySpans() {
  sawReadOnlySpans = true;
}
function seeCollapsedSpans() {
  sawCollapsedSpans = true;
}
function MarkedSpan(marker, from, to) {
  this.marker = marker;
  this.from = from;
  this.to = to;
}
function getMarkedSpanFor(spans, marker) {
  if (spans)
    for (let i2 = 0; i2 < spans.length; ++i2) {
      let span = spans[i2];
      if (span.marker == marker)
        return span;
    }
}
function removeMarkedSpan(spans, span) {
  let r;
  for (let i2 = 0; i2 < spans.length; ++i2)
    if (spans[i2] != span)
      (r || (r = [])).push(spans[i2]);
  return r;
}
function addMarkedSpan(line, span, op) {
  let inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));
  if (inThisOp && inThisOp.has(line.markedSpans)) {
    line.markedSpans.push(span);
  } else {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    if (inThisOp)
      inThisOp.add(line.markedSpans);
  }
  span.marker.attachLine(line);
}
function markedSpansBefore(old, startCh, isInsert) {
  let nw;
  if (old)
    for (let i2 = 0; i2 < old.length; ++i2) {
      let span = old[i2], marker = span.marker;
      let startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        let endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
  return nw;
}
function markedSpansAfter(old, endCh, isInsert) {
  let nw;
  if (old)
    for (let i2 = 0; i2 < old.length; ++i2) {
      let span = old[i2], marker = span.marker;
      let endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        let startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
      }
    }
  return nw;
}
function stretchSpansOverChange(doc, change) {
  if (change.full)
    return null;
  let oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
  let oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
  if (!oldFirst && !oldLast)
    return null;
  let startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
  let first = markedSpansBefore(oldFirst, startCh, isInsert);
  let last = markedSpansAfter(oldLast, endCh, isInsert);
  let sameLine = change.text.length == 1, offset2 = lst(change.text).length + (sameLine ? startCh : 0);
  if (first) {
    for (let i2 = 0; i2 < first.length; ++i2) {
      let span = first[i2];
      if (span.to == null) {
        let found = getMarkedSpanFor(last, span.marker);
        if (!found)
          span.to = startCh;
        else if (sameLine)
          span.to = found.to == null ? null : found.to + offset2;
      }
    }
  }
  if (last) {
    for (let i2 = 0; i2 < last.length; ++i2) {
      let span = last[i2];
      if (span.to != null)
        span.to += offset2;
      if (span.from == null) {
        let found = getMarkedSpanFor(first, span.marker);
        if (!found) {
          span.from = offset2;
          if (sameLine)
            (first || (first = [])).push(span);
        }
      } else {
        span.from += offset2;
        if (sameLine)
          (first || (first = [])).push(span);
      }
    }
  }
  if (first)
    first = clearEmptySpans(first);
  if (last && last != first)
    last = clearEmptySpans(last);
  let newMarkers = [first];
  if (!sameLine) {
    let gap = change.text.length - 2, gapMarkers;
    if (gap > 0 && first) {
      for (let i2 = 0; i2 < first.length; ++i2)
        if (first[i2].to == null)
          (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i2].marker, null, null));
    }
    for (let i2 = 0; i2 < gap; ++i2)
      newMarkers.push(gapMarkers);
    newMarkers.push(last);
  }
  return newMarkers;
}
function clearEmptySpans(spans) {
  for (let i2 = 0; i2 < spans.length; ++i2) {
    let span = spans[i2];
    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
      spans.splice(i2--, 1);
  }
  if (!spans.length)
    return null;
  return spans;
}
function removeReadOnlyRanges(doc, from, to) {
  let markers = null;
  doc.iter(from.line, to.line + 1, (line) => {
    if (line.markedSpans)
      for (let i2 = 0; i2 < line.markedSpans.length; ++i2) {
        let mark = line.markedSpans[i2].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
  });
  if (!markers)
    return null;
  let parts = [{ from, to }];
  for (let i2 = 0; i2 < markers.length; ++i2) {
    let mk = markers[i2], m = mk.find(0);
    for (let j = 0; j < parts.length; ++j) {
      let p = parts[j];
      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)
        continue;
      let newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
        newParts.push({ from: p.from, to: m.from });
      if (dto > 0 || !mk.inclusiveRight && !dto)
        newParts.push({ from: m.to, to: p.to });
      parts.splice.apply(parts, newParts);
      j += newParts.length - 3;
    }
  }
  return parts;
}
function detachMarkedSpans(line) {
  let spans = line.markedSpans;
  if (!spans)
    return;
  for (let i2 = 0; i2 < spans.length; ++i2)
    spans[i2].marker.detachLine(line);
  line.markedSpans = null;
}
function attachMarkedSpans(line, spans) {
  if (!spans)
    return;
  for (let i2 = 0; i2 < spans.length; ++i2)
    spans[i2].marker.attachLine(line);
  line.markedSpans = spans;
}
function extraLeft(marker) {
  return marker.inclusiveLeft ? -1 : 0;
}
function extraRight(marker) {
  return marker.inclusiveRight ? 1 : 0;
}
function compareCollapsedMarkers(a, b) {
  let lenDiff = a.lines.length - b.lines.length;
  if (lenDiff != 0)
    return lenDiff;
  let aPos = a.find(), bPos = b.find();
  let fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
  if (fromCmp)
    return -fromCmp;
  let toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
  if (toCmp)
    return toCmp;
  return b.id - a.id;
}
function collapsedSpanAtSide(line, start2) {
  let sps = sawCollapsedSpans && line.markedSpans, found;
  if (sps)
    for (let sp, i2 = 0; i2 < sps.length; ++i2) {
      sp = sps[i2];
      if (sp.marker.collapsed && (start2 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
  return found;
}
function collapsedSpanAtStart(line) {
  return collapsedSpanAtSide(line, true);
}
function collapsedSpanAtEnd(line) {
  return collapsedSpanAtSide(line, false);
}
function collapsedSpanAround(line, ch) {
  let sps = sawCollapsedSpans && line.markedSpans, found;
  if (sps)
    for (let i2 = 0; i2 < sps.length; ++i2) {
      let sp = sps[i2];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
  return found;
}
function conflictingCollapsedRange(doc, lineNo2, from, to, marker) {
  let line = getLine(doc, lineNo2);
  let sps = sawCollapsedSpans && line.markedSpans;
  if (sps)
    for (let i2 = 0; i2 < sps.length; ++i2) {
      let sp = sps[i2];
      if (!sp.marker.collapsed)
        continue;
      let found = sp.marker.find(0);
      let fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      let toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0)
        continue;
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        return true;
    }
}
function visualLine(line) {
  let merged;
  while (merged = collapsedSpanAtStart(line))
    line = merged.find(-1, true).line;
  return line;
}
function visualLineEnd(line) {
  let merged;
  while (merged = collapsedSpanAtEnd(line))
    line = merged.find(1, true).line;
  return line;
}
function visualLineContinued(line) {
  let merged, lines;
  while (merged = collapsedSpanAtEnd(line)) {
    line = merged.find(1, true).line;
    (lines || (lines = [])).push(line);
  }
  return lines;
}
function visualLineNo(doc, lineN) {
  let line = getLine(doc, lineN), vis = visualLine(line);
  if (line == vis)
    return lineN;
  return lineNo(vis);
}
function visualLineEndNo(doc, lineN) {
  if (lineN > doc.lastLine())
    return lineN;
  let line = getLine(doc, lineN), merged;
  if (!lineIsHidden(doc, line))
    return lineN;
  while (merged = collapsedSpanAtEnd(line))
    line = merged.find(1, true).line;
  return lineNo(line) + 1;
}
function lineIsHidden(doc, line) {
  let sps = sawCollapsedSpans && line.markedSpans;
  if (sps)
    for (let sp, i2 = 0; i2 < sps.length; ++i2) {
      sp = sps[i2];
      if (!sp.marker.collapsed)
        continue;
      if (sp.from == null)
        return true;
      if (sp.marker.widgetNode)
        continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
}
function lineIsHiddenInner(doc, line, span) {
  if (span.to == null) {
    let end2 = span.marker.find(1, true);
    return lineIsHiddenInner(doc, end2.line, getMarkedSpanFor(end2.line.markedSpans, span.marker));
  }
  if (span.marker.inclusiveRight && span.to == line.text.length)
    return true;
  for (let sp, i2 = 0; i2 < line.markedSpans.length; ++i2) {
    sp = line.markedSpans[i2];
    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
      return true;
  }
}
function heightAtLine(lineObj) {
  lineObj = visualLine(lineObj);
  let h2 = 0, chunk = lineObj.parent;
  for (let i2 = 0; i2 < chunk.lines.length; ++i2) {
    let line = chunk.lines[i2];
    if (line == lineObj)
      break;
    else
      h2 += line.height;
  }
  for (let p = chunk.parent; p; chunk = p, p = chunk.parent) {
    for (let i2 = 0; i2 < p.children.length; ++i2) {
      let cur = p.children[i2];
      if (cur == chunk)
        break;
      else
        h2 += cur.height;
    }
  }
  return h2;
}
function lineLength(line) {
  if (line.height == 0)
    return 0;
  let len = line.text.length, merged, cur = line;
  while (merged = collapsedSpanAtStart(cur)) {
    let found = merged.find(0, true);
    cur = found.from.line;
    len += found.from.ch - found.to.ch;
  }
  cur = line;
  while (merged = collapsedSpanAtEnd(cur)) {
    let found = merged.find(0, true);
    len -= cur.text.length - found.from.ch;
    cur = found.to.line;
    len += cur.text.length - found.to.ch;
  }
  return len;
}
function findMaxLine(cm) {
  let d = cm.display, doc = cm.doc;
  d.maxLine = getLine(doc, doc.first);
  d.maxLineLength = lineLength(d.maxLine);
  d.maxLineChanged = true;
  doc.iter((line) => {
    let len = lineLength(line);
    if (len > d.maxLineLength) {
      d.maxLineLength = len;
      d.maxLine = line;
    }
  });
}
class Line {
  constructor(text, markedSpans, estimateHeight2) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight2 ? estimateHeight2(this) : 1;
  }
  lineNo() {
    return lineNo(this);
  }
}
eventMixin(Line);
function updateLine(line, text, markedSpans, estimateHeight2) {
  line.text = text;
  if (line.stateAfter)
    line.stateAfter = null;
  if (line.styles)
    line.styles = null;
  if (line.order != null)
    line.order = null;
  detachMarkedSpans(line);
  attachMarkedSpans(line, markedSpans);
  let estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
  if (estHeight != line.height)
    updateLineHeight(line, estHeight);
}
function cleanUpLine(line) {
  line.parent = null;
  detachMarkedSpans(line);
}
let styleToClassCache = {}, styleToClassCacheWithMode = {};
function interpretTokenStyle(style, options2) {
  if (!style || /^\s*$/.test(style))
    return null;
  let cache = options2.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
  return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
}
function buildLineContent(cm, lineView) {
  let content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
  let builder = {
    pre: eltP("pre", [content], "CodeMirror-line"),
    content,
    col: 0,
    pos: 0,
    cm,
    trailingSpace: false,
    splitSpaces: cm.getOption("lineWrapping")
  };
  lineView.measure = {};
  for (let i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
    let line = i2 ? lineView.rest[i2 - 1] : lineView.line, order2;
    builder.pos = 0;
    builder.addToken = buildToken;
    if (hasBadBidiRects(cm.display.measure) && (order2 = getOrder(line, cm.doc.direction)))
      builder.addToken = buildTokenBadBidi(builder.addToken, order2);
    builder.map = [];
    let allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
    if (line.styleClasses) {
      if (line.styleClasses.bgClass)
        builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
      if (line.styleClasses.textClass)
        builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
    }
    if (builder.map.length == 0)
      builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
    if (i2 == 0) {
      lineView.measure.map = builder.map;
      lineView.measure.cache = {};
    } else {
      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
      (lineView.measure.caches || (lineView.measure.caches = [])).push({});
    }
  }
  if (webkit) {
    let last = builder.content.lastChild;
    if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab"))
      builder.content.className = "cm-tab-wrap-hack";
  }
  signal(cm, "renderLine", cm, lineView.line, builder.pre);
  if (builder.pre.className)
    builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
  return builder;
}
function defaultSpecialCharPlaceholder(ch) {
  let token = elt("span", "\u2022", "cm-invalidchar");
  token.title = "\\u" + ch.charCodeAt(0).toString(16);
  token.setAttribute("aria-label", token.title);
  return token;
}
function buildToken(builder, text, style, startStyle, endStyle, css, attributes2) {
  if (!text)
    return;
  let displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
  let special = builder.cm.state.specialChars, mustWrap = false;
  let content;
  if (!special.test(text)) {
    builder.col += text.length;
    content = document.createTextNode(displayText);
    builder.map.push(builder.pos, builder.pos + text.length, content);
    if (ie && ie_version < 9)
      mustWrap = true;
    builder.pos += text.length;
  } else {
    content = document.createDocumentFragment();
    let pos = 0;
    while (true) {
      special.lastIndex = pos;
      let m = special.exec(text);
      let skipped = m ? m.index - pos : text.length - pos;
      if (skipped) {
        let txt2 = document.createTextNode(displayText.slice(pos, pos + skipped));
        if (ie && ie_version < 9)
          content.appendChild(elt("span", [txt2]));
        else
          content.appendChild(txt2);
        builder.map.push(builder.pos, builder.pos + skipped, txt2);
        builder.col += skipped;
        builder.pos += skipped;
      }
      if (!m)
        break;
      pos += skipped + 1;
      let txt;
      if (m[0] == "	") {
        let tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
        txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
        txt.setAttribute("role", "presentation");
        txt.setAttribute("cm-text", "	");
        builder.col += tabWidth;
      } else if (m[0] == "\r" || m[0] == "\n") {
        txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
        txt.setAttribute("cm-text", m[0]);
        builder.col += 1;
      } else {
        txt = builder.cm.options.specialCharPlaceholder(m[0]);
        txt.setAttribute("cm-text", m[0]);
        if (ie && ie_version < 9)
          content.appendChild(elt("span", [txt]));
        else
          content.appendChild(txt);
        builder.col += 1;
      }
      builder.map.push(builder.pos, builder.pos + 1, txt);
      builder.pos++;
    }
  }
  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
  if (style || startStyle || endStyle || mustWrap || css || attributes2) {
    let fullStyle = style || "";
    if (startStyle)
      fullStyle += startStyle;
    if (endStyle)
      fullStyle += endStyle;
    let token = elt("span", [content], fullStyle, css);
    if (attributes2) {
      for (let attr in attributes2)
        if (attributes2.hasOwnProperty(attr) && attr != "style" && attr != "class")
          token.setAttribute(attr, attributes2[attr]);
    }
    return builder.content.appendChild(token);
  }
  builder.content.appendChild(content);
}
function splitSpaces(text, trailingBefore) {
  if (text.length > 1 && !/  /.test(text))
    return text;
  let spaceBefore = trailingBefore, result = "";
  for (let i2 = 0; i2 < text.length; i2++) {
    let ch = text.charAt(i2);
    if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32))
      ch = "\xA0";
    result += ch;
    spaceBefore = ch == " ";
  }
  return result;
}
function buildTokenBadBidi(inner, order2) {
  return (builder, text, style, startStyle, endStyle, css, attributes2) => {
    style = style ? style + " cm-force-border" : "cm-force-border";
    let start2 = builder.pos, end2 = start2 + text.length;
    for (; ; ) {
      let part;
      for (let i2 = 0; i2 < order2.length; i2++) {
        part = order2[i2];
        if (part.to > start2 && part.from <= start2)
          break;
      }
      if (part.to >= end2)
        return inner(builder, text, style, startStyle, endStyle, css, attributes2);
      inner(builder, text.slice(0, part.to - start2), style, startStyle, null, css, attributes2);
      startStyle = null;
      text = text.slice(part.to - start2);
      start2 = part.to;
    }
  };
}
function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
  let widget = !ignoreWidget && marker.widgetNode;
  if (widget)
    builder.map.push(builder.pos, builder.pos + size, widget);
  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
    if (!widget)
      widget = builder.content.appendChild(document.createElement("span"));
    widget.setAttribute("cm-marker", marker.id);
  }
  if (widget) {
    builder.cm.display.input.setUneditable(widget);
    builder.content.appendChild(widget);
  }
  builder.pos += size;
  builder.trailingSpace = false;
}
function insertLineContent(line, builder, styles) {
  let spans = line.markedSpans, allText = line.text, at = 0;
  if (!spans) {
    for (let i3 = 1; i3 < styles.length; i3 += 2)
      builder.addToken(builder, allText.slice(at, at = styles[i3]), interpretTokenStyle(styles[i3 + 1], builder.cm.options));
    return;
  }
  let len = allText.length, pos = 0, i2 = 1, text = "", style, css;
  let nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes2;
  for (; ; ) {
    if (nextChange == pos) {
      spanStyle = spanEndStyle = spanStartStyle = css = "";
      attributes2 = null;
      collapsed = null;
      nextChange = Infinity;
      let foundBookmarks = [], endStyles;
      for (let j = 0; j < spans.length; ++j) {
        let sp = spans[j], m = sp.marker;
        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
          foundBookmarks.push(m);
        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
            nextChange = sp.to;
            spanEndStyle = "";
          }
          if (m.className)
            spanStyle += " " + m.className;
          if (m.css)
            css = (css ? css + ";" : "") + m.css;
          if (m.startStyle && sp.from == pos)
            spanStartStyle += " " + m.startStyle;
          if (m.endStyle && sp.to == nextChange)
            (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
          if (m.title)
            (attributes2 || (attributes2 = {})).title = m.title;
          if (m.attributes) {
            for (let attr in m.attributes)
              (attributes2 || (attributes2 = {}))[attr] = m.attributes[attr];
          }
          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
            collapsed = sp;
        } else if (sp.from > pos && nextChange > sp.from) {
          nextChange = sp.from;
        }
      }
      if (endStyles) {
        for (let j = 0; j < endStyles.length; j += 2)
          if (endStyles[j + 1] == nextChange)
            spanEndStyle += " " + endStyles[j];
      }
      if (!collapsed || collapsed.from == pos)
        for (let j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      if (collapsed && (collapsed.from || 0) == pos) {
        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
        if (collapsed.to == null)
          return;
        if (collapsed.to == pos)
          collapsed = false;
      }
    }
    if (pos >= len)
      break;
    let upto = Math.min(len, nextChange);
    while (true) {
      if (text) {
        let end2 = pos + text.length;
        if (!collapsed) {
          let tokenText = end2 > upto ? text.slice(0, upto - pos) : text;
          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes2);
        }
        if (end2 >= upto) {
          text = text.slice(upto - pos);
          pos = upto;
          break;
        }
        pos = end2;
        spanStartStyle = "";
      }
      text = allText.slice(at, at = styles[i2++]);
      style = interpretTokenStyle(styles[i2++], builder.cm.options);
    }
  }
}
function LineView(doc, line, lineN) {
  this.line = line;
  this.rest = visualLineContinued(line);
  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
  this.node = this.text = null;
  this.hidden = lineIsHidden(doc, line);
}
function buildViewArray(cm, from, to) {
  let array3 = [], nextPos;
  for (let pos = from; pos < to; pos = nextPos) {
    let view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
    nextPos = pos + view.size;
    array3.push(view);
  }
  return array3;
}
let operationGroup = null;
function pushOperation(op) {
  if (operationGroup) {
    operationGroup.ops.push(op);
  } else {
    op.ownsGroup = operationGroup = {
      ops: [op],
      delayedCallbacks: []
    };
  }
}
function fireCallbacksForOps(group) {
  let callbacks = group.delayedCallbacks, i2 = 0;
  do {
    for (; i2 < callbacks.length; i2++)
      callbacks[i2].call(null);
    for (let j = 0; j < group.ops.length; j++) {
      let op = group.ops[j];
      if (op.cursorActivityHandlers)
        while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
          op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
    }
  } while (i2 < callbacks.length);
}
function finishOperation(op, endCb) {
  let group = op.ownsGroup;
  if (!group)
    return;
  try {
    fireCallbacksForOps(group);
  } finally {
    operationGroup = null;
    endCb(group);
  }
}
let orphanDelayedCallbacks = null;
function signalLater(emitter, type2) {
  let arr = getHandlers(emitter, type2);
  if (!arr.length)
    return;
  let args = Array.prototype.slice.call(arguments, 2), list;
  if (operationGroup) {
    list = operationGroup.delayedCallbacks;
  } else if (orphanDelayedCallbacks) {
    list = orphanDelayedCallbacks;
  } else {
    list = orphanDelayedCallbacks = [];
    setTimeout(fireOrphanDelayed, 0);
  }
  for (let i2 = 0; i2 < arr.length; ++i2)
    list.push(() => arr[i2].apply(null, args));
}
function fireOrphanDelayed() {
  let delayed = orphanDelayedCallbacks;
  orphanDelayedCallbacks = null;
  for (let i2 = 0; i2 < delayed.length; ++i2)
    delayed[i2]();
}
function updateLineForChanges(cm, lineView, lineN, dims) {
  for (let j = 0; j < lineView.changes.length; j++) {
    let type2 = lineView.changes[j];
    if (type2 == "text")
      updateLineText(cm, lineView);
    else if (type2 == "gutter")
      updateLineGutter(cm, lineView, lineN, dims);
    else if (type2 == "class")
      updateLineClasses(cm, lineView);
    else if (type2 == "widget")
      updateLineWidgets(cm, lineView, dims);
  }
  lineView.changes = null;
}
function ensureLineWrapped(lineView) {
  if (lineView.node == lineView.text) {
    lineView.node = elt("div", null, null, "position: relative");
    if (lineView.text.parentNode)
      lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
    lineView.node.appendChild(lineView.text);
    if (ie && ie_version < 8)
      lineView.node.style.zIndex = 2;
  }
  return lineView.node;
}
function updateLineBackground(cm, lineView) {
  let cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
  if (cls)
    cls += " CodeMirror-linebackground";
  if (lineView.background) {
    if (cls)
      lineView.background.className = cls;
    else {
      lineView.background.parentNode.removeChild(lineView.background);
      lineView.background = null;
    }
  } else if (cls) {
    let wrap = ensureLineWrapped(lineView);
    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    cm.display.input.setUneditable(lineView.background);
  }
}
function getLineContent(cm, lineView) {
  let ext = cm.display.externalMeasured;
  if (ext && ext.line == lineView.line) {
    cm.display.externalMeasured = null;
    lineView.measure = ext.measure;
    return ext.built;
  }
  return buildLineContent(cm, lineView);
}
function updateLineText(cm, lineView) {
  let cls = lineView.text.className;
  let built = getLineContent(cm, lineView);
  if (lineView.text == lineView.node)
    lineView.node = built.pre;
  lineView.text.parentNode.replaceChild(built.pre, lineView.text);
  lineView.text = built.pre;
  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
    lineView.bgClass = built.bgClass;
    lineView.textClass = built.textClass;
    updateLineClasses(cm, lineView);
  } else if (cls) {
    lineView.text.className = cls;
  }
}
function updateLineClasses(cm, lineView) {
  updateLineBackground(cm, lineView);
  if (lineView.line.wrapClass)
    ensureLineWrapped(lineView).className = lineView.line.wrapClass;
  else if (lineView.node != lineView.text)
    lineView.node.className = "";
  let textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
  lineView.text.className = textClass || "";
}
function updateLineGutter(cm, lineView, lineN, dims) {
  if (lineView.gutter) {
    lineView.node.removeChild(lineView.gutter);
    lineView.gutter = null;
  }
  if (lineView.gutterBackground) {
    lineView.node.removeChild(lineView.gutterBackground);
    lineView.gutterBackground = null;
  }
  if (lineView.line.gutterClass) {
    let wrap = ensureLineWrapped(lineView);
    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, `left: ${cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth}px; width: ${dims.gutterTotalWidth}px`);
    cm.display.input.setUneditable(lineView.gutterBackground);
    wrap.insertBefore(lineView.gutterBackground, lineView.text);
  }
  let markers = lineView.line.gutterMarkers;
  if (cm.options.lineNumbers || markers) {
    let wrap = ensureLineWrapped(lineView);
    let gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", `left: ${cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth}px`);
    gutterWrap.setAttribute("aria-hidden", "true");
    cm.display.input.setUneditable(gutterWrap);
    wrap.insertBefore(gutterWrap, lineView.text);
    if (lineView.line.gutterClass)
      gutterWrap.className += " " + lineView.line.gutterClass;
    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
      lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", `left: ${dims.gutterLeft["CodeMirror-linenumbers"]}px; width: ${cm.display.lineNumInnerWidth}px`));
    if (markers)
      for (let k = 0; k < cm.display.gutterSpecs.length; ++k) {
        let id2 = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id2) && markers[id2];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", `left: ${dims.gutterLeft[id2]}px; width: ${dims.gutterWidth[id2]}px`));
      }
  }
}
function updateLineWidgets(cm, lineView, dims) {
  if (lineView.alignable)
    lineView.alignable = null;
  let isWidget = classTest("CodeMirror-linewidget");
  for (let node = lineView.node.firstChild, next; node; node = next) {
    next = node.nextSibling;
    if (isWidget.test(node.className))
      lineView.node.removeChild(node);
  }
  insertLineWidgets(cm, lineView, dims);
}
function buildLineElement(cm, lineView, lineN, dims) {
  let built = getLineContent(cm, lineView);
  lineView.text = lineView.node = built.pre;
  if (built.bgClass)
    lineView.bgClass = built.bgClass;
  if (built.textClass)
    lineView.textClass = built.textClass;
  updateLineClasses(cm, lineView);
  updateLineGutter(cm, lineView, lineN, dims);
  insertLineWidgets(cm, lineView, dims);
  return lineView.node;
}
function insertLineWidgets(cm, lineView, dims) {
  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
  if (lineView.rest)
    for (let i2 = 0; i2 < lineView.rest.length; i2++)
      insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
}
function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
  if (!line.widgets)
    return;
  let wrap = ensureLineWrapped(lineView);
  for (let i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
    let widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
    if (!widget.handleMouseEvents)
      node.setAttribute("cm-ignore-events", "true");
    positionLineWidget(widget, node, lineView, dims);
    cm.display.input.setUneditable(node);
    if (allowAbove && widget.above)
      wrap.insertBefore(node, lineView.gutter || lineView.text);
    else
      wrap.appendChild(node);
    signalLater(widget, "redraw");
  }
}
function positionLineWidget(widget, node, lineView, dims) {
  if (widget.noHScroll) {
    (lineView.alignable || (lineView.alignable = [])).push(node);
    let width2 = dims.wrapperWidth;
    node.style.left = dims.fixedPos + "px";
    if (!widget.coverGutter) {
      width2 -= dims.gutterTotalWidth;
      node.style.paddingLeft = dims.gutterTotalWidth + "px";
    }
    node.style.width = width2 + "px";
  }
  if (widget.coverGutter) {
    node.style.zIndex = 5;
    node.style.position = "relative";
    if (!widget.noHScroll)
      node.style.marginLeft = -dims.gutterTotalWidth + "px";
  }
}
function widgetHeight(widget) {
  if (widget.height != null)
    return widget.height;
  let cm = widget.doc.cm;
  if (!cm)
    return 0;
  if (!contains(document.body, widget.node)) {
    let parentStyle = "position: relative;";
    if (widget.coverGutter)
      parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
    if (widget.noHScroll)
      parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
  }
  return widget.height = widget.node.parentNode.offsetHeight;
}
function eventInWidget(display, e) {
  for (let n = e_target(e); n != display.wrapper; n = n.parentNode) {
    if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover)
      return true;
  }
}
function paddingTop(display) {
  return display.lineSpace.offsetTop;
}
function paddingVert(display) {
  return display.mover.offsetHeight - display.lineSpace.offsetHeight;
}
function paddingH(display) {
  if (display.cachedPaddingH)
    return display.cachedPaddingH;
  let e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
  let style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
  let data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
  if (!isNaN(data.left) && !isNaN(data.right))
    display.cachedPaddingH = data;
  return data;
}
function scrollGap(cm) {
  return scrollerGap - cm.display.nativeBarWidth;
}
function displayWidth(cm) {
  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
}
function displayHeight(cm) {
  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
}
function ensureLineHeights(cm, lineView, rect) {
  let wrapping = cm.options.lineWrapping;
  let curWidth = wrapping && displayWidth(cm);
  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
    let heights = lineView.measure.heights = [];
    if (wrapping) {
      lineView.measure.width = curWidth;
      let rects = lineView.text.firstChild.getClientRects();
      for (let i2 = 0; i2 < rects.length - 1; i2++) {
        let cur = rects[i2], next = rects[i2 + 1];
        if (Math.abs(cur.bottom - next.bottom) > 2)
          heights.push((cur.bottom + next.top) / 2 - rect.top);
      }
    }
    heights.push(rect.bottom - rect.top);
  }
}
function mapFromLineView(lineView, line, lineN) {
  if (lineView.line == line)
    return { map: lineView.measure.map, cache: lineView.measure.cache };
  for (let i2 = 0; i2 < lineView.rest.length; i2++)
    if (lineView.rest[i2] == line)
      return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
  for (let i2 = 0; i2 < lineView.rest.length; i2++)
    if (lineNo(lineView.rest[i2]) > lineN)
      return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2], before: true };
}
function updateExternalMeasurement(cm, line) {
  line = visualLine(line);
  let lineN = lineNo(line);
  let view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
  view.lineN = lineN;
  let built = view.built = buildLineContent(cm, view);
  view.text = built.pre;
  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
  return view;
}
function measureChar(cm, line, ch, bias) {
  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
}
function findViewForLine(cm, lineN) {
  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
    return cm.display.view[findViewIndex(cm, lineN)];
  let ext = cm.display.externalMeasured;
  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
    return ext;
}
function prepareMeasureForLine(cm, line) {
  let lineN = lineNo(line);
  let view = findViewForLine(cm, lineN);
  if (view && !view.text) {
    view = null;
  } else if (view && view.changes) {
    updateLineForChanges(cm, view, lineN, getDimensions(cm));
    cm.curOp.forceUpdate = true;
  }
  if (!view)
    view = updateExternalMeasurement(cm, line);
  let info = mapFromLineView(view, line, lineN);
  return {
    line,
    view,
    rect: null,
    map: info.map,
    cache: info.cache,
    before: info.before,
    hasHeights: false
  };
}
function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
  if (prepared.before)
    ch = -1;
  let key = ch + (bias || ""), found;
  if (prepared.cache.hasOwnProperty(key)) {
    found = prepared.cache[key];
  } else {
    if (!prepared.rect)
      prepared.rect = prepared.view.text.getBoundingClientRect();
    if (!prepared.hasHeights) {
      ensureLineHeights(cm, prepared.view, prepared.rect);
      prepared.hasHeights = true;
    }
    found = measureCharInner(cm, prepared, ch, bias);
    if (!found.bogus)
      prepared.cache[key] = found;
  }
  return {
    left: found.left,
    right: found.right,
    top: varHeight ? found.rtop : found.top,
    bottom: varHeight ? found.rbottom : found.bottom
  };
}
let nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
function nodeAndOffsetInLineMap(map2, ch, bias) {
  let node, start2, end2, collapse, mStart, mEnd;
  for (let i2 = 0; i2 < map2.length; i2 += 3) {
    mStart = map2[i2];
    mEnd = map2[i2 + 1];
    if (ch < mStart) {
      start2 = 0;
      end2 = 1;
      collapse = "left";
    } else if (ch < mEnd) {
      start2 = ch - mStart;
      end2 = start2 + 1;
    } else if (i2 == map2.length - 3 || ch == mEnd && map2[i2 + 3] > ch) {
      end2 = mEnd - mStart;
      start2 = end2 - 1;
      if (ch >= mEnd)
        collapse = "right";
    }
    if (start2 != null) {
      node = map2[i2 + 2];
      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
        collapse = bias;
      if (bias == "left" && start2 == 0)
        while (i2 && map2[i2 - 2] == map2[i2 - 3] && map2[i2 - 1].insertLeft) {
          node = map2[(i2 -= 3) + 2];
          collapse = "left";
        }
      if (bias == "right" && start2 == mEnd - mStart)
        while (i2 < map2.length - 3 && map2[i2 + 3] == map2[i2 + 4] && !map2[i2 + 5].insertLeft) {
          node = map2[(i2 += 3) + 2];
          collapse = "right";
        }
      break;
    }
  }
  return { node, start: start2, end: end2, collapse, coverStart: mStart, coverEnd: mEnd };
}
function getUsefulRect(rects, bias) {
  let rect = nullRect;
  if (bias == "left")
    for (let i2 = 0; i2 < rects.length; i2++) {
      if ((rect = rects[i2]).left != rect.right)
        break;
    }
  else
    for (let i2 = rects.length - 1; i2 >= 0; i2--) {
      if ((rect = rects[i2]).left != rect.right)
        break;
    }
  return rect;
}
function measureCharInner(cm, prepared, ch, bias) {
  let place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
  let node = place.node, start2 = place.start, end2 = place.end, collapse = place.collapse;
  let rect;
  if (node.nodeType == 3) {
    for (let i3 = 0; i3 < 4; i3++) {
      while (start2 && isExtendingChar(prepared.line.text.charAt(place.coverStart + start2)))
        --start2;
      while (place.coverStart + end2 < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end2)))
        ++end2;
      if (ie && ie_version < 9 && start2 == 0 && end2 == place.coverEnd - place.coverStart)
        rect = node.parentNode.getBoundingClientRect();
      else
        rect = getUsefulRect(range(node, start2, end2).getClientRects(), bias);
      if (rect.left || rect.right || start2 == 0)
        break;
      end2 = start2;
      start2 = start2 - 1;
      collapse = "right";
    }
    if (ie && ie_version < 11)
      rect = maybeUpdateRectForZooming(cm.display.measure, rect);
  } else {
    if (start2 > 0)
      collapse = bias = "right";
    let rects;
    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
      rect = rects[bias == "right" ? rects.length - 1 : 0];
    else
      rect = node.getBoundingClientRect();
  }
  if (ie && ie_version < 9 && !start2 && (!rect || !rect.left && !rect.right)) {
    let rSpan = node.parentNode.getClientRects()[0];
    if (rSpan)
      rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
    else
      rect = nullRect;
  }
  let rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
  let mid = (rtop + rbot) / 2;
  let heights = prepared.view.measure.heights;
  let i2 = 0;
  for (; i2 < heights.length - 1; i2++)
    if (mid < heights[i2])
      break;
  let top2 = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
  let result = {
    left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
    right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
    top: top2,
    bottom: bot
  };
  if (!rect.left && !rect.right)
    result.bogus = true;
  if (!cm.options.singleCursorHeightPerLine) {
    result.rtop = rtop;
    result.rbottom = rbot;
  }
  return result;
}
function maybeUpdateRectForZooming(measure, rect) {
  if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
    return rect;
  let scaleX = screen.logicalXDPI / screen.deviceXDPI;
  let scaleY = screen.logicalYDPI / screen.deviceYDPI;
  return {
    left: rect.left * scaleX,
    right: rect.right * scaleX,
    top: rect.top * scaleY,
    bottom: rect.bottom * scaleY
  };
}
function clearLineMeasurementCacheFor(lineView) {
  if (lineView.measure) {
    lineView.measure.cache = {};
    lineView.measure.heights = null;
    if (lineView.rest)
      for (let i2 = 0; i2 < lineView.rest.length; i2++)
        lineView.measure.caches[i2] = {};
  }
}
function clearLineMeasurementCache(cm) {
  cm.display.externalMeasure = null;
  removeChildren(cm.display.lineMeasure);
  for (let i2 = 0; i2 < cm.display.view.length; i2++)
    clearLineMeasurementCacheFor(cm.display.view[i2]);
}
function clearCaches(cm) {
  clearLineMeasurementCache(cm);
  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
  if (!cm.options.lineWrapping)
    cm.display.maxLineChanged = true;
  cm.display.lineNumChars = null;
}
function pageScrollX() {
  if (chrome && android)
    return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
  return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
}
function pageScrollY() {
  if (chrome && android)
    return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
  return window.pageYOffset || (document.documentElement || document.body).scrollTop;
}
function widgetTopHeight(lineObj) {
  let height = 0;
  if (lineObj.widgets) {
    for (let i2 = 0; i2 < lineObj.widgets.length; ++i2)
      if (lineObj.widgets[i2].above)
        height += widgetHeight(lineObj.widgets[i2]);
  }
  return height;
}
function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
  if (!includeWidgets) {
    let height = widgetTopHeight(lineObj);
    rect.top += height;
    rect.bottom += height;
  }
  if (context == "line")
    return rect;
  if (!context)
    context = "local";
  let yOff = heightAtLine(lineObj);
  if (context == "local")
    yOff += paddingTop(cm.display);
  else
    yOff -= cm.display.viewOffset;
  if (context == "page" || context == "window") {
    let lOff = cm.display.lineSpace.getBoundingClientRect();
    yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
    let xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
    rect.left += xOff;
    rect.right += xOff;
  }
  rect.top += yOff;
  rect.bottom += yOff;
  return rect;
}
function fromCoordSystem(cm, coords, context) {
  if (context == "div")
    return coords;
  let left2 = coords.left, top2 = coords.top;
  if (context == "page") {
    left2 -= pageScrollX();
    top2 -= pageScrollY();
  } else if (context == "local" || !context) {
    let localBox = cm.display.sizer.getBoundingClientRect();
    left2 += localBox.left;
    top2 += localBox.top;
  }
  let lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
  return { left: left2 - lineSpaceBox.left, top: top2 - lineSpaceBox.top };
}
function charCoords(cm, pos, context, lineObj, bias) {
  if (!lineObj)
    lineObj = getLine(cm.doc, pos.line);
  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
}
function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
  lineObj = lineObj || getLine(cm.doc, pos.line);
  if (!preparedMeasure)
    preparedMeasure = prepareMeasureForLine(cm, lineObj);
  function get(ch2, right2) {
    let m = measureCharPrepared(cm, preparedMeasure, ch2, right2 ? "right" : "left", varHeight);
    if (right2)
      m.left = m.right;
    else
      m.right = m.left;
    return intoCoordSystem(cm, lineObj, m, context);
  }
  let order2 = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
  if (ch >= lineObj.text.length) {
    ch = lineObj.text.length;
    sticky = "before";
  } else if (ch <= 0) {
    ch = 0;
    sticky = "after";
  }
  if (!order2)
    return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
  function getBidi(ch2, partPos2, invert) {
    let part = order2[partPos2], right2 = part.level == 1;
    return get(invert ? ch2 - 1 : ch2, right2 != invert);
  }
  let partPos = getBidiPartAt(order2, ch, sticky);
  let other = bidiOther;
  let val = getBidi(ch, partPos, sticky == "before");
  if (other != null)
    val.other = getBidi(ch, other, sticky != "before");
  return val;
}
function estimateCoords(cm, pos) {
  let left2 = 0;
  pos = clipPos(cm.doc, pos);
  if (!cm.options.lineWrapping)
    left2 = charWidth(cm.display) * pos.ch;
  let lineObj = getLine(cm.doc, pos.line);
  let top2 = heightAtLine(lineObj) + paddingTop(cm.display);
  return { left: left2, right: left2, top: top2, bottom: top2 + lineObj.height };
}
function PosWithInfo(line, ch, sticky, outside, xRel) {
  let pos = Pos(line, ch, sticky);
  pos.xRel = xRel;
  if (outside)
    pos.outside = outside;
  return pos;
}
function coordsChar(cm, x, y) {
  let doc = cm.doc;
  y += cm.display.viewOffset;
  if (y < 0)
    return PosWithInfo(doc.first, 0, null, -1, -1);
  let lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
  if (lineN > last)
    return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
  if (x < 0)
    x = 0;
  let lineObj = getLine(doc, lineN);
  for (; ; ) {
    let found = coordsCharInner(cm, lineObj, lineN, x, y);
    let collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
    if (!collapsed)
      return found;
    let rangeEnd = collapsed.find(1);
    if (rangeEnd.line == lineN)
      return rangeEnd;
    lineObj = getLine(doc, lineN = rangeEnd.line);
  }
}
function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
  y -= widgetTopHeight(lineObj);
  let end2 = lineObj.text.length;
  let begin = findFirst((ch) => measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y, end2, 0);
  end2 = findFirst((ch) => measureCharPrepared(cm, preparedMeasure, ch).top > y, begin, end2);
  return { begin, end: end2 };
}
function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
  if (!preparedMeasure)
    preparedMeasure = prepareMeasureForLine(cm, lineObj);
  let targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
}
function boxIsAfter(box, x, y, left2) {
  return box.bottom <= y ? false : box.top > y ? true : (left2 ? box.left : box.right) > x;
}
function coordsCharInner(cm, lineObj, lineNo2, x, y) {
  y -= heightAtLine(lineObj);
  let preparedMeasure = prepareMeasureForLine(cm, lineObj);
  let widgetHeight2 = widgetTopHeight(lineObj);
  let begin = 0, end2 = lineObj.text.length, ltr = true;
  let order2 = getOrder(lineObj, cm.doc.direction);
  if (order2) {
    let part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order2, x, y);
    ltr = part.level != 1;
    begin = ltr ? part.from : part.to - 1;
    end2 = ltr ? part.to : part.from - 1;
  }
  let chAround = null, boxAround = null;
  let ch = findFirst((ch2) => {
    let box = measureCharPrepared(cm, preparedMeasure, ch2);
    box.top += widgetHeight2;
    box.bottom += widgetHeight2;
    if (!boxIsAfter(box, x, y, false))
      return false;
    if (box.top <= y && box.left <= x) {
      chAround = ch2;
      boxAround = box;
    }
    return true;
  }, begin, end2);
  let baseX, sticky, outside = false;
  if (boxAround) {
    let atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
    ch = chAround + (atStart ? 0 : 1);
    sticky = atStart ? "after" : "before";
    baseX = atLeft ? boxAround.left : boxAround.right;
  } else {
    if (!ltr && (ch == end2 || ch == begin))
      ch++;
    sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
    let coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
    baseX = coords.left;
    outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
  }
  ch = skipExtendingChars(lineObj.text, ch, 1);
  return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);
}
function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order2, x, y) {
  let index2 = findFirst((i2) => {
    let part2 = order2[i2], ltr = part2.level != 1;
    return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr ? part2.to : part2.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
  }, 0, order2.length - 1);
  let part = order2[index2];
  if (index2 > 0) {
    let ltr = part.level != 1;
    let start2 = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
    if (boxIsAfter(start2, x, y, true) && start2.top > y)
      part = order2[index2 - 1];
  }
  return part;
}
function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order2, x, y) {
  let { begin, end: end2 } = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
  if (/\s/.test(lineObj.text.charAt(end2 - 1)))
    end2--;
  let part = null, closestDist = null;
  for (let i2 = 0; i2 < order2.length; i2++) {
    let p = order2[i2];
    if (p.from >= end2 || p.to <= begin)
      continue;
    let ltr = p.level != 1;
    let endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end2, p.to) - 1 : Math.max(begin, p.from)).right;
    let dist = endX < x ? x - endX + 1e9 : endX - x;
    if (!part || closestDist > dist) {
      part = p;
      closestDist = dist;
    }
  }
  if (!part)
    part = order2[order2.length - 1];
  if (part.from < begin)
    part = { from: begin, to: part.to, level: part.level };
  if (part.to > end2)
    part = { from: part.from, to: end2, level: part.level };
  return part;
}
let measureText;
function textHeight(display) {
  if (display.cachedTextHeight != null)
    return display.cachedTextHeight;
  if (measureText == null) {
    measureText = elt("pre", null, "CodeMirror-line-like");
    for (let i2 = 0; i2 < 49; ++i2) {
      measureText.appendChild(document.createTextNode("x"));
      measureText.appendChild(elt("br"));
    }
    measureText.appendChild(document.createTextNode("x"));
  }
  removeChildrenAndAdd(display.measure, measureText);
  let height = measureText.offsetHeight / 50;
  if (height > 3)
    display.cachedTextHeight = height;
  removeChildren(display.measure);
  return height || 1;
}
function charWidth(display) {
  if (display.cachedCharWidth != null)
    return display.cachedCharWidth;
  let anchor = elt("span", "xxxxxxxxxx");
  let pre = elt("pre", [anchor], "CodeMirror-line-like");
  removeChildrenAndAdd(display.measure, pre);
  let rect = anchor.getBoundingClientRect(), width2 = (rect.right - rect.left) / 10;
  if (width2 > 2)
    display.cachedCharWidth = width2;
  return width2 || 10;
}
function getDimensions(cm) {
  let d = cm.display, left2 = {}, width2 = {};
  let gutterLeft = d.gutters.clientLeft;
  for (let n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
    let id2 = cm.display.gutterSpecs[i2].className;
    left2[id2] = n.offsetLeft + n.clientLeft + gutterLeft;
    width2[id2] = n.clientWidth;
  }
  return {
    fixedPos: compensateForHScroll(d),
    gutterTotalWidth: d.gutters.offsetWidth,
    gutterLeft: left2,
    gutterWidth: width2,
    wrapperWidth: d.wrapper.clientWidth
  };
}
function compensateForHScroll(display) {
  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
}
function estimateHeight(cm) {
  let th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
  let perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
  return (line) => {
    if (lineIsHidden(cm.doc, line))
      return 0;
    let widgetsHeight = 0;
    if (line.widgets)
      for (let i2 = 0; i2 < line.widgets.length; i2++) {
        if (line.widgets[i2].height)
          widgetsHeight += line.widgets[i2].height;
      }
    if (wrapping)
      return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
    else
      return widgetsHeight + th;
  };
}
function estimateLineHeights(cm) {
  let doc = cm.doc, est = estimateHeight(cm);
  doc.iter((line) => {
    let estHeight = est(line);
    if (estHeight != line.height)
      updateLineHeight(line, estHeight);
  });
}
function posFromMouse(cm, e, liberal, forRect) {
  let display = cm.display;
  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true")
    return null;
  let x, y, space = display.lineSpace.getBoundingClientRect();
  try {
    x = e.clientX - space.left;
    y = e.clientY - space.top;
  } catch (e2) {
    return null;
  }
  let coords = coordsChar(cm, x, y), line;
  if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
    let colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
  }
  return coords;
}
function findViewIndex(cm, n) {
  if (n >= cm.display.viewTo)
    return null;
  n -= cm.display.viewFrom;
  if (n < 0)
    return null;
  let view = cm.display.view;
  for (let i2 = 0; i2 < view.length; i2++) {
    n -= view[i2].size;
    if (n < 0)
      return i2;
  }
}
function regChange(cm, from, to, lendiff) {
  if (from == null)
    from = cm.doc.first;
  if (to == null)
    to = cm.doc.first + cm.doc.size;
  if (!lendiff)
    lendiff = 0;
  let display = cm.display;
  if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from))
    display.updateLineNumbers = from;
  cm.curOp.viewChanged = true;
  if (from >= display.viewTo) {
    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
      resetView(cm);
  } else if (to <= display.viewFrom) {
    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
      resetView(cm);
    } else {
      display.viewFrom += lendiff;
      display.viewTo += lendiff;
    }
  } else if (from <= display.viewFrom && to >= display.viewTo) {
    resetView(cm);
  } else if (from <= display.viewFrom) {
    let cut = viewCuttingPoint(cm, to, to + lendiff, 1);
    if (cut) {
      display.view = display.view.slice(cut.index);
      display.viewFrom = cut.lineN;
      display.viewTo += lendiff;
    } else {
      resetView(cm);
    }
  } else if (to >= display.viewTo) {
    let cut = viewCuttingPoint(cm, from, from, -1);
    if (cut) {
      display.view = display.view.slice(0, cut.index);
      display.viewTo = cut.lineN;
    } else {
      resetView(cm);
    }
  } else {
    let cutTop = viewCuttingPoint(cm, from, from, -1);
    let cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
    if (cutTop && cutBot) {
      display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
      display.viewTo += lendiff;
    } else {
      resetView(cm);
    }
  }
  let ext = display.externalMeasured;
  if (ext) {
    if (to < ext.lineN)
      ext.lineN += lendiff;
    else if (from < ext.lineN + ext.size)
      display.externalMeasured = null;
  }
}
function regLineChange(cm, line, type2) {
  cm.curOp.viewChanged = true;
  let display = cm.display, ext = cm.display.externalMeasured;
  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
    display.externalMeasured = null;
  if (line < display.viewFrom || line >= display.viewTo)
    return;
  let lineView = display.view[findViewIndex(cm, line)];
  if (lineView.node == null)
    return;
  let arr = lineView.changes || (lineView.changes = []);
  if (indexOf(arr, type2) == -1)
    arr.push(type2);
}
function resetView(cm) {
  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
  cm.display.view = [];
  cm.display.viewOffset = 0;
}
function viewCuttingPoint(cm, oldN, newN, dir) {
  let index2 = findViewIndex(cm, oldN), diff, view = cm.display.view;
  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
    return { index: index2, lineN: newN };
  let n = cm.display.viewFrom;
  for (let i2 = 0; i2 < index2; i2++)
    n += view[i2].size;
  if (n != oldN) {
    if (dir > 0) {
      if (index2 == view.length - 1)
        return null;
      diff = n + view[index2].size - oldN;
      index2++;
    } else {
      diff = n - oldN;
    }
    oldN += diff;
    newN += diff;
  }
  while (visualLineNo(cm.doc, newN) != newN) {
    if (index2 == (dir < 0 ? 0 : view.length - 1))
      return null;
    newN += dir * view[index2 - (dir < 0 ? 1 : 0)].size;
    index2 += dir;
  }
  return { index: index2, lineN: newN };
}
function adjustView(cm, from, to) {
  let display = cm.display, view = display.view;
  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
    display.view = buildViewArray(cm, from, to);
    display.viewFrom = from;
  } else {
    if (display.viewFrom > from)
      display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
    else if (display.viewFrom < from)
      display.view = display.view.slice(findViewIndex(cm, from));
    display.viewFrom = from;
    if (display.viewTo < to)
      display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
    else if (display.viewTo > to)
      display.view = display.view.slice(0, findViewIndex(cm, to));
  }
  display.viewTo = to;
}
function countDirtyView(cm) {
  let view = cm.display.view, dirty = 0;
  for (let i2 = 0; i2 < view.length; i2++) {
    let lineView = view[i2];
    if (!lineView.hidden && (!lineView.node || lineView.changes))
      ++dirty;
  }
  return dirty;
}
function updateSelection(cm) {
  cm.display.input.showSelection(cm.display.input.prepareSelection());
}
function prepareSelection(cm, primary = true) {
  let doc = cm.doc, result = {};
  let curFragment = result.cursors = document.createDocumentFragment();
  let selFragment = result.selection = document.createDocumentFragment();
  for (let i2 = 0; i2 < doc.sel.ranges.length; i2++) {
    if (!primary && i2 == doc.sel.primIndex)
      continue;
    let range2 = doc.sel.ranges[i2];
    if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom)
      continue;
    let collapsed = range2.empty();
    if (collapsed || cm.options.showCursorWhenSelecting)
      drawSelectionCursor(cm, range2.head, curFragment);
    if (!collapsed)
      drawSelectionRange(cm, range2, selFragment);
  }
  return result;
}
function drawSelectionCursor(cm, head, output) {
  let pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
  let cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
  cursor.style.left = pos.left + "px";
  cursor.style.top = pos.top + "px";
  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
  if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
    let charPos = charCoords(cm, head, "div", null, null);
    if (charPos.right - charPos.left > 0) {
      cursor.style.width = charPos.right - charPos.left + "px";
    }
  }
  if (pos.other) {
    let otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
    otherCursor.style.display = "";
    otherCursor.style.left = pos.other.left + "px";
    otherCursor.style.top = pos.other.top + "px";
    otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
  }
}
function cmpCoords(a, b) {
  return a.top - b.top || a.left - b.left;
}
function drawSelectionRange(cm, range2, output) {
  let display = cm.display, doc = cm.doc;
  let fragment = document.createDocumentFragment();
  let padding = paddingH(cm.display), leftSide = padding.left;
  let rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
  let docLTR = doc.direction == "ltr";
  function add(left2, top2, width2, bottom2) {
    if (top2 < 0)
      top2 = 0;
    top2 = Math.round(top2);
    bottom2 = Math.round(bottom2);
    fragment.appendChild(elt("div", null, "CodeMirror-selected", `position: absolute; left: ${left2}px;
                             top: ${top2}px; width: ${width2 == null ? rightSide - left2 : width2}px;
                             height: ${bottom2 - top2}px`));
  }
  function drawForLine(line, fromArg, toArg) {
    let lineObj = getLine(doc, line);
    let lineLen = lineObj.text.length;
    let start2, end2;
    function coords(ch, bias) {
      return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
    }
    function wrapX(pos, dir, side) {
      let extent = wrappedLineExtentChar(cm, lineObj, null, pos);
      let prop = dir == "ltr" == (side == "after") ? "left" : "right";
      let ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
      return coords(ch, prop)[prop];
    }
    let order2 = getOrder(lineObj, doc.direction);
    iterateBidiSections(order2, fromArg || 0, toArg == null ? lineLen : toArg, (from, to, dir, i2) => {
      let ltr = dir == "ltr";
      let fromPos = coords(from, ltr ? "left" : "right");
      let toPos = coords(to - 1, ltr ? "right" : "left");
      let openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
      let first = i2 == 0, last = !order2 || i2 == order2.length - 1;
      if (toPos.top - fromPos.top <= 3) {
        let openLeft = (docLTR ? openStart : openEnd) && first;
        let openRight = (docLTR ? openEnd : openStart) && last;
        let left2 = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
        let right2 = openRight ? rightSide : (ltr ? toPos : fromPos).right;
        add(left2, fromPos.top, right2 - left2, fromPos.bottom);
      } else {
        let topLeft, topRight, botLeft, botRight;
        if (ltr) {
          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
          topRight = docLTR ? rightSide : wrapX(from, dir, "before");
          botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
          botRight = docLTR && openEnd && last ? rightSide : toPos.right;
        } else {
          topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
          botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
        }
        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
        if (fromPos.bottom < toPos.top)
          add(leftSide, fromPos.bottom, null, toPos.top);
        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
      }
      if (!start2 || cmpCoords(fromPos, start2) < 0)
        start2 = fromPos;
      if (cmpCoords(toPos, start2) < 0)
        start2 = toPos;
      if (!end2 || cmpCoords(fromPos, end2) < 0)
        end2 = fromPos;
      if (cmpCoords(toPos, end2) < 0)
        end2 = toPos;
    });
    return { start: start2, end: end2 };
  }
  let sFrom = range2.from(), sTo = range2.to();
  if (sFrom.line == sTo.line) {
    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
  } else {
    let fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
    let singleVLine = visualLine(fromLine) == visualLine(toLine);
    let leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
    let rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
    if (singleVLine) {
      if (leftEnd.top < rightStart.top - 2) {
        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
      } else {
        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
      }
    }
    if (leftEnd.bottom < rightStart.top)
      add(leftSide, leftEnd.bottom, null, rightStart.top);
  }
  output.appendChild(fragment);
}
function restartBlink(cm) {
  if (!cm.state.focused)
    return;
  let display = cm.display;
  clearInterval(display.blinker);
  let on2 = true;
  display.cursorDiv.style.visibility = "";
  if (cm.options.cursorBlinkRate > 0)
    display.blinker = setInterval(() => {
      if (!cm.hasFocus())
        onBlur(cm);
      display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
    }, cm.options.cursorBlinkRate);
  else if (cm.options.cursorBlinkRate < 0)
    display.cursorDiv.style.visibility = "hidden";
}
function ensureFocus(cm) {
  if (!cm.hasFocus()) {
    cm.display.input.focus();
    if (!cm.state.focused)
      onFocus(cm);
  }
}
function delayBlurEvent(cm) {
  cm.state.delayingBlurEvent = true;
  setTimeout(() => {
    if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      if (cm.state.focused)
        onBlur(cm);
    }
  }, 100);
}
function onFocus(cm, e) {
  if (cm.state.delayingBlurEvent && !cm.state.draggingText)
    cm.state.delayingBlurEvent = false;
  if (cm.options.readOnly == "nocursor")
    return;
  if (!cm.state.focused) {
    signal(cm, "focus", cm, e);
    cm.state.focused = true;
    addClass(cm.display.wrapper, "CodeMirror-focused");
    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
      cm.display.input.reset();
      if (webkit)
        setTimeout(() => cm.display.input.reset(true), 20);
    }
    cm.display.input.receivedFocus();
  }
  restartBlink(cm);
}
function onBlur(cm, e) {
  if (cm.state.delayingBlurEvent)
    return;
  if (cm.state.focused) {
    signal(cm, "blur", cm, e);
    cm.state.focused = false;
    rmClass(cm.display.wrapper, "CodeMirror-focused");
  }
  clearInterval(cm.display.blinker);
  setTimeout(() => {
    if (!cm.state.focused)
      cm.display.shift = false;
  }, 150);
}
function updateHeightsInViewport(cm) {
  let display = cm.display;
  let prevBottom = display.lineDiv.offsetTop;
  let viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
  let oldHeight = display.lineDiv.getBoundingClientRect().top;
  let mustScroll = 0;
  for (let i2 = 0; i2 < display.view.length; i2++) {
    let cur = display.view[i2], wrapping = cm.options.lineWrapping;
    let height, width2 = 0;
    if (cur.hidden)
      continue;
    oldHeight += cur.line.height;
    if (ie && ie_version < 8) {
      let bot = cur.node.offsetTop + cur.node.offsetHeight;
      height = bot - prevBottom;
      prevBottom = bot;
    } else {
      let box = cur.node.getBoundingClientRect();
      height = box.bottom - box.top;
      if (!wrapping && cur.text.firstChild)
        width2 = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
    }
    let diff = cur.line.height - height;
    if (diff > 5e-3 || diff < -5e-3) {
      if (oldHeight < viewTop)
        mustScroll -= diff;
      updateLineHeight(cur.line, height);
      updateWidgetHeight(cur.line);
      if (cur.rest)
        for (let j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
    }
    if (width2 > cm.display.sizerWidth) {
      let chWidth = Math.ceil(width2 / charWidth(cm.display));
      if (chWidth > cm.display.maxLineLength) {
        cm.display.maxLineLength = chWidth;
        cm.display.maxLine = cur.line;
        cm.display.maxLineChanged = true;
      }
    }
  }
  if (Math.abs(mustScroll) > 2)
    display.scroller.scrollTop += mustScroll;
}
function updateWidgetHeight(line) {
  if (line.widgets)
    for (let i2 = 0; i2 < line.widgets.length; ++i2) {
      let w = line.widgets[i2], parent2 = w.node.parentNode;
      if (parent2)
        w.height = parent2.offsetHeight;
    }
}
function visibleLines(display, doc, viewport2) {
  let top2 = viewport2 && viewport2.top != null ? Math.max(0, viewport2.top) : display.scroller.scrollTop;
  top2 = Math.floor(top2 - paddingTop(display));
  let bottom2 = viewport2 && viewport2.bottom != null ? viewport2.bottom : top2 + display.wrapper.clientHeight;
  let from = lineAtHeight(doc, top2), to = lineAtHeight(doc, bottom2);
  if (viewport2 && viewport2.ensure) {
    let ensureFrom = viewport2.ensure.from.line, ensureTo = viewport2.ensure.to.line;
    if (ensureFrom < from) {
      from = ensureFrom;
      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
      to = ensureTo;
    }
  }
  return { from, to: Math.max(to, from + 1) };
}
function maybeScrollWindow(cm, rect) {
  if (signalDOMEvent(cm, "scrollCursorIntoView"))
    return;
  let display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
  if (rect.top + box.top < 0)
    doScroll = true;
  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
    doScroll = false;
  if (doScroll != null && !phantom) {
    let scrollNode = elt("div", "\u200B", null, `position: absolute;
                         top: ${rect.top - display.viewOffset - paddingTop(cm.display)}px;
                         height: ${rect.bottom - rect.top + scrollGap(cm) + display.barHeight}px;
                         left: ${rect.left}px; width: ${Math.max(2, rect.right - rect.left)}px;`);
    cm.display.lineSpace.appendChild(scrollNode);
    scrollNode.scrollIntoView(doScroll);
    cm.display.lineSpace.removeChild(scrollNode);
  }
}
function scrollPosIntoView(cm, pos, end2, margin) {
  if (margin == null)
    margin = 0;
  let rect;
  if (!cm.options.lineWrapping && pos == end2) {
    end2 = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
  }
  for (let limit = 0; limit < 5; limit++) {
    let changed = false;
    let coords = cursorCoords(cm, pos);
    let endCoords = !end2 || end2 == pos ? coords : cursorCoords(cm, end2);
    rect = {
      left: Math.min(coords.left, endCoords.left),
      top: Math.min(coords.top, endCoords.top) - margin,
      right: Math.max(coords.left, endCoords.left),
      bottom: Math.max(coords.bottom, endCoords.bottom) + margin
    };
    let scrollPos = calculateScrollPos(cm, rect);
    let startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
      if (Math.abs(cm.doc.scrollTop - startTop) > 1)
        changed = true;
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
        changed = true;
    }
    if (!changed)
      break;
  }
  return rect;
}
function scrollIntoView(cm, rect) {
  let scrollPos = calculateScrollPos(cm, rect);
  if (scrollPos.scrollTop != null)
    updateScrollTop(cm, scrollPos.scrollTop);
  if (scrollPos.scrollLeft != null)
    setScrollLeft(cm, scrollPos.scrollLeft);
}
function calculateScrollPos(cm, rect) {
  let display = cm.display, snapMargin = textHeight(cm.display);
  if (rect.top < 0)
    rect.top = 0;
  let screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
  let screen2 = displayHeight(cm), result = {};
  if (rect.bottom - rect.top > screen2)
    rect.bottom = rect.top + screen2;
  let docBottom = cm.doc.height + paddingVert(display);
  let atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
  if (rect.top < screentop) {
    result.scrollTop = atTop ? 0 : rect.top;
  } else if (rect.bottom > screentop + screen2) {
    let newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
    if (newTop != screentop)
      result.scrollTop = newTop;
  }
  let gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
  let screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
  let screenw = displayWidth(cm) - display.gutters.offsetWidth;
  let tooWide = rect.right - rect.left > screenw;
  if (tooWide)
    rect.right = rect.left + screenw;
  if (rect.left < 10)
    result.scrollLeft = 0;
  else if (rect.left < screenleft)
    result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
  else if (rect.right > screenw + screenleft - 3)
    result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
  return result;
}
function addToScrollTop(cm, top2) {
  if (top2 == null)
    return;
  resolveScrollToPos(cm);
  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top2;
}
function ensureCursorVisible(cm) {
  resolveScrollToPos(cm);
  let cur = cm.getCursor();
  cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
}
function scrollToCoords(cm, x, y) {
  if (x != null || y != null)
    resolveScrollToPos(cm);
  if (x != null)
    cm.curOp.scrollLeft = x;
  if (y != null)
    cm.curOp.scrollTop = y;
}
function scrollToRange(cm, range2) {
  resolveScrollToPos(cm);
  cm.curOp.scrollToPos = range2;
}
function resolveScrollToPos(cm) {
  let range2 = cm.curOp.scrollToPos;
  if (range2) {
    cm.curOp.scrollToPos = null;
    let from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
    scrollToCoordsRange(cm, from, to, range2.margin);
  }
}
function scrollToCoordsRange(cm, from, to, margin) {
  let sPos = calculateScrollPos(cm, {
    left: Math.min(from.left, to.left),
    top: Math.min(from.top, to.top) - margin,
    right: Math.max(from.right, to.right),
    bottom: Math.max(from.bottom, to.bottom) + margin
  });
  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
}
function updateScrollTop(cm, val) {
  if (Math.abs(cm.doc.scrollTop - val) < 2)
    return;
  if (!gecko)
    updateDisplaySimple(cm, { top: val });
  setScrollTop(cm, val, true);
  if (gecko)
    updateDisplaySimple(cm);
  startWorker(cm, 100);
}
function setScrollTop(cm, val, forceScroll) {
  val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
  if (cm.display.scroller.scrollTop == val && !forceScroll)
    return;
  cm.doc.scrollTop = val;
  cm.display.scrollbars.setScrollTop(val);
  if (cm.display.scroller.scrollTop != val)
    cm.display.scroller.scrollTop = val;
}
function setScrollLeft(cm, val, isScroller, forceScroll) {
  val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll)
    return;
  cm.doc.scrollLeft = val;
  alignHorizontally(cm);
  if (cm.display.scroller.scrollLeft != val)
    cm.display.scroller.scrollLeft = val;
  cm.display.scrollbars.setScrollLeft(val);
}
function measureForScrollbars(cm) {
  let d = cm.display, gutterW = d.gutters.offsetWidth;
  let docH = Math.round(cm.doc.height + paddingVert(cm.display));
  return {
    clientHeight: d.scroller.clientHeight,
    viewHeight: d.wrapper.clientHeight,
    scrollWidth: d.scroller.scrollWidth,
    clientWidth: d.scroller.clientWidth,
    viewWidth: d.wrapper.clientWidth,
    barLeft: cm.options.fixedGutter ? gutterW : 0,
    docHeight: docH,
    scrollHeight: docH + scrollGap(cm) + d.barHeight,
    nativeBarWidth: d.nativeBarWidth,
    gutterWidth: gutterW
  };
}
class NativeScrollbars {
  constructor(place, scroll, cm) {
    this.cm = cm;
    let vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    let horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert);
    place(horiz);
    on$1(vert, "scroll", () => {
      if (vert.clientHeight)
        scroll(vert.scrollTop, "vertical");
    });
    on$1(horiz, "scroll", () => {
      if (horiz.clientWidth)
        scroll(horiz.scrollLeft, "horizontal");
    });
    this.checkedZeroWidth = false;
    if (ie && ie_version < 8)
      this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
  }
  update(measure) {
    let needsH = measure.scrollWidth > measure.clientWidth + 1;
    let needsV = measure.scrollHeight > measure.clientHeight + 1;
    let sWidth = measure.nativeBarWidth;
    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      let totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }
    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      let totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }
    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0)
        this.zeroWidthHack();
      this.checkedZeroWidth = true;
    }
    return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
  }
  setScrollLeft(pos) {
    if (this.horiz.scrollLeft != pos)
      this.horiz.scrollLeft = pos;
    if (this.disableHoriz)
      this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
  }
  setScrollTop(pos) {
    if (this.vert.scrollTop != pos)
      this.vert.scrollTop = pos;
    if (this.disableVert)
      this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
  }
  zeroWidthHack() {
    let w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed();
    this.disableVert = new Delayed();
  }
  enableZeroWidthBar(bar, delay, type2) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      let box = bar.getBoundingClientRect();
      let elt2 = type2 == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt2 != bar)
        bar.style.pointerEvents = "none";
      else
        delay.set(1e3, maybeDisable);
    }
    delay.set(1e3, maybeDisable);
  }
  clear() {
    let parent2 = this.horiz.parentNode;
    parent2.removeChild(this.horiz);
    parent2.removeChild(this.vert);
  }
}
class NullScrollbars {
  update() {
    return { bottom: 0, right: 0 };
  }
  setScrollLeft() {
  }
  setScrollTop() {
  }
  clear() {
  }
}
function updateScrollbars(cm, measure) {
  if (!measure)
    measure = measureForScrollbars(cm);
  let startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
  updateScrollbarsInner(cm, measure);
  for (let i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
      updateHeightsInViewport(cm);
    updateScrollbarsInner(cm, measureForScrollbars(cm));
    startWidth = cm.display.barWidth;
    startHeight = cm.display.barHeight;
  }
}
function updateScrollbarsInner(cm, measure) {
  let d = cm.display;
  let sizes = d.scrollbars.update(measure);
  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
  if (sizes.right && sizes.bottom) {
    d.scrollbarFiller.style.display = "block";
    d.scrollbarFiller.style.height = sizes.bottom + "px";
    d.scrollbarFiller.style.width = sizes.right + "px";
  } else
    d.scrollbarFiller.style.display = "";
  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
    d.gutterFiller.style.display = "block";
    d.gutterFiller.style.height = sizes.bottom + "px";
    d.gutterFiller.style.width = measure.gutterWidth + "px";
  } else
    d.gutterFiller.style.display = "";
}
let scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
function initScrollbars(cm) {
  if (cm.display.scrollbars) {
    cm.display.scrollbars.clear();
    if (cm.display.scrollbars.addClass)
      rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }
  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle]((node) => {
    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
    on$1(node, "mousedown", () => {
      if (cm.state.focused)
        setTimeout(() => cm.display.input.focus(), 0);
    });
    node.setAttribute("cm-not-content", "true");
  }, (pos, axis) => {
    if (axis == "horizontal")
      setScrollLeft(cm, pos);
    else
      updateScrollTop(cm, pos);
  }, cm);
  if (cm.display.scrollbars.addClass)
    addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
}
let nextOpId = 0;
function startOperation(cm) {
  cm.curOp = {
    cm,
    viewChanged: false,
    startHeight: cm.doc.height,
    forceUpdate: false,
    updateInput: 0,
    typing: false,
    changeObjs: null,
    cursorActivityHandlers: null,
    cursorActivityCalled: 0,
    selectionChanged: false,
    updateMaxLine: false,
    scrollLeft: null,
    scrollTop: null,
    scrollToPos: null,
    focus: false,
    id: ++nextOpId,
    markArrays: null
  };
  pushOperation(cm.curOp);
}
function endOperation(cm) {
  let op = cm.curOp;
  if (op)
    finishOperation(op, (group) => {
      for (let i2 = 0; i2 < group.ops.length; i2++)
        group.ops[i2].cm.curOp = null;
      endOperations(group);
    });
}
function endOperations(group) {
  let ops = group.ops;
  for (let i2 = 0; i2 < ops.length; i2++)
    endOperation_R1(ops[i2]);
  for (let i2 = 0; i2 < ops.length; i2++)
    endOperation_W1(ops[i2]);
  for (let i2 = 0; i2 < ops.length; i2++)
    endOperation_R2(ops[i2]);
  for (let i2 = 0; i2 < ops.length; i2++)
    endOperation_W2(ops[i2]);
  for (let i2 = 0; i2 < ops.length; i2++)
    endOperation_finish(ops[i2]);
}
function endOperation_R1(op) {
  let cm = op.cm, display = cm.display;
  maybeClipScrollbars(cm);
  if (op.updateMaxLine)
    findMaxLine(cm);
  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
  op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
}
function endOperation_W1(op) {
  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
}
function endOperation_R2(op) {
  let cm = op.cm, display = cm.display;
  if (op.updatedDisplay)
    updateHeightsInViewport(cm);
  op.barMeasure = measureForScrollbars(cm);
  if (display.maxLineChanged && !cm.options.lineWrapping) {
    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
    cm.display.sizerWidth = op.adjustWidthTo;
    op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
  }
  if (op.updatedDisplay || op.selectionChanged)
    op.preparedSelection = display.input.prepareSelection();
}
function endOperation_W2(op) {
  let cm = op.cm;
  if (op.adjustWidthTo != null) {
    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
    if (op.maxScrollLeft < cm.doc.scrollLeft)
      setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
    cm.display.maxLineChanged = false;
  }
  let takeFocus = op.focus && op.focus == activeElt();
  if (op.preparedSelection)
    cm.display.input.showSelection(op.preparedSelection, takeFocus);
  if (op.updatedDisplay || op.startHeight != cm.doc.height)
    updateScrollbars(cm, op.barMeasure);
  if (op.updatedDisplay)
    setDocumentHeight(cm, op.barMeasure);
  if (op.selectionChanged)
    restartBlink(cm);
  if (cm.state.focused && op.updateInput)
    cm.display.input.reset(op.typing);
  if (takeFocus)
    ensureFocus(op.cm);
}
function endOperation_finish(op) {
  let cm = op.cm, display = cm.display, doc = cm.doc;
  if (op.updatedDisplay)
    postUpdateDisplay(cm, op.update);
  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
    display.wheelStartX = display.wheelStartY = null;
  if (op.scrollTop != null)
    setScrollTop(cm, op.scrollTop, op.forceScroll);
  if (op.scrollLeft != null)
    setScrollLeft(cm, op.scrollLeft, true, true);
  if (op.scrollToPos) {
    let rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
    maybeScrollWindow(cm, rect);
  }
  let hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
  if (hidden) {
    for (let i2 = 0; i2 < hidden.length; ++i2)
      if (!hidden[i2].lines.length)
        signal(hidden[i2], "hide");
  }
  if (unhidden) {
    for (let i2 = 0; i2 < unhidden.length; ++i2)
      if (unhidden[i2].lines.length)
        signal(unhidden[i2], "unhide");
  }
  if (display.wrapper.offsetHeight)
    doc.scrollTop = cm.display.scroller.scrollTop;
  if (op.changeObjs)
    signal(cm, "changes", cm, op.changeObjs);
  if (op.update)
    op.update.finish();
}
function runInOp(cm, f) {
  if (cm.curOp)
    return f();
  startOperation(cm);
  try {
    return f();
  } finally {
    endOperation(cm);
  }
}
function operation(cm, f) {
  return function() {
    if (cm.curOp)
      return f.apply(cm, arguments);
    startOperation(cm);
    try {
      return f.apply(cm, arguments);
    } finally {
      endOperation(cm);
    }
  };
}
function methodOp(f) {
  return function() {
    if (this.curOp)
      return f.apply(this, arguments);
    startOperation(this);
    try {
      return f.apply(this, arguments);
    } finally {
      endOperation(this);
    }
  };
}
function docMethodOp(f) {
  return function() {
    let cm = this.cm;
    if (!cm || cm.curOp)
      return f.apply(this, arguments);
    startOperation(cm);
    try {
      return f.apply(this, arguments);
    } finally {
      endOperation(cm);
    }
  };
}
function startWorker(cm, time) {
  if (cm.doc.highlightFrontier < cm.display.viewTo)
    cm.state.highlight.set(time, bind$3(highlightWorker, cm));
}
function highlightWorker(cm) {
  let doc = cm.doc;
  if (doc.highlightFrontier >= cm.display.viewTo)
    return;
  let end2 = +new Date() + cm.options.workTime;
  let context = getContextBefore(cm, doc.highlightFrontier);
  let changedLines = [];
  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), (line) => {
    if (context.line >= cm.display.viewFrom) {
      let oldStyles = line.styles;
      let resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
      let highlighted = highlightLine(cm, line, context, true);
      if (resetState)
        context.state = resetState;
      line.styles = highlighted.styles;
      let oldCls = line.styleClasses, newCls = highlighted.classes;
      if (newCls)
        line.styleClasses = newCls;
      else if (oldCls)
        line.styleClasses = null;
      let ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
      for (let i2 = 0; !ischange && i2 < oldStyles.length; ++i2)
        ischange = oldStyles[i2] != line.styles[i2];
      if (ischange)
        changedLines.push(context.line);
      line.stateAfter = context.save();
      context.nextLine();
    } else {
      if (line.text.length <= cm.options.maxHighlightLength)
        processLine(cm, line.text, context);
      line.stateAfter = context.line % 5 == 0 ? context.save() : null;
      context.nextLine();
    }
    if (+new Date() > end2) {
      startWorker(cm, cm.options.workDelay);
      return true;
    }
  });
  doc.highlightFrontier = context.line;
  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
  if (changedLines.length)
    runInOp(cm, () => {
      for (let i2 = 0; i2 < changedLines.length; i2++)
        regLineChange(cm, changedLines[i2], "text");
    });
}
class DisplayUpdate {
  constructor(cm, viewport2, force) {
    let display = cm.display;
    this.viewport = viewport2;
    this.visible = visibleLines(display, cm.doc, viewport2);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  }
  signal(emitter, type2) {
    if (hasHandler(emitter, type2))
      this.events.push(arguments);
  }
  finish() {
    for (let i2 = 0; i2 < this.events.length; i2++)
      signal.apply(null, this.events[i2]);
  }
}
function maybeClipScrollbars(cm) {
  let display = cm.display;
  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
    display.heightForcer.style.height = scrollGap(cm) + "px";
    display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
    display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
    display.scrollbarsClipped = true;
  }
}
function selectionSnapshot(cm) {
  if (cm.hasFocus())
    return null;
  let active = activeElt();
  if (!active || !contains(cm.display.lineDiv, active))
    return null;
  let result = { activeElt: active };
  if (window.getSelection) {
    let sel = window.getSelection();
    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
      result.anchorNode = sel.anchorNode;
      result.anchorOffset = sel.anchorOffset;
      result.focusNode = sel.focusNode;
      result.focusOffset = sel.focusOffset;
    }
  }
  return result;
}
function restoreSelection(snapshot) {
  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt())
    return;
  snapshot.activeElt.focus();
  if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
    let sel = window.getSelection(), range2 = document.createRange();
    range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
    range2.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range2);
    sel.extend(snapshot.focusNode, snapshot.focusOffset);
  }
}
function updateDisplayIfNeeded(cm, update) {
  let display = cm.display, doc = cm.doc;
  if (update.editorIsHidden) {
    resetView(cm);
    return false;
  }
  if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0)
    return false;
  if (maybeUpdateLineNumberWidth(cm)) {
    resetView(cm);
    update.dims = getDimensions(cm);
  }
  let end2 = doc.first + doc.size;
  let from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
  let to = Math.min(end2, update.visible.to + cm.options.viewportMargin);
  if (display.viewFrom < from && from - display.viewFrom < 20)
    from = Math.max(doc.first, display.viewFrom);
  if (display.viewTo > to && display.viewTo - to < 20)
    to = Math.min(end2, display.viewTo);
  if (sawCollapsedSpans) {
    from = visualLineNo(cm.doc, from);
    to = visualLineEndNo(cm.doc, to);
  }
  let different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
  adjustView(cm, from, to);
  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
  cm.display.mover.style.top = display.viewOffset + "px";
  let toUpdate = countDirtyView(cm);
  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
    return false;
  let selSnapshot = selectionSnapshot(cm);
  if (toUpdate > 4)
    display.lineDiv.style.display = "none";
  patchDisplay(cm, display.updateLineNumbers, update.dims);
  if (toUpdate > 4)
    display.lineDiv.style.display = "";
  display.renderedView = display.view;
  restoreSelection(selSnapshot);
  removeChildren(display.cursorDiv);
  removeChildren(display.selectionDiv);
  display.gutters.style.height = display.sizer.style.minHeight = 0;
  if (different) {
    display.lastWrapHeight = update.wrapperHeight;
    display.lastWrapWidth = update.wrapperWidth;
    startWorker(cm, 400);
  }
  display.updateLineNumbers = null;
  return true;
}
function postUpdateDisplay(cm, update) {
  let viewport2 = update.viewport;
  for (let first = true; ; first = false) {
    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
      if (viewport2 && viewport2.top != null)
        viewport2 = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport2.top) };
      update.visible = visibleLines(cm.display, cm.doc, viewport2);
      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
        break;
    } else if (first) {
      update.visible = visibleLines(cm.display, cm.doc, viewport2);
    }
    if (!updateDisplayIfNeeded(cm, update))
      break;
    updateHeightsInViewport(cm);
    let barMeasure = measureForScrollbars(cm);
    updateSelection(cm);
    updateScrollbars(cm, barMeasure);
    setDocumentHeight(cm, barMeasure);
    update.force = false;
  }
  update.signal(cm, "update", cm);
  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
    cm.display.reportedViewFrom = cm.display.viewFrom;
    cm.display.reportedViewTo = cm.display.viewTo;
  }
}
function updateDisplaySimple(cm, viewport2) {
  let update = new DisplayUpdate(cm, viewport2);
  if (updateDisplayIfNeeded(cm, update)) {
    updateHeightsInViewport(cm);
    postUpdateDisplay(cm, update);
    let barMeasure = measureForScrollbars(cm);
    updateSelection(cm);
    updateScrollbars(cm, barMeasure);
    setDocumentHeight(cm, barMeasure);
    update.finish();
  }
}
function patchDisplay(cm, updateNumbersFrom, dims) {
  let display = cm.display, lineNumbers = cm.options.lineNumbers;
  let container = display.lineDiv, cur = container.firstChild;
  function rm(node) {
    let next = node.nextSibling;
    if (webkit && mac && cm.display.currentWheelTarget == node)
      node.style.display = "none";
    else
      node.parentNode.removeChild(node);
    return next;
  }
  let view = display.view, lineN = display.viewFrom;
  for (let i2 = 0; i2 < view.length; i2++) {
    let lineView = view[i2];
    if (lineView.hidden)
      ;
    else if (!lineView.node || lineView.node.parentNode != container) {
      let node = buildLineElement(cm, lineView, lineN, dims);
      container.insertBefore(node, cur);
    } else {
      while (cur != lineView.node)
        cur = rm(cur);
      let updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
      if (lineView.changes) {
        if (indexOf(lineView.changes, "gutter") > -1)
          updateNumber = false;
        updateLineForChanges(cm, lineView, lineN, dims);
      }
      if (updateNumber) {
        removeChildren(lineView.lineNumber);
        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
      }
      cur = lineView.node.nextSibling;
    }
    lineN += lineView.size;
  }
  while (cur)
    cur = rm(cur);
}
function updateGutterSpace(display) {
  let width2 = display.gutters.offsetWidth;
  display.sizer.style.marginLeft = width2 + "px";
  signalLater(display, "gutterChanged", display);
}
function setDocumentHeight(cm, measure) {
  cm.display.sizer.style.minHeight = measure.docHeight + "px";
  cm.display.heightForcer.style.top = measure.docHeight + "px";
  cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
}
function alignHorizontally(cm) {
  let display = cm.display, view = display.view;
  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
    return;
  let comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
  let gutterW = display.gutters.offsetWidth, left2 = comp + "px";
  for (let i2 = 0; i2 < view.length; i2++)
    if (!view[i2].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i2].gutter)
          view[i2].gutter.style.left = left2;
        if (view[i2].gutterBackground)
          view[i2].gutterBackground.style.left = left2;
      }
      let align = view[i2].alignable;
      if (align)
        for (let j = 0; j < align.length; j++)
          align[j].style.left = left2;
    }
  if (cm.options.fixedGutter)
    display.gutters.style.left = comp + gutterW + "px";
}
function maybeUpdateLineNumberWidth(cm) {
  if (!cm.options.lineNumbers)
    return false;
  let doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
  if (last.length != display.lineNumChars) {
    let test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
    let innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
    display.lineGutter.style.width = "";
    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
    display.lineNumWidth = display.lineNumInnerWidth + padding;
    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
    display.lineGutter.style.width = display.lineNumWidth + "px";
    updateGutterSpace(cm.display);
    return true;
  }
  return false;
}
function getGutters(gutters, lineNumbers) {
  let result = [], sawLineNumbers = false;
  for (let i2 = 0; i2 < gutters.length; i2++) {
    let name2 = gutters[i2], style = null;
    if (typeof name2 != "string") {
      style = name2.style;
      name2 = name2.className;
    }
    if (name2 == "CodeMirror-linenumbers") {
      if (!lineNumbers)
        continue;
      else
        sawLineNumbers = true;
    }
    result.push({ className: name2, style });
  }
  if (lineNumbers && !sawLineNumbers)
    result.push({ className: "CodeMirror-linenumbers", style: null });
  return result;
}
function renderGutters(display) {
  let gutters = display.gutters, specs = display.gutterSpecs;
  removeChildren(gutters);
  display.lineGutter = null;
  for (let i2 = 0; i2 < specs.length; ++i2) {
    let { className, style } = specs[i2];
    let gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
    if (style)
      gElt.style.cssText = style;
    if (className == "CodeMirror-linenumbers") {
      display.lineGutter = gElt;
      gElt.style.width = (display.lineNumWidth || 1) + "px";
    }
  }
  gutters.style.display = specs.length ? "" : "none";
  updateGutterSpace(display);
}
function updateGutters(cm) {
  renderGutters(cm.display);
  regChange(cm);
  alignHorizontally(cm);
}
function Display(place, doc, input2, options2) {
  let d = this;
  this.input = input2;
  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
  d.scrollbarFiller.setAttribute("cm-not-content", "true");
  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
  d.gutterFiller.setAttribute("cm-not-content", "true");
  d.lineDiv = eltP("div", null, "CodeMirror-code");
  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
  d.cursorDiv = elt("div", null, "CodeMirror-cursors");
  d.measure = elt("div", null, "CodeMirror-measure");
  d.lineMeasure = elt("div", null, "CodeMirror-measure");
  d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
  let lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
  d.mover = elt("div", [lines], null, "position: relative");
  d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
  d.sizerWidth = null;
  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
  d.gutters = elt("div", null, "CodeMirror-gutters");
  d.lineGutter = null;
  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
  d.scroller.setAttribute("tabIndex", "-1");
  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
  d.wrapper.setAttribute("translate", "no");
  if (ie && ie_version < 8) {
    d.gutters.style.zIndex = -1;
    d.scroller.style.paddingRight = 0;
  }
  if (!webkit && !(gecko && mobile))
    d.scroller.draggable = true;
  if (place) {
    if (place.appendChild)
      place.appendChild(d.wrapper);
    else
      place(d.wrapper);
  }
  d.viewFrom = d.viewTo = doc.first;
  d.reportedViewFrom = d.reportedViewTo = doc.first;
  d.view = [];
  d.renderedView = null;
  d.externalMeasured = null;
  d.viewOffset = 0;
  d.lastWrapHeight = d.lastWrapWidth = 0;
  d.updateLineNumbers = null;
  d.nativeBarWidth = d.barHeight = d.barWidth = 0;
  d.scrollbarsClipped = false;
  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
  d.alignWidgets = false;
  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
  d.maxLine = null;
  d.maxLineLength = 0;
  d.maxLineChanged = false;
  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
  d.shift = false;
  d.selForContextMenu = null;
  d.activeTouch = null;
  d.gutterSpecs = getGutters(options2.gutters, options2.lineNumbers);
  renderGutters(d);
  input2.init(d);
}
let wheelSamples = 0, wheelPixelsPerUnit = null;
if (ie)
  wheelPixelsPerUnit = -0.53;
else if (gecko)
  wheelPixelsPerUnit = 15;
else if (chrome)
  wheelPixelsPerUnit = -0.7;
else if (safari)
  wheelPixelsPerUnit = -1 / 3;
function wheelEventDelta(e) {
  let dx = e.wheelDeltaX, dy = e.wheelDeltaY;
  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
    dx = e.detail;
  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
    dy = e.detail;
  else if (dy == null)
    dy = e.wheelDelta;
  return { x: dx, y: dy };
}
function wheelEventPixels(e) {
  let delta = wheelEventDelta(e);
  delta.x *= wheelPixelsPerUnit;
  delta.y *= wheelPixelsPerUnit;
  return delta;
}
function onScrollWheel(cm, e) {
  let delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
  let pixelsPerUnit = wheelPixelsPerUnit;
  if (event.deltaMode === 0) {
    dx = e.deltaX;
    dy = e.deltaY;
    pixelsPerUnit = 1;
  }
  let display = cm.display, scroll = display.scroller;
  let canScrollX = scroll.scrollWidth > scroll.clientWidth;
  let canScrollY = scroll.scrollHeight > scroll.clientHeight;
  if (!(dx && canScrollX || dy && canScrollY))
    return;
  if (dy && mac && webkit) {
    outer:
      for (let cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (let i2 = 0; i2 < view.length; i2++) {
          if (view[i2].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
  }
  if (dx && !gecko && !presto && pixelsPerUnit != null) {
    if (dy && canScrollY)
      updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
    if (!dy || dy && canScrollY)
      e_preventDefault(e);
    display.wheelStartX = null;
    return;
  }
  if (dy && pixelsPerUnit != null) {
    let pixels = dy * pixelsPerUnit;
    let top2 = cm.doc.scrollTop, bot = top2 + display.wrapper.clientHeight;
    if (pixels < 0)
      top2 = Math.max(0, top2 + pixels - 50);
    else
      bot = Math.min(cm.doc.height, bot + pixels + 50);
    updateDisplaySimple(cm, { top: top2, bottom: bot });
  }
  if (wheelSamples < 20 && e.deltaMode !== 0) {
    if (display.wheelStartX == null) {
      display.wheelStartX = scroll.scrollLeft;
      display.wheelStartY = scroll.scrollTop;
      display.wheelDX = dx;
      display.wheelDY = dy;
      setTimeout(() => {
        if (display.wheelStartX == null)
          return;
        let movedX = scroll.scrollLeft - display.wheelStartX;
        let movedY = scroll.scrollTop - display.wheelStartY;
        let sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
        display.wheelStartX = display.wheelStartY = null;
        if (!sample)
          return;
        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
        ++wheelSamples;
      }, 200);
    } else {
      display.wheelDX += dx;
      display.wheelDY += dy;
    }
  }
}
class Selection {
  constructor(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }
  primary() {
    return this.ranges[this.primIndex];
  }
  equals(other) {
    if (other == this)
      return true;
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length)
      return false;
    for (let i2 = 0; i2 < this.ranges.length; i2++) {
      let here = this.ranges[i2], there = other.ranges[i2];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head))
        return false;
    }
    return true;
  }
  deepCopy() {
    let out = [];
    for (let i2 = 0; i2 < this.ranges.length; i2++)
      out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
    return new Selection(out, this.primIndex);
  }
  somethingSelected() {
    for (let i2 = 0; i2 < this.ranges.length; i2++)
      if (!this.ranges[i2].empty())
        return true;
    return false;
  }
  contains(pos, end2) {
    if (!end2)
      end2 = pos;
    for (let i2 = 0; i2 < this.ranges.length; i2++) {
      let range2 = this.ranges[i2];
      if (cmp(end2, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0)
        return i2;
    }
    return -1;
  }
}
class Range {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  from() {
    return minPos(this.anchor, this.head);
  }
  to() {
    return maxPos(this.anchor, this.head);
  }
  empty() {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  }
}
function normalizeSelection(cm, ranges, primIndex) {
  let mayTouch = cm && cm.options.selectionsMayTouch;
  let prim = ranges[primIndex];
  ranges.sort((a, b) => cmp(a.from(), b.from()));
  primIndex = indexOf(ranges, prim);
  for (let i2 = 1; i2 < ranges.length; i2++) {
    let cur = ranges[i2], prev = ranges[i2 - 1];
    let diff = cmp(prev.to(), cur.from());
    if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
      let from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
      let inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
      if (i2 <= primIndex)
        --primIndex;
      ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));
    }
  }
  return new Selection(ranges, primIndex);
}
function simpleSelection(anchor, head) {
  return new Selection([new Range(anchor, head || anchor)], 0);
}
function changeEnd(change) {
  if (!change.text)
    return change.to;
  return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
}
function adjustForChange(pos, change) {
  if (cmp(pos, change.from) < 0)
    return pos;
  if (cmp(pos, change.to) <= 0)
    return changeEnd(change);
  let line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
  if (pos.line == change.to.line)
    ch += changeEnd(change).ch - change.to.ch;
  return Pos(line, ch);
}
function computeSelAfterChange(doc, change) {
  let out = [];
  for (let i2 = 0; i2 < doc.sel.ranges.length; i2++) {
    let range2 = doc.sel.ranges[i2];
    out.push(new Range(adjustForChange(range2.anchor, change), adjustForChange(range2.head, change)));
  }
  return normalizeSelection(doc.cm, out, doc.sel.primIndex);
}
function offsetPos(pos, old, nw) {
  if (pos.line == old.line)
    return Pos(nw.line, pos.ch - old.ch + nw.ch);
  else
    return Pos(nw.line + (pos.line - old.line), pos.ch);
}
function computeReplacedSel(doc, changes, hint) {
  let out = [];
  let oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
  for (let i2 = 0; i2 < changes.length; i2++) {
    let change = changes[i2];
    let from = offsetPos(change.from, oldPrev, newPrev);
    let to = offsetPos(changeEnd(change), oldPrev, newPrev);
    oldPrev = change.to;
    newPrev = to;
    if (hint == "around") {
      let range2 = doc.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
      out[i2] = new Range(inv ? to : from, inv ? from : to);
    } else {
      out[i2] = new Range(from, from);
    }
  }
  return new Selection(out, doc.sel.primIndex);
}
function loadMode(cm) {
  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
  resetModeState(cm);
}
function resetModeState(cm) {
  cm.doc.iter((line) => {
    if (line.stateAfter)
      line.stateAfter = null;
    if (line.styles)
      line.styles = null;
  });
  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
  startWorker(cm, 100);
  cm.state.modeGen++;
  if (cm.curOp)
    regChange(cm);
}
function isWholeLineUpdate(doc, change) {
  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
}
function updateDoc(doc, change, markedSpans, estimateHeight2) {
  function spansFor(n) {
    return markedSpans ? markedSpans[n] : null;
  }
  function update(line, text2, spans) {
    updateLine(line, text2, spans, estimateHeight2);
    signalLater(line, "change", line, change);
  }
  function linesFor(start2, end2) {
    let result = [];
    for (let i2 = start2; i2 < end2; ++i2)
      result.push(new Line(text[i2], spansFor(i2), estimateHeight2));
    return result;
  }
  let from = change.from, to = change.to, text = change.text;
  let firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
  let lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
  if (change.full) {
    doc.insert(0, linesFor(0, text.length));
    doc.remove(text.length, doc.size - text.length);
  } else if (isWholeLineUpdate(doc, change)) {
    let added = linesFor(0, text.length - 1);
    update(lastLine, lastLine.text, lastSpans);
    if (nlines)
      doc.remove(from.line, nlines);
    if (added.length)
      doc.insert(from.line, added);
  } else if (firstLine == lastLine) {
    if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
    } else {
      let added = linesFor(1, text.length - 1);
      added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      doc.insert(from.line + 1, added);
    }
  } else if (text.length == 1) {
    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
    doc.remove(from.line + 1, nlines);
  } else {
    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
    let added = linesFor(1, text.length - 1);
    if (nlines > 1)
      doc.remove(from.line + 1, nlines - 1);
    doc.insert(from.line + 1, added);
  }
  signalLater(doc, "change", doc, change);
}
function linkedDocs(doc, f, sharedHistOnly) {
  function propagate(doc2, skip, sharedHist) {
    if (doc2.linked)
      for (let i2 = 0; i2 < doc2.linked.length; ++i2) {
        let rel = doc2.linked[i2];
        if (rel.doc == skip)
          continue;
        let shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared)
          continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc2, shared);
      }
  }
  propagate(doc, null, true);
}
function attachDoc(cm, doc) {
  if (doc.cm)
    throw new Error("This document is already in use.");
  cm.doc = doc;
  doc.cm = cm;
  estimateLineHeights(cm);
  loadMode(cm);
  setDirectionClass(cm);
  cm.options.direction = doc.direction;
  if (!cm.options.lineWrapping)
    findMaxLine(cm);
  cm.options.mode = doc.modeOption;
  regChange(cm);
}
function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
}
function directionChanged(cm) {
  runInOp(cm, () => {
    setDirectionClass(cm);
    regChange(cm);
  });
}
function History(prev) {
  this.done = [];
  this.undone = [];
  this.undoDepth = prev ? prev.undoDepth : Infinity;
  this.lastModTime = this.lastSelTime = 0;
  this.lastOp = this.lastSelOp = null;
  this.lastOrigin = this.lastSelOrigin = null;
  this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
}
function historyChangeFromChange(doc, change) {
  let histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
  linkedDocs(doc, (doc2) => attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1), true);
  return histChange;
}
function clearSelectionEvents(array3) {
  while (array3.length) {
    let last = lst(array3);
    if (last.ranges)
      array3.pop();
    else
      break;
  }
}
function lastChangeEvent(hist, force) {
  if (force) {
    clearSelectionEvents(hist.done);
    return lst(hist.done);
  } else if (hist.done.length && !lst(hist.done).ranges) {
    return lst(hist.done);
  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
    hist.done.pop();
    return lst(hist.done);
  }
}
function addChangeToHistory(doc, change, selAfter, opId) {
  let hist = doc.history;
  hist.undone.length = 0;
  let time = +new Date(), cur;
  let last;
  if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
    last = lst(cur.changes);
    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
      last.to = changeEnd(change);
    } else {
      cur.changes.push(historyChangeFromChange(doc, change));
    }
  } else {
    let before = lst(hist.done);
    if (!before || !before.ranges)
      pushSelectionToHistory(doc.sel, hist.done);
    cur = {
      changes: [historyChangeFromChange(doc, change)],
      generation: hist.generation
    };
    hist.done.push(cur);
    while (hist.done.length > hist.undoDepth) {
      hist.done.shift();
      if (!hist.done[0].ranges)
        hist.done.shift();
    }
  }
  hist.done.push(selAfter);
  hist.generation = ++hist.maxGeneration;
  hist.lastModTime = hist.lastSelTime = time;
  hist.lastOp = hist.lastSelOp = opId;
  hist.lastOrigin = hist.lastSelOrigin = change.origin;
  if (!last)
    signal(doc, "historyAdded");
}
function selectionEventCanBeMerged(doc, origin, prev, sel) {
  let ch = origin.charAt(0);
  return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
}
function addSelectionToHistory(doc, sel, opId, options2) {
  let hist = doc.history, origin = options2 && options2.origin;
  if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)))
    hist.done[hist.done.length - 1] = sel;
  else
    pushSelectionToHistory(sel, hist.done);
  hist.lastSelTime = +new Date();
  hist.lastSelOrigin = origin;
  hist.lastSelOp = opId;
  if (options2 && options2.clearRedo !== false)
    clearSelectionEvents(hist.undone);
}
function pushSelectionToHistory(sel, dest) {
  let top2 = lst(dest);
  if (!(top2 && top2.ranges && top2.equals(sel)))
    dest.push(sel);
}
function attachLocalSpans(doc, change, from, to) {
  let existing = change["spans_" + doc.id], n = 0;
  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), (line) => {
    if (line.markedSpans)
      (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
    ++n;
  });
}
function removeClearedSpans(spans) {
  if (!spans)
    return null;
  let out;
  for (let i2 = 0; i2 < spans.length; ++i2) {
    if (spans[i2].marker.explicitlyCleared) {
      if (!out)
        out = spans.slice(0, i2);
    } else if (out)
      out.push(spans[i2]);
  }
  return !out ? spans : out.length ? out : null;
}
function getOldSpans(doc, change) {
  let found = change["spans_" + doc.id];
  if (!found)
    return null;
  let nw = [];
  for (let i2 = 0; i2 < change.text.length; ++i2)
    nw.push(removeClearedSpans(found[i2]));
  return nw;
}
function mergeOldSpans(doc, change) {
  let old = getOldSpans(doc, change);
  let stretched = stretchSpansOverChange(doc, change);
  if (!old)
    return stretched;
  if (!stretched)
    return old;
  for (let i2 = 0; i2 < old.length; ++i2) {
    let oldCur = old[i2], stretchCur = stretched[i2];
    if (oldCur && stretchCur) {
      spans:
        for (let j = 0; j < stretchCur.length; ++j) {
          let span = stretchCur[j];
          for (let k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker)
              continue spans;
          oldCur.push(span);
        }
    } else if (stretchCur) {
      old[i2] = stretchCur;
    }
  }
  return old;
}
function copyHistoryArray(events2, newGroup, instantiateSel) {
  let copy = [];
  for (let i2 = 0; i2 < events2.length; ++i2) {
    let event2 = events2[i2];
    if (event2.ranges) {
      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event2) : event2);
      continue;
    }
    let changes = event2.changes, newChanges = [];
    copy.push({ changes: newChanges });
    for (let j = 0; j < changes.length; ++j) {
      let change = changes[j], m;
      newChanges.push({ from: change.from, to: change.to, text: change.text });
      if (newGroup) {
        for (var prop in change)
          if (m = prop.match(/^spans_(\d+)$/)) {
            if (indexOf(newGroup, Number(m[1])) > -1) {
              lst(newChanges)[prop] = change[prop];
              delete change[prop];
            }
          }
      }
    }
  }
  return copy;
}
function extendRange(range2, head, other, extend2) {
  if (extend2) {
    let anchor = range2.anchor;
    if (other) {
      let posBefore = cmp(head, anchor) < 0;
      if (posBefore != cmp(other, anchor) < 0) {
        anchor = head;
        head = other;
      } else if (posBefore != cmp(head, other) < 0) {
        head = other;
      }
    }
    return new Range(anchor, head);
  } else {
    return new Range(other || head, head);
  }
}
function extendSelection(doc, head, other, options2, extend2) {
  if (extend2 == null)
    extend2 = doc.cm && (doc.cm.display.shift || doc.extend);
  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend2)], 0), options2);
}
function extendSelections(doc, heads, options2) {
  let out = [];
  let extend2 = doc.cm && (doc.cm.display.shift || doc.extend);
  for (let i2 = 0; i2 < doc.sel.ranges.length; i2++)
    out[i2] = extendRange(doc.sel.ranges[i2], heads[i2], null, extend2);
  let newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
  setSelection(doc, newSel, options2);
}
function replaceOneSelection(doc, i2, range2, options2) {
  let ranges = doc.sel.ranges.slice(0);
  ranges[i2] = range2;
  setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options2);
}
function setSimpleSelection(doc, anchor, head, options2) {
  setSelection(doc, simpleSelection(anchor, head), options2);
}
function filterSelectionChange(doc, sel, options2) {
  let obj = {
    ranges: sel.ranges,
    update: function(ranges) {
      this.ranges = [];
      for (let i2 = 0; i2 < ranges.length; i2++)
        this.ranges[i2] = new Range(clipPos(doc, ranges[i2].anchor), clipPos(doc, ranges[i2].head));
    },
    origin: options2 && options2.origin
  };
  signal(doc, "beforeSelectionChange", doc, obj);
  if (doc.cm)
    signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
  if (obj.ranges != sel.ranges)
    return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
  else
    return sel;
}
function setSelectionReplaceHistory(doc, sel, options2) {
  let done = doc.history.done, last = lst(done);
  if (last && last.ranges) {
    done[done.length - 1] = sel;
    setSelectionNoUndo(doc, sel, options2);
  } else {
    setSelection(doc, sel, options2);
  }
}
function setSelection(doc, sel, options2) {
  setSelectionNoUndo(doc, sel, options2);
  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options2);
}
function setSelectionNoUndo(doc, sel, options2) {
  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
    sel = filterSelectionChange(doc, sel, options2);
  let bias = options2 && options2.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
  if (!(options2 && options2.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor")
    ensureCursorVisible(doc.cm);
}
function setSelectionInner(doc, sel) {
  if (sel.equals(doc.sel))
    return;
  doc.sel = sel;
  if (doc.cm) {
    doc.cm.curOp.updateInput = 1;
    doc.cm.curOp.selectionChanged = true;
    signalCursorActivity(doc.cm);
  }
  signalLater(doc, "cursorActivity", doc);
}
function reCheckSelection(doc) {
  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
}
function skipAtomicInSelection(doc, sel, bias, mayClear) {
  let out;
  for (let i2 = 0; i2 < sel.ranges.length; i2++) {
    let range2 = sel.ranges[i2];
    let old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i2];
    let newAnchor = skipAtomic(doc, range2.anchor, old && old.anchor, bias, mayClear);
    let newHead = skipAtomic(doc, range2.head, old && old.head, bias, mayClear);
    if (out || newAnchor != range2.anchor || newHead != range2.head) {
      if (!out)
        out = sel.ranges.slice(0, i2);
      out[i2] = new Range(newAnchor, newHead);
    }
  }
  return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
}
function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
  let line = getLine(doc, pos.line);
  if (line.markedSpans)
    for (let i2 = 0; i2 < line.markedSpans.length; ++i2) {
      let sp = line.markedSpans[i2], m = sp.marker;
      let preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
      let preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans)
              break;
            else {
              --i2;
              continue;
            }
          }
        }
        if (!m.atomic)
          continue;
        if (oldPos) {
          let near = m.find(dir < 0 ? 1 : -1), diff;
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            return skipAtomicInner(doc, near, pos, dir, mayClear);
        }
        let far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          far = movePos(doc, far, dir, far.line == pos.line ? line : null);
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
      }
    }
  return pos;
}
function skipAtomic(doc, pos, oldPos, bias, mayClear) {
  let dir = bias || 1;
  let found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
  if (!found) {
    doc.cantEdit = true;
    return Pos(doc.first, 0);
  }
  return found;
}
function movePos(doc, pos, dir, line) {
  if (dir < 0 && pos.ch == 0) {
    if (pos.line > doc.first)
      return clipPos(doc, Pos(pos.line - 1));
    else
      return null;
  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
    if (pos.line < doc.first + doc.size - 1)
      return Pos(pos.line + 1, 0);
    else
      return null;
  } else {
    return new Pos(pos.line, pos.ch + dir);
  }
}
function selectAll(cm) {
  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
}
function filterChange(doc, change, update) {
  let obj = {
    canceled: false,
    from: change.from,
    to: change.to,
    text: change.text,
    origin: change.origin,
    cancel: () => obj.canceled = true
  };
  if (update)
    obj.update = (from, to, text, origin) => {
      if (from)
        obj.from = clipPos(doc, from);
      if (to)
        obj.to = clipPos(doc, to);
      if (text)
        obj.text = text;
      if (origin !== void 0)
        obj.origin = origin;
    };
  signal(doc, "beforeChange", doc, obj);
  if (doc.cm)
    signal(doc.cm, "beforeChange", doc.cm, obj);
  if (obj.canceled) {
    if (doc.cm)
      doc.cm.curOp.updateInput = 2;
    return null;
  }
  return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
}
function makeChange(doc, change, ignoreReadOnly) {
  if (doc.cm) {
    if (!doc.cm.curOp)
      return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
    if (doc.cm.state.suppressEdits)
      return;
  }
  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
    change = filterChange(doc, change, true);
    if (!change)
      return;
  }
  let split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
  if (split) {
    for (let i2 = split.length - 1; i2 >= 0; --i2)
      makeChangeInner(doc, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
  } else {
    makeChangeInner(doc, change);
  }
}
function makeChangeInner(doc, change) {
  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0)
    return;
  let selAfter = computeSelAfterChange(doc, change);
  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
  let rebased = [];
  linkedDocs(doc, (doc2, sharedHist) => {
    if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
      rebaseHist(doc2.history, change);
      rebased.push(doc2.history);
    }
    makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));
  });
}
function makeChangeFromHistory(doc, type2, allowSelectionOnly) {
  let suppress = doc.cm && doc.cm.state.suppressEdits;
  if (suppress && !allowSelectionOnly)
    return;
  let hist = doc.history, event2, selAfter = doc.sel;
  let source2 = type2 == "undo" ? hist.done : hist.undone, dest = type2 == "undo" ? hist.undone : hist.done;
  let i2 = 0;
  for (; i2 < source2.length; i2++) {
    event2 = source2[i2];
    if (allowSelectionOnly ? event2.ranges && !event2.equals(doc.sel) : !event2.ranges)
      break;
  }
  if (i2 == source2.length)
    return;
  hist.lastOrigin = hist.lastSelOrigin = null;
  for (; ; ) {
    event2 = source2.pop();
    if (event2.ranges) {
      pushSelectionToHistory(event2, dest);
      if (allowSelectionOnly && !event2.equals(doc.sel)) {
        setSelection(doc, event2, { clearRedo: false });
        return;
      }
      selAfter = event2;
    } else if (suppress) {
      source2.push(event2);
      return;
    } else
      break;
  }
  let antiChanges = [];
  pushSelectionToHistory(selAfter, dest);
  dest.push({ changes: antiChanges, generation: hist.generation });
  hist.generation = event2.generation || ++hist.maxGeneration;
  let filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
  for (let i3 = event2.changes.length - 1; i3 >= 0; --i3) {
    let change = event2.changes[i3];
    change.origin = type2;
    if (filter && !filterChange(doc, change, false)) {
      source2.length = 0;
      return;
    }
    antiChanges.push(historyChangeFromChange(doc, change));
    let after = i3 ? computeSelAfterChange(doc, change) : lst(source2);
    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
    if (!i3 && doc.cm)
      doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
    let rebased = [];
    linkedDocs(doc, (doc2, sharedHist) => {
      if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
        rebaseHist(doc2.history, change);
        rebased.push(doc2.history);
      }
      makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));
    });
  }
}
function shiftDoc(doc, distance) {
  if (distance == 0)
    return;
  doc.first += distance;
  doc.sel = new Selection(map(doc.sel.ranges, (range2) => new Range(Pos(range2.anchor.line + distance, range2.anchor.ch), Pos(range2.head.line + distance, range2.head.ch))), doc.sel.primIndex);
  if (doc.cm) {
    regChange(doc.cm, doc.first, doc.first - distance, distance);
    for (let d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
      regLineChange(doc.cm, l, "gutter");
  }
}
function makeChangeSingleDoc(doc, change, selAfter, spans) {
  if (doc.cm && !doc.cm.curOp)
    return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
  if (change.to.line < doc.first) {
    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
    return;
  }
  if (change.from.line > doc.lastLine())
    return;
  if (change.from.line < doc.first) {
    let shift = change.text.length - 1 - (doc.first - change.from.line);
    shiftDoc(doc, shift);
    change = {
      from: Pos(doc.first, 0),
      to: Pos(change.to.line + shift, change.to.ch),
      text: [lst(change.text)],
      origin: change.origin
    };
  }
  let last = doc.lastLine();
  if (change.to.line > last) {
    change = {
      from: change.from,
      to: Pos(last, getLine(doc, last).text.length),
      text: [change.text[0]],
      origin: change.origin
    };
  }
  change.removed = getBetween(doc, change.from, change.to);
  if (!selAfter)
    selAfter = computeSelAfterChange(doc, change);
  if (doc.cm)
    makeChangeSingleDocInEditor(doc.cm, change, spans);
  else
    updateDoc(doc, change, spans);
  setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
    doc.cantEdit = false;
}
function makeChangeSingleDocInEditor(cm, change, spans) {
  let doc = cm.doc, display = cm.display, from = change.from, to = change.to;
  let recomputeMaxLength = false, checkWidthStart = from.line;
  if (!cm.options.lineWrapping) {
    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
    doc.iter(checkWidthStart, to.line + 1, (line) => {
      if (line == display.maxLine) {
        recomputeMaxLength = true;
        return true;
      }
    });
  }
  if (doc.sel.contains(change.from, change.to) > -1)
    signalCursorActivity(cm);
  updateDoc(doc, change, spans, estimateHeight(cm));
  if (!cm.options.lineWrapping) {
    doc.iter(checkWidthStart, from.line + change.text.length, (line) => {
      let len = lineLength(line);
      if (len > display.maxLineLength) {
        display.maxLine = line;
        display.maxLineLength = len;
        display.maxLineChanged = true;
        recomputeMaxLength = false;
      }
    });
    if (recomputeMaxLength)
      cm.curOp.updateMaxLine = true;
  }
  retreatFrontier(doc, from.line);
  startWorker(cm, 400);
  let lendiff = change.text.length - (to.line - from.line) - 1;
  if (change.full)
    regChange(cm);
  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
    regLineChange(cm, from.line, "text");
  else
    regChange(cm, from.line, to.line + 1, lendiff);
  let changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
  if (changeHandler || changesHandler) {
    let obj = {
      from,
      to,
      text: change.text,
      removed: change.removed,
      origin: change.origin
    };
    if (changeHandler)
      signalLater(cm, "change", cm, obj);
    if (changesHandler)
      (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
  }
  cm.display.selForContextMenu = null;
}
function replaceRange(doc, code, from, to, origin) {
  if (!to)
    to = from;
  if (cmp(to, from) < 0)
    [from, to] = [to, from];
  if (typeof code == "string")
    code = doc.splitLines(code);
  makeChange(doc, { from, to, text: code, origin });
}
function rebaseHistSelSingle(pos, from, to, diff) {
  if (to < pos.line) {
    pos.line += diff;
  } else if (from < pos.line) {
    pos.line = from;
    pos.ch = 0;
  }
}
function rebaseHistArray(array3, from, to, diff) {
  for (let i2 = 0; i2 < array3.length; ++i2) {
    let sub = array3[i2], ok = true;
    if (sub.ranges) {
      if (!sub.copied) {
        sub = array3[i2] = sub.deepCopy();
        sub.copied = true;
      }
      for (let j = 0; j < sub.ranges.length; j++) {
        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
      }
      continue;
    }
    for (let j = 0; j < sub.changes.length; ++j) {
      let cur = sub.changes[j];
      if (to < cur.from.line) {
        cur.from = Pos(cur.from.line + diff, cur.from.ch);
        cur.to = Pos(cur.to.line + diff, cur.to.ch);
      } else if (from <= cur.to.line) {
        ok = false;
        break;
      }
    }
    if (!ok) {
      array3.splice(0, i2 + 1);
      i2 = 0;
    }
  }
}
function rebaseHist(hist, change) {
  let from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
  rebaseHistArray(hist.done, from, to, diff);
  rebaseHistArray(hist.undone, from, to, diff);
}
function changeLine(doc, handle, changeType, op) {
  let no = handle, line = handle;
  if (typeof handle == "number")
    line = getLine(doc, clipLine(doc, handle));
  else
    no = lineNo(handle);
  if (no == null)
    return null;
  if (op(line, no) && doc.cm)
    regLineChange(doc.cm, no, changeType);
  return line;
}
function LeafChunk(lines) {
  this.lines = lines;
  this.parent = null;
  let height = 0;
  for (let i2 = 0; i2 < lines.length; ++i2) {
    lines[i2].parent = this;
    height += lines[i2].height;
  }
  this.height = height;
}
LeafChunk.prototype = {
  chunkSize() {
    return this.lines.length;
  },
  removeInner(at, n) {
    for (let i2 = at, e = at + n; i2 < e; ++i2) {
      let line = this.lines[i2];
      this.height -= line.height;
      cleanUpLine(line);
      signalLater(line, "delete");
    }
    this.lines.splice(at, n);
  },
  collapse(lines) {
    lines.push.apply(lines, this.lines);
  },
  insertInner(at, lines, height) {
    this.height += height;
    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
    for (let i2 = 0; i2 < lines.length; ++i2)
      lines[i2].parent = this;
  },
  iterN(at, n, op) {
    for (let e = at + n; at < e; ++at)
      if (op(this.lines[at]))
        return true;
  }
};
function BranchChunk(children) {
  this.children = children;
  let size = 0, height = 0;
  for (let i2 = 0; i2 < children.length; ++i2) {
    let ch = children[i2];
    size += ch.chunkSize();
    height += ch.height;
    ch.parent = this;
  }
  this.size = size;
  this.height = height;
  this.parent = null;
}
BranchChunk.prototype = {
  chunkSize() {
    return this.size;
  },
  removeInner(at, n) {
    this.size -= n;
    for (let i2 = 0; i2 < this.children.length; ++i2) {
      let child = this.children[i2], sz = child.chunkSize();
      if (at < sz) {
        let rm = Math.min(n, sz - at), oldHeight = child.height;
        child.removeInner(at, rm);
        this.height -= oldHeight - child.height;
        if (sz == rm) {
          this.children.splice(i2--, 1);
          child.parent = null;
        }
        if ((n -= rm) == 0)
          break;
        at = 0;
      } else
        at -= sz;
    }
    if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
      let lines = [];
      this.collapse(lines);
      this.children = [new LeafChunk(lines)];
      this.children[0].parent = this;
    }
  },
  collapse(lines) {
    for (let i2 = 0; i2 < this.children.length; ++i2)
      this.children[i2].collapse(lines);
  },
  insertInner(at, lines, height) {
    this.size += lines.length;
    this.height += height;
    for (let i2 = 0; i2 < this.children.length; ++i2) {
      let child = this.children[i2], sz = child.chunkSize();
      if (at <= sz) {
        child.insertInner(at, lines, height);
        if (child.lines && child.lines.length > 50) {
          let remaining = child.lines.length % 25 + 25;
          for (let pos = remaining; pos < child.lines.length; ) {
            let leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
            child.height -= leaf.height;
            this.children.splice(++i2, 0, leaf);
            leaf.parent = this;
          }
          child.lines = child.lines.slice(0, remaining);
          this.maybeSpill();
        }
        break;
      }
      at -= sz;
    }
  },
  maybeSpill() {
    if (this.children.length <= 10)
      return;
    let me = this;
    do {
      let spilled = me.children.splice(me.children.length - 5, 5);
      let sibling = new BranchChunk(spilled);
      if (!me.parent) {
        let copy = new BranchChunk(me.children);
        copy.parent = me;
        me.children = [copy, sibling];
        me = copy;
      } else {
        me.size -= sibling.size;
        me.height -= sibling.height;
        let myIndex = indexOf(me.parent.children, me);
        me.parent.children.splice(myIndex + 1, 0, sibling);
      }
      sibling.parent = me.parent;
    } while (me.children.length > 10);
    me.parent.maybeSpill();
  },
  iterN(at, n, op) {
    for (let i2 = 0; i2 < this.children.length; ++i2) {
      let child = this.children[i2], sz = child.chunkSize();
      if (at < sz) {
        let used = Math.min(n, sz - at);
        if (child.iterN(at, used, op))
          return true;
        if ((n -= used) == 0)
          break;
        at = 0;
      } else
        at -= sz;
    }
  }
};
class LineWidget {
  constructor(doc, node, options2) {
    if (options2) {
      for (let opt in options2)
        if (options2.hasOwnProperty(opt))
          this[opt] = options2[opt];
    }
    this.doc = doc;
    this.node = node;
  }
  clear() {
    let cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws)
      return;
    for (let i2 = 0; i2 < ws.length; ++i2)
      if (ws[i2] == this)
        ws.splice(i2--, 1);
    if (!ws.length)
      line.widgets = null;
    let height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, () => {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  }
  changed() {
    let oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    let diff = widgetHeight(this) - oldH;
    if (!diff)
      return;
    if (!lineIsHidden(this.doc, line))
      updateLineHeight(line, line.height + diff);
    if (cm) {
      runInOp(cm, () => {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this, lineNo(line));
      });
    }
  }
}
eventMixin(LineWidget);
function adjustScrollWhenAboveVisible(cm, line, diff) {
  if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop))
    addToScrollTop(cm, diff);
}
function addLineWidget(doc, handle, node, options2) {
  let widget = new LineWidget(doc, node, options2);
  let cm = doc.cm;
  if (cm && widget.noHScroll)
    cm.display.alignWidgets = true;
  changeLine(doc, handle, "widget", (line) => {
    let widgets = line.widgets || (line.widgets = []);
    if (widget.insertAt == null)
      widgets.push(widget);
    else
      widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
    widget.line = line;
    if (cm && !lineIsHidden(doc, line)) {
      let aboveVisible = heightAtLine(line) < doc.scrollTop;
      updateLineHeight(line, line.height + widgetHeight(widget));
      if (aboveVisible)
        addToScrollTop(cm, widget.height);
      cm.curOp.forceUpdate = true;
    }
    return true;
  });
  if (cm)
    signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
  return widget;
}
let nextMarkerId = 0;
class TextMarker {
  constructor(doc, type2) {
    this.lines = [];
    this.type = type2;
    this.doc = doc;
    this.id = ++nextMarkerId;
  }
  clear() {
    if (this.explicitlyCleared)
      return;
    let cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp)
      startOperation(cm);
    if (hasHandler(this, "clear")) {
      let found = this.find();
      if (found)
        signalLater(this, "clear", found.from, found.to);
    }
    let min2 = null, max2 = null;
    for (let i2 = 0; i2 < this.lines.length; ++i2) {
      let line = this.lines[i2];
      let span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed)
        regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null)
          max2 = lineNo(line);
        if (span.from != null)
          min2 = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping)
      for (let i2 = 0; i2 < this.lines.length; ++i2) {
        let visual = visualLine(this.lines[i2]), len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    if (min2 != null && cm && this.collapsed)
      regChange(cm, min2, max2 + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm)
        reCheckSelection(cm.doc);
    }
    if (cm)
      signalLater(cm, "markerCleared", cm, this, min2, max2);
    if (withOp)
      endOperation(cm);
    if (this.parent)
      this.parent.clear();
  }
  find(side, lineObj) {
    if (side == null && this.type == "bookmark")
      side = 1;
    let from, to;
    for (let i2 = 0; i2 < this.lines.length; ++i2) {
      let line = this.lines[i2];
      let span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1)
          return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1)
          return to;
      }
    }
    return from && { from, to };
  }
  changed() {
    let pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm)
      return;
    runInOp(cm, () => {
      let line = pos.line, lineN = lineNo(pos.line);
      let view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        let oldHeight = widget.height;
        widget.height = null;
        let dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
      signalLater(cm, "markerChanged", cm, this);
    });
  }
  attachLine(line) {
    if (!this.lines.length && this.doc.cm) {
      let op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  }
  detachLine(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      let op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  }
}
eventMixin(TextMarker);
function markText(doc, from, to, options2, type2) {
  if (options2 && options2.shared)
    return markTextShared(doc, from, to, options2, type2);
  if (doc.cm && !doc.cm.curOp)
    return operation(doc.cm, markText)(doc, from, to, options2, type2);
  let marker = new TextMarker(doc, type2), diff = cmp(from, to);
  if (options2)
    copyObj(options2, marker, false);
  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
    return marker;
  if (marker.replacedWith) {
    marker.collapsed = true;
    marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
    if (!options2.handleMouseEvents)
      marker.widgetNode.setAttribute("cm-ignore-events", "true");
    if (options2.insertLeft)
      marker.widgetNode.insertLeft = true;
  }
  if (marker.collapsed) {
    if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
      throw new Error("Inserting collapsed marker partially overlapping an existing one");
    seeCollapsedSpans();
  }
  if (marker.addToHistory)
    addChangeToHistory(doc, { from, to, origin: "markText" }, doc.sel, NaN);
  let curLine = from.line, cm = doc.cm, updateMaxLine;
  doc.iter(curLine, to.line + 1, (line) => {
    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
      updateMaxLine = true;
    if (marker.collapsed && curLine != from.line)
      updateLineHeight(line, 0);
    addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
    ++curLine;
  });
  if (marker.collapsed)
    doc.iter(from.line, to.line + 1, (line) => {
      if (lineIsHidden(doc, line))
        updateLineHeight(line, 0);
    });
  if (marker.clearOnEnter)
    on$1(marker, "beforeCursorEnter", () => marker.clear());
  if (marker.readOnly) {
    seeReadOnlySpans();
    if (doc.history.done.length || doc.history.undone.length)
      doc.clearHistory();
  }
  if (marker.collapsed) {
    marker.id = ++nextMarkerId;
    marker.atomic = true;
  }
  if (cm) {
    if (updateMaxLine)
      cm.curOp.updateMaxLine = true;
    if (marker.collapsed)
      regChange(cm, from.line, to.line + 1);
    else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title)
      for (let i2 = from.line; i2 <= to.line; i2++)
        regLineChange(cm, i2, "text");
    if (marker.atomic)
      reCheckSelection(cm.doc);
    signalLater(cm, "markerAdded", cm, marker);
  }
  return marker;
}
class SharedTextMarker {
  constructor(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (let i2 = 0; i2 < markers.length; ++i2)
      markers[i2].parent = this;
  }
  clear() {
    if (this.explicitlyCleared)
      return;
    this.explicitlyCleared = true;
    for (let i2 = 0; i2 < this.markers.length; ++i2)
      this.markers[i2].clear();
    signalLater(this, "clear");
  }
  find(side, lineObj) {
    return this.primary.find(side, lineObj);
  }
}
eventMixin(SharedTextMarker);
function markTextShared(doc, from, to, options2, type2) {
  options2 = copyObj(options2);
  options2.shared = false;
  let markers = [markText(doc, from, to, options2, type2)], primary = markers[0];
  let widget = options2.widgetNode;
  linkedDocs(doc, (doc2) => {
    if (widget)
      options2.widgetNode = widget.cloneNode(true);
    markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options2, type2));
    for (let i2 = 0; i2 < doc2.linked.length; ++i2)
      if (doc2.linked[i2].isParent)
        return;
    primary = lst(markers);
  });
  return new SharedTextMarker(markers, primary);
}
function findSharedMarkers(doc) {
  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), (m) => m.parent);
}
function copySharedMarkers(doc, markers) {
  for (let i2 = 0; i2 < markers.length; i2++) {
    let marker = markers[i2], pos = marker.find();
    let mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
    if (cmp(mFrom, mTo)) {
      let subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
      marker.markers.push(subMark);
      subMark.parent = marker;
    }
  }
}
function detachSharedMarkers(markers) {
  for (let i2 = 0; i2 < markers.length; i2++) {
    let marker = markers[i2], linked = [marker.primary.doc];
    linkedDocs(marker.primary.doc, (d) => linked.push(d));
    for (let j = 0; j < marker.markers.length; j++) {
      let subMarker = marker.markers[j];
      if (indexOf(linked, subMarker.doc) == -1) {
        subMarker.parent = null;
        marker.markers.splice(j--, 1);
      }
    }
  }
}
let nextDocId = 0;
let Doc = function(text, mode, firstLine, lineSep, direction) {
  if (!(this instanceof Doc))
    return new Doc(text, mode, firstLine, lineSep, direction);
  if (firstLine == null)
    firstLine = 0;
  BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
  this.first = firstLine;
  this.scrollTop = this.scrollLeft = 0;
  this.cantEdit = false;
  this.cleanGeneration = 1;
  this.modeFrontier = this.highlightFrontier = firstLine;
  let start2 = Pos(firstLine, 0);
  this.sel = simpleSelection(start2);
  this.history = new History(null);
  this.id = ++nextDocId;
  this.modeOption = mode;
  this.lineSep = lineSep;
  this.direction = direction == "rtl" ? "rtl" : "ltr";
  this.extend = false;
  if (typeof text == "string")
    text = this.splitLines(text);
  updateDoc(this, { from: start2, to: start2, text });
  setSelection(this, simpleSelection(start2), sel_dontScroll);
};
Doc.prototype = createObj(BranchChunk.prototype, {
  constructor: Doc,
  iter: function(from, to, op) {
    if (op)
      this.iterN(from - this.first, to - from, op);
    else
      this.iterN(this.first, this.first + this.size, from);
  },
  insert: function(at, lines) {
    let height = 0;
    for (let i2 = 0; i2 < lines.length; ++i2)
      height += lines[i2].height;
    this.insertInner(at - this.first, lines, height);
  },
  remove: function(at, n) {
    this.removeInner(at - this.first, n);
  },
  getValue: function(lineSep) {
    let lines = getLines(this, this.first, this.first + this.size);
    if (lineSep === false)
      return lines;
    return lines.join(lineSep || this.lineSeparator());
  },
  setValue: docMethodOp(function(code) {
    let top2 = Pos(this.first, 0), last = this.first + this.size - 1;
    makeChange(this, {
      from: top2,
      to: Pos(last, getLine(this, last).text.length),
      text: this.splitLines(code),
      origin: "setValue",
      full: true
    }, true);
    if (this.cm)
      scrollToCoords(this.cm, 0, 0);
    setSelection(this, simpleSelection(top2), sel_dontScroll);
  }),
  replaceRange: function(code, from, to, origin) {
    from = clipPos(this, from);
    to = to ? clipPos(this, to) : from;
    replaceRange(this, code, from, to, origin);
  },
  getRange: function(from, to, lineSep) {
    let lines = getBetween(this, clipPos(this, from), clipPos(this, to));
    if (lineSep === false)
      return lines;
    if (lineSep === "")
      return lines.join("");
    return lines.join(lineSep || this.lineSeparator());
  },
  newRange: function(anchor, head) {
    return new Range(anchor, head);
  },
  getLine: function(line) {
    let l = this.getLineHandle(line);
    return l && l.text;
  },
  getLineHandle: function(line) {
    if (isLine(this, line))
      return getLine(this, line);
  },
  getLineNumber: function(line) {
    return lineNo(line);
  },
  getLineHandleVisualStart: function(line) {
    if (typeof line == "number")
      line = getLine(this, line);
    return visualLine(line);
  },
  lineCount: function() {
    return this.size;
  },
  firstLine: function() {
    return this.first;
  },
  lastLine: function() {
    return this.first + this.size - 1;
  },
  clipPos: function(pos) {
    return clipPos(this, pos);
  },
  getCursor: function(start2) {
    let range2 = this.sel.primary(), pos;
    if (start2 == null || start2 == "head")
      pos = range2.head;
    else if (start2 == "anchor")
      pos = range2.anchor;
    else if (start2 == "end" || start2 == "to" || start2 === false)
      pos = range2.to();
    else
      pos = range2.from();
    return pos;
  },
  listSelections: function() {
    return this.sel.ranges;
  },
  somethingSelected: function() {
    return this.sel.somethingSelected();
  },
  setCursor: docMethodOp(function(line, ch, options2) {
    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options2);
  }),
  setSelection: docMethodOp(function(anchor, head, options2) {
    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options2);
  }),
  extendSelection: docMethodOp(function(head, other, options2) {
    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options2);
  }),
  extendSelections: docMethodOp(function(heads, options2) {
    extendSelections(this, clipPosArray(this, heads), options2);
  }),
  extendSelectionsBy: docMethodOp(function(f, options2) {
    let heads = map(this.sel.ranges, f);
    extendSelections(this, clipPosArray(this, heads), options2);
  }),
  setSelections: docMethodOp(function(ranges, primary, options2) {
    if (!ranges.length)
      return;
    let out = [];
    for (let i2 = 0; i2 < ranges.length; i2++)
      out[i2] = new Range(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));
    if (primary == null)
      primary = Math.min(ranges.length - 1, this.sel.primIndex);
    setSelection(this, normalizeSelection(this.cm, out, primary), options2);
  }),
  addSelection: docMethodOp(function(anchor, head, options2) {
    let ranges = this.sel.ranges.slice(0);
    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
    setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options2);
  }),
  getSelection: function(lineSep) {
    let ranges = this.sel.ranges, lines;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
      lines = lines ? lines.concat(sel) : sel;
    }
    if (lineSep === false)
      return lines;
    else
      return lines.join(lineSep || this.lineSeparator());
  },
  getSelections: function(lineSep) {
    let parts = [], ranges = this.sel.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
      if (lineSep !== false)
        sel = sel.join(lineSep || this.lineSeparator());
      parts[i2] = sel;
    }
    return parts;
  },
  replaceSelection: function(code, collapse, origin) {
    let dup = [];
    for (let i2 = 0; i2 < this.sel.ranges.length; i2++)
      dup[i2] = code;
    this.replaceSelections(dup, collapse, origin || "+input");
  },
  replaceSelections: docMethodOp(function(code, collapse, origin) {
    let changes = [], sel = this.sel;
    for (let i2 = 0; i2 < sel.ranges.length; i2++) {
      let range2 = sel.ranges[i2];
      changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };
    }
    let newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
    for (let i2 = changes.length - 1; i2 >= 0; i2--)
      makeChange(this, changes[i2]);
    if (newSel)
      setSelectionReplaceHistory(this, newSel);
    else if (this.cm)
      ensureCursorVisible(this.cm);
  }),
  undo: docMethodOp(function() {
    makeChangeFromHistory(this, "undo");
  }),
  redo: docMethodOp(function() {
    makeChangeFromHistory(this, "redo");
  }),
  undoSelection: docMethodOp(function() {
    makeChangeFromHistory(this, "undo", true);
  }),
  redoSelection: docMethodOp(function() {
    makeChangeFromHistory(this, "redo", true);
  }),
  setExtending: function(val) {
    this.extend = val;
  },
  getExtending: function() {
    return this.extend;
  },
  historySize: function() {
    let hist = this.history, done = 0, undone = 0;
    for (let i2 = 0; i2 < hist.done.length; i2++)
      if (!hist.done[i2].ranges)
        ++done;
    for (let i2 = 0; i2 < hist.undone.length; i2++)
      if (!hist.undone[i2].ranges)
        ++undone;
    return { undo: done, redo: undone };
  },
  clearHistory: function() {
    this.history = new History(this.history);
    linkedDocs(this, (doc) => doc.history = this.history, true);
  },
  markClean: function() {
    this.cleanGeneration = this.changeGeneration(true);
  },
  changeGeneration: function(forceSplit) {
    if (forceSplit)
      this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
    return this.history.generation;
  },
  isClean: function(gen) {
    return this.history.generation == (gen || this.cleanGeneration);
  },
  getHistory: function() {
    return {
      done: copyHistoryArray(this.history.done),
      undone: copyHistoryArray(this.history.undone)
    };
  },
  setHistory: function(histData) {
    let hist = this.history = new History(this.history);
    hist.done = copyHistoryArray(histData.done.slice(0), null, true);
    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
  },
  setGutterMarker: docMethodOp(function(line, gutterID, value2) {
    return changeLine(this, line, "gutter", (line2) => {
      let markers = line2.gutterMarkers || (line2.gutterMarkers = {});
      markers[gutterID] = value2;
      if (!value2 && isEmpty(markers))
        line2.gutterMarkers = null;
      return true;
    });
  }),
  clearGutter: docMethodOp(function(gutterID) {
    this.iter((line) => {
      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
        changeLine(this, line, "gutter", () => {
          line.gutterMarkers[gutterID] = null;
          if (isEmpty(line.gutterMarkers))
            line.gutterMarkers = null;
          return true;
        });
      }
    });
  }),
  lineInfo: function(line) {
    let n;
    if (typeof line == "number") {
      if (!isLine(this, line))
        return null;
      n = line;
      line = getLine(this, line);
      if (!line)
        return null;
    } else {
      n = lineNo(line);
      if (n == null)
        return null;
    }
    return {
      line: n,
      handle: line,
      text: line.text,
      gutterMarkers: line.gutterMarkers,
      textClass: line.textClass,
      bgClass: line.bgClass,
      wrapClass: line.wrapClass,
      widgets: line.widgets
    };
  },
  addLineClass: docMethodOp(function(handle, where, cls) {
    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", (line) => {
      let prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
      if (!line[prop])
        line[prop] = cls;
      else if (classTest(cls).test(line[prop]))
        return false;
      else
        line[prop] += " " + cls;
      return true;
    });
  }),
  removeLineClass: docMethodOp(function(handle, where, cls) {
    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", (line) => {
      let prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
      let cur = line[prop];
      if (!cur)
        return false;
      else if (cls == null)
        line[prop] = null;
      else {
        let found = cur.match(classTest(cls));
        if (!found)
          return false;
        let end2 = found.index + found[0].length;
        line[prop] = cur.slice(0, found.index) + (!found.index || end2 == cur.length ? "" : " ") + cur.slice(end2) || null;
      }
      return true;
    });
  }),
  addLineWidget: docMethodOp(function(handle, node, options2) {
    return addLineWidget(this, handle, node, options2);
  }),
  removeLineWidget: function(widget) {
    widget.clear();
  },
  markText: function(from, to, options2) {
    return markText(this, clipPos(this, from), clipPos(this, to), options2, options2 && options2.type || "range");
  },
  setBookmark: function(pos, options2) {
    let realOpts = {
      replacedWith: options2 && (options2.nodeType == null ? options2.widget : options2),
      insertLeft: options2 && options2.insertLeft,
      clearWhenEmpty: false,
      shared: options2 && options2.shared,
      handleMouseEvents: options2 && options2.handleMouseEvents
    };
    pos = clipPos(this, pos);
    return markText(this, pos, pos, realOpts, "bookmark");
  },
  findMarksAt: function(pos) {
    pos = clipPos(this, pos);
    let markers = [], spans = getLine(this, pos.line).markedSpans;
    if (spans)
      for (let i2 = 0; i2 < spans.length; ++i2) {
        let span = spans[i2];
        if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
    return markers;
  },
  findMarks: function(from, to, filter) {
    from = clipPos(this, from);
    to = clipPos(this, to);
    let found = [], lineNo2 = from.line;
    this.iter(from.line, to.line + 1, (line) => {
      let spans = line.markedSpans;
      if (spans)
        for (let i2 = 0; i2 < spans.length; i2++) {
          let span = spans[i2];
          if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
      ++lineNo2;
    });
    return found;
  },
  getAllMarks: function() {
    let markers = [];
    this.iter((line) => {
      let sps = line.markedSpans;
      if (sps) {
        for (let i2 = 0; i2 < sps.length; ++i2)
          if (sps[i2].from != null)
            markers.push(sps[i2].marker);
      }
    });
    return markers;
  },
  posFromIndex: function(off2) {
    let ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
    this.iter((line) => {
      let sz = line.text.length + sepSize;
      if (sz > off2) {
        ch = off2;
        return true;
      }
      off2 -= sz;
      ++lineNo2;
    });
    return clipPos(this, Pos(lineNo2, ch));
  },
  indexFromPos: function(coords) {
    coords = clipPos(this, coords);
    let index2 = coords.ch;
    if (coords.line < this.first || coords.ch < 0)
      return 0;
    let sepSize = this.lineSeparator().length;
    this.iter(this.first, coords.line, (line) => {
      index2 += line.text.length + sepSize;
    });
    return index2;
  },
  copy: function(copyHistory) {
    let doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
    doc.scrollTop = this.scrollTop;
    doc.scrollLeft = this.scrollLeft;
    doc.sel = this.sel;
    doc.extend = false;
    if (copyHistory) {
      doc.history.undoDepth = this.history.undoDepth;
      doc.setHistory(this.getHistory());
    }
    return doc;
  },
  linkedDoc: function(options2) {
    if (!options2)
      options2 = {};
    let from = this.first, to = this.first + this.size;
    if (options2.from != null && options2.from > from)
      from = options2.from;
    if (options2.to != null && options2.to < to)
      to = options2.to;
    let copy = new Doc(getLines(this, from, to), options2.mode || this.modeOption, from, this.lineSep, this.direction);
    if (options2.sharedHist)
      copy.history = this.history;
    (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options2.sharedHist });
    copy.linked = [{ doc: this, isParent: true, sharedHist: options2.sharedHist }];
    copySharedMarkers(copy, findSharedMarkers(this));
    return copy;
  },
  unlinkDoc: function(other) {
    if (other instanceof CodeMirror$3)
      other = other.doc;
    if (this.linked)
      for (let i2 = 0; i2 < this.linked.length; ++i2) {
        let link = this.linked[i2];
        if (link.doc != other)
          continue;
        this.linked.splice(i2, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
    if (other.history == this.history) {
      let splitIds = [other.id];
      linkedDocs(other, (doc) => splitIds.push(doc.id), true);
      other.history = new History(null);
      other.history.done = copyHistoryArray(this.history.done, splitIds);
      other.history.undone = copyHistoryArray(this.history.undone, splitIds);
    }
  },
  iterLinkedDocs: function(f) {
    linkedDocs(this, f);
  },
  getMode: function() {
    return this.mode;
  },
  getEditor: function() {
    return this.cm;
  },
  splitLines: function(str) {
    if (this.lineSep)
      return str.split(this.lineSep);
    return splitLinesAuto(str);
  },
  lineSeparator: function() {
    return this.lineSep || "\n";
  },
  setDirection: docMethodOp(function(dir) {
    if (dir != "rtl")
      dir = "ltr";
    if (dir == this.direction)
      return;
    this.direction = dir;
    this.iter((line) => line.order = null);
    if (this.cm)
      directionChanged(this.cm);
  })
});
Doc.prototype.eachLine = Doc.prototype.iter;
let lastDrop = 0;
function onDrop(e) {
  let cm = this;
  clearDragCursor(cm);
  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
    return;
  e_preventDefault(e);
  if (ie)
    lastDrop = +new Date();
  let pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
  if (!pos || cm.isReadOnly())
    return;
  if (files && files.length && window.FileReader && window.File) {
    let n = files.length, text = Array(n), read2 = 0;
    const markAsReadAndPasteIfAllFilesAreRead = () => {
      if (++read2 == n) {
        operation(cm, () => {
          pos = clipPos(cm.doc, pos);
          let change = {
            from: pos,
            to: pos,
            text: cm.doc.splitLines(text.filter((t) => t != null).join(cm.doc.lineSeparator())),
            origin: "paste"
          };
          makeChange(cm.doc, change);
          setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
        })();
      }
    };
    const readTextFromFile = (file, i2) => {
      if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
        markAsReadAndPasteIfAllFilesAreRead();
        return;
      }
      let reader = new FileReader();
      reader.onerror = () => markAsReadAndPasteIfAllFilesAreRead();
      reader.onload = () => {
        let content = reader.result;
        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
          markAsReadAndPasteIfAllFilesAreRead();
          return;
        }
        text[i2] = content;
        markAsReadAndPasteIfAllFilesAreRead();
      };
      reader.readAsText(file);
    };
    for (let i2 = 0; i2 < files.length; i2++)
      readTextFromFile(files[i2], i2);
  } else {
    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
      cm.state.draggingText(e);
      setTimeout(() => cm.display.input.focus(), 20);
      return;
    }
    try {
      let text = e.dataTransfer.getData("Text");
      if (text) {
        let selected;
        if (cm.state.draggingText && !cm.state.draggingText.copy)
          selected = cm.listSelections();
        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
        if (selected)
          for (let i2 = 0; i2 < selected.length; ++i2)
            replaceRange(cm.doc, "", selected[i2].anchor, selected[i2].head, "drag");
        cm.replaceSelection(text, "around", "paste");
        cm.display.input.focus();
      }
    } catch (e2) {
    }
  }
}
function onDragStart(cm, e) {
  if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
    e_stop(e);
    return;
  }
  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
    return;
  e.dataTransfer.setData("Text", cm.getSelection());
  e.dataTransfer.effectAllowed = "copyMove";
  if (e.dataTransfer.setDragImage && !safari) {
    let img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
    if (presto) {
      img.width = img.height = 1;
      cm.display.wrapper.appendChild(img);
      img._top = img.offsetTop;
    }
    e.dataTransfer.setDragImage(img, 0, 0);
    if (presto)
      img.parentNode.removeChild(img);
  }
}
function onDragOver(cm, e) {
  let pos = posFromMouse(cm, e);
  if (!pos)
    return;
  let frag = document.createDocumentFragment();
  drawSelectionCursor(cm, pos, frag);
  if (!cm.display.dragCursor) {
    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
  }
  removeChildrenAndAdd(cm.display.dragCursor, frag);
}
function clearDragCursor(cm) {
  if (cm.display.dragCursor) {
    cm.display.lineSpace.removeChild(cm.display.dragCursor);
    cm.display.dragCursor = null;
  }
}
function forEachCodeMirror(f) {
  if (!document.getElementsByClassName)
    return;
  let byClass = document.getElementsByClassName("CodeMirror"), editors = [];
  for (let i2 = 0; i2 < byClass.length; i2++) {
    let cm = byClass[i2].CodeMirror;
    if (cm)
      editors.push(cm);
  }
  if (editors.length)
    editors[0].operation(() => {
      for (let i2 = 0; i2 < editors.length; i2++)
        f(editors[i2]);
    });
}
let globalsRegistered = false;
function ensureGlobalHandlers() {
  if (globalsRegistered)
    return;
  registerGlobalHandlers();
  globalsRegistered = true;
}
function registerGlobalHandlers() {
  let resizeTimer;
  on$1(window, "resize", () => {
    if (resizeTimer == null)
      resizeTimer = setTimeout(() => {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100);
  });
  on$1(window, "blur", () => forEachCodeMirror(onBlur));
}
function onResize(cm) {
  let d = cm.display;
  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
  d.scrollbarsClipped = false;
  cm.setSize();
}
let keyNames = {
  3: "Pause",
  8: "Backspace",
  9: "Tab",
  13: "Enter",
  16: "Shift",
  17: "Ctrl",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Esc",
  32: "Space",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "Left",
  38: "Up",
  39: "Right",
  40: "Down",
  44: "PrintScrn",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Mod",
  92: "Mod",
  93: "Mod",
  106: "*",
  107: "=",
  109: "-",
  110: ".",
  111: "/",
  145: "ScrollLock",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  224: "Mod",
  63232: "Up",
  63233: "Down",
  63234: "Left",
  63235: "Right",
  63272: "Delete",
  63273: "Home",
  63275: "End",
  63276: "PageUp",
  63277: "PageDown",
  63302: "Insert"
};
for (let i2 = 0; i2 < 10; i2++)
  keyNames[i2 + 48] = keyNames[i2 + 96] = String(i2);
for (let i2 = 65; i2 <= 90; i2++)
  keyNames[i2] = String.fromCharCode(i2);
for (let i2 = 1; i2 <= 12; i2++)
  keyNames[i2 + 111] = keyNames[i2 + 63235] = "F" + i2;
let keyMap = {};
keyMap.basic = {
  "Left": "goCharLeft",
  "Right": "goCharRight",
  "Up": "goLineUp",
  "Down": "goLineDown",
  "End": "goLineEnd",
  "Home": "goLineStartSmart",
  "PageUp": "goPageUp",
  "PageDown": "goPageDown",
  "Delete": "delCharAfter",
  "Backspace": "delCharBefore",
  "Shift-Backspace": "delCharBefore",
  "Tab": "defaultTab",
  "Shift-Tab": "indentAuto",
  "Enter": "newlineAndIndent",
  "Insert": "toggleOverwrite",
  "Esc": "singleSelection"
};
keyMap.pcDefault = {
  "Ctrl-A": "selectAll",
  "Ctrl-D": "deleteLine",
  "Ctrl-Z": "undo",
  "Shift-Ctrl-Z": "redo",
  "Ctrl-Y": "redo",
  "Ctrl-Home": "goDocStart",
  "Ctrl-End": "goDocEnd",
  "Ctrl-Up": "goLineUp",
  "Ctrl-Down": "goLineDown",
  "Ctrl-Left": "goGroupLeft",
  "Ctrl-Right": "goGroupRight",
  "Alt-Left": "goLineStart",
  "Alt-Right": "goLineEnd",
  "Ctrl-Backspace": "delGroupBefore",
  "Ctrl-Delete": "delGroupAfter",
  "Ctrl-S": "save",
  "Ctrl-F": "find",
  "Ctrl-G": "findNext",
  "Shift-Ctrl-G": "findPrev",
  "Shift-Ctrl-F": "replace",
  "Shift-Ctrl-R": "replaceAll",
  "Ctrl-[": "indentLess",
  "Ctrl-]": "indentMore",
  "Ctrl-U": "undoSelection",
  "Shift-Ctrl-U": "redoSelection",
  "Alt-U": "redoSelection",
  "fallthrough": "basic"
};
keyMap.emacsy = {
  "Ctrl-F": "goCharRight",
  "Ctrl-B": "goCharLeft",
  "Ctrl-P": "goLineUp",
  "Ctrl-N": "goLineDown",
  "Ctrl-A": "goLineStart",
  "Ctrl-E": "goLineEnd",
  "Ctrl-V": "goPageDown",
  "Shift-Ctrl-V": "goPageUp",
  "Ctrl-D": "delCharAfter",
  "Ctrl-H": "delCharBefore",
  "Alt-Backspace": "delWordBefore",
  "Ctrl-K": "killLine",
  "Ctrl-T": "transposeChars",
  "Ctrl-O": "openLine"
};
keyMap.macDefault = {
  "Cmd-A": "selectAll",
  "Cmd-D": "deleteLine",
  "Cmd-Z": "undo",
  "Shift-Cmd-Z": "redo",
  "Cmd-Y": "redo",
  "Cmd-Home": "goDocStart",
  "Cmd-Up": "goDocStart",
  "Cmd-End": "goDocEnd",
  "Cmd-Down": "goDocEnd",
  "Alt-Left": "goGroupLeft",
  "Alt-Right": "goGroupRight",
  "Cmd-Left": "goLineLeft",
  "Cmd-Right": "goLineRight",
  "Alt-Backspace": "delGroupBefore",
  "Ctrl-Alt-Backspace": "delGroupAfter",
  "Alt-Delete": "delGroupAfter",
  "Cmd-S": "save",
  "Cmd-F": "find",
  "Cmd-G": "findNext",
  "Shift-Cmd-G": "findPrev",
  "Cmd-Alt-F": "replace",
  "Shift-Cmd-Alt-F": "replaceAll",
  "Cmd-[": "indentLess",
  "Cmd-]": "indentMore",
  "Cmd-Backspace": "delWrappedLineLeft",
  "Cmd-Delete": "delWrappedLineRight",
  "Cmd-U": "undoSelection",
  "Shift-Cmd-U": "redoSelection",
  "Ctrl-Up": "goDocStart",
  "Ctrl-Down": "goDocEnd",
  "fallthrough": ["basic", "emacsy"]
};
keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
function normalizeKeyName(name2) {
  let parts = name2.split(/-(?!$)/);
  name2 = parts[parts.length - 1];
  let alt, ctrl, shift, cmd;
  for (let i2 = 0; i2 < parts.length - 1; i2++) {
    let mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod))
      cmd = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift = true;
    else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    name2 = "Alt-" + name2;
  if (ctrl)
    name2 = "Ctrl-" + name2;
  if (cmd)
    name2 = "Cmd-" + name2;
  if (shift)
    name2 = "Shift-" + name2;
  return name2;
}
function normalizeKeyMap(keymap) {
  let copy = {};
  for (let keyname in keymap)
    if (keymap.hasOwnProperty(keyname)) {
      let value2 = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname))
        continue;
      if (value2 == "...") {
        delete keymap[keyname];
        continue;
      }
      let keys2 = map(keyname.split(" "), normalizeKeyName);
      for (let i2 = 0; i2 < keys2.length; i2++) {
        let val, name2;
        if (i2 == keys2.length - 1) {
          name2 = keys2.join(" ");
          val = value2;
        } else {
          name2 = keys2.slice(0, i2 + 1).join(" ");
          val = "...";
        }
        let prev = copy[name2];
        if (!prev)
          copy[name2] = val;
        else if (prev != val)
          throw new Error("Inconsistent bindings for " + name2);
      }
      delete keymap[keyname];
    }
  for (let prop in copy)
    keymap[prop] = copy[prop];
  return keymap;
}
function lookupKey(key, map2, handle, context) {
  map2 = getKeyMap(map2);
  let found = map2.call ? map2.call(key, context) : map2[key];
  if (found === false)
    return "nothing";
  if (found === "...")
    return "multi";
  if (found != null && handle(found))
    return "handled";
  if (map2.fallthrough) {
    if (Object.prototype.toString.call(map2.fallthrough) != "[object Array]")
      return lookupKey(key, map2.fallthrough, handle, context);
    for (let i2 = 0; i2 < map2.fallthrough.length; i2++) {
      let result = lookupKey(key, map2.fallthrough[i2], handle, context);
      if (result)
        return result;
    }
  }
}
function isModifierKey(value2) {
  let name2 = typeof value2 == "string" ? value2 : keyNames[value2.keyCode];
  return name2 == "Ctrl" || name2 == "Alt" || name2 == "Shift" || name2 == "Mod";
}
function addModifierNames(name2, event2, noShift) {
  let base = name2;
  if (event2.altKey && base != "Alt")
    name2 = "Alt-" + name2;
  if ((flipCtrlCmd ? event2.metaKey : event2.ctrlKey) && base != "Ctrl")
    name2 = "Ctrl-" + name2;
  if ((flipCtrlCmd ? event2.ctrlKey : event2.metaKey) && base != "Mod")
    name2 = "Cmd-" + name2;
  if (!noShift && event2.shiftKey && base != "Shift")
    name2 = "Shift-" + name2;
  return name2;
}
function keyName(event2, noShift) {
  if (presto && event2.keyCode == 34 && event2["char"])
    return false;
  let name2 = keyNames[event2.keyCode];
  if (name2 == null || event2.altGraphKey)
    return false;
  if (event2.keyCode == 3 && event2.code)
    name2 = event2.code;
  return addModifierNames(name2, event2, noShift);
}
function getKeyMap(val) {
  return typeof val == "string" ? keyMap[val] : val;
}
function deleteNearSelection(cm, compute) {
  let ranges = cm.doc.sel.ranges, kill = [];
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let toKill = compute(ranges[i2]);
    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
      let replaced = kill.pop();
      if (cmp(replaced.from, toKill.from) < 0) {
        toKill.from = replaced.from;
        break;
      }
    }
    kill.push(toKill);
  }
  runInOp(cm, () => {
    for (let i2 = kill.length - 1; i2 >= 0; i2--)
      replaceRange(cm.doc, "", kill[i2].from, kill[i2].to, "+delete");
    ensureCursorVisible(cm);
  });
}
function moveCharLogically(line, ch, dir) {
  let target = skipExtendingChars(line.text, ch + dir, dir);
  return target < 0 || target > line.text.length ? null : target;
}
function moveLogically(line, start2, dir) {
  let ch = moveCharLogically(line, start2.ch, dir);
  return ch == null ? null : new Pos(start2.line, ch, dir < 0 ? "after" : "before");
}
function endOfLine(visually, cm, lineObj, lineNo2, dir) {
  if (visually) {
    if (cm.doc.direction == "rtl")
      dir = -dir;
    let order2 = getOrder(lineObj, cm.doc.direction);
    if (order2) {
      let part = dir < 0 ? lst(order2) : order2[0];
      let moveInStorageOrder = dir < 0 == (part.level == 1);
      let sticky = moveInStorageOrder ? "after" : "before";
      let ch;
      if (part.level > 0 || cm.doc.direction == "rtl") {
        let prep = prepareMeasureForLine(cm, lineObj);
        ch = dir < 0 ? lineObj.text.length - 1 : 0;
        let targetTop = measureCharPrepared(cm, prep, ch).top;
        ch = findFirst((ch2) => measureCharPrepared(cm, prep, ch2).top == targetTop, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
        if (sticky == "before")
          ch = moveCharLogically(lineObj, ch, 1);
      } else
        ch = dir < 0 ? part.to : part.from;
      return new Pos(lineNo2, ch, sticky);
    }
  }
  return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
}
function moveVisually(cm, line, start2, dir) {
  let bidi = getOrder(line, cm.doc.direction);
  if (!bidi)
    return moveLogically(line, start2, dir);
  if (start2.ch >= line.text.length) {
    start2.ch = line.text.length;
    start2.sticky = "before";
  } else if (start2.ch <= 0) {
    start2.ch = 0;
    start2.sticky = "after";
  }
  let partPos = getBidiPartAt(bidi, start2.ch, start2.sticky), part = bidi[partPos];
  if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start2.ch : part.from < start2.ch)) {
    return moveLogically(line, start2, dir);
  }
  let mv = (pos, dir2) => moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
  let prep;
  let getWrappedLineExtent = (ch) => {
    if (!cm.options.lineWrapping)
      return { begin: 0, end: line.text.length };
    prep = prep || prepareMeasureForLine(cm, line);
    return wrappedLineExtentChar(cm, line, prep, ch);
  };
  let wrappedLineExtent2 = getWrappedLineExtent(start2.sticky == "before" ? mv(start2, -1) : start2.ch);
  if (cm.doc.direction == "rtl" || part.level == 1) {
    let moveInStorageOrder = part.level == 1 == dir < 0;
    let ch = mv(start2, moveInStorageOrder ? 1 : -1);
    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
      let sticky = moveInStorageOrder ? "before" : "after";
      return new Pos(start2.line, ch, sticky);
    }
  }
  let searchInVisualLine = (partPos2, dir2, wrappedLineExtent3) => {
    let getRes = (ch, moveInStorageOrder) => moveInStorageOrder ? new Pos(start2.line, mv(ch, 1), "before") : new Pos(start2.line, ch, "after");
    for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
      let part2 = bidi[partPos2];
      let moveInStorageOrder = dir2 > 0 == (part2.level != 1);
      let ch = moveInStorageOrder ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
      if (part2.from <= ch && ch < part2.to)
        return getRes(ch, moveInStorageOrder);
      ch = moveInStorageOrder ? part2.from : mv(part2.to, -1);
      if (wrappedLineExtent3.begin <= ch && ch < wrappedLineExtent3.end)
        return getRes(ch, moveInStorageOrder);
    }
  };
  let res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
  if (res)
    return res;
  let nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
    if (res)
      return res;
  }
  return null;
}
let commands = {
  selectAll,
  singleSelection: (cm) => cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll),
  killLine: (cm) => deleteNearSelection(cm, (range2) => {
    if (range2.empty()) {
      let len = getLine(cm.doc, range2.head.line).text.length;
      if (range2.head.ch == len && range2.head.line < cm.lastLine())
        return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
      else
        return { from: range2.head, to: Pos(range2.head.line, len) };
    } else {
      return { from: range2.from(), to: range2.to() };
    }
  }),
  deleteLine: (cm) => deleteNearSelection(cm, (range2) => ({
    from: Pos(range2.from().line, 0),
    to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
  })),
  delLineLeft: (cm) => deleteNearSelection(cm, (range2) => ({
    from: Pos(range2.from().line, 0),
    to: range2.from()
  })),
  delWrappedLineLeft: (cm) => deleteNearSelection(cm, (range2) => {
    let top2 = cm.charCoords(range2.head, "div").top + 5;
    let leftPos = cm.coordsChar({ left: 0, top: top2 }, "div");
    return { from: leftPos, to: range2.from() };
  }),
  delWrappedLineRight: (cm) => deleteNearSelection(cm, (range2) => {
    let top2 = cm.charCoords(range2.head, "div").top + 5;
    let rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
    return { from: range2.from(), to: rightPos };
  }),
  undo: (cm) => cm.undo(),
  redo: (cm) => cm.redo(),
  undoSelection: (cm) => cm.undoSelection(),
  redoSelection: (cm) => cm.redoSelection(),
  goDocStart: (cm) => cm.extendSelection(Pos(cm.firstLine(), 0)),
  goDocEnd: (cm) => cm.extendSelection(Pos(cm.lastLine())),
  goLineStart: (cm) => cm.extendSelectionsBy((range2) => lineStart(cm, range2.head.line), { origin: "+move", bias: 1 }),
  goLineStartSmart: (cm) => cm.extendSelectionsBy((range2) => lineStartSmart(cm, range2.head), { origin: "+move", bias: 1 }),
  goLineEnd: (cm) => cm.extendSelectionsBy((range2) => lineEnd(cm, range2.head.line), { origin: "+move", bias: -1 }),
  goLineRight: (cm) => cm.extendSelectionsBy((range2) => {
    let top2 = cm.cursorCoords(range2.head, "div").top + 5;
    return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
  }, sel_move),
  goLineLeft: (cm) => cm.extendSelectionsBy((range2) => {
    let top2 = cm.cursorCoords(range2.head, "div").top + 5;
    return cm.coordsChar({ left: 0, top: top2 }, "div");
  }, sel_move),
  goLineLeftSmart: (cm) => cm.extendSelectionsBy((range2) => {
    let top2 = cm.cursorCoords(range2.head, "div").top + 5;
    let pos = cm.coordsChar({ left: 0, top: top2 }, "div");
    if (pos.ch < cm.getLine(pos.line).search(/\S/))
      return lineStartSmart(cm, range2.head);
    return pos;
  }, sel_move),
  goLineUp: (cm) => cm.moveV(-1, "line"),
  goLineDown: (cm) => cm.moveV(1, "line"),
  goPageUp: (cm) => cm.moveV(-1, "page"),
  goPageDown: (cm) => cm.moveV(1, "page"),
  goCharLeft: (cm) => cm.moveH(-1, "char"),
  goCharRight: (cm) => cm.moveH(1, "char"),
  goColumnLeft: (cm) => cm.moveH(-1, "column"),
  goColumnRight: (cm) => cm.moveH(1, "column"),
  goWordLeft: (cm) => cm.moveH(-1, "word"),
  goGroupRight: (cm) => cm.moveH(1, "group"),
  goGroupLeft: (cm) => cm.moveH(-1, "group"),
  goWordRight: (cm) => cm.moveH(1, "word"),
  delCharBefore: (cm) => cm.deleteH(-1, "codepoint"),
  delCharAfter: (cm) => cm.deleteH(1, "char"),
  delWordBefore: (cm) => cm.deleteH(-1, "word"),
  delWordAfter: (cm) => cm.deleteH(1, "word"),
  delGroupBefore: (cm) => cm.deleteH(-1, "group"),
  delGroupAfter: (cm) => cm.deleteH(1, "group"),
  indentAuto: (cm) => cm.indentSelection("smart"),
  indentMore: (cm) => cm.indentSelection("add"),
  indentLess: (cm) => cm.indentSelection("subtract"),
  insertTab: (cm) => cm.replaceSelection("	"),
  insertSoftTab: (cm) => {
    let spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let pos = ranges[i2].from();
      let col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
      spaces.push(spaceStr(tabSize - col % tabSize));
    }
    cm.replaceSelections(spaces);
  },
  defaultTab: (cm) => {
    if (cm.somethingSelected())
      cm.indentSelection("add");
    else
      cm.execCommand("insertTab");
  },
  transposeChars: (cm) => runInOp(cm, () => {
    let ranges = cm.listSelections(), newSel = [];
    for (let i2 = 0; i2 < ranges.length; i2++) {
      if (!ranges[i2].empty())
        continue;
      let cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
      if (line) {
        if (cur.ch == line.length)
          cur = new Pos(cur.line, cur.ch - 1);
        if (cur.ch > 0) {
          cur = new Pos(cur.line, cur.ch + 1);
          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
        } else if (cur.line > cm.doc.first) {
          let prev = getLine(cm.doc, cur.line - 1).text;
          if (prev) {
            cur = new Pos(cur.line, 1);
            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
          }
        }
      }
      newSel.push(new Range(cur, cur));
    }
    cm.setSelections(newSel);
  }),
  newlineAndIndent: (cm) => runInOp(cm, () => {
    let sels = cm.listSelections();
    for (let i2 = sels.length - 1; i2 >= 0; i2--)
      cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
    sels = cm.listSelections();
    for (let i2 = 0; i2 < sels.length; i2++)
      cm.indentLine(sels[i2].from().line, null, true);
    ensureCursorVisible(cm);
  }),
  openLine: (cm) => cm.replaceSelection("\n", "start"),
  toggleOverwrite: (cm) => cm.toggleOverwrite()
};
function lineStart(cm, lineN) {
  let line = getLine(cm.doc, lineN);
  let visual = visualLine(line);
  if (visual != line)
    lineN = lineNo(visual);
  return endOfLine(true, cm, visual, lineN, 1);
}
function lineEnd(cm, lineN) {
  let line = getLine(cm.doc, lineN);
  let visual = visualLineEnd(line);
  if (visual != line)
    lineN = lineNo(visual);
  return endOfLine(true, cm, line, lineN, -1);
}
function lineStartSmart(cm, pos) {
  let start2 = lineStart(cm, pos.line);
  let line = getLine(cm.doc, start2.line);
  let order2 = getOrder(line, cm.doc.direction);
  if (!order2 || order2[0].level == 0) {
    let firstNonWS = Math.max(start2.ch, line.text.search(/\S/));
    let inWS = pos.line == start2.line && pos.ch <= firstNonWS && pos.ch;
    return Pos(start2.line, inWS ? 0 : firstNonWS, start2.sticky);
  }
  return start2;
}
function doHandleBinding(cm, bound, dropShift) {
  if (typeof bound == "string") {
    bound = commands[bound];
    if (!bound)
      return false;
  }
  cm.display.input.ensurePolled();
  let prevShift = cm.display.shift, done = false;
  try {
    if (cm.isReadOnly())
      cm.state.suppressEdits = true;
    if (dropShift)
      cm.display.shift = false;
    done = bound(cm) != Pass;
  } finally {
    cm.display.shift = prevShift;
    cm.state.suppressEdits = false;
  }
  return done;
}
function lookupKeyForEditor(cm, name2, handle) {
  for (let i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
    let result = lookupKey(name2, cm.state.keyMaps[i2], handle, cm);
    if (result)
      return result;
  }
  return cm.options.extraKeys && lookupKey(name2, cm.options.extraKeys, handle, cm) || lookupKey(name2, cm.options.keyMap, handle, cm);
}
let stopSeq = new Delayed();
function dispatchKey(cm, name2, e, handle) {
  let seq = cm.state.keySeq;
  if (seq) {
    if (isModifierKey(name2))
      return "handled";
    if (/\'$/.test(name2))
      cm.state.keySeq = null;
    else
      stopSeq.set(50, () => {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
    if (dispatchKeyInner(cm, seq + " " + name2, e, handle))
      return true;
  }
  return dispatchKeyInner(cm, name2, e, handle);
}
function dispatchKeyInner(cm, name2, e, handle) {
  let result = lookupKeyForEditor(cm, name2, handle);
  if (result == "multi")
    cm.state.keySeq = name2;
  if (result == "handled")
    signalLater(cm, "keyHandled", cm, name2, e);
  if (result == "handled" || result == "multi") {
    e_preventDefault(e);
    restartBlink(cm);
  }
  return !!result;
}
function handleKeyBinding(cm, e) {
  let name2 = keyName(e, true);
  if (!name2)
    return false;
  if (e.shiftKey && !cm.state.keySeq) {
    return dispatchKey(cm, "Shift-" + name2, e, (b) => doHandleBinding(cm, b, true)) || dispatchKey(cm, name2, e, (b) => {
      if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
        return doHandleBinding(cm, b);
    });
  } else {
    return dispatchKey(cm, name2, e, (b) => doHandleBinding(cm, b));
  }
}
function handleCharBinding(cm, e, ch) {
  return dispatchKey(cm, "'" + ch + "'", e, (b) => doHandleBinding(cm, b, true));
}
let lastStoppedKey = null;
function onKeyDown(e) {
  let cm = this;
  if (e.target && e.target != cm.display.input.getField())
    return;
  cm.curOp.focus = activeElt();
  if (signalDOMEvent(cm, e))
    return;
  if (ie && ie_version < 11 && e.keyCode == 27)
    e.returnValue = false;
  let code = e.keyCode;
  cm.display.shift = code == 16 || e.shiftKey;
  let handled = handleKeyBinding(cm, e);
  if (presto) {
    lastStoppedKey = handled ? code : null;
    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
      cm.replaceSelection("", null, "cut");
  }
  if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
    document.execCommand("cut");
  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
    showCrossHair(cm);
}
function showCrossHair(cm) {
  let lineDiv = cm.display.lineDiv;
  addClass(lineDiv, "CodeMirror-crosshair");
  function up(e) {
    if (e.keyCode == 18 || !e.altKey) {
      rmClass(lineDiv, "CodeMirror-crosshair");
      off$1(document, "keyup", up);
      off$1(document, "mouseover", up);
    }
  }
  on$1(document, "keyup", up);
  on$1(document, "mouseover", up);
}
function onKeyUp(e) {
  if (e.keyCode == 16)
    this.doc.sel.shift = false;
  signalDOMEvent(this, e);
}
function onKeyPress(e) {
  let cm = this;
  if (e.target && e.target != cm.display.input.getField())
    return;
  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)
    return;
  let keyCode = e.keyCode, charCode = e.charCode;
  if (presto && keyCode == lastStoppedKey) {
    lastStoppedKey = null;
    e_preventDefault(e);
    return;
  }
  if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e))
    return;
  let ch = String.fromCharCode(charCode == null ? keyCode : charCode);
  if (ch == "\b")
    return;
  if (handleCharBinding(cm, e, ch))
    return;
  cm.display.input.onKeyPress(e);
}
const DOUBLECLICK_DELAY = 400;
class PastClick {
  constructor(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  }
  compare(time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
  }
}
let lastClick, lastDoubleClick;
function clickRepeat(pos, button) {
  let now2 = +new Date();
  if (lastDoubleClick && lastDoubleClick.compare(now2, pos, button)) {
    lastClick = lastDoubleClick = null;
    return "triple";
  } else if (lastClick && lastClick.compare(now2, pos, button)) {
    lastDoubleClick = new PastClick(now2, pos, button);
    lastClick = null;
    return "double";
  } else {
    lastClick = new PastClick(now2, pos, button);
    lastDoubleClick = null;
    return "single";
  }
}
function onMouseDown(e) {
  let cm = this, display = cm.display;
  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch())
    return;
  display.input.ensurePolled();
  display.shift = e.shiftKey;
  if (eventInWidget(display, e)) {
    if (!webkit) {
      display.scroller.draggable = false;
      setTimeout(() => display.scroller.draggable = true, 100);
    }
    return;
  }
  if (clickInGutter(cm, e))
    return;
  let pos = posFromMouse(cm, e), button = e_button(e), repeat2 = pos ? clickRepeat(pos, button) : "single";
  window.focus();
  if (button == 1 && cm.state.selectingText)
    cm.state.selectingText(e);
  if (pos && handleMappedButton(cm, button, pos, repeat2, e))
    return;
  if (button == 1) {
    if (pos)
      leftButtonDown(cm, pos, repeat2, e);
    else if (e_target(e) == display.scroller)
      e_preventDefault(e);
  } else if (button == 2) {
    if (pos)
      extendSelection(cm.doc, pos);
    setTimeout(() => display.input.focus(), 20);
  } else if (button == 3) {
    if (captureRightClick)
      cm.display.input.onContextMenu(e);
    else
      delayBlurEvent(cm);
  }
}
function handleMappedButton(cm, button, pos, repeat2, event2) {
  let name2 = "Click";
  if (repeat2 == "double")
    name2 = "Double" + name2;
  else if (repeat2 == "triple")
    name2 = "Triple" + name2;
  name2 = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name2;
  return dispatchKey(cm, addModifierNames(name2, event2), event2, (bound) => {
    if (typeof bound == "string")
      bound = commands[bound];
    if (!bound)
      return false;
    let done = false;
    try {
      if (cm.isReadOnly())
        cm.state.suppressEdits = true;
      done = bound(cm, pos) != Pass;
    } finally {
      cm.state.suppressEdits = false;
    }
    return done;
  });
}
function configureMouse(cm, repeat2, event2) {
  let option2 = cm.getOption("configureMouse");
  let value2 = option2 ? option2(cm, repeat2, event2) : {};
  if (value2.unit == null) {
    let rect = chromeOS ? event2.shiftKey && event2.metaKey : event2.altKey;
    value2.unit = rect ? "rectangle" : repeat2 == "single" ? "char" : repeat2 == "double" ? "word" : "line";
  }
  if (value2.extend == null || cm.doc.extend)
    value2.extend = cm.doc.extend || event2.shiftKey;
  if (value2.addNew == null)
    value2.addNew = mac ? event2.metaKey : event2.ctrlKey;
  if (value2.moveOnDrag == null)
    value2.moveOnDrag = !(mac ? event2.altKey : event2.ctrlKey);
  return value2;
}
function leftButtonDown(cm, pos, repeat2, event2) {
  if (ie)
    setTimeout(bind$3(ensureFocus, cm), 0);
  else
    cm.curOp.focus = activeElt();
  let behavior = configureMouse(cm, repeat2, event2);
  let sel = cm.doc.sel, contained;
  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat2 == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
    leftButtonStartDrag(cm, event2, pos, behavior);
  else
    leftButtonSelect(cm, event2, pos, behavior);
}
function leftButtonStartDrag(cm, event2, pos, behavior) {
  let display = cm.display, moved2 = false;
  let dragEnd = operation(cm, (e) => {
    if (webkit)
      display.scroller.draggable = false;
    cm.state.draggingText = false;
    if (cm.state.delayingBlurEvent) {
      if (cm.hasFocus())
        cm.state.delayingBlurEvent = false;
      else
        delayBlurEvent(cm);
    }
    off$1(display.wrapper.ownerDocument, "mouseup", dragEnd);
    off$1(display.wrapper.ownerDocument, "mousemove", mouseMove);
    off$1(display.scroller, "dragstart", dragStart2);
    off$1(display.scroller, "drop", dragEnd);
    if (!moved2) {
      e_preventDefault(e);
      if (!behavior.addNew)
        extendSelection(cm.doc, pos, null, null, behavior.extend);
      if (webkit && !safari || ie && ie_version == 9)
        setTimeout(() => {
          display.wrapper.ownerDocument.body.focus({ preventScroll: true });
          display.input.focus();
        }, 20);
      else
        display.input.focus();
    }
  });
  let mouseMove = function(e2) {
    moved2 = moved2 || Math.abs(event2.clientX - e2.clientX) + Math.abs(event2.clientY - e2.clientY) >= 10;
  };
  let dragStart2 = () => moved2 = true;
  if (webkit)
    display.scroller.draggable = true;
  cm.state.draggingText = dragEnd;
  dragEnd.copy = !behavior.moveOnDrag;
  on$1(display.wrapper.ownerDocument, "mouseup", dragEnd);
  on$1(display.wrapper.ownerDocument, "mousemove", mouseMove);
  on$1(display.scroller, "dragstart", dragStart2);
  on$1(display.scroller, "drop", dragEnd);
  cm.state.delayingBlurEvent = true;
  setTimeout(() => display.input.focus(), 20);
  if (display.scroller.dragDrop)
    display.scroller.dragDrop();
}
function rangeForUnit(cm, pos, unit) {
  if (unit == "char")
    return new Range(pos, pos);
  if (unit == "word")
    return cm.findWordAt(pos);
  if (unit == "line")
    return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
  let result = unit(cm, pos);
  return new Range(result.from, result.to);
}
function leftButtonSelect(cm, event2, start2, behavior) {
  if (ie)
    delayBlurEvent(cm);
  let display = cm.display, doc = cm.doc;
  e_preventDefault(event2);
  let ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
  if (behavior.addNew && !behavior.extend) {
    ourIndex = doc.sel.contains(start2);
    if (ourIndex > -1)
      ourRange = ranges[ourIndex];
    else
      ourRange = new Range(start2, start2);
  } else {
    ourRange = doc.sel.primary();
    ourIndex = doc.sel.primIndex;
  }
  if (behavior.unit == "rectangle") {
    if (!behavior.addNew)
      ourRange = new Range(start2, start2);
    start2 = posFromMouse(cm, event2, true, true);
    ourIndex = -1;
  } else {
    let range2 = rangeForUnit(cm, start2, behavior.unit);
    if (behavior.extend)
      ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
    else
      ourRange = range2;
  }
  if (!behavior.addNew) {
    ourIndex = 0;
    setSelection(doc, new Selection([ourRange], 0), sel_mouse);
    startSel = doc.sel;
  } else if (ourIndex == -1) {
    ourIndex = ranges.length;
    setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
    setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
    startSel = doc.sel;
  } else {
    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
  }
  let lastPos = start2;
  function extendTo(pos) {
    if (cmp(lastPos, pos) == 0)
      return;
    lastPos = pos;
    if (behavior.unit == "rectangle") {
      let ranges2 = [], tabSize = cm.options.tabSize;
      let startCol = countColumn(getLine(doc, start2.line).text, start2.ch, tabSize);
      let posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
      let left2 = Math.min(startCol, posCol), right2 = Math.max(startCol, posCol);
      for (let line = Math.min(start2.line, pos.line), end2 = Math.min(cm.lastLine(), Math.max(start2.line, pos.line)); line <= end2; line++) {
        let text = getLine(doc, line).text, leftPos = findColumn(text, left2, tabSize);
        if (left2 == right2)
          ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
        else if (text.length > leftPos)
          ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right2, tabSize))));
      }
      if (!ranges2.length)
        ranges2.push(new Range(start2, start2));
      setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
      cm.scrollIntoView(pos);
    } else {
      let oldRange = ourRange;
      let range2 = rangeForUnit(cm, pos, behavior.unit);
      let anchor = oldRange.anchor, head;
      if (cmp(range2.anchor, anchor) > 0) {
        head = range2.head;
        anchor = minPos(oldRange.from(), range2.anchor);
      } else {
        head = range2.anchor;
        anchor = maxPos(oldRange.to(), range2.head);
      }
      let ranges2 = startSel.ranges.slice(0);
      ranges2[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
      setSelection(doc, normalizeSelection(cm, ranges2, ourIndex), sel_mouse);
    }
  }
  let editorSize = display.wrapper.getBoundingClientRect();
  let counter = 0;
  function extend2(e) {
    let curCount = ++counter;
    let cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
    if (!cur)
      return;
    if (cmp(cur, lastPos) != 0) {
      cm.curOp.focus = activeElt();
      extendTo(cur);
      let visible2 = visibleLines(display, doc);
      if (cur.line >= visible2.to || cur.line < visible2.from)
        setTimeout(operation(cm, () => {
          if (counter == curCount)
            extend2(e);
        }), 150);
    } else {
      let outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
      if (outside)
        setTimeout(operation(cm, () => {
          if (counter != curCount)
            return;
          display.scroller.scrollTop += outside;
          extend2(e);
        }), 50);
    }
  }
  function done(e) {
    cm.state.selectingText = false;
    counter = Infinity;
    if (e) {
      e_preventDefault(e);
      display.input.focus();
    }
    off$1(display.wrapper.ownerDocument, "mousemove", move);
    off$1(display.wrapper.ownerDocument, "mouseup", up);
    doc.history.lastSelOrigin = null;
  }
  let move = operation(cm, (e) => {
    if (e.buttons === 0 || !e_button(e))
      done(e);
    else
      extend2(e);
  });
  let up = operation(cm, done);
  cm.state.selectingText = up;
  on$1(display.wrapper.ownerDocument, "mousemove", move);
  on$1(display.wrapper.ownerDocument, "mouseup", up);
}
function bidiSimplify(cm, range2) {
  let { anchor, head } = range2, anchorLine = getLine(cm.doc, anchor.line);
  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky)
    return range2;
  let order2 = getOrder(anchorLine);
  if (!order2)
    return range2;
  let index2 = getBidiPartAt(order2, anchor.ch, anchor.sticky), part = order2[index2];
  if (part.from != anchor.ch && part.to != anchor.ch)
    return range2;
  let boundary = index2 + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
  if (boundary == 0 || boundary == order2.length)
    return range2;
  let leftSide;
  if (head.line != anchor.line) {
    leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
  } else {
    let headIndex = getBidiPartAt(order2, head.ch, head.sticky);
    let dir = headIndex - index2 || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
    if (headIndex == boundary - 1 || headIndex == boundary)
      leftSide = dir < 0;
    else
      leftSide = dir > 0;
  }
  let usePart = order2[boundary + (leftSide ? -1 : 0)];
  let from = leftSide == (usePart.level == 1);
  let ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
  return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
}
function gutterEvent(cm, e, type2, prevent) {
  let mX, mY;
  if (e.touches) {
    mX = e.touches[0].clientX;
    mY = e.touches[0].clientY;
  } else {
    try {
      mX = e.clientX;
      mY = e.clientY;
    } catch (e2) {
      return false;
    }
  }
  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right))
    return false;
  if (prevent)
    e_preventDefault(e);
  let display = cm.display;
  let lineBox = display.lineDiv.getBoundingClientRect();
  if (mY > lineBox.bottom || !hasHandler(cm, type2))
    return e_defaultPrevented(e);
  mY -= lineBox.top - display.viewOffset;
  for (let i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
    let g = display.gutters.childNodes[i2];
    if (g && g.getBoundingClientRect().right >= mX) {
      let line = lineAtHeight(cm.doc, mY);
      let gutter = cm.display.gutterSpecs[i2];
      signal(cm, type2, cm, line, gutter.className, e);
      return e_defaultPrevented(e);
    }
  }
}
function clickInGutter(cm, e) {
  return gutterEvent(cm, e, "gutterClick", true);
}
function onContextMenu(cm, e) {
  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e))
    return;
  if (signalDOMEvent(cm, e, "contextmenu"))
    return;
  if (!captureRightClick)
    cm.display.input.onContextMenu(e);
}
function contextMenuInGutter(cm, e) {
  if (!hasHandler(cm, "gutterContextMenu"))
    return false;
  return gutterEvent(cm, e, "gutterContextMenu", false);
}
function themeChanged(cm) {
  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
  clearCaches(cm);
}
let Init = { toString: function() {
  return "CodeMirror.Init";
} };
let defaults$6 = {};
let optionHandlers = {};
function defineOptions(CodeMirror2) {
  let optionHandlers2 = CodeMirror2.optionHandlers;
  function option2(name2, deflt, handle, notOnInit) {
    CodeMirror2.defaults[name2] = deflt;
    if (handle)
      optionHandlers2[name2] = notOnInit ? (cm, val, old) => {
        if (old != Init)
          handle(cm, val, old);
      } : handle;
  }
  CodeMirror2.defineOption = option2;
  CodeMirror2.Init = Init;
  option2("value", "", (cm, val) => cm.setValue(val), true);
  option2("mode", null, (cm, val) => {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);
  option2("indentUnit", 2, loadMode, true);
  option2("indentWithTabs", false);
  option2("smartIndent", true);
  option2("tabSize", 4, (cm) => {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option2("lineSeparator", null, (cm, val) => {
    cm.doc.lineSep = val;
    if (!val)
      return;
    let newBreaks = [], lineNo2 = cm.doc.first;
    cm.doc.iter((line) => {
      for (let pos = 0; ; ) {
        let found = line.text.indexOf(val, pos);
        if (found == -1)
          break;
        pos = found + val.length;
        newBreaks.push(Pos(lineNo2, found));
      }
      lineNo2++;
    });
    for (let i2 = newBreaks.length - 1; i2 >= 0; i2--)
      replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
  });
  option2("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, (cm, val, old) => {
    cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
    if (old != Init)
      cm.refresh();
  });
  option2("specialCharPlaceholder", defaultSpecialCharPlaceholder, (cm) => cm.refresh(), true);
  option2("electricChars", true);
  option2("inputStyle", mobile ? "contenteditable" : "textarea", () => {
    throw new Error("inputStyle can not (yet) be changed in a running editor");
  }, true);
  option2("spellcheck", false, (cm, val) => cm.getInputField().spellcheck = val, true);
  option2("autocorrect", false, (cm, val) => cm.getInputField().autocorrect = val, true);
  option2("autocapitalize", false, (cm, val) => cm.getInputField().autocapitalize = val, true);
  option2("rtlMoveVisually", !windows);
  option2("wholeLineUpdateBefore", true);
  option2("theme", "default", (cm) => {
    themeChanged(cm);
    updateGutters(cm);
  }, true);
  option2("keyMap", "default", (cm, val, old) => {
    let next = getKeyMap(val);
    let prev = old != Init && getKeyMap(old);
    if (prev && prev.detach)
      prev.detach(cm, next);
    if (next.attach)
      next.attach(cm, prev || null);
  });
  option2("extraKeys", null);
  option2("configureMouse", null);
  option2("lineWrapping", false, wrappingChanged, true);
  option2("gutters", [], (cm, val) => {
    cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
    updateGutters(cm);
  }, true);
  option2("fixedGutter", true, (cm, val) => {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option2("coverGutterNextToScrollbar", false, (cm) => updateScrollbars(cm), true);
  option2("scrollbarStyle", "native", (cm) => {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option2("lineNumbers", false, (cm, val) => {
    cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
    updateGutters(cm);
  }, true);
  option2("firstLineNumber", 1, updateGutters, true);
  option2("lineNumberFormatter", (integer3) => integer3, updateGutters, true);
  option2("showCursorWhenSelecting", false, updateSelection, true);
  option2("resetSelectionOnContextMenu", true);
  option2("lineWiseCopyCut", true);
  option2("pasteLinesPerSelection", true);
  option2("selectionsMayTouch", false);
  option2("readOnly", false, (cm, val) => {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
    }
    cm.display.input.readOnlyChanged(val);
  });
  option2("screenReaderLabel", null, (cm, val) => {
    val = val === "" ? null : val;
    cm.display.input.screenReaderLabelChanged(val);
  });
  option2("disableInput", false, (cm, val) => {
    if (!val)
      cm.display.input.reset();
  }, true);
  option2("dragDrop", true, dragDropChanged);
  option2("allowDropFileTypes", null);
  option2("cursorBlinkRate", 530);
  option2("cursorScrollMargin", 0);
  option2("cursorHeight", 1, updateSelection, true);
  option2("singleCursorHeightPerLine", true, updateSelection, true);
  option2("workTime", 100);
  option2("workDelay", 100);
  option2("flattenSpans", true, resetModeState, true);
  option2("addModeClass", false, resetModeState, true);
  option2("pollInterval", 100);
  option2("undoDepth", 200, (cm, val) => cm.doc.history.undoDepth = val);
  option2("historyEventDelay", 1250);
  option2("viewportMargin", 10, (cm) => cm.refresh(), true);
  option2("maxHighlightLength", 1e4, resetModeState, true);
  option2("moveInputWithCursor", true, (cm, val) => {
    if (!val)
      cm.display.input.resetPosition();
  });
  option2("tabindex", null, (cm, val) => cm.display.input.getField().tabIndex = val || "");
  option2("autofocus", null);
  option2("direction", "ltr", (cm, val) => cm.doc.setDirection(val), true);
  option2("phrases", null);
}
function dragDropChanged(cm, value2, old) {
  let wasOn = old && old != Init;
  if (!value2 != !wasOn) {
    let funcs = cm.display.dragFunctions;
    let toggle = value2 ? on$1 : off$1;
    toggle(cm.display.scroller, "dragstart", funcs.start);
    toggle(cm.display.scroller, "dragenter", funcs.enter);
    toggle(cm.display.scroller, "dragover", funcs.over);
    toggle(cm.display.scroller, "dragleave", funcs.leave);
    toggle(cm.display.scroller, "drop", funcs.drop);
  }
}
function wrappingChanged(cm) {
  if (cm.options.lineWrapping) {
    addClass(cm.display.wrapper, "CodeMirror-wrap");
    cm.display.sizer.style.minWidth = "";
    cm.display.sizerWidth = null;
  } else {
    rmClass(cm.display.wrapper, "CodeMirror-wrap");
    findMaxLine(cm);
  }
  estimateLineHeights(cm);
  regChange(cm);
  clearCaches(cm);
  setTimeout(() => updateScrollbars(cm), 100);
}
function CodeMirror$3(place, options2) {
  if (!(this instanceof CodeMirror$3))
    return new CodeMirror$3(place, options2);
  this.options = options2 = options2 ? copyObj(options2) : {};
  copyObj(defaults$6, options2, false);
  let doc = options2.value;
  if (typeof doc == "string")
    doc = new Doc(doc, options2.mode, null, options2.lineSeparator, options2.direction);
  else if (options2.mode)
    doc.modeOption = options2.mode;
  this.doc = doc;
  let input2 = new CodeMirror$3.inputStyles[options2.inputStyle](this);
  let display = this.display = new Display(place, doc, input2, options2);
  display.wrapper.CodeMirror = this;
  themeChanged(this);
  if (options2.lineWrapping)
    this.display.wrapper.className += " CodeMirror-wrap";
  initScrollbars(this);
  this.state = {
    keyMaps: [],
    overlays: [],
    modeGen: 0,
    overwrite: false,
    delayingBlurEvent: false,
    focused: false,
    suppressEdits: false,
    pasteIncoming: -1,
    cutIncoming: -1,
    selectingText: false,
    draggingText: false,
    highlight: new Delayed(),
    keySeq: null,
    specialChars: null
  };
  if (options2.autofocus && !mobile)
    display.input.focus();
  if (ie && ie_version < 11)
    setTimeout(() => this.display.input.reset(true), 20);
  registerEventHandlers(this);
  ensureGlobalHandlers();
  startOperation(this);
  this.curOp.forceUpdate = true;
  attachDoc(this, doc);
  if (options2.autofocus && !mobile || this.hasFocus())
    setTimeout(() => {
      if (this.hasFocus() && !this.state.focused)
        onFocus(this);
    }, 20);
  else
    onBlur(this);
  for (let opt in optionHandlers)
    if (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](this, options2[opt], Init);
  maybeUpdateLineNumberWidth(this);
  if (options2.finishInit)
    options2.finishInit(this);
  for (let i2 = 0; i2 < initHooks.length; ++i2)
    initHooks[i2](this);
  endOperation(this);
  if (webkit && options2.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
    display.lineDiv.style.textRendering = "auto";
}
CodeMirror$3.defaults = defaults$6;
CodeMirror$3.optionHandlers = optionHandlers;
function registerEventHandlers(cm) {
  let d = cm.display;
  on$1(d.scroller, "mousedown", operation(cm, onMouseDown));
  if (ie && ie_version < 11)
    on$1(d.scroller, "dblclick", operation(cm, (e) => {
      if (signalDOMEvent(cm, e))
        return;
      let pos = posFromMouse(cm, e);
      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
        return;
      e_preventDefault(e);
      let word = cm.findWordAt(pos);
      extendSelection(cm.doc, word.anchor, word.head);
    }));
  else
    on$1(d.scroller, "dblclick", (e) => signalDOMEvent(cm, e) || e_preventDefault(e));
  on$1(d.scroller, "contextmenu", (e) => onContextMenu(cm, e));
  on$1(d.input.getField(), "contextmenu", (e) => {
    if (!d.scroller.contains(e.target))
      onContextMenu(cm, e);
  });
  let touchFinished, prevTouch = { end: 0 };
  function finishTouch() {
    if (d.activeTouch) {
      touchFinished = setTimeout(() => d.activeTouch = null, 1e3);
      prevTouch = d.activeTouch;
      prevTouch.end = +new Date();
    }
  }
  function isMouseLikeTouchEvent(e) {
    if (e.touches.length != 1)
      return false;
    let touch = e.touches[0];
    return touch.radiusX <= 1 && touch.radiusY <= 1;
  }
  function farAway(touch, other) {
    if (other.left == null)
      return true;
    let dx = other.left - touch.left, dy = other.top - touch.top;
    return dx * dx + dy * dy > 20 * 20;
  }
  on$1(d.scroller, "touchstart", (e) => {
    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
      d.input.ensurePolled();
      clearTimeout(touchFinished);
      let now2 = +new Date();
      d.activeTouch = {
        start: now2,
        moved: false,
        prev: now2 - prevTouch.end <= 300 ? prevTouch : null
      };
      if (e.touches.length == 1) {
        d.activeTouch.left = e.touches[0].pageX;
        d.activeTouch.top = e.touches[0].pageY;
      }
    }
  });
  on$1(d.scroller, "touchmove", () => {
    if (d.activeTouch)
      d.activeTouch.moved = true;
  });
  on$1(d.scroller, "touchend", (e) => {
    let touch = d.activeTouch;
    if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
      let pos = cm.coordsChar(d.activeTouch, "page"), range2;
      if (!touch.prev || farAway(touch, touch.prev))
        range2 = new Range(pos, pos);
      else if (!touch.prev.prev || farAway(touch, touch.prev.prev))
        range2 = cm.findWordAt(pos);
      else
        range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
      cm.setSelection(range2.anchor, range2.head);
      cm.focus();
      e_preventDefault(e);
    }
    finishTouch();
  });
  on$1(d.scroller, "touchcancel", finishTouch);
  on$1(d.scroller, "scroll", () => {
    if (d.scroller.clientHeight) {
      updateScrollTop(cm, d.scroller.scrollTop);
      setScrollLeft(cm, d.scroller.scrollLeft, true);
      signal(cm, "scroll", cm);
    }
  });
  on$1(d.scroller, "mousewheel", (e) => onScrollWheel(cm, e));
  on$1(d.scroller, "DOMMouseScroll", (e) => onScrollWheel(cm, e));
  on$1(d.wrapper, "scroll", () => d.wrapper.scrollTop = d.wrapper.scrollLeft = 0);
  d.dragFunctions = {
    enter: (e) => {
      if (!signalDOMEvent(cm, e))
        e_stop(e);
    },
    over: (e) => {
      if (!signalDOMEvent(cm, e)) {
        onDragOver(cm, e);
        e_stop(e);
      }
    },
    start: (e) => onDragStart(cm, e),
    drop: operation(cm, onDrop),
    leave: (e) => {
      if (!signalDOMEvent(cm, e)) {
        clearDragCursor(cm);
      }
    }
  };
  let inp = d.input.getField();
  on$1(inp, "keyup", (e) => onKeyUp.call(cm, e));
  on$1(inp, "keydown", operation(cm, onKeyDown));
  on$1(inp, "keypress", operation(cm, onKeyPress));
  on$1(inp, "focus", (e) => onFocus(cm, e));
  on$1(inp, "blur", (e) => onBlur(cm, e));
}
let initHooks = [];
CodeMirror$3.defineInitHook = (f) => initHooks.push(f);
function indentLine(cm, n, how, aggressive) {
  let doc = cm.doc, state;
  if (how == null)
    how = "add";
  if (how == "smart") {
    if (!doc.mode.indent)
      how = "prev";
    else
      state = getContextBefore(cm, n).state;
  }
  let tabSize = cm.options.tabSize;
  let line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
  if (line.stateAfter)
    line.stateAfter = null;
  let curSpaceString = line.text.match(/^\s*/)[0], indentation;
  if (!aggressive && !/\S/.test(line.text)) {
    indentation = 0;
    how = "not";
  } else if (how == "smart") {
    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
    if (indentation == Pass || indentation > 150) {
      if (!aggressive)
        return;
      how = "prev";
    }
  }
  if (how == "prev") {
    if (n > doc.first)
      indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
    else
      indentation = 0;
  } else if (how == "add") {
    indentation = curSpace + cm.options.indentUnit;
  } else if (how == "subtract") {
    indentation = curSpace - cm.options.indentUnit;
  } else if (typeof how == "number") {
    indentation = curSpace + how;
  }
  indentation = Math.max(0, indentation);
  let indentString = "", pos = 0;
  if (cm.options.indentWithTabs)
    for (let i2 = Math.floor(indentation / tabSize); i2; --i2) {
      pos += tabSize;
      indentString += "	";
    }
  if (pos < indentation)
    indentString += spaceStr(indentation - pos);
  if (indentString != curSpaceString) {
    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    line.stateAfter = null;
    return true;
  } else {
    for (let i2 = 0; i2 < doc.sel.ranges.length; i2++) {
      let range2 = doc.sel.ranges[i2];
      if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
        let pos2 = Pos(n, curSpaceString.length);
        replaceOneSelection(doc, i2, new Range(pos2, pos2));
        break;
      }
    }
  }
}
let lastCopied = null;
function setLastCopied(newLastCopied) {
  lastCopied = newLastCopied;
}
function applyTextInput(cm, inserted, deleted, sel, origin) {
  let doc = cm.doc;
  cm.display.shift = false;
  if (!sel)
    sel = doc.sel;
  let recent = +new Date() - 200;
  let paste = origin == "paste" || cm.state.pasteIncoming > recent;
  let textLines = splitLinesAuto(inserted), multiPaste = null;
  if (paste && sel.ranges.length > 1) {
    if (lastCopied && lastCopied.text.join("\n") == inserted) {
      if (sel.ranges.length % lastCopied.text.length == 0) {
        multiPaste = [];
        for (let i2 = 0; i2 < lastCopied.text.length; i2++)
          multiPaste.push(doc.splitLines(lastCopied.text[i2]));
      }
    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
      multiPaste = map(textLines, (l) => [l]);
    }
  }
  let updateInput = cm.curOp.updateInput;
  for (let i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
    let range2 = sel.ranges[i2];
    let from = range2.from(), to = range2.to();
    if (range2.empty()) {
      if (deleted && deleted > 0)
        from = Pos(from.line, from.ch - deleted);
      else if (cm.state.overwrite && !paste)
        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n"))
        from = to = Pos(from.line, 0);
    }
    let changeEvent = {
      from,
      to,
      text: multiPaste ? multiPaste[i2 % multiPaste.length] : textLines,
      origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
    };
    makeChange(cm.doc, changeEvent);
    signalLater(cm, "inputRead", cm, changeEvent);
  }
  if (inserted && !paste)
    triggerElectric(cm, inserted);
  ensureCursorVisible(cm);
  if (cm.curOp.updateInput < 2)
    cm.curOp.updateInput = updateInput;
  cm.curOp.typing = true;
  cm.state.pasteIncoming = cm.state.cutIncoming = -1;
}
function handlePaste(e, cm) {
  let pasted = e.clipboardData && e.clipboardData.getData("Text");
  if (pasted) {
    e.preventDefault();
    if (!cm.isReadOnly() && !cm.options.disableInput)
      runInOp(cm, () => applyTextInput(cm, pasted, 0, null, "paste"));
    return true;
  }
}
function triggerElectric(cm, inserted) {
  if (!cm.options.electricChars || !cm.options.smartIndent)
    return;
  let sel = cm.doc.sel;
  for (let i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
    let range2 = sel.ranges[i2];
    if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line)
      continue;
    let mode = cm.getModeAt(range2.head);
    let indented = false;
    if (mode.electricChars) {
      for (let j = 0; j < mode.electricChars.length; j++)
        if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
          indented = indentLine(cm, range2.head.line, "smart");
          break;
        }
    } else if (mode.electricInput) {
      if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch)))
        indented = indentLine(cm, range2.head.line, "smart");
    }
    if (indented)
      signalLater(cm, "electricInput", cm, range2.head.line);
  }
}
function copyableRanges(cm) {
  let text = [], ranges = [];
  for (let i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
    let line = cm.doc.sel.ranges[i2].head.line;
    let lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
    ranges.push(lineRange);
    text.push(cm.getRange(lineRange.anchor, lineRange.head));
  }
  return { text, ranges };
}
function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
  field.setAttribute("autocorrect", autocorrect ? "" : "off");
  field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
  field.setAttribute("spellcheck", !!spellcheck);
}
function hiddenTextarea() {
  let te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
  let div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
  if (webkit)
    te.style.width = "1000px";
  else
    te.setAttribute("wrap", "off");
  if (ios)
    te.style.border = "1px solid black";
  disableBrowserMagic(te);
  return div;
}
function addEditorMethods(CodeMirror2) {
  let optionHandlers2 = CodeMirror2.optionHandlers;
  let helpers = CodeMirror2.helpers = {};
  CodeMirror2.prototype = {
    constructor: CodeMirror2,
    focus: function() {
      window.focus();
      this.display.input.focus();
    },
    setOption: function(option2, value2) {
      let options2 = this.options, old = options2[option2];
      if (options2[option2] == value2 && option2 != "mode")
        return;
      options2[option2] = value2;
      if (optionHandlers2.hasOwnProperty(option2))
        operation(this, optionHandlers2[option2])(this, value2, old);
      signal(this, "optionChange", this, option2);
    },
    getOption: function(option2) {
      return this.options[option2];
    },
    getDoc: function() {
      return this.doc;
    },
    addKeyMap: function(map2, bottom2) {
      this.state.keyMaps[bottom2 ? "push" : "unshift"](getKeyMap(map2));
    },
    removeKeyMap: function(map2) {
      let maps = this.state.keyMaps;
      for (let i2 = 0; i2 < maps.length; ++i2)
        if (maps[i2] == map2 || maps[i2].name == map2) {
          maps.splice(i2, 1);
          return true;
        }
    },
    addOverlay: methodOp(function(spec, options2) {
      let mode = spec.token ? spec : CodeMirror2.getMode(this.options, spec);
      if (mode.startState)
        throw new Error("Overlays may not be stateful.");
      insertSorted(this.state.overlays, {
        mode,
        modeSpec: spec,
        opaque: options2 && options2.opaque,
        priority: options2 && options2.priority || 0
      }, (overlay) => overlay.priority);
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      let overlays = this.state.overlays;
      for (let i2 = 0; i2 < overlays.length; ++i2) {
        let cur = overlays[i2].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i2, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),
    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null)
          dir = this.options.smartIndent ? "smart" : "prev";
        else
          dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n))
        indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      let ranges = this.doc.sel.ranges, end2 = -1;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let range2 = ranges[i2];
        if (!range2.empty()) {
          let from = range2.from(), to = range2.to();
          let start2 = Math.max(end2, from.line);
          end2 = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (let j = start2; j < end2; ++j)
            indentLine(this, j, how);
          let newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0)
            replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);
        } else if (range2.head.line > end2) {
          indentLine(this, range2.head.line, how, true);
          end2 = range2.head.line;
          if (i2 == this.doc.sel.primIndex)
            ensureCursorVisible(this);
        }
      }
    }),
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },
    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },
    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      let styles = getLineStyles(this, getLine(this.doc, pos.line));
      let before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      let type2;
      if (ch == 0)
        type2 = styles[2];
      else
        for (; ; ) {
          let mid = before + after >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
            after = mid;
          else if (styles[mid * 2 + 1] < ch)
            before = mid + 1;
          else {
            type2 = styles[mid * 2 + 2];
            break;
          }
        }
      let cut = type2 ? type2.indexOf("overlay ") : -1;
      return cut < 0 ? type2 : cut == 0 ? null : type2.slice(0, cut - 1);
    },
    getModeAt: function(pos) {
      let mode = this.doc.mode;
      if (!mode.innerMode)
        return mode;
      return CodeMirror2.innerMode(mode, this.getTokenAt(pos).state).mode;
    },
    getHelper: function(pos, type2) {
      return this.getHelpers(pos, type2)[0];
    },
    getHelpers: function(pos, type2) {
      let found = [];
      if (!helpers.hasOwnProperty(type2))
        return found;
      let help = helpers[type2], mode = this.getModeAt(pos);
      if (typeof mode[type2] == "string") {
        if (help[mode[type2]])
          found.push(help[mode[type2]]);
      } else if (mode[type2]) {
        for (let i2 = 0; i2 < mode[type2].length; i2++) {
          let val = help[mode[type2][i2]];
          if (val)
            found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (let i2 = 0; i2 < help._global.length; i2++) {
        let cur = help._global[i2];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },
    getStateAfter: function(line, precise) {
      let doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
      return getContextBefore(this, line + 1, precise).state;
    },
    cursorCoords: function(start2, mode) {
      let pos, range2 = this.doc.sel.primary();
      if (start2 == null)
        pos = range2.head;
      else if (typeof start2 == "object")
        pos = clipPos(this.doc, start2);
      else
        pos = start2 ? range2.from() : range2.to();
      return cursorCoords(this, pos, mode || "page");
    },
    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },
    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },
    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode, includeWidgets) {
      let end2 = false, lineObj;
      if (typeof line == "number") {
        let last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first)
          line = this.doc.first;
        else if (line > last) {
          line = last;
          end2 = true;
        }
        lineObj = getLine(this.doc, line);
      } else {
        lineObj = line;
      }
      return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end2).top + (end2 ? this.doc.height - heightAtLine(lineObj) : 0);
    },
    defaultTextHeight: function() {
      return textHeight(this.display);
    },
    defaultCharWidth: function() {
      return charWidth(this.display);
    },
    getViewport: function() {
      return { from: this.display.viewFrom, to: this.display.viewTo };
    },
    addWidget: function(pos, node, scroll, vert, horiz) {
      let display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      let top2 = pos.bottom, left2 = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top2 = pos.top;
      } else if (vert == "above" || vert == "near") {
        let vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top2 = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top2 = pos.bottom;
        if (left2 + node.offsetWidth > hspace)
          left2 = hspace - node.offsetWidth;
      }
      node.style.top = top2 + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left2 = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left")
          left2 = 0;
        else if (horiz == "middle")
          left2 = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left2 + "px";
      }
      if (scroll)
        scrollIntoView(this, { left: left2, top: top2, right: left2 + node.offsetWidth, bottom: top2 + node.offsetHeight });
    },
    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,
    triggerOnMouseDown: methodOp(onMouseDown),
    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd].call(null, this);
    },
    triggerElectric: methodOp(function(text) {
      triggerElectric(this, text);
    }),
    findPosH: function(from, amount, unit, visually) {
      let dir = 1;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      let cur = clipPos(this.doc, from);
      for (let i2 = 0; i2 < amount; ++i2) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveH: methodOp(function(dir, unit) {
      this.extendSelectionsBy((range2) => {
        if (this.display.shift || this.doc.extend || range2.empty())
          return findPosH(this.doc, range2.head, dir, unit, this.options.rtlMoveVisually);
        else
          return dir < 0 ? range2.from() : range2.to();
      }, sel_move);
    }),
    deleteH: methodOp(function(dir, unit) {
      let sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, (range2) => {
          let other = findPosH(doc, range2.head, dir, unit, false);
          return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
        });
    }),
    findPosV: function(from, amount, unit, goalColumn) {
      let dir = 1, x = goalColumn;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      let cur = clipPos(this.doc, from);
      for (let i2 = 0; i2 < amount; ++i2) {
        let coords = cursorCoords(this, cur, "div");
        if (x == null)
          x = coords.left;
        else
          coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveV: methodOp(function(dir, unit) {
      let doc = this.doc, goals = [];
      let collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy((range2) => {
        if (collapse)
          return dir < 0 ? range2.from() : range2.to();
        let headPos = cursorCoords(this, range2.head, "div");
        if (range2.goalColumn != null)
          headPos.left = range2.goalColumn;
        goals.push(headPos.left);
        let pos = findPosV(this, headPos, dir, unit);
        if (unit == "page" && range2 == doc.sel.primary())
          addToScrollTop(this, charCoords(this, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length)
        for (let i2 = 0; i2 < doc.sel.ranges.length; i2++)
          doc.sel.ranges[i2].goalColumn = goals[i2];
    }),
    findWordAt: function(pos) {
      let doc = this.doc, line = getLine(doc, pos.line).text;
      let start2 = pos.ch, end2 = pos.ch;
      if (line) {
        let helper = this.getHelper(pos, "wordChars");
        if ((pos.sticky == "before" || end2 == line.length) && start2)
          --start2;
        else
          ++end2;
        let startChar = line.charAt(start2);
        let check = isWordChar(startChar, helper) ? (ch) => isWordChar(ch, helper) : /\s/.test(startChar) ? (ch) => /\s/.test(ch) : (ch) => !/\s/.test(ch) && !isWordChar(ch);
        while (start2 > 0 && check(line.charAt(start2 - 1)))
          --start2;
        while (end2 < line.length && check(line.charAt(end2)))
          ++end2;
      }
      return new Range(Pos(pos.line, start2), Pos(pos.line, end2));
    },
    toggleOverwrite: function(value2) {
      if (value2 != null && value2 == this.state.overwrite)
        return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() {
      return this.display.input.getField() == activeElt();
    },
    isReadOnly: function() {
      return !!(this.options.readOnly || this.doc.cantEdit);
    },
    scrollTo: methodOp(function(x, y) {
      scrollToCoords(this, x, y);
    }),
    getScrollInfo: function() {
      let scroller = this.display.scroller;
      return {
        left: scroller.scrollLeft,
        top: scroller.scrollTop,
        height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
        width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
        clientHeight: displayHeight(this),
        clientWidth: displayWidth(this)
      };
    },
    scrollIntoView: methodOp(function(range2, margin) {
      if (range2 == null) {
        range2 = { from: this.doc.sel.primary().head, to: null };
        if (margin == null)
          margin = this.options.cursorScrollMargin;
      } else if (typeof range2 == "number") {
        range2 = { from: Pos(range2, 0), to: null };
      } else if (range2.from == null) {
        range2 = { from: range2, to: null };
      }
      if (!range2.to)
        range2.to = range2.from;
      range2.margin = margin || 0;
      if (range2.from.line != null) {
        scrollToRange(this, range2);
      } else {
        scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
      }
    }),
    setSize: methodOp(function(width2, height) {
      let interpret = (val) => typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      if (width2 != null)
        this.display.wrapper.style.width = interpret(width2);
      if (height != null)
        this.display.wrapper.style.height = interpret(height);
      if (this.options.lineWrapping)
        clearLineMeasurementCache(this);
      let lineNo2 = this.display.viewFrom;
      this.doc.iter(lineNo2, this.display.viewTo, (line) => {
        if (line.widgets) {
          for (let i2 = 0; i2 < line.widgets.length; i2++)
            if (line.widgets[i2].noHScroll) {
              regLineChange(this, lineNo2, "widget");
              break;
            }
        }
        ++lineNo2;
      });
      this.curOp.forceUpdate = true;
      signal(this, "refresh", this);
    }),
    operation: function(f) {
      return runInOp(this, f);
    },
    startOperation: function() {
      return startOperation(this);
    },
    endOperation: function() {
      return endOperation(this);
    },
    refresh: methodOp(function() {
      let oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this.display);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),
    swapDoc: methodOp(function(doc) {
      let old = this.doc;
      old.cm = null;
      if (this.state.selectingText)
        this.state.selectingText();
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),
    phrase: function(phraseText) {
      let phrases = this.options.phrases;
      return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
    },
    getInputField: function() {
      return this.display.input.getField();
    },
    getWrapperElement: function() {
      return this.display.wrapper;
    },
    getScrollerElement: function() {
      return this.display.scroller;
    },
    getGutterElement: function() {
      return this.display.gutters;
    }
  };
  eventMixin(CodeMirror2);
  CodeMirror2.registerHelper = function(type2, name2, value2) {
    if (!helpers.hasOwnProperty(type2))
      helpers[type2] = CodeMirror2[type2] = { _global: [] };
    helpers[type2][name2] = value2;
  };
  CodeMirror2.registerGlobalHelper = function(type2, name2, predicate, value2) {
    CodeMirror2.registerHelper(type2, name2, value2);
    helpers[type2]._global.push({ pred: predicate, val: value2 });
  };
}
function findPosH(doc, pos, dir, unit, visually) {
  let oldPos = pos;
  let origDir = dir;
  let lineObj = getLine(doc, pos.line);
  let lineDir = visually && doc.direction == "rtl" ? -dir : dir;
  function findNextLine() {
    let l = pos.line + lineDir;
    if (l < doc.first || l >= doc.first + doc.size)
      return false;
    pos = new Pos(l, pos.ch, pos.sticky);
    return lineObj = getLine(doc, l);
  }
  function moveOnce(boundToLine) {
    let next;
    if (unit == "codepoint") {
      let ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
      if (isNaN(ch)) {
        next = null;
      } else {
        let astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
        next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
      }
    } else if (visually) {
      next = moveVisually(doc.cm, lineObj, pos, dir);
    } else {
      next = moveLogically(lineObj, pos, dir);
    }
    if (next == null) {
      if (!boundToLine && findNextLine())
        pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
      else
        return false;
    } else {
      pos = next;
    }
    return true;
  }
  if (unit == "char" || unit == "codepoint") {
    moveOnce();
  } else if (unit == "column") {
    moveOnce(true);
  } else if (unit == "word" || unit == "group") {
    let sawType = null, group = unit == "group";
    let helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
    for (let first = true; ; first = false) {
      if (dir < 0 && !moveOnce(!first))
        break;
      let cur = lineObj.text.charAt(pos.ch) || "\n";
      let type2 = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
      if (group && !first && !type2)
        type2 = "s";
      if (sawType && sawType != type2) {
        if (dir < 0) {
          dir = 1;
          moveOnce();
          pos.sticky = "after";
        }
        break;
      }
      if (type2)
        sawType = type2;
      if (dir > 0 && !moveOnce(!first))
        break;
    }
  }
  let result = skipAtomic(doc, pos, oldPos, origDir, true);
  if (equalCursorPos(oldPos, result))
    result.hitSide = true;
  return result;
}
function findPosV(cm, pos, dir, unit) {
  let doc = cm.doc, x = pos.left, y;
  if (unit == "page") {
    let pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
    let moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
  } else if (unit == "line") {
    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
  }
  let target;
  for (; ; ) {
    target = coordsChar(cm, x, y);
    if (!target.outside)
      break;
    if (dir < 0 ? y <= 0 : y >= doc.height) {
      target.hitSide = true;
      break;
    }
    y += dir * 5;
  }
  return target;
}
class ContentEditableInput {
  constructor(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  }
  init(display) {
    let input2 = this, cm = input2.cm;
    let div = input2.div = display.lineDiv;
    div.contentEditable = true;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
    function belongsToInput(e) {
      for (let t = e.target; t; t = t.parentNode) {
        if (t == div)
          return true;
        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className))
          break;
      }
      return false;
    }
    on$1(div, "paste", (e) => {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm))
        return;
      if (ie_version <= 11)
        setTimeout(operation(cm, () => this.updateFromDOM()), 20);
    });
    on$1(div, "compositionstart", (e) => {
      this.composing = { data: e.data, done: false };
    });
    on$1(div, "compositionupdate", (e) => {
      if (!this.composing)
        this.composing = { data: e.data, done: false };
    });
    on$1(div, "compositionend", (e) => {
      if (this.composing) {
        if (e.data != this.composing.data)
          this.readFromDOMSoon();
        this.composing.done = true;
      }
    });
    on$1(div, "touchstart", () => input2.forceCompositionEnd());
    on$1(div, "input", () => {
      if (!this.composing)
        this.readFromDOMSoon();
    });
    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e))
        return;
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
        if (e.type == "cut")
          cm.replaceSelection("", null, "cut");
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        let ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.operation(() => {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        let content = lastCopied.text.join("\n");
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return;
        }
      }
      let kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      let hadFocus = activeElt();
      selectInput(te);
      setTimeout(() => {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div)
          input2.showPrimarySelection();
      }, 50);
    }
    on$1(div, "copy", onCopyCut);
    on$1(div, "cut", onCopyCut);
  }
  screenReaderLabelChanged(label) {
    if (label) {
      this.div.setAttribute("aria-label", label);
    } else {
      this.div.removeAttribute("aria-label");
    }
  }
  prepareSelection() {
    let result = prepareSelection(this.cm, false);
    result.focus = activeElt() == this.div;
    return result;
  }
  showSelection(info, takeFocus) {
    if (!info || !this.cm.display.view.length)
      return;
    if (info.focus || takeFocus)
      this.showPrimarySelection();
    this.showMultipleSelections(info);
  }
  getSelection() {
    return this.cm.display.wrapper.ownerDocument.getSelection();
  }
  showPrimarySelection() {
    let sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    let from = prim.from(), to = prim.to();
    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return;
    }
    let curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    let curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0)
      return;
    let view = cm.display.view;
    let start2 = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
    let end2 = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end2) {
      let measure = view[view.length - 1].measure;
      let map2 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end2 = { node: map2[map2.length - 1], offset: map2[map2.length - 2] - map2[map2.length - 3] };
    }
    if (!start2 || !end2) {
      sel.removeAllRanges();
      return;
    }
    let old = sel.rangeCount && sel.getRangeAt(0), rng2;
    try {
      rng2 = range(start2.node, start2.offset, end2.offset, end2.node);
    } catch (e) {
    }
    if (rng2) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start2.node, start2.offset);
        if (!rng2.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng2);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng2);
      }
      if (old && sel.anchorNode == null)
        sel.addRange(old);
      else if (gecko)
        this.startGracePeriod();
    }
    this.rememberSelection();
  }
  startGracePeriod() {
    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(() => {
      this.gracePeriod = false;
      if (this.selectionChanged())
        this.cm.operation(() => this.cm.curOp.selectionChanged = true);
    }, 20);
  }
  showMultipleSelections(info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  }
  rememberSelection() {
    let sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode;
    this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode;
    this.lastFocusOffset = sel.focusOffset;
  }
  selectionInEditor() {
    let sel = this.getSelection();
    if (!sel.rangeCount)
      return false;
    let node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node);
  }
  focus() {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || activeElt() != this.div)
        this.showSelection(this.prepareSelection(), true);
      this.div.focus();
    }
  }
  blur() {
    this.div.blur();
  }
  getField() {
    return this.div;
  }
  supportsTouch() {
    return true;
  }
  receivedFocus() {
    let input2 = this;
    if (this.selectionInEditor())
      setTimeout(() => this.pollSelection(), 20);
    else
      runInOp(this.cm, () => input2.cm.curOp.selectionChanged = true);
    function poll() {
      if (input2.cm.state.focused) {
        input2.pollSelection();
        input2.polling.set(input2.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  }
  selectionChanged() {
    let sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
  }
  pollSelection() {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())
      return;
    let sel = this.getSelection(), cm = this.cm;
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
      this.blur();
      this.focus();
      return;
    }
    if (this.composing)
      return;
    this.rememberSelection();
    let anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    let head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head)
      runInOp(cm, () => {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
        if (anchor.bad || head.bad)
          cm.curOp.selectionChanged = true;
      });
  }
  pollContent() {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }
    let cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    let from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      to = Pos(to.line + 1, 0);
    if (from.line < display.viewFrom || to.line > display.viewTo - 1)
      return false;
    let fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    let toIndex = findViewIndex(cm, to.line);
    let toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }
    if (!fromNode)
      return false;
    let newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    let oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) {
        newText.pop();
        oldText.pop();
        toLine--;
      } else if (newText[0] == oldText[0]) {
        newText.shift();
        oldText.shift();
        fromLine++;
      } else
        break;
    }
    let cutFront = 0, cutEnd = 0;
    let newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      ++cutFront;
    let newBot = lst(newText), oldBot = lst(oldText);
    let maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      ++cutEnd;
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }
    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
    let chFrom = Pos(fromLine, cutFront);
    let chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true;
    }
  }
  ensurePolled() {
    this.forceCompositionEnd();
  }
  reset() {
    this.forceCompositionEnd();
  }
  forceCompositionEnd() {
    if (!this.composing)
      return;
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  }
  readFromDOMSoon() {
    if (this.readDOMTimeout != null)
      return;
    this.readDOMTimeout = setTimeout(() => {
      this.readDOMTimeout = null;
      if (this.composing) {
        if (this.composing.done)
          this.composing = null;
        else
          return;
      }
      this.updateFromDOM();
    }, 80);
  }
  updateFromDOM() {
    if (this.cm.isReadOnly() || !this.pollContent())
      runInOp(this.cm, () => regChange(this.cm));
  }
  setUneditable(node) {
    node.contentEditable = "false";
  }
  onKeyPress(e) {
    if (e.charCode == 0 || this.composing)
      return;
    e.preventDefault();
    if (!this.cm.isReadOnly())
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
  }
  readOnlyChanged(val) {
    this.div.contentEditable = String(val != "nocursor");
  }
  onContextMenu() {
  }
  resetPosition() {
  }
}
ContentEditableInput.prototype.needsContentAttribute = true;
function posToDOM(cm, pos) {
  let view = findViewForLine(cm, pos.line);
  if (!view || view.hidden)
    return null;
  let line = getLine(cm.doc, pos.line);
  let info = mapFromLineView(view, line, pos.line);
  let order2 = getOrder(line, cm.doc.direction), side = "left";
  if (order2) {
    let partPos = getBidiPartAt(order2, pos.ch);
    side = partPos % 2 ? "right" : "left";
  }
  let result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
  result.offset = result.collapse == "right" ? result.end : result.start;
  return result;
}
function isInGutter(node) {
  for (let scan = node; scan; scan = scan.parentNode)
    if (/CodeMirror-gutter-wrapper/.test(scan.className))
      return true;
  return false;
}
function badPos(pos, bad) {
  if (bad)
    pos.bad = true;
  return pos;
}
function domTextBetween(cm, from, to, fromLine, toLine) {
  let text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
  function recognizeMarker(id2) {
    return (marker) => marker.id == id2;
  }
  function close2() {
    if (closing) {
      text += lineSep;
      if (extraLinebreak)
        text += lineSep;
      closing = extraLinebreak = false;
    }
  }
  function addText(str) {
    if (str) {
      close2();
      text += str;
    }
  }
  function walk(node) {
    if (node.nodeType == 1) {
      let cmText = node.getAttribute("cm-text");
      if (cmText) {
        addText(cmText);
        return;
      }
      let markerID = node.getAttribute("cm-marker"), range2;
      if (markerID) {
        let found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
        if (found.length && (range2 = found[0].find(0)))
          addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
        return;
      }
      if (node.getAttribute("contenteditable") == "false")
        return;
      let isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
      if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0)
        return;
      if (isBlock)
        close2();
      for (let i2 = 0; i2 < node.childNodes.length; i2++)
        walk(node.childNodes[i2]);
      if (/^(pre|p)$/i.test(node.nodeName))
        extraLinebreak = true;
      if (isBlock)
        closing = true;
    } else if (node.nodeType == 3) {
      addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
    }
  }
  for (; ; ) {
    walk(from);
    if (from == to)
      break;
    from = from.nextSibling;
    extraLinebreak = false;
  }
  return text;
}
function domToPos(cm, node, offset2) {
  let lineNode;
  if (node == cm.display.lineDiv) {
    lineNode = cm.display.lineDiv.childNodes[offset2];
    if (!lineNode)
      return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
    node = null;
    offset2 = 0;
  } else {
    for (lineNode = node; ; lineNode = lineNode.parentNode) {
      if (!lineNode || lineNode == cm.display.lineDiv)
        return null;
      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv)
        break;
    }
  }
  for (let i2 = 0; i2 < cm.display.view.length; i2++) {
    let lineView = cm.display.view[i2];
    if (lineView.node == lineNode)
      return locateNodeInLineView(lineView, node, offset2);
  }
}
function locateNodeInLineView(lineView, node, offset2) {
  let wrapper = lineView.text.firstChild, bad = false;
  if (!node || !contains(wrapper, node))
    return badPos(Pos(lineNo(lineView.line), 0), true);
  if (node == wrapper) {
    bad = true;
    node = wrapper.childNodes[offset2];
    offset2 = 0;
    if (!node) {
      let line = lineView.rest ? lst(lineView.rest) : lineView.line;
      return badPos(Pos(lineNo(line), line.text.length), bad);
    }
  }
  let textNode = node.nodeType == 3 ? node : null, topNode = node;
  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
    textNode = node.firstChild;
    if (offset2)
      offset2 = textNode.nodeValue.length;
  }
  while (topNode.parentNode != wrapper)
    topNode = topNode.parentNode;
  let measure = lineView.measure, maps = measure.maps;
  function find2(textNode2, topNode2, offset3) {
    for (let i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
      let map2 = i2 < 0 ? measure.map : maps[i2];
      for (let j = 0; j < map2.length; j += 3) {
        let curNode = map2[j + 2];
        if (curNode == textNode2 || curNode == topNode2) {
          let line = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
          let ch = map2[j] + offset3;
          if (offset3 < 0 || curNode != textNode2)
            ch = map2[j + (offset3 ? 1 : 0)];
          return Pos(line, ch);
        }
      }
    }
  }
  let found = find2(textNode, topNode, offset2);
  if (found)
    return badPos(found, bad);
  for (let after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset2 : 0; after; after = after.nextSibling) {
    found = find2(after, after.firstChild, 0);
    if (found)
      return badPos(Pos(found.line, found.ch - dist), bad);
    else
      dist += after.textContent.length;
  }
  for (let before = topNode.previousSibling, dist = offset2; before; before = before.previousSibling) {
    found = find2(before, before.firstChild, -1);
    if (found)
      return badPos(Pos(found.line, found.ch + dist), bad);
    else
      dist += before.textContent.length;
  }
}
class TextareaInput {
  constructor(cm) {
    this.cm = cm;
    this.prevInput = "";
    this.pollingFast = false;
    this.polling = new Delayed();
    this.hasSelection = false;
    this.composing = null;
  }
  init(display) {
    let input2 = this, cm = this.cm;
    this.createField(display);
    const te = this.textarea;
    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
    if (ios)
      te.style.width = "0px";
    on$1(te, "input", () => {
      if (ie && ie_version >= 9 && this.hasSelection)
        this.hasSelection = null;
      input2.poll();
    });
    on$1(te, "paste", (e) => {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm))
        return;
      cm.state.pasteIncoming = +new Date();
      input2.fastPoll();
    });
    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e))
        return;
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        let ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input2.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut")
        cm.state.cutIncoming = +new Date();
    }
    on$1(te, "cut", prepareCopyCut);
    on$1(te, "copy", prepareCopyCut);
    on$1(display.scroller, "paste", (e) => {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e))
        return;
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date();
        input2.focus();
        return;
      }
      const event2 = new Event("paste");
      event2.clipboardData = e.clipboardData;
      te.dispatchEvent(event2);
    });
    on$1(display.lineSpace, "selectstart", (e) => {
      if (!eventInWidget(display, e))
        e_preventDefault(e);
    });
    on$1(te, "compositionstart", () => {
      let start2 = cm.getCursor("from");
      if (input2.composing)
        input2.composing.range.clear();
      input2.composing = {
        start: start2,
        range: cm.markText(start2, cm.getCursor("to"), { className: "CodeMirror-composing" })
      };
    });
    on$1(te, "compositionend", () => {
      if (input2.composing) {
        input2.poll();
        input2.composing.range.clear();
        input2.composing = null;
      }
    });
  }
  createField(_display) {
    this.wrapper = hiddenTextarea();
    this.textarea = this.wrapper.firstChild;
  }
  screenReaderLabelChanged(label) {
    if (label) {
      this.textarea.setAttribute("aria-label", label);
    } else {
      this.textarea.removeAttribute("aria-label");
    }
  }
  prepareSelection() {
    let cm = this.cm, display = cm.display, doc = cm.doc;
    let result = prepareSelection(cm);
    if (cm.options.moveInputWithCursor) {
      let headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      let wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
    }
    return result;
  }
  showSelection(drawn) {
    let cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  }
  reset(typing) {
    if (this.contextMenuPending || this.composing)
      return;
    let cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      let content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused)
        selectInput(this.textarea);
      if (ie && ie_version >= 9)
        this.hasSelection = content;
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9)
        this.hasSelection = null;
    }
  }
  getField() {
    return this.textarea;
  }
  supportsTouch() {
    return false;
  }
  focus() {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try {
        this.textarea.focus();
      } catch (e) {
      }
    }
  }
  blur() {
    this.textarea.blur();
  }
  resetPosition() {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  }
  receivedFocus() {
    this.slowPoll();
  }
  slowPoll() {
    if (this.pollingFast)
      return;
    this.polling.set(this.cm.options.pollInterval, () => {
      this.poll();
      if (this.cm.state.focused)
        this.slowPoll();
    });
  }
  fastPoll() {
    let missed = false, input2 = this;
    input2.pollingFast = true;
    function p() {
      let changed = input2.poll();
      if (!changed && !missed) {
        missed = true;
        input2.polling.set(60, p);
      } else {
        input2.pollingFast = false;
        input2.slowPoll();
      }
    }
    input2.polling.set(20, p);
  }
  poll() {
    let cm = this.cm, input2 = this.textarea, prevInput = this.prevInput;
    if (this.contextMenuPending || !cm.state.focused || hasSelection(input2) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      return false;
    let text = input2.value;
    if (text == prevInput && !cm.somethingSelected())
      return false;
    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false;
    }
    if (cm.doc.sel == cm.display.selForContextMenu) {
      let first = text.charCodeAt(0);
      if (first == 8203 && !prevInput)
        prevInput = "\u200B";
      if (first == 8666) {
        this.reset();
        return this.cm.execCommand("undo");
      }
    }
    let same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
      ++same;
    runInOp(cm, () => {
      applyTextInput(cm, text.slice(same), prevInput.length - same, null, this.composing ? "*compose" : null);
      if (text.length > 1e3 || text.indexOf("\n") > -1)
        input2.value = this.prevInput = "";
      else
        this.prevInput = text;
      if (this.composing) {
        this.composing.range.clear();
        this.composing.range = cm.markText(this.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
      }
    });
    return true;
  }
  ensurePolled() {
    if (this.pollingFast && this.poll())
      this.pollingFast = false;
  }
  onKeyPress() {
    if (ie && ie_version >= 9)
      this.hasSelection = null;
    this.fastPoll();
  }
  onContextMenu(e) {
    let input2 = this, cm = input2.cm, display = cm.display, te = input2.textarea;
    if (input2.contextMenuPending)
      input2.contextMenuPending();
    let pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto)
      return;
    let reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
    let oldCSS = te.style.cssText, oldWrapperCSS = input2.wrapper.style.cssText;
    let wrapperBox = input2.wrapper.offsetParent.getBoundingClientRect();
    input2.wrapper.style.cssText = "position: static";
    te.style.cssText = `position: absolute; width: 30px; height: 30px;
      top: ${e.clientY - wrapperBox.top - 5}px; left: ${e.clientX - wrapperBox.left - 5}px;
      z-index: 1000; background: ${ie ? "rgba(255, 255, 255, .05)" : "transparent"};
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;
    let oldScrollY;
    if (webkit)
      oldScrollY = window.scrollY;
    display.input.focus();
    if (webkit)
      window.scrollTo(null, oldScrollY);
    display.input.reset();
    if (!cm.somethingSelected())
      te.value = input2.prevInput = " ";
    input2.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        let selected = cm.somethingSelected();
        let extval = "\u200B" + (selected ? te.value : "");
        te.value = "\u21DA";
        te.value = extval;
        input2.prevInput = selected ? "" : "\u200B";
        te.selectionStart = 1;
        te.selectionEnd = extval.length;
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input2.contextMenuPending != rehide)
        return;
      input2.contextMenuPending = false;
      input2.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9)
        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
      if (te.selectionStart != null) {
        if (!ie || ie && ie_version < 9)
          prepareSelectAllHack();
        let i2 = 0, poll = () => {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input2.prevInput == "\u200B") {
            operation(cm, selectAll)(cm);
          } else if (i2++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (ie && ie_version >= 9)
      prepareSelectAllHack();
    if (captureRightClick) {
      e_stop(e);
      let mouseup = () => {
        off$1(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on$1(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }
  readOnlyChanged(val) {
    if (!val)
      this.reset();
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  }
  setUneditable() {
  }
}
TextareaInput.prototype.needsContentAttribute = false;
function fromTextArea(textarea, options2) {
  options2 = options2 ? copyObj(options2) : {};
  options2.value = textarea.value;
  if (!options2.tabindex && textarea.tabIndex)
    options2.tabindex = textarea.tabIndex;
  if (!options2.placeholder && textarea.placeholder)
    options2.placeholder = textarea.placeholder;
  if (options2.autofocus == null) {
    let hasFocus = activeElt();
    options2.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
  }
  function save2() {
    textarea.value = cm.getValue();
  }
  let realSubmit;
  if (textarea.form) {
    on$1(textarea.form, "submit", save2);
    if (!options2.leaveSubmitMethodAlone) {
      let form = textarea.form;
      realSubmit = form.submit;
      try {
        let wrappedSubmit = form.submit = () => {
          save2();
          form.submit = realSubmit;
          form.submit();
          form.submit = wrappedSubmit;
        };
      } catch (e) {
      }
    }
  }
  options2.finishInit = (cm2) => {
    cm2.save = save2;
    cm2.getTextArea = () => textarea;
    cm2.toTextArea = () => {
      cm2.toTextArea = isNaN;
      save2();
      textarea.parentNode.removeChild(cm2.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off$1(textarea.form, "submit", save2);
        if (!options2.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
  };
  textarea.style.display = "none";
  let cm = CodeMirror$3((node) => textarea.parentNode.insertBefore(node, textarea.nextSibling), options2);
  return cm;
}
function addLegacyProps(CodeMirror2) {
  CodeMirror2.off = off$1;
  CodeMirror2.on = on$1;
  CodeMirror2.wheelEventPixels = wheelEventPixels;
  CodeMirror2.Doc = Doc;
  CodeMirror2.splitLines = splitLinesAuto;
  CodeMirror2.countColumn = countColumn;
  CodeMirror2.findColumn = findColumn;
  CodeMirror2.isWordChar = isWordCharBasic;
  CodeMirror2.Pass = Pass;
  CodeMirror2.signal = signal;
  CodeMirror2.Line = Line;
  CodeMirror2.changeEnd = changeEnd;
  CodeMirror2.scrollbarModel = scrollbarModel;
  CodeMirror2.Pos = Pos;
  CodeMirror2.cmpPos = cmp;
  CodeMirror2.modes = modes;
  CodeMirror2.mimeModes = mimeModes;
  CodeMirror2.resolveMode = resolveMode;
  CodeMirror2.getMode = getMode;
  CodeMirror2.modeExtensions = modeExtensions;
  CodeMirror2.extendMode = extendMode;
  CodeMirror2.copyState = copyState;
  CodeMirror2.startState = startState;
  CodeMirror2.innerMode = innerMode;
  CodeMirror2.commands = commands;
  CodeMirror2.keyMap = keyMap;
  CodeMirror2.keyName = keyName;
  CodeMirror2.isModifierKey = isModifierKey;
  CodeMirror2.lookupKey = lookupKey;
  CodeMirror2.normalizeKeyMap = normalizeKeyMap;
  CodeMirror2.StringStream = StringStream;
  CodeMirror2.SharedTextMarker = SharedTextMarker;
  CodeMirror2.TextMarker = TextMarker;
  CodeMirror2.LineWidget = LineWidget;
  CodeMirror2.e_preventDefault = e_preventDefault;
  CodeMirror2.e_stopPropagation = e_stopPropagation;
  CodeMirror2.e_stop = e_stop;
  CodeMirror2.addClass = addClass;
  CodeMirror2.contains = contains;
  CodeMirror2.rmClass = rmClass;
  CodeMirror2.keyNames = keyNames;
}
defineOptions(CodeMirror$3);
addEditorMethods(CodeMirror$3);
let dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
for (let prop in Doc.prototype)
  if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror$3.prototype[prop] = function(method3) {
      return function() {
        return method3.apply(this.doc, arguments);
      };
    }(Doc.prototype[prop]);
eventMixin(Doc);
CodeMirror$3.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
CodeMirror$3.defineMode = function(name2) {
  if (!CodeMirror$3.defaults.mode && name2 != "null")
    CodeMirror$3.defaults.mode = name2;
  defineMode.apply(this, arguments);
};
CodeMirror$3.defineMIME = defineMIME;
CodeMirror$3.defineMode("null", () => ({ token: (stream) => stream.skipToEnd() }));
CodeMirror$3.defineMIME("text/plain", "null");
CodeMirror$3.defineExtension = (name2, func) => {
  CodeMirror$3.prototype[name2] = func;
};
CodeMirror$3.defineDocExtension = (name2, func) => {
  Doc.prototype[name2] = func;
};
CodeMirror$3.fromTextArea = fromTextArea;
addLegacyProps(CodeMirror$3);
CodeMirror$3.version = "5.63.1";
window.CodeMirror = CodeMirror$3;
(function(mod) {
  mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineOption("placeholder", "", function(cm, val, old) {
    var prev = old && old != CodeMirror2.Init;
    if (val && !prev) {
      cm.on("blur", onBlur2);
      cm.on("change", onChange);
      cm.on("swapDoc", onChange);
      CodeMirror2.on(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose = function() {
        onComposition(cm);
      });
      onChange(cm);
    } else if (!val && prev) {
      cm.off("blur", onBlur2);
      cm.off("change", onChange);
      cm.off("swapDoc", onChange);
      CodeMirror2.off(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose);
      clearPlaceholder(cm);
      var wrapper = cm.getWrapperElement();
      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
    }
    if (val && !cm.hasFocus())
      onBlur2(cm);
  });
  function clearPlaceholder(cm) {
    if (cm.state.placeholder) {
      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
      cm.state.placeholder = null;
    }
  }
  function setPlaceholder(cm) {
    clearPlaceholder(cm);
    var elt2 = cm.state.placeholder = document.createElement("pre");
    elt2.style.cssText = "height: 0; overflow: visible";
    elt2.style.direction = cm.getOption("direction");
    elt2.className = "CodeMirror-placeholder CodeMirror-line-like";
    var placeHolder = cm.getOption("placeholder");
    if (typeof placeHolder == "string")
      placeHolder = document.createTextNode(placeHolder);
    elt2.appendChild(placeHolder);
    cm.display.lineSpace.insertBefore(elt2, cm.display.lineSpace.firstChild);
  }
  function onComposition(cm) {
    setTimeout(function() {
      var empty = false;
      if (cm.lineCount() == 1) {
        var input2 = cm.getInputField();
        empty = input2.nodeName == "TEXTAREA" ? !cm.getLine(0).length : !/[^\u200b]/.test(input2.querySelector(".CodeMirror-line").textContent);
      }
      if (empty)
        setPlaceholder(cm);
      else
        clearPlaceholder(cm);
    }, 20);
  }
  function onBlur2(cm) {
    if (isEmpty2(cm))
      setPlaceholder(cm);
  }
  function onChange(cm) {
    var wrapper = cm.getWrapperElement(), empty = isEmpty2(cm);
    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");
    if (empty)
      setPlaceholder(cm);
    else
      clearPlaceholder(cm);
  }
  function isEmpty2(cm) {
    return cm.lineCount() === 1 && cm.getLine(0) === "";
  }
});
(function(mod) {
  mod(CodeMirror);
})(function(CodeMirror2) {
  var HINT_ELEMENT_CLASS = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";
  CodeMirror2.showHint = function(cm, getHints, options2) {
    if (!getHints)
      return cm.showHint(options2);
    if (options2 && options2.async)
      getHints.async = true;
    var newOpts = { hint: getHints };
    if (options2)
      for (var prop in options2)
        newOpts[prop] = options2[prop];
    return cm.showHint(newOpts);
  };
  CodeMirror2.defineExtension("showHint", function(options2) {
    options2 = parseOptions(this, this.getCursor("start"), options2);
    var selections = this.listSelections();
    if (selections.length > 1)
      return;
    if (this.somethingSelected()) {
      if (!options2.hint.supportsSelection)
        return;
      for (var i2 = 0; i2 < selections.length; i2++)
        if (selections[i2].head.line != selections[i2].anchor.line)
          return;
    }
    if (this.state.completionActive)
      this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options2);
    if (!completion.options.hint)
      return;
    CodeMirror2.signal(this, "startCompletion", this);
    completion.update(true);
  });
  CodeMirror2.defineExtension("closeHint", function() {
    if (this.state.completionActive)
      this.state.completionActive.close();
  });
  function Completion(cm, options2) {
    this.cm = cm;
    this.options = options2;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
    if (this.options.updateOnCursorActivity) {
      var self2 = this;
      cm.on("cursorActivity", this.activityFunc = function() {
        self2.cursorActivity();
      });
    }
  }
  function enterSwitch(editor, atKeyWord) {
    var matchReg = /@[0-9a-zA-Z]+\([0-9a-zA-Z,@\*]+\)/;
    var editorValue = editor.getRange(CodeMirror2.Pos(0, 0), editor.getCursor("start"));
    if (matchReg.test(atKeyWord)) {
      var curruntAt = editorValue.split("").reverse().join("").split("@")[0].split("").reverse().join("").replace("(", ",").replace(")", "");
      if (curruntAt != null && curruntAt != "")
        curruntAt = "@" + curruntAt;
      var startValue = editorValue.substring(0, editorValue.length - curruntAt.length - 1).replace(/\(/g, ",").replace(/,/g, ")");
      var param = startValue + curruntAt;
      var a = param.split(",");
      var startCh = a[0].length + 1;
      var ranges = [];
      for (var j = 1; j < a.length; j++) {
        var endCh = startCh + a[j].length;
        var lineRange = editor.newRange(CodeMirror2.Pos(0, startCh), CodeMirror2.Pos(0, endCh));
        ranges.push(lineRange);
        if (j === 1)
          editor.setSelection(CodeMirror2.Pos(0, startCh), CodeMirror2.Pos(0, endCh), { scroll: false });
        startCh = endCh + 1;
      }
      var selection = { "ranges": ranges, primary: 1 };
      editor.setOption("selection", selection);
    }
  }
  function getKey(completion) {
    if (typeof completion == "string")
      return completion;
    else
      return completion.key ? completion.key : completion.text;
  }
  var requestAnimationFrame2 = window.requestAnimationFrame || function(fn2) {
    return setTimeout(fn2, 1e3 / 60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
  Completion.prototype = {
    close: function() {
      if (!this.active())
        return;
      this.cm.state.completionActive = null;
      this.tick = null;
      if (this.options.updateOnCursorActivity) {
        this.cm.off("cursorActivity", this.activityFunc);
      }
      if (this.widget && this.data)
        CodeMirror2.signal(this.data, "close");
      if (this.widget)
        this.widget.close();
      CodeMirror2.signal(this.cm, "endCompletion", this.cm);
    },
    active: function() {
      return this.cm.state.completionActive == this;
    },
    pick: function(data, i2) {
      var completion = data.list[i2], self2 = this;
      this.cm.operation(function() {
        if (completion.hint)
          completion.hint(self2.cm, data, completion);
        else
          self2.cm.replaceRange(getKey(completion), completion.from || data.from, completion.to || data.to, "complete");
        CodeMirror2.signal(data, "pick", completion);
        self2.cm.scrollIntoView();
      });
      enterSwitch(this.cm, getKey(completion));
      if (this.options.closeOnPick) {
        this.close();
      }
    },
    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }
      var identStart = this.startPos;
      if (this.data) {
        identStart = this.data.from;
      }
      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < identStart.ch || this.cm.somethingSelected() || (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self2 = this;
        this.debounce = requestAnimationFrame2(function() {
          self2.update();
        });
        if (this.widget)
          this.widget.disable();
      }
    },
    update: function(first) {
      if (this.tick == null)
        return;
      var self2 = this, myTick = ++this.tick;
      fetchHints(this.options.hint, this.cm, this.options, function(data) {
        if (self2.tick == myTick)
          self2.finishUpdate(data, first);
      });
    },
    finishUpdate: function(data, first) {
      if (this.data)
        CodeMirror2.signal(this.data, "update");
      var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
      if (this.widget)
        this.widget.close();
      this.data = data;
      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror2.signal(data, "shown");
        }
      }
    }
  };
  function parseOptions(cm, pos, options2) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions)
      out[prop] = defaultOptions[prop];
    if (editor) {
      for (var prop in editor)
        if (editor[prop] !== void 0)
          out[prop] = editor[prop];
    }
    if (options2) {
      for (var prop in options2)
        if (options2[prop] !== void 0)
          out[prop] = options2[prop];
    }
    if (out.hint.resolve)
      out.hint = out.hint.resolve(cm, pos);
    return out;
  }
  function getText(completion) {
    if (typeof completion == "string")
      return completion;
    else
      return completion.text;
  }
  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {
        handle.moveFocus(-1);
      },
      Down: function() {
        handle.moveFocus(1);
      },
      PageUp: function() {
        handle.moveFocus(-handle.menuSize() + 1, true);
      },
      PageDown: function() {
        handle.moveFocus(handle.menuSize() - 1, true);
      },
      Home: function() {
        handle.setFocus(0);
      },
      End: function() {
        handle.setFocus(handle.length - 1);
      },
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var mac2 = /Mac/.test(navigator.platform);
    if (mac2) {
      baseMap["Ctrl-P"] = function() {
        handle.moveFocus(-1);
      };
      baseMap["Ctrl-N"] = function() {
        handle.moveFocus(1);
      };
    }
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key2, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) {
          return val(cm, handle);
        };
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key2] = bound;
    }
    if (custom) {
      for (var key in custom)
        if (custom.hasOwnProperty(key))
          addBinding(key, custom[key]);
    }
    var extra = completion.options.extraKeys;
    if (extra) {
      for (var key in extra)
        if (extra.hasOwnProperty(key))
          addBinding(key, extra[key]);
    }
    return ourMap;
  }
  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement)
        return el;
      el = el.parentNode;
    }
  }
  function Widget(completion, data) {
    this.id = "cm-complete-" + Math.floor(Math.random(1e6));
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;
    var ownerDocument = cm.getInputField().ownerDocument;
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;
    var hints = this.hints = ownerDocument.createElement("ul");
    hints.setAttribute("role", "listbox");
    hints.setAttribute("aria-expanded", "true");
    hints.id = this.id;
    var theme = completion.cm.options.theme;
    hints.className = "CodeMirror-hints " + theme;
    this.selectedHint = data.selectedHint || 0;
    var completions = data.list;
    for (var i2 = 0; i2 < completions.length; ++i2) {
      var elt2 = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i2];
      var className = HINT_ELEMENT_CLASS + (i2 != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null)
        className = cur.className + " " + className;
      elt2.className = className;
      if (i2 == this.selectedHint)
        elt2.setAttribute("aria-selected", "true");
      elt2.id = this.id + "-" + i2;
      elt2.setAttribute("role", "option");
      if (cur.render)
        cur.render(elt2, data, cur);
      else
        elt2.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
      elt2.hintId = i2;
    }
    var container = completion.options.container || ownerDocument.body;
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left2 = pos.left, top2 = pos.bottom, below = true;
    var offsetLeft = 0, offsetTop = 0;
    if (container !== ownerDocument.body) {
      var isContainerPositioned = ["absolute", "relative", "fixed"].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
      var offsetParent = isContainerPositioned ? container : container.offsetParent;
      var offsetParentPosition = offsetParent.getBoundingClientRect();
      var bodyPosition = ownerDocument.body.getBoundingClientRect();
      offsetLeft = offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft;
      offsetTop = offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop;
    }
    hints.style.left = left2 - offsetLeft + "px";
    hints.style.top = top2 - offsetTop + "px";
    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
    container.appendChild(hints);
    cm.getInputField().setAttribute("aria-autocomplete", "list");
    cm.getInputField().setAttribute("aria-owns", this.id);
    cm.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint);
    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();
    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;
    var startScroll;
    setTimeout(function() {
      startScroll = cm.getScrollInfo();
    });
    var overlapY = box.bottom - winH;
    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) {
        hints.style.top = (top2 = pos.top - height - offsetTop) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = winH - 5 + "px";
        hints.style.top = (top2 = pos.bottom - box.top - offsetTop) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left2 = pos.left - offsetLeft) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (scrolls)
      overlapX += cm.display.nativeBarWidth;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = winW - 5 + "px";
        overlapX -= box.right - box.left - winW;
      }
      hints.style.left = (left2 = pos.left - overlapX - offsetLeft) + "px";
    }
    if (scrolls)
      for (var node = hints.firstChild; node; node = node.nextSibling)
        node.style.paddingRight = cm.display.nativeBarWidth + "px";
    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) {
        widget.changeActive(widget.selectedHint + n, avoidWrap);
      },
      setFocus: function(n) {
        widget.changeActive(n);
      },
      menuSize: function() {
        return widget.screenAmount();
      },
      length: completions.length,
      close: function() {
        completion.close();
      },
      pick: function() {
        widget.pick();
      },
      data
    }));
    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() {
        closingOnBlur = setTimeout(function() {
          completion.close();
        }, 100);
      });
      cm.on("focus", this.onFocus = function() {
        clearTimeout(closingOnBlur);
      });
    }
    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      if (!startScroll)
        startScroll = cm.getScrollInfo();
      var newTop = top2 + startScroll.top - curScroll.top;
      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
      if (!below)
        point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom)
        return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = left2 + startScroll.left - curScroll.left + "px";
    });
    CodeMirror2.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        widget.pick();
      }
    });
    CodeMirror2.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick)
          widget.pick();
      }
    });
    CodeMirror2.on(hints, "mousedown", function() {
      setTimeout(function() {
        cm.focus();
      }, 20);
    });
    var selectedHintRange = this.getSelectedHintRange();
    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {
      this.scrollToActive();
    }
    CodeMirror2.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }
  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this)
        return;
      this.completion.widget = null;
      if (this.hints.parentNode)
        this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);
      var input2 = this.completion.cm.getInputField();
      input2.removeAttribute("aria-activedescendant");
      input2.removeAttribute("aria-owns");
      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },
    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = { Enter: function() {
        widget.picked = true;
      } };
      this.completion.cm.addKeyMap(this.keyMap);
    },
    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },
    changeActive: function(i2, avoidWrap) {
      if (i2 >= this.data.list.length)
        i2 = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i2 < 0)
        i2 = avoidWrap ? 0 : this.data.list.length - 1;
      if (this.selectedHint == i2)
        return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) {
        node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
        node.removeAttribute("aria-selected");
      }
      node = this.hints.childNodes[this.selectedHint = i2];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      node.setAttribute("aria-selected", "true");
      this.completion.cm.getInputField().setAttribute("aria-activedescendant", node.id);
      this.scrollToActive();
      CodeMirror2.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },
    scrollToActive: function() {
      var selectedHintRange = this.getSelectedHintRange();
      var node1 = this.hints.childNodes[selectedHintRange.from];
      var node2 = this.hints.childNodes[selectedHintRange.to];
      var firstNode = this.hints.firstChild;
      if (node1.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;
      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;
    },
    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    },
    getSelectedHintRange: function() {
      var margin = this.completion.options.scrollMargin || 0;
      return {
        from: Math.max(0, this.selectedHint - margin),
        to: Math.min(this.data.list.length - 1, this.selectedHint + margin)
      };
    }
  };
  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected())
      return helpers;
    var result = [];
    for (var i2 = 0; i2 < helpers.length; i2++)
      if (helpers[i2].supportsSelection)
        result.push(helpers[i2]);
    return result;
  }
  function fetchHints(hint, cm, options2, callback) {
    if (hint.async) {
      hint(cm, callback, options2);
    } else {
      var result = hint(cm, options2);
      if (result && result.then)
        result.then(callback);
      else
        callback(result);
    }
  }
  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words;
    if (helpers.length) {
      var resolved = function(cm2, callback, options2) {
        var app = applicableHelpers(cm2, helpers);
        function run(i2) {
          if (i2 == app.length)
            return callback(null);
          fetchHints(app[i2], cm2, options2, function(result) {
            if (result && result.list.length > 0)
              callback(result);
            else
              run(i2 + 1);
          });
        }
        run(0);
      };
      resolved.async = true;
      resolved.supportsSelection = true;
      return resolved;
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function(cm2) {
        return CodeMirror2.hint.fromList(cm2, { words });
      };
    } else if (CodeMirror2.hint.anyword) {
      return function(cm2, options2) {
        return CodeMirror2.hint.anyword(cm2, options2);
      };
    } else {
      return function() {
      };
    }
  }
  CodeMirror2.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });
  CodeMirror2.registerHelper("hint", "fromList", function(cm, options2) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var term, from = CodeMirror2.Pos(cur.line, token.start), to = cur;
    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start);
    } else {
      term = "";
      from = cur;
    }
    var found = [];
    for (var i2 = 0; i2 < options2.words.length; i2++) {
      var word = options2.words[i2];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }
    if (found.length)
      return { list: found, from, to };
  });
  CodeMirror2.commands.autocomplete = CodeMirror2.showHint;
  var defaultOptions = {
    hint: CodeMirror2.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnPick: true,
    closeOnUnfocus: true,
    updateOnCursorActivity: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null,
    paddingForScrollbar: true,
    moveOnOverlap: true
  };
  CodeMirror2.defineOption("hintOptions", null);
});
var _export_sfc = (sfc, props2) => {
  for (const [key, val] of props2) {
    sfc[key] = val;
  }
  return sfc;
};
const CodeMirror$2 = window.CodeMirror || CodeMirror$3;
if (typeof Object.assign != "function") {
  Object.defineProperty(Object, "assign", {
    value(target, varArgs) {
      if (target == null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      const to = Object(target);
      for (let index2 = 1; index2 < arguments.length; index2++) {
        const nextSource = arguments[index2];
        if (nextSource != null) {
          for (const nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
const _sfc_main$I = defineComponent({
  name: "AwsuiCodemirror",
  props: {
    code: String,
    modelValue: String,
    marker: Function,
    unseenLines: Array,
    name: {
      type: String,
      default: "codemirror"
    },
    placeholder: {
      type: String
    },
    merge: {
      type: Boolean,
      default: false
    },
    options: {
      type: Object,
      default: () => ({})
    },
    events: {
      type: Array,
      default: () => []
    },
    globalOptions: {
      type: Object,
      default: () => ({})
    },
    globalEvents: {
      type: Array,
      default: () => []
    }
  },
  setup(props2, context) {
    const content = ref("");
    let codemirror2 = null;
    let cminstance = null;
    let mergeview = ref(null);
    let textarea = ref(null);
    const methods = {
      getCodeMirrorInstance() {
        return cminstance;
      },
      getCodeMirror() {
        return codemirror2;
      },
      initialize() {
        const cmOptions = Object.assign({}, props2.globalOptions, props2.options);
        if (props2.merge) {
          codemirror2 = CodeMirror$2.MergeView(mergeview.value, cmOptions);
          cminstance = codemirror2.edit;
        } else {
          codemirror2 = CodeMirror$2.fromTextArea(textarea.value, cmOptions);
          cminstance = codemirror2;
          cminstance.setValue(props2.code || props2.modelValue || content.value);
          setTimeout(() => {
            cminstance.refresh();
          }, 100);
        }
        cminstance.on("change", (cm) => {
          content.value = cm.getValue();
          if (context.emit) {
            context.emit("update:modelValue", content.value);
          }
        });
        cminstance.on("keyup", (cm, event2) => {
          if (!cm.state.completionActive && (event2.keyCode >= 65 && event2.keyCode <= 90 || event2.keyCode === 50 || event2.keyCode === 8)) {
            if (CodeMirror$2.commands.autocomplete) {
              CodeMirror$2.commands.autocomplete(cm, null, { completeSingle: false });
            }
          }
        });
        const tmpEvents = {};
        [
          "scroll",
          "changes",
          "beforeChange",
          "cursorActivity",
          "keyHandled",
          "inputRead",
          "electricInput",
          "beforeSelectionChange",
          "viewportChange",
          "swapDoc",
          "gutterClick",
          "gutterContextMenu",
          "focus",
          "blur",
          "refresh",
          "optionChange",
          "scrollCursorIntoView",
          "update"
        ].concat(props2.events).concat(props2.globalEvents).filter((e) => !tmpEvents[e] && (tmpEvents[e] = true)).forEach((event2) => {
          cminstance.on(event2, (...args) => {
            context.emit(event2, ...args);
            const lowerCaseEvent = event2.replace(/([A-Z])/g, "-$1").toLowerCase();
            if (lowerCaseEvent !== event2) {
              context.emit(lowerCaseEvent, ...args);
            }
          });
        });
        context.emit("ready", codemirror2);
        methods.unseenLineMarkers();
        methods.refresh();
      },
      refresh() {
        nextTick(() => {
          cminstance.refresh();
        });
      },
      destroy() {
        const element = cminstance.doc.cm.getWrapperElement();
        element && element.remove && element.remove();
      },
      handerCodeChange(newVal) {
        const cm_value = cminstance.getValue();
        if (newVal !== cm_value) {
          const scrollInfo = cminstance.getScrollInfo();
          cminstance.setValue(newVal);
          setTimeout(() => {
            cminstance.refresh();
          }, 100);
          content.value = newVal;
          cminstance.scrollTo(scrollInfo.left, scrollInfo.top);
        }
        methods.unseenLineMarkers();
      },
      unseenLineMarkers() {
        const marker = props2.marker;
        if (props2.unseenLines !== void 0 && marker !== void 0) {
          props2.unseenLines.forEach((lineProxy) => {
            let line = lineProxy;
            const info = cminstance.lineInfo(line);
            cminstance.setGutterMarker(line, "breakpoints", info.gutterMarkers ? null : marker());
          });
        }
      },
      switchMerge() {
        const history = cminstance.doc.history;
        const cleanGeneration = cminstance.doc.cleanGeneration;
        this.options.value = cminstance.getValue();
        methods.destroy();
        methods.initialize();
        cminstance.doc.history = history;
        cminstance.doc.cleanGeneration = cleanGeneration;
      }
    };
    watch(() => {
      return props2.options;
    }, (options2) => {
      for (const key in options2) {
        cminstance.setOption(key, options2[key]);
      }
    }, {
      deep: true
    });
    watch(() => {
      return props2.merge;
    }, () => {
      nextTick(methods.switchMerge);
    });
    watch(() => {
      return props2.code;
    }, (newVal) => {
      methods.handerCodeChange(newVal);
    });
    watch(() => {
      return props2.modelValue;
    }, (newVal) => {
      methods.handerCodeChange(newVal);
    });
    onMounted(() => {
      methods.initialize();
    });
    onUnmounted(() => {
      methods.destroy();
    });
    return __spreadValues2({
      content,
      mergeview,
      textarea
    }, methods);
  }
});
const _hoisted_1$q = {
  key: 0,
  ref: "mergeview"
};
const _hoisted_2$l = ["name", "placeholder"];
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["awsui-codemirror", { merge: _ctx.merge }])
  }, [
    _ctx.merge ? (openBlock(), createElementBlock("div", _hoisted_1$q, null, 512)) : (openBlock(), createElementBlock("textarea", {
      key: 1,
      ref: "textarea",
      name: _ctx.name,
      placeholder: _ctx.placeholder
    }, null, 8, _hoisted_2$l))
  ], 2);
}
var AwsuiCodemirror = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$I]]);
AwsuiCodemirror.install = (app, config2) => {
  if (config2) {
    if (config2.options) {
      AwsuiCodemirror.props.globalOptions.default = () => config2.options;
    }
    if (config2.events) {
      AwsuiCodemirror.props.globalEvents.default = () => config2.events;
    }
  }
  app.component(AwsuiCodemirror.name, AwsuiCodemirror);
};
var axios$3 = { exports: {} };
var bind$2 = function bind2(fn2, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn2.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString = Object.prototype.toString;
function isArray$2(val) {
  return toString.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(val) {
  return toString.call(val) === "[object Date]";
}
function isFile(val) {
  return toString.call(val) === "[object File]";
}
function isBlob(val) {
  return toString.call(val) === "[object Blob]";
}
function isFunction(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.replace(/^\s*/, "").replace(/\s*$/, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach$1(obj, fn2) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$2(obj)) {
    for (var i2 = 0, l = obj.length; i2 < l; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn2.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge$1() {
  var result = {};
  function assignValue2(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge$1(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge$1({}, val);
    } else if (isArray$2(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    forEach$1(arguments[i2], assignValue2);
  }
  return result;
}
function extend$1(a, b, thisArg) {
  forEach$1(b, function assignValue2(val, key) {
    if (thisArg && typeof val === "function") {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$g = {
  isArray: isArray$2,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach: forEach$1,
  merge: merge$1,
  extend: extend$1,
  trim,
  stripBOM
};
var utils$f = utils$g;
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL2(url2, params, paramsSerializer) {
  if (!params) {
    return url2;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$f.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$f.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$f.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$f.forEach(val, function parseValue(v) {
        if (utils$f.isDate(v)) {
          v = v.toISOString();
        } else if (utils$f.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode$1(key) + "=" + encode$1(v));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
};
var utils$e = utils$g;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled,
    rejected
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn2) {
  utils$e.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn2(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$d = utils$g;
var transformData$1 = function transformData2(data, headers, fns) {
  utils$d.forEach(fns, function transform(fn2) {
    data = fn2(data, headers);
  });
  return data;
};
var isCancel$1 = function isCancel2(value2) {
  return !!(value2 && value2.__CANCEL__);
};
var utils$c = utils$g;
var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
  utils$c.forEach(headers, function processHeader(value2, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value2;
      delete headers[name2];
    }
  });
};
var enhanceError$1 = function enhanceError2(error, config2, code, request2, response) {
  error.config = config2;
  if (code) {
    error.code = code;
  }
  error.request = request2;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code
    };
  };
  return error;
};
var enhanceError = enhanceError$1;
var createError$2 = function createError2(message2, config2, code, request2, response) {
  var error = new Error(message2);
  return enhanceError(error, config2, code, request2, response);
};
var createError$1 = createError$2;
var settle$1 = function settle2(resolve, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
  }
};
var utils$b = utils$g;
var cookies$1 = utils$b.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write2(name2, value2, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value2));
      if (utils$b.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$b.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils$b.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read2(name2) {
      var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write2() {
    },
    read: function read2() {
      return null;
    },
    remove: function remove() {
    }
  };
}();
var isAbsoluteURL$1 = function isAbsoluteURL2(url2) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url2);
};
var combineURLs$1 = function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL = isAbsoluteURL$1;
var combineURLs = combineURLs$1;
var buildFullPath$1 = function buildFullPath2(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$a = utils$g;
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders$1 = function parseHeaders2(headers) {
  var parsed = {};
  var key;
  var val;
  var i2;
  if (!headers) {
    return parsed;
  }
  utils$a.forEach(headers.split("\n"), function parser2(line) {
    i2 = line.indexOf(":");
    key = utils$a.trim(line.substr(0, i2)).toLowerCase();
    val = utils$a.trim(line.substr(i2 + 1));
    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var utils$9 = utils$g;
var isURLSameOrigin$1 = utils$9.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url2) {
    var href = url2;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils$9.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
var utils$8 = utils$g;
var settle = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath = buildFullPath$1;
var parseHeaders = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError = createError$2;
var xhr = function xhrAdapter(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config2.data;
    var requestHeaders = config2.headers;
    if (utils$8.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request2 = new XMLHttpRequest();
    if (config2.auth) {
      var username = config2.auth.username || "";
      var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL$1(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    request2.onreadystatechange = function handleLoad() {
      if (!request2 || request2.readyState !== 4) {
        return;
      }
      if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders(request2.getAllResponseHeaders()) : null;
      var responseData = !config2.responseType || config2.responseType === "text" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(resolve, reject, response);
      request2 = null;
    };
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(createError("Request aborted", config2, "ECONNABORTED", request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(createError("Network Error", config2, null, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config2, "ECONNABORTED", request2));
      request2 = null;
    };
    if (utils$8.isStandardBrowserEnv()) {
      var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config2.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils$8.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request2.setRequestHeader(key, val);
        }
      });
    }
    if (!utils$8.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (config2.responseType) {
      try {
        request2.responseType = config2.responseType;
      } catch (e) {
        if (config2.responseType !== "json") {
          throw e;
        }
      }
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", config2.onDownloadProgress);
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config2.onUploadProgress);
    }
    if (config2.cancelToken) {
      config2.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request2) {
          return;
        }
        request2.abort();
        reject(cancel);
        request2 = null;
      });
    }
    if (!requestData) {
      requestData = null;
    }
    request2.send(requestData);
  });
};
var utils$7 = utils$g;
var normalizeHeaderName = normalizeHeaderName$1;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value2) {
  if (!utils$7.isUndefined(headers) && utils$7.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value2;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
var defaults$5 = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, "Accept");
    normalizeHeaderName(headers, "Content-Type");
    if (utils$7.isFormData(data) || utils$7.isArrayBuffer(data) || utils$7.isBuffer(data) || utils$7.isStream(data) || utils$7.isFile(data) || utils$7.isBlob(data)) {
      return data;
    }
    if (utils$7.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$7.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data.toString();
    }
    if (utils$7.isObject(data)) {
      setContentTypeIfUnset(headers, "application/json;charset=utf-8");
      return JSON.stringify(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    if (typeof data === "string") {
      try {
        data = JSON.parse(data);
      } catch (e) {
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults$5.headers = {
  common: {
    "Accept": "application/json, text/plain, */*"
  }
};
utils$7.forEach(["delete", "get", "head"], function forEachMethodNoData(method3) {
  defaults$5.headers[method3] = {};
});
utils$7.forEach(["post", "put", "patch"], function forEachMethodWithData(method3) {
  defaults$5.headers[method3] = utils$7.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$5;
var utils$6 = utils$g;
var transformData = transformData$1;
var isCancel = isCancel$1;
var defaults$4 = defaults_1;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
}
var dispatchRequest$1 = function dispatchRequest2(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData(config2.data, config2.headers, config2.transformRequest);
  config2.headers = utils$6.merge(config2.headers.common || {}, config2.headers[config2.method] || {}, config2.headers);
  utils$6.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method3) {
    delete config2.headers[method3];
  });
  var adapter = config2.adapter || defaults$4.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData(response.data, response.headers, config2.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config2.transformResponse);
      }
    }
    return Promise.reject(reason);
  });
};
var utils$5 = utils$g;
var mergeConfig$2 = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  var valueFromConfig2Keys = ["url", "method", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
  var defaultToConfig2Keys = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ];
  var directMergeKeys = ["validateStatus"];
  function getMergedValue(target, source2) {
    if (utils$5.isPlainObject(target) && utils$5.isPlainObject(source2)) {
      return utils$5.merge(target, source2);
    } else if (utils$5.isPlainObject(source2)) {
      return utils$5.merge({}, source2);
    } else if (utils$5.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  }
  utils$5.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    }
  });
  utils$5.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils$5.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  utils$5.forEach(directMergeKeys, function merge3(prop) {
    if (prop in config2) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils$5.forEach(otherKeys, mergeDeepProperties);
  return config3;
};
var utils$4 = utils$g;
var buildURL = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(config2) {
  if (typeof config2 === "string") {
    config2 = arguments[1] || {};
    config2.url = arguments[0];
  } else {
    config2 = config2 || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var chain = [dispatchRequest, void 0];
  var promise = Promise.resolve(config2);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });
  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method3) {
  Axios$1.prototype[method3] = function(url2, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method: method3,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData2(method3) {
  Axios$1.prototype[method3] = function(url2, data, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method: method3,
      url: url2,
      data
    }));
  };
});
var Axios_1 = Axios$1;
function Cancel$1(message2) {
  this.message = message2;
}
Cancel$1.prototype.toString = function toString2() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$1.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message2) {
    if (token.reason) {
      return;
    }
    token.reason = new Cancel(message2);
    resolvePromise(token.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return typeof payload === "object" && payload.isAxiosError === true;
};
var utils$3 = utils$g;
var bind = bind$2;
var Axios = Axios_1;
var mergeConfig = mergeConfig$2;
var defaults$3 = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);
  utils$3.extend(instance, Axios.prototype, context);
  utils$3.extend(instance, context);
  return instance;
}
var axios$2 = createInstance(defaults$3);
axios$2.Axios = Axios;
axios$2.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios$2.defaults, instanceConfig));
};
axios$2.Cancel = Cancel_1;
axios$2.CancelToken = CancelToken_1;
axios$2.isCancel = isCancel$1;
axios$2.all = function all(promises) {
  return Promise.all(promises);
};
axios$2.spread = spread;
axios$2.isAxiosError = isAxiosError;
axios$3.exports = axios$2;
axios$3.exports.default = axios$2;
var axios$1 = axios$3.exports;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$1 = Array.isArray;
var hexTable = function() {
  var array3 = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array3.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array3;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$1(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source2, options2) {
  var obj = options2 && options2.plainObjects ? Object.create(null) : {};
  for (var i2 = 0; i2 < source2.length; ++i2) {
    if (typeof source2[i2] !== "undefined") {
      obj[i2] = source2[i2];
    }
  }
  return obj;
};
var merge = function merge2(target, source2, options2) {
  if (!source2) {
    return target;
  }
  if (typeof source2 !== "object") {
    if (isArray$1(target)) {
      target.push(source2);
    } else if (target && typeof target === "object") {
      if (options2 && (options2.plainObjects || options2.allowPrototypes) || !has$2.call(Object.prototype, source2)) {
        target[source2] = true;
      }
    } else {
      return [target, source2];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source2);
  }
  var mergeTarget = target;
  if (isArray$1(target) && !isArray$1(source2)) {
    mergeTarget = arrayToObject(target, options2);
  }
  if (isArray$1(target) && isArray$1(source2)) {
    source2.forEach(function(item, i2) {
      if (has$2.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge2(targetItem, item, options2);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source2).reduce(function(acc, key) {
    var value2 = source2[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge2(acc[key], value2, options2);
    } else {
      acc[key] = value2;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source2) {
  return Object.keys(source2).reduce(function(acc, key) {
    acc[key] = source2[key];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset) {
  if (str.length === 0) {
    return str;
  }
  var string2 = typeof str === "string" ? str : String(str);
  if (charset === "iso-8859-1") {
    return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i2 = 0; i2 < string2.length; ++i2) {
    var c = string2.charCodeAt(i2);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
      out += string2.charAt(i2);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i2 += 1;
    c = 65536 + ((c & 1023) << 10 | string2.charCodeAt(i2) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value2) {
  var queue = [{ obj: { o: value2 }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue.length; ++i2) {
    var item = queue[i2];
    var obj = item.obj[item.prop];
    var keys2 = Object.keys(obj);
    for (var j = 0; j < keys2.length; ++j) {
      var key = keys2[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value2;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  merge
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var formats$2 = {
  "default": "RFC3986",
  formatters: {
    RFC1738: function(value2) {
      return replace.call(value2, percentTwenties, "+");
    },
    RFC3986: function(value2) {
      return value2;
    }
  },
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var utils$1 = utils$2;
var formats$1 = formats$2;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaults$2 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  formatter: formats$1.formatters[formats$1["default"]],
  indices: false,
  serializeDate: function serializeDate(date3) {
    return toISO.call(date3);
  },
  skipNulls: false,
  strictNullHandling: false
};
var stringify$1 = function stringify2(object3, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort2, allowDots, serializeDate2, formatter2, encodeValuesOnly, charset) {
  var obj = object3;
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray(obj)) {
    obj = obj.join(",");
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$2.encoder, charset) : prefix;
    }
    obj = "";
  }
  if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$2.encoder, charset);
      return [formatter2(keyValue) + "=" + formatter2(encoder(obj, defaults$2.encoder, charset))];
    }
    return [formatter2(prefix) + "=" + formatter2(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (isArray(filter)) {
    objKeys = filter;
  } else {
    var keys2 = Object.keys(obj);
    objKeys = sort2 ? keys2.sort(sort2) : keys2;
  }
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    if (skipNulls && obj[key] === null) {
      continue;
    }
    if (isArray(obj)) {
      pushToArray(values, stringify2(obj[key], typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort2, allowDots, serializeDate2, formatter2, encodeValuesOnly, charset));
    } else {
      pushToArray(values, stringify2(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort2, allowDots, serializeDate2, formatter2, encodeValuesOnly, charset));
    }
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$2;
  }
  if (opts.encoder !== null && opts.encoder !== void 0 && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$2.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter2 = formats$1.formatters[format2];
  var filter = defaults$2.filter;
  if (typeof opts.filter === "function" || isArray(opts.filter)) {
    filter = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$2.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$2.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$2.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$2.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$2.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$2.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$2.encodeValuesOnly,
    filter,
    formatter: formatter2,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$2.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$2.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$2.strictNullHandling
  };
};
var stringify_1 = function(object3, opts) {
  var obj = object3;
  var options2 = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options2.filter === "function") {
    filter = options2.filter;
    obj = filter("", obj);
  } else if (isArray(options2.filter)) {
    filter = options2.filter;
    objKeys = filter;
  }
  var keys2 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options2.sort) {
    objKeys.sort(options2.sort);
  }
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    if (options2.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys2, stringify$1(obj[key], key, generateArrayPrefix, options2.strictNullHandling, options2.skipNulls, options2.encode ? options2.encoder : null, options2.filter, options2.sort, options2.allowDots, options2.serializeDate, options2.formatter, options2.encodeValuesOnly, options2.charset));
  }
  var joined = keys2.join(options2.delimiter);
  var prefix = options2.addQueryPrefix === true ? "?" : "";
  if (options2.charsetSentinel) {
    if (options2.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var defaults$1 = {
  allowDots: false,
  allowPrototypes: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options2) {
  var obj = {};
  var cleanStr = options2.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options2.parameterLimit === Infinity ? void 0 : options2.parameterLimit;
  var parts = cleanStr.split(options2.delimiter, limit);
  var skipIndex = -1;
  var i2;
  var charset = options2.charset;
  if (options2.charsetSentinel) {
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (parts[i2].indexOf("utf8=") === 0) {
        if (parts[i2] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i2] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts.length;
      }
    }
  }
  for (i2 = 0; i2 < parts.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options2.decoder(part, defaults$1.decoder, charset);
      val = options2.strictNullHandling ? null : "";
    } else {
      key = options2.decoder(part.slice(0, pos), defaults$1.decoder, charset);
      val = options2.decoder(part.slice(pos + 1), defaults$1.decoder, charset);
    }
    if (val && options2.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (val && options2.comma && val.indexOf(",") > -1) {
      val = val.split(",");
    }
    if (has.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options2) {
  var leaf = val;
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root2 = chain[i2];
    if (root2 === "[]" && options2.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options2.plainObjects ? Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var index2 = parseInt(cleanRoot, 10);
      if (!options2.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options2.parseArrays && index2 <= options2.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options2) {
  if (!givenKey) {
    return;
  }
  var key = options2.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = brackets2.exec(key);
  var parent2 = segment ? key.slice(0, segment.index) : key;
  var keys2 = [];
  if (parent2) {
    if (!options2.plainObjects && has.call(Object.prototype, parent2)) {
      if (!options2.allowPrototypes) {
        return;
      }
    }
    keys2.push(parent2);
  }
  var i2 = 0;
  while ((segment = child.exec(key)) !== null && i2 < options2.depth) {
    i2 += 1;
    if (!options2.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options2.allowPrototypes) {
        return;
      }
    }
    keys2.push(segment[1]);
  }
  if (segment) {
    keys2.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys2, val, options2);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults$1.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$1.allowPrototypes,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$1.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults$1.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$1.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
    depth: typeof opts.depth === "number" ? opts.depth : defaults$1.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$1.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$1.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var parse$1 = function(str, opts) {
  var options2 = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options2.plainObjects ? Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options2) : str;
  var obj = options2.plainObjects ? Object.create(null) : {};
  var keys2 = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys2.length; ++i2) {
    var key = keys2[i2];
    var newObj = parseKeys(key, tempObj[key], options2);
    obj = utils.merge(obj, newObj, options2);
  }
  return utils.compact(obj);
};
var stringify = stringify_1;
var parse = parse$1;
var formats = formats$2;
var lib = {
  formats,
  parse,
  stringify
};
let AWSPageContextObject = {};
const getDesc = (data) => {
  if (data) {
    if (data.desc) {
      return data.desc;
    } else if (data.data) {
      return data.data.desc ? data.data.desc : "";
    }
  }
  return "";
};
const config = (AWSPageContext2) => {
  AWSPageContextObject = AWSPageContext2;
  axios$1.defaults.baseURL = AWSPageContext2.axiosBaseUrl == null ? "./" : AWSPageContext2.axiosBaseUrl;
  axios$1.defaults.headers = {
    "Content-Type": "application/x-www-form-urlencoded; charset=utf-8"
  };
  axios$1.interceptors.request.use((config2) => {
    if (config2.method === "get") {
      config2.paramsSerializer = function(params) {
        return lib.stringify(params, { arrayFormat: "repeat" });
      };
    } else if (config2.method === "post") {
      config2.params = {};
    }
    return config2;
  }, function(error) {
    if (error.response == null) {
      throw error;
    }
    const data = error.response.data;
    if (data.msg != void 0 && data.msg != null && data.msg.indexOf("\u7528\u6237\u4F1A\u8BDD\u5DF2\u5931\u6548") > -1) {
      ElMessage({
        type: "warning",
        message: data.desc ? data.desc : data.msg,
        duration: 2e3,
        onClose: () => {
          setTimeout(function() {
            const topHomePageId = top.homePageId;
            if (topHomePageId == void 0) {
              top.window.location.href = "../";
            } else {
              top.window.location.href = "../console";
            }
          }, 2e3);
        }
      });
    } else if (data.msg != void 0 && data.msg != null && data.msg.indexOf("\u6A21\u578B\u53D7\u7BA1\uFF0C\u64CD\u4F5C\u88AB\u62D2\u7EDD") > -1) {
      ElMessage({
        type: "error",
        message: data.desc ? data.desc : data.msg,
        onClose: function() {
          window.location.reload();
        }
      });
    } else {
      const desc = getDesc(data);
      ElMessage({
        type: "error",
        dangerouslyUseHTMLString: true,
        message: data.msg + (desc != "" && desc != null ? "<div style='margin-top:5px'>" + desc.split("\n")[0] + "</div>" : ""),
        onClose: function() {
          window.location.reload();
        }
      });
    }
    return Promise.reject(error);
  });
  axios$1.interceptors.response.use(function(response) {
    if (response.config.alert !== false) {
      if (response.data.result == "error" || response.data.result == "warning") {
        const data = response.data;
        const desc = getDesc(data);
        const par = {
          dangerouslyUseHTMLString: true,
          type: response.data.result,
          showClose: response.data.result == "error",
          duration: response.data.result == "error" ? 0 : 2e3,
          message: data.msg + (desc != "" && desc != null ? "<div style='margin-top:5px'>" + desc.split("\n")[0] + "</div>" : "")
        };
        if (response.data.msg.indexOf("\u6A21\u578B\u53D7\u7BA1\uFF0C\u64CD\u4F5C\u88AB\u62D2\u7EDD") > -1) {
          par["onClose"] = () => {
            window.location.reload();
          };
        }
        ElMessage(par);
      }
    }
    return response.data;
  }, function(error) {
    if (error.response == null) {
      throw error;
    }
    const data = error.response.data;
    if (error.response.status == 500) {
      ElMessage({
        type: "error",
        message: "\u672A\u80FD\u8FDE\u63A5\u5230\u670D\u52A1\u5668",
        onClose: function() {
          window.location.reload();
        }
      });
      return;
    }
    if (data.msg != void 0 && data.msg != null && data.msg.indexOf("\u7528\u6237\u4F1A\u8BDD\u5DF2\u5931\u6548") > -1) {
      ElMessage({
        type: "warning",
        message: data.desc ? data.desc : data.msg,
        duration: 1e3,
        onClose: () => {
          setTimeout(function() {
            const topHomePageId = top.homePageId;
            if (topHomePageId == void 0) {
              top.window.location.href = "../";
            } else {
              top.window.location.href = "../console";
            }
          }, 2e3);
        }
      });
    } else if (data.msg != void 0 && data.msg != null && data.msg.indexOf("\u6A21\u578B\u53D7\u7BA1\uFF0C\u64CD\u4F5C\u88AB\u62D2\u7EDD") > -1) {
      ElMessage({
        type: "error",
        message: data.desc ? data.desc : data.msg,
        onClose: function() {
          window.location.reload();
        }
      });
    } else {
      const desc = getDesc(data);
      ElMessage({
        type: "error",
        dangerouslyUseHTMLString: true,
        message: data.msg + (desc != "" && desc != null ? "<div style='margin-top:5px'>" + desc.split("\n")[0] + "</div>" : ""),
        onClose: function() {
          window.location.reload();
        }
      });
    }
    return Promise.reject(error);
  });
};
function checkCMD(params) {
  const cmd = params.data.cmd;
  if (cmd === "CLIENT_USER_LOGIN" || cmd === "CONSOLE_ADMIN_LOGIN" || cmd === "CLIENT_MOBILE_USER_LOGIN" || cmd === "COE_USER_LOGIN" || cmd === "com.actionsoft.apps.coe.pal_user_login") {
    return;
  } else {
    if (typeof params.data.sid === "undefined") {
      const projectSetting = AWSPageContextObject.settingParam;
      params.data.sid = projectSetting.sessionId;
    }
  }
}
var axios = {
  config,
  get(params) {
    checkCMD(params);
  },
  post(params) {
    checkCMD(params);
    return axios$1.post(params.url, lib.stringify(params.data, { arrayFormat: "repeat" }));
  },
  aslp(params) {
    const data = {
      cmd: "API_CALL_ASLP",
      sourceAppId: "",
      aslp: ""
    };
    if (typeof params.data.sid !== "undefined") {
      data.authentication = params.data.sid;
    }
    Object.assign(data, params.data);
    return axios$1.post(params.url, lib.stringify(params.data, { arrayFormat: "repeat" }));
  }
};
var getSid = {
  async exec(app) {
    const { settingParam: setting, devUserInfo: devUserData } = app.config.globalProperties.AWSPageContext;
    if (setting == null) {
      console.log("\u65E0settingParam\u53C2\u6570\uFF0C\u65E0\u6CD5\u5B58\u50A8sid");
      return;
    }
    return axios.post({
      url: "jd",
      data: {
        userid: devUserData.userid,
        pwd: devUserData.pwd,
        lang: "cn",
        cmd: "CONSOLE_ADMIN_LOGIN",
        vueDeviceType: "pc"
      }
    }).then((r) => {
      if (r.result != "error") {
        setting.sessionId = r.data.sid;
      }
    });
  }
};
var rngBrowser = { exports: {} };
var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
if (getRandomValues) {
  var rnds8 = new Uint8Array(16);
  rngBrowser.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  var rnds = new Array(16);
  rngBrowser.exports = function mathRNG() {
    for (var i2 = 0, r; i2 < 16; i2++) {
      if ((i2 & 3) === 0)
        r = Math.random() * 4294967296;
      rnds[i2] = r >>> ((i2 & 3) << 3) & 255;
    }
    return rnds;
  };
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 256).toString(16).substr(1);
}
function bytesToUuid$1(buf, offset2) {
  var i2 = offset2 || 0;
  var bth = byteToHex;
  return [
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]]
  ].join("");
}
var bytesToUuid_1 = bytesToUuid$1;
var rng = rngBrowser.exports;
var bytesToUuid = bytesToUuid_1;
function v4(options2, buf, offset2) {
  var i2 = buf && offset2 || 0;
  if (typeof options2 == "string") {
    buf = options2 === "binary" ? new Array(16) : null;
    options2 = null;
  }
  options2 = options2 || {};
  var rnds2 = options2.random || (options2.rng || rng)();
  rnds2[6] = rnds2[6] & 15 | 64;
  rnds2[8] = rnds2[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i2 + ii] = rnds2[ii];
    }
  }
  return buf || bytesToUuid(rnds2);
}
var v4_1 = v4;
const countIndexMap = { defCount: 0 };
const tools = {
  getConstByName(name, defaultValue) {
    let value;
    try {
      value = eval(name);
    } catch (e) {
      value = defaultValue;
    }
    return value;
  },
  uuid() {
    return "obj_" + v4_1().replace(/-/g, "");
  },
  getCountIndex(type2) {
    if (type2 == null) {
      return countIndexMap.defCount++;
    } else {
      if (countIndexMap[type2] == null) {
        countIndexMap[type2] = 0;
      } else {
        return countIndexMap[type2]++;
      }
    }
    return -1;
  },
  isNotNull(str) {
    return str !== void 0 && str != null && str.length > 0;
  },
  isNull(str) {
    return !this.isNotNull(str);
  },
  isNotNullObject(obj) {
    return obj !== void 0 && Object.keys(obj).length > 0;
  },
  queryObjectInArrayIndex(arr, objKey, filed) {
    for (const [index2, arrElement] of arr.entries()) {
      if (arrElement[objKey] === filed) {
        return index2;
      } else {
        return -1;
      }
    }
    return -1;
  },
  getOffset: (elem) => {
    const isWindow = function(obj) {
      return obj != null && obj == obj.window;
    };
    const getWindow2 = (elem2) => {
      return isWindow(elem2) ? elem2 : elem2.nodeType === 9 ? elem2.defaultView || elem2.parentWindow : false;
    };
    let box = { top: 0, left: 0 };
    const doc = elem && elem.ownerDocument;
    const docElem = doc.documentElement;
    if (typeof elem.getBoundingClientRect !== "undefined") {
      box = elem.getBoundingClientRect();
    }
    const win = getWindow2(doc);
    return {
      top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
      left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
      height: elem.offsetHeight,
      width: elem.offsetWidth
    };
  },
  addCls: (toDom, cls) => {
    if (toDom != null) {
      if (toDom.className.length == 0) {
        toDom.className = cls;
        return;
      }
      const clsSet = new Set(toDom.className.split(" "));
      clsSet.add(cls);
      const clsArray = [];
      clsSet.forEach((val) => {
        clsArray.push(val);
      });
      toDom.className = clsArray.join(" ");
    }
  },
  removeCls: (toDom, cls) => {
    if (toDom != null) {
      toDom.className = toDom.className.replace(" " + cls, "").replace(cls, "");
    }
  },
  _buildIndex(baseId, ...args) {
    let id2 = baseId;
    if (args != null) {
      for (const a of args) {
        if (a != "") {
          id2 += a == -1 ? "" : "~" + a;
        }
      }
    }
    return id2;
  },
  formatDate(date3, fmt) {
    const padLeftZero = function(str) {
      return ("00" + str).substr(str.length);
    };
    if (/(y+)/.test(fmt)) {
      fmt = fmt.replace(RegExp.$1, (date3.getFullYear() + "").substr(4 - RegExp.$1.length));
    }
    const o = {
      "M+": date3.getMonth() + 1,
      "d+": date3.getDate(),
      "H+": date3.getHours(),
      "m+": date3.getMinutes(),
      "s+": date3.getSeconds()
    };
    for (const k in o) {
      if (new RegExp(`(${k})`).test(fmt)) {
        const str = o[k] + "";
        fmt = fmt.replace(RegExp.$1, RegExp.$1.length === 1 ? str : padLeftZero(str));
      }
    }
    return fmt;
  },
  generMenuId(item, baseId, i2) {
    i2 = i2 == null ? -1 : i2;
    baseId = this._buildIndex(baseId, i2);
    item.id = baseId;
    if (item.children) {
      let m = 1;
      for (const k of item.children) {
        this.generMenuId(k, baseId, m);
        m++;
      }
    }
  },
  getBrowser() {
    const ua = window.navigator.userAgent.toLowerCase();
    const isOpera = ua.indexOf("msie 6") > -1, isSafari = ua.indexOf("safari") > -1 && ua.indexOf("chrome") == -1, isIE2 = "ActiveXObject" in window, isStrict = document.compatMode == "CSS1Compat";
    return {
      isStrict,
      isOpera,
      isSafari,
      isIE: "ActiveXObject" in window,
      isIE6: !isOpera && ua.indexOf("msie 6") > -1,
      isIE7: !isOpera && ua.indexOf("msie 7") > -1,
      isIE8: !isOpera && ua.indexOf("msie 8") > -1,
      isIE9: !isOpera && ua.indexOf("msie 9") > -1,
      isIE10: !isOpera && ua.indexOf("msie 10") > -1,
      isIE11: /trident\/7\./.test(ua) && ua.indexOf("rv:11") > -1,
      isGecko: !isSafari && ua.indexOf("gecko") > -1,
      isFirefox: !isSafari && ua.indexOf("gecko") > -1 && ua.indexOf("firefox") > -1,
      isChrome: ua.indexOf("chrome") !== -1,
      isBorderBox: isIE2 && !isStrict,
      isWindows: ua.indexOf("windows") != -1 || ua.indexOf("win32") != -1,
      isMac: ua.indexOf("macintosh") != -1 || ua.indexOf("mac os x") != -1,
      isAir: ua.indexOf("adobeair") != -1,
      isLinux: ua.indexOf("linux") != -1,
      isSecure: window.location.href.toLowerCase().indexOf("https") === 0,
      isIPhone: ua.match(/(iphone\sos)\s([\d_]+)/) != null || ua.match(/(ipad).*os\s([\d_]+)/) != null,
      isIPhoneX: /iphone/gi.test(window.navigator.userAgent) && window.screen.height >= 812,
      isIPad: ua.match(/(ipad).*os\s([\d_]+)/) != null,
      isAWSMobilePortalApp: ua.indexOf("awsmobileportal") > 0,
      isAndroid: ua.indexOf("android") > 0,
      isDingtalk: ua.indexOf("alibaba") > 0 || ua.indexOf("dingtalk") > 0 && ua.indexOf("mobile") > 0,
      isWechat: ua.indexOf("micromessenger") > 0 && ua.indexOf("wxwork") == -1,
      isWxWork: ua.indexOf("micromessenger") > 0 && ua.indexOf("wxwork") > 0,
      isFeishu: ua.indexOf("lark") > 0,
      isWeLink: ua.indexOf("welink") > 0 || ua.indexOf("huawei") > 0,
      isMobile: !!ua.match(/(iphone|ipod|android|ios)/i)
    };
  }
};
var tools$1 = {
  tools,
  install(app) {
    app.config.globalProperties.awsuiTools = tools;
    app.config.globalProperties.browser = tools.getBrowser();
  }
};
const _sfc_main$H = defineComponent({
  name: "AwsuiSelect",
  components: {
    "el-select": ElSelect,
    "el-option": ElOption$2,
    "el-option-group": ElOptionGroup
  },
  inject: {
    awsuiForm: {
      default: ""
    }
  },
  data() {
    return {
      list: [],
      label: this.$attrs.placeholder || "\u8BF7\u9009\u62E9",
      changeColor: false,
      isFiterable: this.custom && this.filterable ? true : false,
      selected: this.multiple ? [] : {},
      changeHeight: false,
      width: 0
    };
  },
  emits: ["update:modelValue", "remove-tag", "clear", "change", "input"],
  props: {
    modelValue: {},
    group: {
      type: Boolean,
      default: false
    },
    className: String,
    size: {
      type: String,
      default: ""
    },
    loading: {
      type: Boolean,
      default: false
    },
    loadingText: {
      type: String,
      default: "\u52A0\u8F7D\u4E2D"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    clearable: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    custom: {
      type: Boolean,
      default: false
    },
    filterable: {
      type: Boolean,
      default: false
    },
    remote: {
      type: Boolean,
      default: false
    },
    remoteMethod: {
      type: Function,
      default: function() {
        console.log("\u9ED8\u8BA4");
      }
    },
    allowCreate: {
      type: Boolean,
      default: false
    },
    defaultFirstOption: {
      type: Boolean,
      default: false
    },
    popperAppendToBody: {
      type: Boolean,
      default: true
    },
    searchList: {
      default: () => {
        return [];
      },
      type: Array
    }
  },
  computed: {
    selectValue: {
      get() {
        return this.modelValue;
      },
      set(val) {
        this.$emit("update:modelValue", val);
      }
    },
    setLabel: function setLabel() {
      this.initLabel();
      return this.label;
    },
    selectDisabled() {
      return this.disabled || (this.awsuiForm || {}).disabled;
    },
    options() {
      return this.$attrs.options;
    },
    selectSize() {
      return this.size;
    },
    placeholder() {
      return this.$attrs.placeholder || "\u8BF7\u9009\u62E9";
    }
  },
  mounted() {
    let _this = this;
    _this.initLabel();
    this.$nextTick(() => {
      setTimeout(() => {
        if (this.$refs.awsuiSelectRef) {
          if (this.$refs.awsuiSelectRef.$el.getElementsByClassName("el-input__inner")[0] !== void 0) {
            let inputInner = this.$refs.awsuiSelectRef.$el.getElementsByClassName("el-input__inner")[0];
            if (!this.filterable && inputInner.getAttribute("readonly")) {
              inputInner.setAttribute("unselectable", "no");
            }
          }
        }
      }, 100);
      _this.setSelectHeight();
    });
    window.addEventListener("resize", function() {
      _this.setSelectHeight();
      _this.setWidth();
    });
  },
  methods: {
    initLabel() {
      let _that = this;
      if (_that.custom) {
        if (_that.options.length > 0) {
          this.options.forEach((item) => {
            if (item.options !== void 0 && item.options.length > 0) {
              item.options.forEach((el) => {
                console.log(_that);
                if (el.value === _that.selectValue) {
                  if (el.label !== void 0) {
                    this.getItem(el);
                  }
                }
              });
            } else {
              if (item.value === _that.selectValue) {
                if (item.label !== void 0) {
                  _that.getItem(item);
                }
              }
            }
          });
        }
      }
    },
    delHtmlTag(str) {
      let result = "";
      if (str.indexOf('<span class="awsui-select-right">') !== -1) {
        result = str.split('<span class="awsui-select-right">')[0];
      } else if (str.indexOf("<span class='awsui-select-right'>") !== -1) {
        result = str.split("<span class='awsui-select-right'>")[0];
      } else {
        result = str;
      }
      result = result.replace(/<[^>]+>/g, "").replace(/&#[^;]+;/g, "").replace(/[^\u4e00-\u9fa5a-zA-Z0-9\w]/g, "").trim();
      return result;
    },
    con(label) {
      var reg = /[\u4e00-\u9fa5]/g;
      label = label.match(reg);
      return label.join("");
    },
    switchTab() {
      if (this.custom && this.filterable) {
        this.isFiterable = true;
      }
      this.$refs["awsuiSelectRef"].$el.click();
    },
    change(val) {
      this.setWidth();
      this.$emit("update:modelValue", val);
      this.$emit("change", val);
      this.$refs.awsuiSelectRef.query = "";
      this.$forceUpdate();
    },
    handleClick() {
      this.setWidth();
    },
    handleClearClick() {
      this.deleteSelected();
    },
    deleteSelected() {
      const value2 = this.multiple ? [] : "";
      this.label = "";
      if (this.label === "") {
        this.isFiterable = true;
      }
      this.change(value2);
      this.$emit("clear");
    },
    deleteTag(val) {
      this.$emit("remove-tag", val);
      this.setSelectHeight();
    },
    getItem(item) {
      let _that = this;
      _that.label = item.label;
      _that.changeColor = true;
      if (_that.custom) {
        if (_that.filterable) {
          _that.isFiterable = false;
        }
        if (item.type !== void 0) {
          if (item.label.includes("awsui-select-right")) {
            let reg = new RegExp("awsui-select-right", "g");
            _that.label = item.label.replace(reg, item.type);
          }
        }
      }
      if (_that.multiple) {
        _that.deleteTag(item.value);
      }
    },
    setSelectHeight() {
      this.$nextTick(() => {
        setTimeout(() => {
          if (this.$refs.awsuiSelectRef) {
            if (this.$refs.awsuiSelectRef.$el !== null) {
              if (this.$refs.awsuiSelectRef.$el.getElementsByClassName("el-select__tags")[0] !== void 0) {
                let height = parseInt(this.$refs.awsuiSelectRef.$el.getElementsByClassName("el-select__tags")[0].clientHeight);
                if (this.$refs.awsuiSelectRef.$el.getElementsByClassName("el-input__inner")[0] !== void 0) {
                  let inputInner = this.$refs.awsuiSelectRef.$el.getElementsByClassName("el-input__inner")[0];
                  if (height > 40) {
                    this.changeHeight = false;
                    inputInner.style.height = height + "px!important";
                  } else {
                    this.changeHeight = true;
                    inputInner.style.height = "28px!important";
                  }
                }
              }
            }
          }
        }, 0);
      });
    },
    setWidth() {
      this.$nextTick(() => {
        setTimeout(() => {
          if (this.$refs.awsuiSelectRef) {
            this.width = this.$refs.awsuiSelectRef.$el.clientWidth;
          }
        }, 0);
      });
    }
  },
  watch: {
    width(val) {
      if (!this.timer) {
        this.width = val;
        this.timer = true;
        let that = this;
        setTimeout(function() {
          console.log(that.width);
          that.timer = false;
        }, 100);
      }
    }
  }
});
const _hoisted_1$p = { class: "awsui-box-component" };
const _hoisted_2$k = ["innerHTML"];
const _hoisted_3$k = ["innerHTML"];
const _hoisted_4$f = ["innerHTML"];
const _hoisted_5$c = ["innerHTML"];
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = resolveComponent("el-option");
  const _component_el_option_group = resolveComponent("el-option-group");
  const _component_el_select = resolveComponent("el-select");
  return openBlock(), createElementBlock("div", _hoisted_1$p, [
    _ctx.custom ? (openBlock(), createElementBlock("span", {
      key: 0,
      ref: "span",
      class: "awsui-select-label",
      style: normalizeStyle({ "color": _ctx.changeColor ? "#666" : "#c0c4cc", "display": _ctx.isFiterable || _ctx.multiple ? "none" : "" }),
      innerHTML: _ctx.setLabel,
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.switchTab && _ctx.switchTab(...args))
    }, null, 12, _hoisted_2$k)) : createCommentVNode("v-if", true),
    createVNode(_component_el_select, mergeProps({
      ref: "awsuiSelectRef",
      "value-key": "value",
      modelValue: _ctx.selectValue,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.selectValue = $event)
    }, _ctx.$attrs, {
      placeholder: _ctx.placeholder,
      class: [
        "awsui-select",
        _ctx.selectSize ? "awsui-select--" + _ctx.selectSize : "",
        _ctx.className ? _ctx.className : "",
        _ctx.changeHeight ? "awsui-select-multiple" : ""
      ],
      "reserve-keyword": "",
      disabled: _ctx.selectDisabled,
      clearable: _ctx.clearable,
      multiple: _ctx.multiple,
      filterable: _ctx.filterable,
      remote: _ctx.remote,
      "allow-create": _ctx.allowCreate,
      "default-first-option": _ctx.defaultFirstOption,
      "popper-append-to-body": _ctx.popperAppendToBody,
      "remote-method": _ctx.remoteMethod,
      loading: _ctx.loading,
      "loading-text": _ctx.loadingText,
      style: { "width": "100%" },
      onClick: _ctx.handleClick,
      onFocus: _ctx.setWidth,
      onChange: _ctx.change,
      onClear: _ctx.handleClearClick,
      onRemoveTag: _ctx.deleteTag
    }), {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (item) => {
          return openBlock(), createElementBlock(Fragment, {
            key: item.value || item.label
          }, [
            item.options != null ? (openBlock(), createBlock(_component_el_option_group, {
              key: 0,
              label: _ctx.custom ? "" : item.label
            }, {
              default: withCtx(() => [
                _ctx.custom ? (openBlock(), createElementBlock("li", {
                  key: 0,
                  class: "el-select-group__title",
                  style: normalizeStyle({ "margin-top": _ctx.custom ? "-5px" : "0px" }),
                  innerHTML: item.label
                }, null, 12, _hoisted_3$k)) : createCommentVNode("v-if", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(item.options, (child) => {
                  return openBlock(), createBlock(_component_el_option, {
                    key: child.value,
                    label: _ctx.custom ? _ctx.delHtmlTag(child.label) : child.label,
                    value: child.value,
                    disabled: child.disabled,
                    onClick: ($event) => _ctx.getItem(child),
                    onKeyup: withKeys(($event) => _ctx.getItem(child), ["enter"]),
                    style: normalizeStyle({ "width": _ctx.width + "px" })
                  }, {
                    default: withCtx(() => [
                      _ctx.custom ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: "awsui-select-option-item-label awsui-ellipsis",
                        innerHTML: child.label
                      }, null, 8, _hoisted_4$f)) : createCommentVNode("v-if", true)
                    ]),
                    _: 2
                  }, 1032, ["label", "value", "disabled", "onClick", "onKeyup", "style"]);
                }), 128))
              ]),
              _: 2
            }, 1032, ["label"])) : (openBlock(), createBlock(_component_el_option, {
              key: 1,
              label: _ctx.custom ? _ctx.delHtmlTag(item.label) : item.label,
              value: item.value,
              disabled: item.disabled,
              onClick: ($event) => _ctx.getItem(item),
              style: normalizeStyle({ "width": _ctx.width + "px" })
            }, {
              default: withCtx(() => [
                _ctx.custom ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "awsui-select-option-item-label awsui-ellipsis",
                  innerHTML: item.label
                }, null, 8, _hoisted_5$c)) : createCommentVNode("v-if", true)
              ]),
              _: 2
            }, 1032, ["label", "value", "disabled", "onClick", "style"]))
          ], 64);
        }), 128))
      ]),
      _: 1
    }, 16, ["modelValue", "placeholder", "class", "disabled", "clearable", "multiple", "filterable", "remote", "allow-create", "default-first-option", "popper-append-to-body", "remote-method", "loading", "loading-text", "onClick", "onFocus", "onChange", "onClear", "onRemoveTag"])
  ]);
}
var AwsuiSelect$1 = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$H]]);
const _sfc_main$G = defineComponent({
  name: "HelloWorld",
  props: {
    msg: String
  },
  data: () => {
    return {
      code: "\u8FD9\u662F\u4E00\u4E2Acode",
      sqlOptions: {
        mode: "text/x-mariadb",
        styleActiveLine: true,
        autofocus: true,
        smartIndent: true,
        lineNumbers: true,
        theme: "dracula",
        lineWrapping: true,
        matchBrackets: true,
        extraKeys: { "Ctrl": "autocomplete" },
        hintOptions: {
          tables: {
            users: ["name", "score", "birthDate"],
            countries: ["name", "population", "size"]
          }
        }
      },
      options: [
        {
          value: "\u9009\u98791",
          label: "\u9EC4\u91D1\u7CD5"
        },
        {
          value: "\u9009\u98792",
          label: "\u53CC\u76AE\u5976"
        },
        {
          value: "\u9009\u98793",
          label: "\u86B5\u4ED4\u714E"
        },
        {
          value: "\u9009\u98794",
          label: "\u9F99\u987B\u9762"
        },
        {
          value: "\u9009\u98795",
          label: "\u5317\u4EAC\u70E4\u9E2D"
        }
      ],
      value: "\u9009\u98792"
    };
  },
  components: { AwsuiSelect: AwsuiSelect$1, [AwsuiCodemirror.name]: AwsuiCodemirror },
  methods: {
    onCmCodeChangeWhereSql(newCode) {
      console.log(newCode);
    },
    clickText() {
      alert(this.msg);
      alert(this.userid);
    }
  },
  computed: {
    userid() {
      return devUserInfo.userid;
    },
    sessionID() {
      return settingParam.sessionId;
    }
  }
});
const _withScopeId$8 = (n) => (pushScopeId("data-v-c15aa334"), n = n(), popScopeId(), n);
const _hoisted_1$o = { class: "hello" };
const _hoisted_2$j = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_3$j = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_4$e = { style: { "width": "300px" } };
const _hoisted_5$b = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_select = resolveComponent("awsui-select");
  const _component_awsui_codemirror = resolveComponent("awsui-codemirror");
  return openBlock(), createElementBlock("div", _hoisted_1$o, [
    createElementVNode("h1", null, toDisplayString(_ctx.msg), 1),
    createElementVNode("p", null, [
      createElementVNode("span", {
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickText && _ctx.clickText(...args))
      }, "\u57FA\u4E8Evue3.0+typescript\u6A21\u677Ftest"),
      _hoisted_2$j,
      createTextVNode(" \u7528\u6237\u540D\uFF1A" + toDisplayString(_ctx.userid) + " ", 1),
      _hoisted_3$j,
      createTextVNode(" sessionID\uFF1A" + toDisplayString(_ctx.sessionID), 1)
    ]),
    createElementVNode("div", _hoisted_4$e, [
      createVNode(_component_awsui_select, {
        modelValue: _ctx.value,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.value = $event),
        options: _ctx.options
      }, null, 8, ["modelValue", "options"])
    ]),
    _hoisted_5$b,
    createElementVNode("div", null, [
      createVNode(_component_awsui_codemirror, {
        ref: "cmEditorWhereSql",
        modelValue: _ctx.code,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.code = $event),
        placeholder: "\u4F8B\u5982\uFF1ACREATEUSER = '@uid'",
        options: _ctx.sqlOptions,
        onInput: _ctx.onCmCodeChangeWhereSql
      }, null, 8, ["modelValue", "options", "onInput"])
    ])
  ]);
}
var HelloWorld = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$G], ["__scopeId", "data-v-c15aa334"]]);
AwsuiSelect$1.install = (app) => {
  app.component(AwsuiSelect$1.name, AwsuiSelect$1);
};
const _sfc_main$F = defineComponent({
  name: "AwsuiCascader",
  components: {
    "el-cascader": ElCascader,
    "el-cascader-panel": ElCascaderPanel
  },
  props: {
    modelValue: [Number, String, Array],
    options: {
      type: Array,
      default: () => {
        return [];
      }
    },
    placeholder: String,
    event: String,
    size: String,
    disabled: {
      type: Boolean,
      default: false
    },
    clearable: {
      type: Boolean,
      default: false
    },
    showAllLevels: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean,
      default: false
    },
    collapseTags: {
      type: Boolean,
      default: false
    },
    checkStrictly: {
      type: Boolean,
      default: false
    },
    lazy: {
      type: Boolean,
      default: false
    },
    lazyLoad: Function,
    filterable: {
      type: Boolean,
      default: false
    },
    panel: {
      type: Boolean,
      default: false
    },
    filterMethod: Function
  },
  setup(props2, context) {
    return {
      cascaderSize: computed(() => {
        return props2.size;
      }),
      isDisabled: computed(() => {
        const awsuiForm = inject("awsuiForm", {});
        return props2.disabled || awsuiForm.disabled;
      }),
      handleChange(value2) {
        context.emit("change", value2);
      },
      currentValue: computed({
        get: () => {
          return props2.modelValue;
        },
        set: (val) => {
          context.emit("update:modelValue", val);
        }
      })
    };
  }
});
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_panel = resolveComponent("el-cascader-panel");
  const _component_el_cascader = resolveComponent("el-cascader");
  return openBlock(), createElementBlock("div", null, [
    _ctx.panel ? (openBlock(), createBlock(_component_el_cascader_panel, {
      key: 0,
      modelValue: _ctx.currentValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.currentValue = $event),
      options: _ctx.options,
      props: {
        expandTrigger: _ctx.event === "click" ? "click" : "hover",
        multiple: _ctx.multiple,
        checkStrictly: _ctx.checkStrictly,
        lazy: _ctx.lazy,
        lazyLoad: _ctx.lazyLoad
      },
      onChange: _ctx.handleChange
    }, null, 8, ["modelValue", "options", "props", "onChange"])) : (openBlock(), createBlock(_component_el_cascader, {
      key: 1,
      class: normalizeClass(["awsui-cascader", [
        _ctx.cascaderSize ? "awsui-cascader--" + _ctx.cascaderSize : "",
        _ctx.multiple ? "awsui-cascader--multiple" : ""
      ]]),
      modelValue: _ctx.currentValue,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.currentValue = $event),
      placeholder: _ctx.placeholder,
      options: _ctx.options,
      props: {
        expandTrigger: _ctx.event === "click" ? "click" : "hover",
        multiple: _ctx.multiple,
        checkStrictly: _ctx.checkStrictly,
        lazy: _ctx.lazy,
        lazyLoad: _ctx.lazyLoad
      },
      clearable: _ctx.clearable,
      disabled: _ctx.isDisabled,
      "show-all-levels": _ctx.showAllLevels ? true : false,
      "collapse-tags": _ctx.collapseTags,
      filterable: _ctx.filterable,
      filterMethod: _ctx.filterMethod,
      onChange: _ctx.handleChange
    }, null, 8, ["class", "modelValue", "placeholder", "options", "props", "clearable", "disabled", "show-all-levels", "collapse-tags", "filterable", "filterMethod", "onChange"]))
  ]);
}
var AwsuiCascader = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$F]]);
AwsuiCascader.install = (app) => {
  app.component(AwsuiCascader.name, AwsuiCascader);
};
const _sfc_main$E = defineComponent({
  name: "AwsuiInput",
  data: () => {
    return {};
  }
});
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  return openBlock(), createBlock(_component_el_input, mergeProps(_ctx.$attrs, { class: "awsui-input" }), createSlots({ _: 2 }, [
    renderList(_ctx.$slots, (index2, name2) => {
      return {
        name: name2,
        fn: withCtx(() => [
          renderSlot(_ctx.$slots, name2)
        ])
      };
    })
  ]), 1040);
}
var input = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$E]]);
input.install = (app) => {
  app.component(input.name, input);
};
const _sfc_main$D = defineComponent({
  name: "AwsuiButton",
  inject: {
    awsuiForm: {
      default: ""
    }
  },
  props: {
    type: {
      type: String,
      default: "default"
    },
    size: String,
    icon: {
      type: String,
      default: ""
    },
    nativeType: {
      type: String,
      default: "button"
    },
    loading: Boolean,
    disabled: Boolean,
    plain: Boolean,
    autofocus: Boolean,
    round: Boolean,
    circle: Boolean,
    square: Boolean
  },
  computed: {
    buttonSize() {
      return this.size;
    },
    buttonDisabled() {
      return this.disabled || (this.awsuiForm || {}).disabled;
    }
  },
  methods: {}
});
const _hoisted_1$n = ["disabled", "autofocus", "type"];
const _hoisted_2$i = { class: "awsui-button-content" };
const _hoisted_3$i = ["innerHTML"];
const _hoisted_4$d = {
  key: 1,
  class: "awsui-loading",
  style: { "margin-right": "4px" }
};
const _hoisted_5$a = ["innerHTML"];
const _hoisted_6$a = {
  key: 1,
  class: "awsui-loading"
};
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: normalizeClass(["awsui-button", [
      _ctx.type ? "awsui-button--" + _ctx.type : "",
      _ctx.buttonSize ? "awsui-button--" + _ctx.buttonSize : "",
      {
        "is-disabled": _ctx.buttonDisabled,
        "is-loading": _ctx.loading,
        "is-plain": _ctx.plain,
        "is-round": _ctx.round,
        "is-circle": _ctx.circle,
        "is-square": _ctx.square
      }
    ]]),
    disabled: _ctx.buttonDisabled,
    autofocus: _ctx.autofocus,
    type: _ctx.nativeType
  }, [
    createElementVNode("span", _hoisted_2$i, [
      _ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.icon != "" ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: "awsui-iconfont",
          style: { "margin-right": "4px" },
          innerHTML: _ctx.icon
        }, null, 8, _hoisted_3$i)) : createCommentVNode("v-if", true),
        _ctx.loading ? (openBlock(), createElementBlock("i", _hoisted_4$d)) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default")
      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.icon != "" ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: "awsui-iconfont",
          innerHTML: _ctx.icon
        }, null, 8, _hoisted_5$a)) : createCommentVNode("v-if", true),
        _ctx.loading ? (openBlock(), createElementBlock("i", _hoisted_6$a)) : createCommentVNode("v-if", true)
      ], 64))
    ])
  ], 10, _hoisted_1$n);
}
var AwsuiButton = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$D]]);
AwsuiButton.install = (app) => {
  app.component(AwsuiButton.name, AwsuiButton);
};
const _sfc_main$C = defineComponent({
  name: "AwsuiButtonGroup"
});
const _hoisted_1$m = { class: "awsui-button-group" };
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$m, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var AwsuiButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$C]]);
AwsuiButtonGroup.install = (app) => {
  app.component(AwsuiButtonGroup.name, AwsuiButtonGroup);
};
const _sfc_main$B = defineComponent({
  name: "AwsuiRadio",
  props: {
    group: {
      type: Boolean,
      default: false
    },
    radios: {
      type: Array,
      default: function() {
        return [];
      }
    }
  }
});
const _hoisted_1$l = { key: 0 };
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio = resolveComponent("el-radio");
  const _component_el_radio_group = resolveComponent("el-radio-group");
  return _ctx.group ? (openBlock(), createBlock(_component_el_radio_group, normalizeProps(mergeProps({ key: 0 }, _ctx.$attrs)), {
    default: withCtx(() => [
      createTextVNode(" ==" + toDisplayString(_ctx.$slots.default) + "== ", 1),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.radios, (item, index2) => {
        return openBlock(), createBlock(_component_el_radio, {
          key: item.value,
          label: item.value,
          class: "awsui-radio"
        }, createSlots({
          default: withCtx(() => [
            _ctx.$slots.default == null ? (openBlock(), createElementBlock("span", _hoisted_1$l, toDisplayString(item.label), 1)) : createCommentVNode("v-if", true)
          ]),
          _: 2
        }, [
          renderList(_ctx.$slots, (indexSlot, name2) => {
            return {
              name: name2,
              fn: withCtx(() => [
                name2 == "default" ? renderSlot(_ctx.$slots, name2, {
                  key: 0,
                  data: { item, index: index2 }
                }) : renderSlot(_ctx.$slots, name2, { key: 1 })
              ])
            };
          })
        ]), 1032, ["label"]);
      }), 128))
    ]),
    _: 3
  }, 16)) : (openBlock(), createBlock(_component_el_radio, mergeProps({ key: 1 }, _ctx.$attrs, { class: "awsui-radio" }), createSlots({ _: 2 }, [
    renderList(_ctx.$slots, (index2, name2) => {
      return {
        name: name2,
        fn: withCtx(() => [
          renderSlot(_ctx.$slots, name2)
        ])
      };
    })
  ]), 1040));
}
var AwsuiSelect = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$B]]);
AwsuiSelect.install = (app) => {
  app.component(AwsuiSelect.name, AwsuiSelect);
};
const _sfc_main$A = defineComponent({
  name: "AwsuiIframe",
  props: {
    reload: {
      type: Number,
      default: -1
    },
    iframeOption: {
      type: Object,
      default: () => {
        return {
          url: "./w"
        };
      }
    }
  },
  setup(props2, context) {
    const index2 = tools.getCountIndex("awsui-iframe");
    const iframeTargetForm = ref(null);
    const toIframe = ref(null);
    const loadIframe = () => {
      if (props2.iframeOption == null) {
        return;
      }
      nextTick(() => {
        let form = iframeTargetForm.value;
        let iframe2 = toIframe.value;
        if (iframe2 != null && form != null) {
          form.method = props2.iframeOption.type == "get" ? "get" : "post";
          context.emit("loading", true);
          if (iframe2.attachEvent) {
            iframe2.attachEvent("onload", () => {
              if (props2.iframeOption.onload) {
                props2.iframeOption.onload();
              }
              context.emit("loading", false);
            });
          } else {
            iframe2.onload = () => {
              if (props2.iframeOption.onload) {
                props2.iframeOption.onload();
              }
              context.emit("loading", false);
            };
          }
          form.submit();
        }
      });
    };
    watch(() => props2.reload, (value2) => {
      loadIframe();
    });
    return {
      index: index2,
      iframeTargetForm,
      getWin() {
        var _a;
        return (_a = toIframe.value) == null ? void 0 : _a.contentWindow;
      },
      toIframe
    };
  }
});
const _hoisted_1$k = ["name", "width", "height", "scrolling"];
const _hoisted_2$h = ["name", "target", "action"];
const _hoisted_3$h = ["name", "value"];
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createElementVNode("iframe", mergeProps({
      frameborder: "0",
      name: "awsui-dialog-iframe-" + _ctx.index,
      width: _ctx.iframeOption.width ? _ctx.iframeOption.width : "100%",
      height: _ctx.iframeOption.height ? _ctx.iframeOption.height : "99%",
      scrolling: _ctx.iframeOption.scrolling ? _ctx.iframeOption.scrolling : "auto"
    }, _ctx.$attrs, { ref: "toIframe" }), null, 16, _hoisted_1$k),
    createElementVNode("form", {
      name: "awsui-dialog-iframe-form-" + _ctx.index,
      target: "awsui-dialog-iframe-" + _ctx.index,
      action: _ctx.iframeOption.url,
      ref: "iframeTargetForm",
      style: { "display": "none" }
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.iframeOption.data, (value2, key) => {
        return openBlock(), createElementBlock("textarea", {
          key,
          name: key,
          value: value2
        }, null, 8, _hoisted_3$h);
      }), 128))
    ], 8, _hoisted_2$h)
  ], 64);
}
var iframe = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$A]]);
const _sfc_main$z = defineComponent({
  name: "AwsuiDialog",
  components: { ElDialog, AwsuiIframe: iframe },
  props: {
    height: {
      type: String
    },
    class: {
      type: [String, Array, Object]
    },
    iframeOption: Object,
    iframeReload: Number,
    dialogLoading: {
      type: Boolean,
      default: false
    }
  },
  setup(props2, context) {
    let dialogDom = ref(null);
    let loadingInstance = null;
    const reload2 = ref(0);
    const iframeRef = ref(null);
    const toloading = (val) => {
      if (val && dialogDom.value != null) {
        loadingInstance = ElLoading.service({
          target: dialogDom.value.dialogRef,
          fullscreen: true
        });
      } else {
        if (loadingInstance != null)
          loadingInstance.close();
      }
    };
    const loadingForIframe = ref(false);
    watch(() => props2.iframeReload, (value2) => {
      nextTick(() => {
        reload2.value++;
      });
    });
    watch(() => props2.dialogLoading, toloading);
    watch(() => loadingForIframe.value, (val) => {
      toloading(val);
    });
    const changeHeight = (val) => {
      if (val != null) {
        nextTick(() => {
          dialogDom.value.dialogRef.style.height = val;
          dialogDom.value.dialogRef.classList.add("awsui-dialog-forHeight");
        });
      }
    };
    watch(() => props2.height, changeHeight);
    onMounted(() => {
      changeHeight(props2.height);
    });
    const title = toRef(context.attrs, "title");
    const customClass = toRef(props2, "class");
    const methods = {
      buildCustomClass() {
        const cls = {};
        let classArr = [];
        if (typeof customClass.value == "string") {
          classArr = customClass.value.split(" ");
        } else if (Array.isArray(customClass.value)) {
          classArr = customClass.value;
        } else if (typeof customClass.value == "object") {
          Object.assign(cls, customClass.value);
          classArr.length = 0;
        }
        if (classArr.length > 0) {
          for (const cl of classArr) {
            cls[cl] = true;
          }
        }
        if (title.value == null || title.value == "") {
          Object.assign(cls, {
            "awsui-dialog": true
          });
        }
        const classes = [];
        for (const c in cls) {
          if (cls[c]) {
            classes.push(c);
          }
        }
        return classes.join(" ");
      }
    };
    return __spreadProps2(__spreadValues2({
      title
    }, methods), {
      dialogDom,
      reload: reload2,
      loadingForIframe,
      iframeRef
    });
  }
});
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_iframe = resolveComponent("awsui-iframe");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createBlock(_component_el_dialog, {
    "custom-class": _ctx.buildCustomClass(),
    ref: "dialogDom"
  }, createSlots({
    default: withCtx(() => [
      _ctx.iframeOption != null && _ctx.iframeOption.url != null ? (openBlock(), createBlock(_component_awsui_iframe, {
        key: 0,
        iframeOption: _ctx.iframeOption,
        reload: _ctx.reload,
        onLoading: _cache[0] || (_cache[0] = (show) => {
          _ctx.loadingForIframe = show;
        }),
        ref: "iframeRef"
      }, null, 8, ["iframeOption", "reload"])) : createCommentVNode("v-if", true)
    ]),
    _: 2
  }, [
    renderList(_ctx.$slots, (index2, name2) => {
      return {
        name: name2,
        fn: withCtx(() => [
          renderSlot(_ctx.$slots, name2)
        ])
      };
    })
  ]), 1032, ["custom-class"]);
}
var AwsuiDialog = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$z]]);
AwsuiDialog.install = (app) => {
  app.component(AwsuiDialog.name, AwsuiDialog);
};
const _sfc_main$y = defineComponent({
  name: "AwsuiSidebar",
  components: { ElDrawer },
  props: {
    dialogLoading: {
      type: Boolean,
      default: false
    }
  },
  setup(props2, context) {
    let dialogDom = ref(null);
    let loadingInstance = null;
    watch(() => props2.dialogLoading, (val) => {
      if (val && dialogDom.value != null) {
        loadingInstance = ElLoading.service({
          target: dialogDom.value.$el.nextElementSibling.querySelector(".el-dialog"),
          fullscreen: true
        });
      } else {
        if (loadingInstance != null)
          loadingInstance.close();
      }
    });
    return {
      dialogDom,
      loading: ref(true)
    };
  }
});
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_drawer = resolveComponent("el-drawer");
  return openBlock(), createBlock(_component_el_drawer, { ref: "dialogDom" }, createSlots({ _: 2 }, [
    renderList(_ctx.$slots, (index2, name2) => {
      return {
        name: name2,
        fn: withCtx(() => [
          renderSlot(_ctx.$slots, name2)
        ])
      };
    })
  ]), 1536);
}
var sidebar = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$y]]);
sidebar.install = (app) => {
  app.component(sidebar.name, sidebar);
};
var language = {
  zh: {
    hint: "\u70B9\u51FB\uFF0C\u6216\u62D6\u52A8\u56FE\u7247\u81F3\u6B64\u5904",
    loading: "\u6B63\u5728\u4E0A\u4F20\u2026\u2026",
    noSupported: "\u6D4F\u89C8\u5668\u4E0D\u652F\u6301\u8BE5\u529F\u80FD\uFF0C\u8BF7\u4F7F\u7528IE10\u4EE5\u4E0A\u6216\u5176\u4ED6\u73B0\u5728\u6D4F\u89C8\u5668\uFF01",
    success: "\u4E0A\u4F20\u6210\u529F",
    fail: "\u56FE\u7247\u4E0A\u4F20\u5931\u8D25",
    preview: "\u5934\u50CF\u9884\u89C8",
    btn: {
      off: "\u53D6\u6D88",
      close: "\u5173\u95ED",
      back: "\u4E0A\u4E00\u6B65",
      save: "\u4FDD\u5B58"
    },
    error: {
      onlyImg: "\u4EC5\u9650\u56FE\u7247\u683C\u5F0F",
      outOfSize: "\u5355\u6587\u4EF6\u5927\u5C0F\u4E0D\u80FD\u8D85\u8FC7 ",
      lowestPx: "\u56FE\u7247\u6700\u4F4E\u50CF\u7D20\u4E3A\uFF08\u5BBD*\u9AD8\uFF09\uFF1A"
    }
  },
  en: {
    hint: "Click or drag the file here to upload",
    loading: "Uploading\u2026",
    noSupported: "Browser is not supported, please use IE10+ or other browsers",
    success: "Upload success",
    fail: "Upload failed",
    preview: "Preview",
    btn: {
      off: "Cancel",
      close: "Close",
      back: "Back",
      save: "Save"
    },
    error: {
      onlyImg: "Image only",
      outOfSize: "Image exceeds size limit: ",
      lowestPx: "Image's size is too low. Expected at least: "
    }
  },
  ro: {
    hint: "Atinge sau trage fi\u0219ierul aici",
    loading: "Se \xEEncarc\u0103",
    noSupported: "Browser-ul t\u0103u nu suport\u0103 acest feature. Te rug\u0103m \xEEncearc\u0103 cu alt browser.",
    success: "S-a \xEEnc\u0103rcat cu succes",
    fail: "A ap\u0103rut o problem\u0103 la \xEEnc\u0103rcare",
    preview: "Previzualizeaz\u0103",
    btn: {
      off: "Anuleaz\u0103",
      close: "\xCEnchide",
      back: "\xCEnapoi",
      save: "Salveaz\u0103"
    },
    error: {
      onlyImg: "Doar imagini",
      outOfSize: "Imaginea dep\u0103\u0219e\u0219te limita de: ",
      loewstPx: "Imaginea este prea mic\u0103; Minim: "
    }
  },
  ru: {
    hint: "\u041D\u0430\u0436\u043C\u0438\u0442\u0435, \u0438\u043B\u0438 \u043F\u0435\u0440\u0435\u0442\u0430\u0449\u0438\u0442\u0435 \u0444\u0430\u0439\u043B \u0432 \u044D\u0442\u043E \u043E\u043A\u043D\u043E",
    loading: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u044E\u2026\u2026",
    noSupported: "\u0412\u0430\u0448 \u0431\u0440\u0430\u0443\u0437\u0435\u0440 \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F, \u043F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 IE10 + \u0438\u043B\u0438 \u0434\u0440\u0443\u0433\u0438\u0435 \u0431\u0440\u0430\u0443\u0437\u0435\u0440\u044B",
    success: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u0430 \u0443\u0441\u043F\u0435\u0448\u043D\u043E",
    fail: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438",
    preview: "\u041F\u0440\u0435\u0434\u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440",
    btn: {
      off: "\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C",
      close: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C",
      back: "\u041D\u0430\u0437\u0430\u0434",
      save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C"
    },
    error: {
      onlyImg: "\u0422\u043E\u043B\u044C\u043A\u043E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
      outOfSize: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043F\u0440\u0435\u0432\u044B\u0448\u0430\u0435\u0442 \u043F\u0440\u0435\u0434\u0435\u043B\u044C\u043D\u044B\u0439 \u0440\u0430\u0437\u043C\u0435\u0440: ",
      lowestPx: "\u041C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0440\u0430\u0437\u043C\u0435\u0440 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F: "
    }
  },
  "pt-br": {
    hint: "Clique ou arraste o arquivo aqui para carregar",
    loading: "Carregando\u2026",
    noSupported: "Browser n\xE3o suportado, use o IE10+ ou outro browser",
    success: "Sucesso ao carregar imagem",
    fail: "Falha ao carregar imagem",
    preview: "Pr\xE9-visualizar",
    btn: {
      off: "Cancelar",
      close: "Fechar",
      back: "Voltar",
      save: "Salvar"
    },
    error: {
      onlyImg: "Apenas imagens",
      outOfSize: "A imagem excede o limite de tamanho: ",
      lowestPx: "O tamanho da imagem \xE9 muito pequeno. Tamanho m\xEDnimo: "
    }
  },
  fr: {
    hint: "Cliquez ou glissez le fichier ici.",
    loading: "T\xE9l\xE9chargement\u2026",
    noSupported: "Votre navigateur n'est pas support\xE9. Utilisez IE10 + ou un autre navigateur s'il vous pla\xEEt.",
    success: "T\xE9l\xE9chargement r\xE9ussit",
    fail: "T\xE9l\xE9chargement echou\xE9",
    preview: "Aper\xE7u",
    btn: {
      off: "Annuler",
      close: "Fermer",
      back: "Retour",
      save: "Enregistrer"
    },
    error: {
      onlyImg: "Image uniquement",
      outOfSize: "L'image s\xE9lectionn\xE9e d\xE9passe la taille maximum: ",
      lowestPx: "L'image s\xE9lectionn\xE9e est trop petite. Dimensions attendues: "
    }
  },
  nl: {
    hint: "Klik hier of sleep een afbeelding in dit vlak",
    loading: "Uploaden\u2026",
    noSupported: "Je browser wordt helaas niet ondersteund. Gebruik IE10+ of een andere browser.",
    success: "Upload succesvol",
    fail: "Upload mislukt",
    preview: "Voorbeeld",
    btn: {
      off: "Annuleren",
      close: "Sluiten",
      back: "Terug",
      save: "Opslaan"
    },
    error: {
      onlyImg: "Alleen afbeeldingen",
      outOfSize: "De afbeelding is groter dan: ",
      lowestPx: "De afbeelding is te klein! Minimale afmetingen: "
    }
  },
  tr: {
    hint: "T\u0131kla veya y\xFCklemek istedi\u011Fini buraya s\xFCr\xFCkle",
    loading: "Y\xFCkleniyor\u2026",
    noSupported: "Taray\u0131c\u0131 desteklenmiyor, l\xFCtfen IE10+ veya farkl\u0131 taray\u0131c\u0131 kullan\u0131n",
    success: "Y\xFCkleme ba\u015Far\u0131l\u0131",
    fail: "Y\xFCklemede hata olu\u015Ftu",
    preview: "\xD6nizle",
    btn: {
      off: "\u0130ptal",
      close: "Kapat",
      back: "Geri",
      save: "Kaydet"
    },
    error: {
      onlyImg: "Sadece resim",
      outOfSize: "Resim y\xFCkleme limitini a\u015F\u0131yor: ",
      lowestPx: "Resmin boyutu \xE7ok k\xFC\xE7\xFCk. En az olmas\u0131 gereken: "
    }
  },
  "es-MX": {
    hint: "Selecciona o arrastra una imagen",
    loading: "Subiendo...",
    noSupported: "Tu navegador no es soportado, porfavor usa IE10+ u otros navegadores mas recientes",
    success: "Subido exitosamente",
    fail: "Sucedi\xF3 un error",
    preview: "Vista previa",
    btn: {
      off: "Cancelar",
      close: "Cerrar",
      back: "Atras",
      save: "Guardar"
    },
    error: {
      onlyImg: "Unicamente imagenes",
      outOfSize: "La imagen excede el tama\xF1o maximo:",
      lowestPx: "La imagen es demasiado peque\xF1o. Se espera por lo menos:"
    }
  }
};
const mimes = {
  "jpg": "image/jpeg",
  "png": "image/png",
  "gif": "image/gif",
  "svg": "image/svg+xml",
  "psd": "image/photoshop"
};
const languageCurr = language;
const _sfc_main$x = defineComponent({
  name: "AwsuiUploadImage",
  props: {
    dialogVisible: {
      type: Boolean,
      default: false
    },
    field: {
      type: String,
      "default": "avatar"
    },
    ki: {
      "default": 0
    },
    url: {
      type: String,
      "default": ""
    },
    params: {
      type: Object,
      "default": () => null
    },
    headers: {
      type: Object,
      "default": () => null
    },
    width: {
      type: Number,
      default: 200
    },
    height: {
      type: Number,
      default: 200
    },
    noRotate: {
      type: Boolean,
      default: true
    },
    noCircle: {
      type: Boolean,
      default: false
    },
    noSquare: {
      type: Boolean,
      default: false
    },
    maxSize: {
      type: Number,
      "default": 10240
    },
    langType: {
      type: String,
      "default": "zh"
    },
    langExt: {
      type: Object,
      "default": () => null
    },
    imgFormat: {
      type: String,
      "default": "png"
    },
    imgBgc: {
      type: String,
      "default": "#fff"
    },
    withCredentials: {
      type: Boolean,
      "default": false
    },
    method: {
      type: String,
      "default": "POST"
    },
    imgUrl: {
      type: String,
      "default": ""
    },
    allowImgFormat: {
      type: Array,
      "default": () => [
        "gif",
        "jpg",
        "png"
      ]
    }
  },
  emits: ["update:dialogVisible", "src-file-set", "crop-success", "crop-upload-success", "crop-upload-fail"],
  setup(props2, context) {
    const fileinput = ref(null);
    const canvasRef = ref(null);
    const { dialogVisible: dialogVisible2 } = toRefs(props2);
    const parent2 = __spreadValues2({}, context);
    let tempImgFormat = ref(props2.allowImgFormat.indexOf(props2.imgFormat) === -1 ? "jpg" : props2.imgFormat);
    let mime = mimes[tempImgFormat.value];
    let lang = languageCurr[props2.langType] ? languageCurr[props2.langType] : languageCurr["en"];
    if (props2.langExt) {
      Object.assign(lang, props2.langExt);
    }
    const state = reactive({
      visible: dialogVisible2.value,
      mime,
      lang,
      isSupported: true,
      step: props2.imgUrl !== "" || props2.imgUrl !== null ? 2 : 1,
      loading: 0,
      progress: 0,
      hasError: false,
      errorMsg: "",
      ratio: props2.width / props2.height,
      sourceImg: null,
      sourceImgUrl: props2.imgUrl !== "" || props2.imgUrl !== null ? props2.imgUrl : "",
      createImgUrl: props2.imgUrl !== "" || props2.imgUrl !== null ? props2.imgUrl : "",
      sourceImgMouseDown: {
        on: false,
        mX: 0,
        mY: 0,
        x: 0,
        y: 0
      },
      previewContainer: {
        width: 100,
        height: 100
      },
      sourceImgContainer: {
        width: 240,
        height: 184
      },
      scale: {
        zoomAddOn: false,
        zoomSubOn: false,
        range: 1,
        rotateLeft: false,
        rotateRight: false,
        degree: 0,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        maxWidth: 0,
        maxHeight: 0,
        minWidth: 0,
        minHeight: 0,
        naturalWidth: 0,
        naturalHeight: 0
      },
      progressStyle: computed(() => {
        return {
          width: state.progress + "%"
        };
      }),
      sourceImgStyle: computed(() => {
        let {
          scale,
          sourceImgMasking
        } = state;
        return {
          top: scale.y + sourceImgMasking.y + "px",
          left: scale.x + sourceImgMasking.x + "px",
          width: scale.width + "px",
          height: scale.height + "px",
          transform: "rotate(" + scale.degree + "deg)",
          "-ms-transform": "rotate(" + scale.degree + "deg)",
          "-moz-transform": "rotate(" + scale.degree + "deg)",
          "-webkit-transform": "rotate(" + scale.degree + "deg)",
          "-o-transform": "rotate(" + scale.degree + "deg)"
        };
      }),
      sourceImgMasking: computed(() => {
        let {
          ratio,
          sourceImgContainer
        } = state, sic = sourceImgContainer, sicRatio = sic.width / sic.height, x = 0, y = 0, w = sic.width, h2 = sic.height, scale = 1;
        if (ratio < sicRatio) {
          scale = sic.height / props2.height;
          w = sic.height * ratio;
          x = (sic.width - w) / 2;
        }
        if (ratio > sicRatio) {
          scale = sic.width / props2.width;
          h2 = sic.width / ratio;
          y = (sic.height - h2) / 2;
        }
        return {
          scale,
          x,
          y,
          width: w,
          height: h2
        };
      }),
      sourceImgShadeStyle: computed(() => {
        let {
          sourceImgMasking,
          sourceImgContainer
        } = state, sic = sourceImgContainer, sim = sourceImgMasking, w = sim.width == sic.width ? sim.width : (sic.width - sim.width) / 2, h2 = sim.height == sic.height ? sim.height : (sic.height - sim.height) / 2;
        return {
          width: w + "px",
          height: h2 + "px"
        };
      }),
      previewStyle: computed(() => {
        let {
          ratio,
          previewContainer
        } = state, pc = previewContainer, w = pc.width, h2 = pc.height, pcRatio = w / h2;
        if (ratio < pcRatio) {
          w = pc.height * ratio;
        }
        if (ratio > pcRatio) {
          h2 = pc.width / ratio;
        }
        return {
          width: w + "px",
          height: h2 + "px"
        };
      })
    });
    if (typeof FormData != "function") {
      state.isSupported = false;
    }
    watch(dialogVisible2, (val) => {
      state.visible = val;
      if (val && state.loading != 1) {
        initDataImg();
      } else {
        off2();
      }
    });
    const off2 = () => {
      setTimeout(() => {
        parent2.emit("update:dialogVisible", false);
        if (state.step == 3 && state.loading == 2) {
          setStep(1);
        }
      }, 200);
    };
    const prepareUpload = () => {
      let { createImgUrl } = state;
      parent2.emit("crop-success", createImgUrl, props2.field, props2.ki);
      if (typeof props2.url == "string" && props2.url) {
        upload2();
      } else {
        off2();
      }
    };
    const getBase64 = (imgUrl, callback) => {
      const image = new Image();
      image.setAttribute("crossOrigin", "anonymous");
      const imageUrl = imgUrl;
      image.src = imageUrl;
      image.onload = function() {
        let canvas = document.createElement("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        let ctx2 = canvas.getContext("2d");
        ctx2.fillStyle = "#fff";
        ctx2.fillRect(0, 0, image.width, image.height);
        ctx2.drawImage(image, 0, 0, image.width, image.height);
        let quality = 0.8;
        const dataurl = canvas.toDataURL("image/jpeg", quality);
        callback ? callback(dataurl) : null;
      };
    };
    const initDataImg = () => {
      reset();
      if (state.sourceImgUrl !== "") {
        if (state.sourceImgUrl.indexOf("data:image") !== -1) {
          createImg("no");
          setStep(2);
        } else {
          getBase64(state.sourceImgUrl, (dataURL) => {
            state.sourceImgUrl = dataURL;
            state.createImgUrl = dataURL;
            startCrop();
          });
        }
      } else {
        setStep(1);
      }
    };
    const setStep = (no) => {
      setTimeout(() => {
        state.step = no;
      }, 200);
    };
    const preventDefault = (e) => {
      e.preventDefault();
      return false;
    };
    const handleClick = (e) => {
      if (state.loading !== 1) {
        setTimeout(() => {
          if (e.target !== fileinput.value) {
            e.preventDefault();
            reset();
            if (document.activeElement !== fileinput.value) {
              fileinput.value.click();
            }
          }
        }, 200);
      }
    };
    const handleChange = (e) => {
      e.preventDefault();
      if (state.loading !== 1) {
        let files = e.target.files || e.dataTransfer.files;
        reset();
        if (checkFile(files[0])) {
          setSourceImg(files[0]);
        }
      }
    };
    const checkFile = (file) => {
      let that = state, {
        lang: lang2
      } = that;
      if (file.type.indexOf("image") === -1) {
        that.hasError = true;
        that.errorMsg = lang2.error.onlyImg;
        return false;
      }
      if (file.size / 1024 > props2.maxSize) {
        that.hasError = true;
        that.errorMsg = lang2.error.outOfSize + props2.maxSize + "kb";
        return false;
      }
      return true;
    };
    const reset = () => {
      state.loading = 0;
      state.progress = 0;
      state.hasError = false;
      state.errorMsg = "";
    };
    const setSourceImg = (file) => {
      let that = state, fr = new FileReader();
      fr.onload = function(e) {
        that.sourceImgUrl = fr.result;
        startCrop();
      };
      fr.readAsDataURL(file);
    };
    const startCrop = () => {
      let that = state, {
        ratio,
        scale,
        sourceImgUrl,
        sourceImgMasking,
        lang: lang2
      } = that, sim = sourceImgMasking, img = new Image();
      img.src = sourceImgUrl;
      img.onload = function() {
        let nWidth = img.naturalWidth, nHeight = img.naturalHeight, nRatio = nWidth / nHeight, w = sim.width, h2 = sim.height, x = 0, y = 0;
        if (nWidth < props2.width || nHeight < props2.height) {
          that.hasError = true;
          that.errorMsg = lang2.error.lowestPx + props2.width + "*" + props2.height;
        }
        if (ratio > nRatio) {
          h2 = w / nRatio;
          y = (sim.height - h2) / 2;
        }
        if (ratio < nRatio) {
          w = h2 * nRatio;
          x = (sim.width - w) / 2;
        }
        scale.range = 0;
        scale.x = x;
        scale.y = y;
        scale.width = w;
        scale.height = h2;
        scale.degree = 0;
        scale.minWidth = w;
        scale.minHeight = h2;
        scale.maxWidth = nWidth * sim.scale;
        scale.maxHeight = nHeight * sim.scale;
        scale.naturalWidth = nWidth;
        scale.naturalHeight = nHeight;
        that.sourceImg = img;
        createImg("no");
        setStep(2);
      };
    };
    const imgStartMove = (e) => {
      e.preventDefault();
      if (state.isSupportTouch && !e.targetTouches) {
        return false;
      }
      let et = e.targetTouches ? e.targetTouches[0] : e, {
        sourceImgMouseDown,
        scale
      } = state, simd = sourceImgMouseDown;
      simd.mX = et.screenX;
      simd.mY = et.screenY;
      simd.x = scale.x;
      simd.y = scale.y;
      simd.on = true;
    };
    const imgMove = (e) => {
      e.preventDefault();
      if (state.isSupportTouch && !e.targetTouches) {
        return false;
      }
      let et = e.targetTouches ? e.targetTouches[0] : e, {
        sourceImgMouseDown: {
          on: on2,
          mX,
          mY,
          x,
          y
        },
        scale,
        sourceImgMasking
      } = state, sim = sourceImgMasking, nX = et.screenX, nY = et.screenY, dX = nX - mX, dY = nY - mY, rX = x + dX, rY = y + dY;
      if (!on2)
        return;
      if (rX > 0) {
        rX = 0;
      }
      if (rY > 0) {
        rY = 0;
      }
      if (rX < sim.width - scale.width) {
        rX = sim.width - scale.width;
      }
      if (rY < sim.height - scale.height) {
        rY = sim.height - scale.height;
      }
      scale.x = rX;
      scale.y = rY;
    };
    const startRotateRight = (e) => {
      let that = state, {
        scale
      } = that;
      scale.rotateRight = true;
      function rotate() {
        if (scale.rotateRight) {
          let degree = ++scale.degree;
          createImg(degree);
          setTimeout(function() {
            rotate();
          }, 60);
        }
      }
      rotate();
    };
    const endRotate = () => {
      let {
        scale
      } = state;
      scale.rotateLeft = false;
      scale.rotateRight = false;
    };
    const startZoomAdd = (e) => {
      let that = state, {
        scale
      } = that;
      scale.zoomAddOn = true;
      function zoom() {
        if (scale.zoomAddOn) {
          let range2 = scale.range >= 100 ? 100 : ++scale.range;
          zoomImg(range2);
          setTimeout(function() {
            zoom();
          }, 60);
        }
      }
      zoom();
    };
    const endZoomAdd = (e) => {
      state.scale.zoomAddOn = false;
    };
    const startZoomSub = (e) => {
      let that = state, {
        scale
      } = that;
      scale.zoomSubOn = true;
      function zoom() {
        if (scale.zoomSubOn) {
          let range2 = scale.range <= 0 ? 0 : --scale.range;
          zoomImg(range2);
          setTimeout(function() {
            zoom();
          }, 60);
        }
      }
      zoom();
    };
    const endZoomSub = (e) => {
      let {
        scale
      } = state;
      scale.zoomSubOn = false;
    };
    const zoomChange = (e) => {
      zoomImg(e.target.value);
    };
    const zoomImg = (newRange) => {
      let that = state, {
        sourceImgMasking,
        sourceImgMouseDown,
        scale
      } = that, {
        maxWidth,
        maxHeight,
        minWidth,
        minHeight,
        x,
        y,
        range: range2
      } = scale, sim = sourceImgMasking, sWidth = sim.width, sHeight = sim.height, nWidth = minWidth + (maxWidth - minWidth) * newRange / 100, nHeight = minHeight + (maxHeight - minHeight) * newRange / 100, nX = sWidth / 2 - nWidth / props2.width * (sWidth / 2 - x), nY = sHeight / 2 - nHeight / props2.height * (sHeight / 2 - y);
      if (nX > 0) {
        nX = 0;
      }
      if (nY > 0) {
        nY = 0;
      }
      if (nX < sWidth - nWidth) {
        nX = sWidth - nWidth;
      }
      if (nY < sHeight - nHeight) {
        nY = sHeight - nHeight;
      }
      scale.x = nX;
      scale.y = nY;
      scale.width = nWidth;
      scale.height = nHeight;
      scale.range = newRange;
      setTimeout(function() {
        if (scale.range == newRange) {
          createImg("no");
        }
      }, 300);
    };
    const createImg = (status) => {
      let that = state, {
        mime: mime2,
        sourceImg,
        scale: {
          x,
          y,
          width: width2,
          height,
          degree
        },
        sourceImgMasking: {
          scale
        }
      } = that;
      if (canvasRef.value !== null) {
        let canvas = canvasRef.value;
        let ctx2 = canvas.getContext("2d");
        if (status !== void 0 && status !== "no") {
          that.sourceImgMouseDown.on = false;
        }
        canvas.width = props2.width;
        canvas.height = props2.height;
        ctx2.clearRect(0, 0, props2.width, props2.height);
        if (props2.imgFormat == "png") {
          ctx2.fillStyle = "rgba(0,0,0,0)";
        } else {
          ctx2.fillStyle = props2.imgBgc;
        }
        ctx2.fillRect(0, 0, props2.width, props2.height);
        ctx2.translate(props2.width * 0.5, props2.height * 0.5);
        ctx2.rotate(Math.PI * degree / 180);
        ctx2.translate(-props2.width * 0.5, -props2.height * 0.5);
        ctx2.drawImage(sourceImg, x / scale, y / scale, width2 / scale, height / scale);
        that.createImgUrl = canvas.toDataURL(mime2);
      }
    };
    const upload2 = () => {
      let that = state, {
        lang: lang2,
        mime: mime2,
        createImgUrl
      } = that, fmData = new FormData();
      fmData.append(props2.field, data2blob(createImgUrl, mime2), props2.field + "." + props2.imgFormat);
      if (typeof props2.params == "object" && props2.params) {
        Object.keys(props2.params).forEach((k) => {
          fmData.append(k, props2.params[k]);
        });
      }
      const uploadProgress = function(event2) {
        if (event2.lengthComputable) {
          that.progress = 100 * Math.round(event2.loaded) / event2.total;
        }
      };
      reset();
      that.loading = 1;
      setStep(3);
      new Promise(function(resolve, reject) {
        let client = new XMLHttpRequest();
        client.open("POST", props2.url, true);
        client.withCredentials = props2.withCredentials;
        client.onreadystatechange = function() {
          if (this.readyState !== 4) {
            return;
          }
          if (this.status === 200 || this.status === 201) {
            resolve(JSON.parse(this.responseText));
          } else {
            reject(this.status);
          }
        };
        client.upload.addEventListener("progress", uploadProgress, false);
        if (typeof props2.headers == "object" && props2.headers) {
          Object.keys(props2.headers).forEach((k) => {
            client.setRequestHeader(k, props2.headers[k]);
          });
        }
        client.send(fmData);
      }).then(function(resData) {
        if (that.visible) {
          that.loading = 2;
          parent2.emit("crop-upload-success", resData, props2.field, props2.ki);
          off2();
        }
      }, function(sts) {
        if (that.visible) {
          that.loading = 3;
          that.hasError = true;
          that.errorMsg = lang2.fail;
          parent2.emit("crop-upload-fail", sts, props2.field, props2.ki);
        }
      });
    };
    const data2blob = (data, mime2) => {
      data = data.split(",")[1];
      data = window.atob(data);
      var ia = new Uint8Array(data.length);
      for (var i2 = 0; i2 < data.length; i2++) {
        ia[i2] = data.charCodeAt(i2);
      }
      return new Blob([ia], {
        type: mime2
      });
    };
    onMounted(() => {
      nextTick(() => {
        initDataImg();
      });
      document.addEventListener("keyup", (e) => {
        if (state.visible && (e.key == "Escape" || e.keyCode == 27)) {
          off2();
        }
      });
    });
    return __spreadProps2(__spreadValues2({
      fileinput,
      canvasRef,
      tempImgFormat
    }, toRefs(state)), {
      off: off2,
      prepareUpload,
      getBase64,
      initDataImg,
      setStep,
      preventDefault,
      handleClick,
      handleChange,
      checkFile,
      reset,
      setSourceImg,
      startCrop,
      imgStartMove,
      imgMove,
      startRotateRight,
      endRotate,
      startZoomAdd,
      endZoomAdd,
      startZoomSub,
      endZoomSub,
      zoomChange,
      zoomImg,
      createImg,
      upload: upload2,
      data2blob
    });
  }
});
const _withScopeId$7 = (n) => (pushScopeId("data-v-147c01c6"), n = n(), popScopeId(), n);
const _hoisted_1$j = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("i", { class: "awsui-iconfont" }, " \uE6FE ", -1));
const _hoisted_2$g = [
  _hoisted_1$j
];
const _hoisted_3$g = { class: "vicp-wrap" };
const _hoisted_4$c = { class: "vicp-step1" };
const _hoisted_5$9 = { class: "vicp-crop" };
const _hoisted_6$9 = { class: "vicp-crop-left" };
const _hoisted_7$8 = { class: "vicp-img-container" };
const _hoisted_8$8 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("i", { class: "awsui-iconfont" }, " \uE8B4 ", -1));
const _hoisted_9$8 = [
  _hoisted_8$8
];
const _hoisted_10$5 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("div", { class: "vicp-img-info" }, "\u6839\u636E\u60A8\u7684\u9700\u8981\u88C1\u526A\u548C\u8C03\u6574\u56FE\u7247\u7684\u4F4D\u7F6E", -1));
const _hoisted_11$4 = { class: "vicp-crop-right" };
const _hoisted_12$4 = { class: "vicp-preview" };
const _hoisted_13$4 = {
  key: 0,
  class: "vicp-preview-item"
};
const _hoisted_14$3 = {
  key: 1,
  class: "vicp-preview-item vicp-preview-item-circle"
};
const _hoisted_15$3 = {
  key: 0,
  class: "vicp-step2"
};
const _hoisted_16$3 = { class: "vicp-crop" };
const _hoisted_17$3 = { class: "vicp-crop-left" };
const _hoisted_18$3 = { class: "vicp-img-container" };
const _hoisted_19$3 = ["src"];
const _hoisted_20$3 = { class: "vicp-range" };
const _hoisted_21$3 = {
  key: 0,
  class: "vicp-rotate"
};
const _hoisted_22$3 = { class: "vicp-crop-right" };
const _hoisted_23$3 = { class: "vicp-preview" };
const _hoisted_24$3 = {
  key: 0,
  class: "vicp-preview-item"
};
const _hoisted_25$3 = ["src"];
const _hoisted_26$3 = {
  key: 1,
  class: "vicp-preview-item vicp-preview-item-circle"
};
const _hoisted_27$3 = ["src"];
const _hoisted_28$2 = {
  key: 1,
  class: "vicp-step3"
};
const _hoisted_29$2 = { class: "vicp-upload" };
const _hoisted_30$2 = { class: "vicp-progress-wrap" };
const _hoisted_31$2 = { class: "vicp-error" };
const _hoisted_32$2 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("i", { class: "vicp-icon2" }, null, -1));
const _hoisted_33$2 = { class: "vicp-success" };
const _hoisted_34$2 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("i", { class: "vicp-icon3" }, null, -1));
const _hoisted_35$1 = ["width", "height"];
const _hoisted_36$1 = { class: "dialog-footer" };
const _hoisted_37$1 = /* @__PURE__ */ createTextVNode("\u9009\u62E9\u56FE\u7247");
const _hoisted_38$1 = /* @__PURE__ */ createTextVNode("\u786E \u5B9A");
const _hoisted_39$1 = /* @__PURE__ */ createTextVNode("\u53D6 \u6D88");
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_button = resolveComponent("awsui-button");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createBlock(_component_el_dialog, {
    title: "\u4FEE\u6539\u5934\u50CF",
    "custom-class": "awsui-upload",
    "show-close": false,
    width: "680px",
    modelValue: _ctx.visible,
    "onUpdate:modelValue": _cache[32] || (_cache[32] = ($event) => _ctx.visible = $event),
    onClose: _ctx.off
  }, {
    footer: withCtx(() => [
      createElementVNode("span", _hoisted_36$1, [
        createVNode(_component_awsui_button, {
          class: "awsui-left",
          onClick: _ctx.handleClick
        }, {
          default: withCtx(() => [
            _hoisted_37$1
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_awsui_button, {
          type: "primary",
          disabled: _ctx.sourceImgUrl == "",
          onClick: _ctx.prepareUpload
        }, {
          default: withCtx(() => [
            _hoisted_38$1
          ]),
          _: 1
        }, 8, ["disabled", "onClick"]),
        createVNode(_component_awsui_button, { onClick: _ctx.off }, {
          default: withCtx(() => [
            _hoisted_39$1
          ]),
          _: 1
        }, 8, ["onClick"])
      ])
    ]),
    default: withCtx(() => [
      createElementVNode("button", {
        type: "button",
        class: "vicp-close",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.off && _ctx.off(...args))
      }, _hoisted_2$g),
      withDirectives(createElementVNode("input", {
        type: "file",
        onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        ref: "fileinput"
      }, null, 544), [
        [vShow, false]
      ]),
      createElementVNode("div", _hoisted_3$g, [
        withDirectives(createElementVNode("div", _hoisted_4$c, [
          createElementVNode("div", _hoisted_5$9, [
            withDirectives(createElementVNode("div", _hoisted_6$9, [
              createElementVNode("div", _hoisted_7$8, [
                createElementVNode("div", {
                  class: "vicp-img-default",
                  onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
                }, _hoisted_9$8)
              ]),
              _hoisted_10$5
            ], 512), [
              [vShow, true]
            ]),
            withDirectives(createElementVNode("div", _hoisted_11$4, [
              createElementVNode("div", _hoisted_12$4, [
                createElementVNode("span", null, toDisplayString(_ctx.lang.preview), 1),
                !_ctx.noSquare ? (openBlock(), createElementBlock("div", _hoisted_13$4)) : createCommentVNode("v-if", true),
                !_ctx.noCircle ? (openBlock(), createElementBlock("div", _hoisted_14$3)) : createCommentVNode("v-if", true)
              ])
            ], 512), [
              [vShow, true]
            ])
          ])
        ], 512), [
          [vShow, _ctx.step == 1]
        ]),
        _ctx.step == 2 ? (openBlock(), createElementBlock("div", _hoisted_15$3, [
          createElementVNode("div", _hoisted_16$3, [
            withDirectives(createElementVNode("div", _hoisted_17$3, [
              createElementVNode("div", _hoisted_18$3, [
                createElementVNode("img", {
                  src: _ctx.sourceImgUrl,
                  style: normalizeStyle(_ctx.sourceImgStyle),
                  class: "vicp-img",
                  draggable: "false",
                  onDrag: _cache[3] || (_cache[3] = (...args) => _ctx.preventDefault && _ctx.preventDefault(...args)),
                  onDragstart: _cache[4] || (_cache[4] = (...args) => _ctx.preventDefault && _ctx.preventDefault(...args)),
                  onDragend: _cache[5] || (_cache[5] = (...args) => _ctx.preventDefault && _ctx.preventDefault(...args)),
                  onDragleave: _cache[6] || (_cache[6] = (...args) => _ctx.preventDefault && _ctx.preventDefault(...args)),
                  onDragover: _cache[7] || (_cache[7] = (...args) => _ctx.preventDefault && _ctx.preventDefault(...args)),
                  onDragenter: _cache[8] || (_cache[8] = (...args) => _ctx.preventDefault && _ctx.preventDefault(...args)),
                  onDrop: _cache[9] || (_cache[9] = (...args) => _ctx.preventDefault && _ctx.preventDefault(...args)),
                  onTouchstart: _cache[10] || (_cache[10] = (...args) => _ctx.imgStartMove && _ctx.imgStartMove(...args)),
                  onTouchmove: _cache[11] || (_cache[11] = (...args) => _ctx.imgMove && _ctx.imgMove(...args)),
                  onTouchend: _cache[12] || (_cache[12] = (...args) => _ctx.createImg && _ctx.createImg(...args)),
                  onTouchcancel: _cache[13] || (_cache[13] = (...args) => _ctx.createImg && _ctx.createImg(...args)),
                  onMousedown: _cache[14] || (_cache[14] = (...args) => _ctx.imgStartMove && _ctx.imgStartMove(...args)),
                  onMousemove: _cache[15] || (_cache[15] = (...args) => _ctx.imgMove && _ctx.imgMove(...args)),
                  onMouseup: _cache[16] || (_cache[16] = (...args) => _ctx.createImg && _ctx.createImg(...args)),
                  onMouseout: _cache[17] || (_cache[17] = (...args) => _ctx.createImg && _ctx.createImg(...args)),
                  ref: "img"
                }, null, 44, _hoisted_19$3),
                createElementVNode("div", {
                  class: "vicp-img-shade vicp-img-shade-1",
                  style: normalizeStyle(_ctx.sourceImgShadeStyle)
                }, null, 4),
                createElementVNode("div", {
                  class: "vicp-img-shade vicp-img-shade-2",
                  style: normalizeStyle(_ctx.sourceImgShadeStyle)
                }, null, 4)
              ]),
              createElementVNode("div", _hoisted_20$3, [
                withDirectives(createElementVNode("input", {
                  type: "range",
                  "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => _ctx.scale.range = $event),
                  step: "1",
                  min: "0",
                  max: "100",
                  onInput: _cache[19] || (_cache[19] = (...args) => _ctx.zoomChange && _ctx.zoomChange(...args))
                }, null, 544), [
                  [vModelText, _ctx.scale.range]
                ]),
                createElementVNode("i", {
                  onMousedown: _cache[20] || (_cache[20] = (...args) => _ctx.startZoomSub && _ctx.startZoomSub(...args)),
                  onMouseout: _cache[21] || (_cache[21] = (...args) => _ctx.endZoomSub && _ctx.endZoomSub(...args)),
                  onMouseup: _cache[22] || (_cache[22] = (...args) => _ctx.endZoomSub && _ctx.endZoomSub(...args)),
                  class: "vicp-icon5"
                }, null, 32),
                createElementVNode("i", {
                  onMousedown: _cache[23] || (_cache[23] = (...args) => _ctx.startZoomAdd && _ctx.startZoomAdd(...args)),
                  onMouseout: _cache[24] || (_cache[24] = (...args) => _ctx.endZoomAdd && _ctx.endZoomAdd(...args)),
                  onMouseup: _cache[25] || (_cache[25] = (...args) => _ctx.endZoomAdd && _ctx.endZoomAdd(...args)),
                  class: "vicp-icon6"
                }, null, 32)
              ]),
              !_ctx.noRotate ? (openBlock(), createElementBlock("div", _hoisted_21$3, [
                createElementVNode("i", {
                  onMousedown: _cache[26] || (_cache[26] = (...args) => _ctx.startRotateLeft && _ctx.startRotateLeft(...args)),
                  onMouseout: _cache[27] || (_cache[27] = (...args) => _ctx.endRotate && _ctx.endRotate(...args)),
                  onMouseup: _cache[28] || (_cache[28] = (...args) => _ctx.endRotate && _ctx.endRotate(...args))
                }, "\u21BA", 32),
                createElementVNode("i", {
                  onMousedown: _cache[29] || (_cache[29] = (...args) => _ctx.startRotateRight && _ctx.startRotateRight(...args)),
                  onMouseout: _cache[30] || (_cache[30] = (...args) => _ctx.endRotate && _ctx.endRotate(...args)),
                  onMouseup: _cache[31] || (_cache[31] = (...args) => _ctx.endRotate && _ctx.endRotate(...args))
                }, "\u21BB", 32)
              ])) : createCommentVNode("v-if", true)
            ], 512), [
              [vShow, true]
            ]),
            withDirectives(createElementVNode("div", _hoisted_22$3, [
              createElementVNode("div", _hoisted_23$3, [
                createElementVNode("span", null, toDisplayString(_ctx.lang.preview), 1),
                !_ctx.noSquare ? (openBlock(), createElementBlock("div", _hoisted_24$3, [
                  createElementVNode("img", {
                    src: _ctx.createImgUrl,
                    style: normalizeStyle(_ctx.previewStyle)
                  }, null, 12, _hoisted_25$3)
                ])) : createCommentVNode("v-if", true),
                !_ctx.noCircle ? (openBlock(), createElementBlock("div", _hoisted_26$3, [
                  createElementVNode("img", {
                    src: _ctx.createImgUrl,
                    style: normalizeStyle(_ctx.previewStyle)
                  }, null, 12, _hoisted_27$3)
                ])) : createCommentVNode("v-if", true)
              ])
            ], 512), [
              [vShow, true]
            ])
          ])
        ])) : createCommentVNode("v-if", true),
        _ctx.step == 3 ? (openBlock(), createElementBlock("div", _hoisted_28$2, [
          createElementVNode("div", _hoisted_29$2, [
            withDirectives(createElementVNode("span", { class: "vicp-loading" }, toDisplayString(_ctx.lang.loading), 513), [
              [vShow, _ctx.loading === 1]
            ]),
            createElementVNode("div", _hoisted_30$2, [
              withDirectives(createElementVNode("span", {
                class: "vicp-progress",
                style: normalizeStyle(_ctx.progressStyle)
              }, null, 4), [
                [vShow, _ctx.loading === 1]
              ])
            ]),
            withDirectives(createElementVNode("div", _hoisted_31$2, [
              _hoisted_32$2,
              createTextVNode(" " + toDisplayString(_ctx.errorMsg), 1)
            ], 512), [
              [vShow, _ctx.hasError]
            ]),
            withDirectives(createElementVNode("div", _hoisted_33$2, [
              _hoisted_34$2,
              createTextVNode(" " + toDisplayString(_ctx.lang.success), 1)
            ], 512), [
              [vShow, _ctx.loading === 2]
            ])
          ])
        ])) : createCommentVNode("v-if", true),
        withDirectives(createElementVNode("canvas", {
          id: "canvas",
          width: _ctx.width,
          height: _ctx.height,
          ref: "canvasRef"
        }, null, 8, _hoisted_35$1), [
          [vShow, false]
        ])
      ])
    ]),
    _: 1
  }, 8, ["modelValue", "onClose"]);
}
var AwsuiUploadImage = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$x], ["__scopeId", "data-v-147c01c6"]]);
AwsuiUploadImage.install = (app) => {
  app.component(AwsuiUploadImage.name, AwsuiUploadImage);
};
const _sfc_main$w = defineComponent({
  name: "AwsuiCheckbox",
  components: {
    "el-checkbox": ElCheckbox,
    "el-checkbox-group": ElCheckboxGroup$1
  },
  inject: {
    awsuiForm: {
      default: ""
    }
  },
  props: {
    checkAll: {
      type: Boolean,
      default: false
    },
    group: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    className: String,
    size: {
      type: String,
      default: ""
    },
    list: {
      type: Array,
      default: function() {
        return [];
      }
    },
    checkedList: {
      type: Array,
      default: function() {
        return [];
      }
    },
    label: {}
  },
  data() {
    return {
      isCheckAll: false,
      isIndeterminate: true,
      clist: this.list,
      checkList: this.checkedList
    };
  },
  emits: ["click", "change"],
  computed: {
    checked: {
      get() {
        return this.$attrs.modelValue || false;
      },
      set(val) {
        this.$emit("update:modelValue", val);
      }
    },
    checkboxSize() {
      return this.size;
    },
    isDisabled() {
      return this.disabled || (this.awsuiForm || {}).disabled;
    }
  },
  methods: {
    change(val) {
      this.$emit("change", val);
      this.$emit("input", val);
    },
    changeList(data) {
      this.checkList = data;
      this.$emit("change", this.checkList);
      this.$emit("input", this.checkList);
    },
    handleCheckAllChange(val) {
      let list = [];
      this.list.forEach((item) => {
        list.push(item.value);
      });
      this.checkList = val ? list : [];
      this.isIndeterminate = false;
      this.$emit("change", this.checkList);
      this.$emit("input", this.checkList);
    },
    handleCheckedListChange(value2) {
      let checkedCount = value2.length;
      this.isCheckAll = checkedCount === this.list.length;
      this.isIndeterminate = checkedCount > 0 && checkedCount < this.list.length;
    }
  },
  watch: {
    checked(val) {
      this.checked = val;
    },
    checkedList(val) {
      this.checkList = val;
    }
  }
});
const _hoisted_1$i = { class: "awsui-component" };
const _hoisted_2$f = /* @__PURE__ */ createTextVNode(" \u5168\u9009 ");
const _hoisted_3$f = /* @__PURE__ */ createElementVNode("div", { style: { "margin": "15px 0" } }, null, -1);
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
  return openBlock(), createElementBlock("div", _hoisted_1$i, [
    _ctx.checkAll ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createVNode(_component_el_checkbox, {
        indeterminate: _ctx.isIndeterminate,
        modelValue: _ctx.isCheckAll,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.isCheckAll = $event),
        onChange: _ctx.handleCheckAllChange
      }, {
        default: withCtx(() => [
          _hoisted_2$f
        ]),
        _: 1
      }, 8, ["indeterminate", "modelValue", "onChange"]),
      _hoisted_3$f,
      createVNode(_component_el_checkbox_group, {
        modelValue: _ctx.checkList,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.checkList = $event),
        onChange: _ctx.handleCheckedListChange
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, index2) => {
            return openBlock(), createBlock(_component_el_checkbox, {
              key: index2,
              label: item.value,
              disabled: item.disabled || (_ctx.awsuiForm || {}).disabled,
              class: normalizeClass(["awsui-checkbox", [
                _ctx.checkboxSize ? "awsui-checkbox-" + _ctx.checkboxSize : "",
                _ctx.className ? _ctx.className : ""
              ]])
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(typeof item.label != "undefined" ? item.label : item.value), 1)
              ]),
              _: 2
            }, 1032, ["label", "disabled", "class"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["modelValue", "onChange"])
    ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      _ctx.group ? (openBlock(), createBlock(_component_el_checkbox_group, {
        key: 0,
        modelValue: _ctx.checkList,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.checkList = $event),
        onChange: _ctx.changeList
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, index2) => {
            return openBlock(), createBlock(_component_el_checkbox, {
              key: index2,
              label: item.value,
              disabled: item.disabled || (_ctx.awsuiForm || {}).disabled,
              class: normalizeClass(["awsui-checkbox", [
                _ctx.checkboxSize ? "awsui-checkbox-" + _ctx.checkboxSize : "",
                _ctx.className ? _ctx.className : ""
              ]])
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(typeof item.label != "undefined" ? item.label : item.value), 1)
              ]),
              _: 2
            }, 1032, ["label", "disabled", "class"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["modelValue", "onChange"])) : (openBlock(), createBlock(_component_el_checkbox, mergeProps({
        key: 1,
        label: _ctx.label !== void 0 ? _ctx.label : ""
      }, _ctx.$attrs, {
        modelValue: _ctx.checked,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.checked = $event),
        disabled: _ctx.isDisabled,
        class: ["awsui-checkbox", [
          _ctx.checkboxSize ? "awsui-checkbox-" + _ctx.checkboxSize : "",
          _ctx.className ? _ctx.className : ""
        ]],
        onChange: _ctx.change
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["label", "modelValue", "disabled", "class", "onChange"]))
    ], 2112))
  ]);
}
var AwsuiCheckbox = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$w]]);
AwsuiCheckbox.install = (app) => {
  app.component(AwsuiCheckbox.name, AwsuiCheckbox);
};
var velocity_min = { exports: {} };
/*! VelocityJS.org (1.5.2). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
(function(module) {
  /*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
  !function(a) {
    function b(a2) {
      var b2 = a2.length, d2 = c.type(a2);
      return d2 !== "function" && !c.isWindow(a2) && (!(a2.nodeType !== 1 || !b2) || (d2 === "array" || b2 === 0 || typeof b2 == "number" && b2 > 0 && b2 - 1 in a2));
    }
    if (!a.jQuery) {
      var c = function(a2, b2) {
        return new c.fn.init(a2, b2);
      };
      c.isWindow = function(a2) {
        return a2 && a2 === a2.window;
      }, c.type = function(a2) {
        return a2 ? typeof a2 == "object" || typeof a2 == "function" ? e[g.call(a2)] || "object" : typeof a2 : a2 + "";
      }, c.isArray = Array.isArray || function(a2) {
        return c.type(a2) === "array";
      }, c.isPlainObject = function(a2) {
        var b2;
        if (!a2 || c.type(a2) !== "object" || a2.nodeType || c.isWindow(a2))
          return false;
        try {
          if (a2.constructor && !f.call(a2, "constructor") && !f.call(a2.constructor.prototype, "isPrototypeOf"))
            return false;
        } catch (d2) {
          return false;
        }
        for (b2 in a2)
          ;
        return b2 === void 0 || f.call(a2, b2);
      }, c.each = function(a2, c2, d2) {
        var e2 = 0, f2 = a2.length, g2 = b(a2);
        if (d2) {
          if (g2)
            for (; e2 < f2 && c2.apply(a2[e2], d2) !== false; e2++)
              ;
          else
            for (e2 in a2)
              if (a2.hasOwnProperty(e2) && c2.apply(a2[e2], d2) === false)
                break;
        } else if (g2)
          for (; e2 < f2 && c2.call(a2[e2], e2, a2[e2]) !== false; e2++)
            ;
        else
          for (e2 in a2)
            if (a2.hasOwnProperty(e2) && c2.call(a2[e2], e2, a2[e2]) === false)
              break;
        return a2;
      }, c.data = function(a2, b2, e2) {
        if (e2 === void 0) {
          var f2 = a2[c.expando], g2 = f2 && d[f2];
          if (b2 === void 0)
            return g2;
          if (g2 && b2 in g2)
            return g2[b2];
        } else if (b2 !== void 0) {
          var h3 = a2[c.expando] || (a2[c.expando] = ++c.uuid);
          return d[h3] = d[h3] || {}, d[h3][b2] = e2, e2;
        }
      }, c.removeData = function(a2, b2) {
        var e2 = a2[c.expando], f2 = e2 && d[e2];
        f2 && (b2 ? c.each(b2, function(a3, b3) {
          delete f2[b3];
        }) : delete d[e2]);
      }, c.extend = function() {
        var a2, b2, d2, e2, f2, g2, h3 = arguments[0] || {}, i3 = 1, j = arguments.length, k = false;
        for (typeof h3 == "boolean" && (k = h3, h3 = arguments[i3] || {}, i3++), typeof h3 != "object" && c.type(h3) !== "function" && (h3 = {}), i3 === j && (h3 = this, i3--); i3 < j; i3++)
          if (f2 = arguments[i3])
            for (e2 in f2)
              f2.hasOwnProperty(e2) && (a2 = h3[e2], d2 = f2[e2], h3 !== d2 && (k && d2 && (c.isPlainObject(d2) || (b2 = c.isArray(d2))) ? (b2 ? (b2 = false, g2 = a2 && c.isArray(a2) ? a2 : []) : g2 = a2 && c.isPlainObject(a2) ? a2 : {}, h3[e2] = c.extend(k, g2, d2)) : d2 !== void 0 && (h3[e2] = d2)));
        return h3;
      }, c.queue = function(a2, d2, e2) {
        if (a2) {
          d2 = (d2 || "fx") + "queue";
          var f2 = c.data(a2, d2);
          return e2 ? (!f2 || c.isArray(e2) ? f2 = c.data(a2, d2, function(a3, c2) {
            var d3 = c2 || [];
            return a3 && (b(Object(a3)) ? function(a4, b2) {
              for (var c3 = +b2.length, d4 = 0, e3 = a4.length; d4 < c3; )
                a4[e3++] = b2[d4++];
              if (c3 !== c3)
                for (; b2[d4] !== void 0; )
                  a4[e3++] = b2[d4++];
              a4.length = e3;
            }(d3, typeof a3 == "string" ? [a3] : a3) : [].push.call(d3, a3)), d3;
          }(e2)) : f2.push(e2), f2) : f2 || [];
        }
      }, c.dequeue = function(a2, b2) {
        c.each(a2.nodeType ? [a2] : a2, function(a3, d2) {
          b2 = b2 || "fx";
          var e2 = c.queue(d2, b2), f2 = e2.shift();
          f2 === "inprogress" && (f2 = e2.shift()), f2 && (b2 === "fx" && e2.unshift("inprogress"), f2.call(d2, function() {
            c.dequeue(d2, b2);
          }));
        });
      }, c.fn = c.prototype = { init: function(a2) {
        if (a2.nodeType)
          return this[0] = a2, this;
        throw new Error("Not a DOM node.");
      }, offset: function() {
        var b2 = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : { top: 0, left: 0 };
        return { top: b2.top + (a.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0), left: b2.left + (a.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0) };
      }, position: function() {
        var a2 = this[0], b2 = function(a3) {
          for (var b3 = a3.offsetParent; b3 && b3.nodeName.toLowerCase() !== "html" && b3.style && b3.style.position.toLowerCase() === "static"; )
            b3 = b3.offsetParent;
          return b3 || document;
        }(a2), d2 = this.offset(), e2 = /^(?:body|html)$/i.test(b2.nodeName) ? { top: 0, left: 0 } : c(b2).offset();
        return d2.top -= parseFloat(a2.style.marginTop) || 0, d2.left -= parseFloat(a2.style.marginLeft) || 0, b2.style && (e2.top += parseFloat(b2.style.borderTopWidth) || 0, e2.left += parseFloat(b2.style.borderLeftWidth) || 0), { top: d2.top - e2.top, left: d2.left - e2.left };
      } };
      var d = {};
      c.expando = "velocity" + new Date().getTime(), c.uuid = 0;
      for (var e = {}, f = e.hasOwnProperty, g = e.toString, h2 = "Boolean Number String Function Array Date RegExp Object Error".split(" "), i2 = 0; i2 < h2.length; i2++)
        e["[object " + h2[i2] + "]"] = h2[i2].toLowerCase();
      c.fn.init.prototype = c.fn, a.Velocity = { Utilities: c };
    }
  }(window), function(a) {
    module.exports = a();
  }(function() {
    return function(a, b, c, d) {
      function e(a2) {
        for (var b2 = -1, c2 = a2 ? a2.length : 0, d2 = []; ++b2 < c2; ) {
          var e2 = a2[b2];
          e2 && d2.push(e2);
        }
        return d2;
      }
      function f(a2) {
        return u.isWrapped(a2) ? a2 = s.call(a2) : u.isNode(a2) && (a2 = [a2]), a2;
      }
      function g(a2) {
        var b2 = o.data(a2, "velocity");
        return b2 === null ? d : b2;
      }
      function h2(a2, b2) {
        var c2 = g(a2);
        c2 && c2.delayTimer && !c2.delayPaused && (c2.delayRemaining = c2.delay - b2 + c2.delayBegin, c2.delayPaused = true, clearTimeout(c2.delayTimer.setTimeout));
      }
      function i2(a2, b2) {
        var c2 = g(a2);
        c2 && c2.delayTimer && c2.delayPaused && (c2.delayPaused = false, c2.delayTimer.setTimeout = setTimeout(c2.delayTimer.next, c2.delayRemaining));
      }
      function j(a2) {
        return function(b2) {
          return Math.round(b2 * a2) * (1 / a2);
        };
      }
      function k(a2, c2, d2, e2) {
        function f2(a3, b2) {
          return 1 - 3 * b2 + 3 * a3;
        }
        function g2(a3, b2) {
          return 3 * b2 - 6 * a3;
        }
        function h3(a3) {
          return 3 * a3;
        }
        function i3(a3, b2, c3) {
          return ((f2(b2, c3) * a3 + g2(b2, c3)) * a3 + h3(b2)) * a3;
        }
        function j2(a3, b2, c3) {
          return 3 * f2(b2, c3) * a3 * a3 + 2 * g2(b2, c3) * a3 + h3(b2);
        }
        function k2(b2, c3) {
          for (var e3 = 0; e3 < p2; ++e3) {
            var f3 = j2(c3, a2, d2);
            if (f3 === 0)
              return c3;
            c3 -= (i3(c3, a2, d2) - b2) / f3;
          }
          return c3;
        }
        function l2() {
          for (var b2 = 0; b2 < t2; ++b2)
            x2[b2] = i3(b2 * u2, a2, d2);
        }
        function m2(b2, c3, e3) {
          var f3, g3, h4 = 0;
          do {
            g3 = c3 + (e3 - c3) / 2, f3 = i3(g3, a2, d2) - b2, f3 > 0 ? e3 = g3 : c3 = g3;
          } while (Math.abs(f3) > r2 && ++h4 < s2);
          return g3;
        }
        function n2(b2) {
          for (var c3 = 0, e3 = 1, f3 = t2 - 1; e3 !== f3 && x2[e3] <= b2; ++e3)
            c3 += u2;
          --e3;
          var g3 = (b2 - x2[e3]) / (x2[e3 + 1] - x2[e3]), h4 = c3 + g3 * u2, i4 = j2(h4, a2, d2);
          return i4 >= q2 ? k2(b2, h4) : i4 === 0 ? h4 : m2(b2, c3, c3 + u2);
        }
        function o2() {
          y2 = true, a2 === c2 && d2 === e2 || l2();
        }
        var p2 = 4, q2 = 1e-3, r2 = 1e-7, s2 = 10, t2 = 11, u2 = 1 / (t2 - 1), v2 = "Float32Array" in b;
        if (arguments.length !== 4)
          return false;
        for (var w2 = 0; w2 < 4; ++w2)
          if (typeof arguments[w2] != "number" || isNaN(arguments[w2]) || !isFinite(arguments[w2]))
            return false;
        a2 = Math.min(a2, 1), d2 = Math.min(d2, 1), a2 = Math.max(a2, 0), d2 = Math.max(d2, 0);
        var x2 = v2 ? new Float32Array(t2) : new Array(t2), y2 = false, z2 = function(b2) {
          return y2 || o2(), a2 === c2 && d2 === e2 ? b2 : b2 === 0 ? 0 : b2 === 1 ? 1 : i3(n2(b2), c2, e2);
        };
        z2.getControlPoints = function() {
          return [{ x: a2, y: c2 }, { x: d2, y: e2 }];
        };
        var A2 = "generateBezier(" + [a2, c2, d2, e2] + ")";
        return z2.toString = function() {
          return A2;
        }, z2;
      }
      function l(a2, b2) {
        var c2 = a2;
        return u.isString(a2) ? y.Easings[a2] || (c2 = false) : c2 = u.isArray(a2) && a2.length === 1 ? j.apply(null, a2) : u.isArray(a2) && a2.length === 2 ? z.apply(null, a2.concat([b2])) : !(!u.isArray(a2) || a2.length !== 4) && k.apply(null, a2), c2 === false && (c2 = y.Easings[y.defaults.easing] ? y.defaults.easing : x), c2;
      }
      function m(a2) {
        if (a2) {
          var b2 = y.timestamp && a2 !== true ? a2 : r.now(), c2 = y.State.calls.length;
          c2 > 1e4 && (y.State.calls = e(y.State.calls), c2 = y.State.calls.length);
          for (var f2 = 0; f2 < c2; f2++)
            if (y.State.calls[f2]) {
              var h3 = y.State.calls[f2], i3 = h3[0], j2 = h3[2], k2 = h3[3], l2 = !k2, q2 = null, s2 = h3[5], t2 = h3[6];
              if (k2 || (k2 = y.State.calls[f2][3] = b2 - 16), s2) {
                if (s2.resume !== true)
                  continue;
                k2 = h3[3] = Math.round(b2 - t2 - 16), h3[5] = null;
              }
              t2 = h3[6] = b2 - k2;
              for (var v2 = Math.min(t2 / j2.duration, 1), w2 = 0, x2 = i3.length; w2 < x2; w2++) {
                var z2 = i3[w2], B2 = z2.element;
                if (g(B2)) {
                  var D2 = false;
                  if (j2.display !== d && j2.display !== null && j2.display !== "none") {
                    if (j2.display === "flex") {
                      var E = ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex"];
                      o.each(E, function(a3, b3) {
                        A.setPropertyValue(B2, "display", b3);
                      });
                    }
                    A.setPropertyValue(B2, "display", j2.display);
                  }
                  j2.visibility !== d && j2.visibility !== "hidden" && A.setPropertyValue(B2, "visibility", j2.visibility);
                  for (var F in z2)
                    if (z2.hasOwnProperty(F) && F !== "element") {
                      var G, H = z2[F], I = u.isString(H.easing) ? y.Easings[H.easing] : H.easing;
                      if (u.isString(H.pattern)) {
                        var J = v2 === 1 ? function(a3, b3, c3) {
                          var d2 = H.endValue[b3];
                          return c3 ? Math.round(d2) : d2;
                        } : function(a3, b3, c3) {
                          var d2 = H.startValue[b3], e2 = H.endValue[b3] - d2, f3 = d2 + e2 * I(v2, j2, e2);
                          return c3 ? Math.round(f3) : f3;
                        };
                        G = H.pattern.replace(/{(\d+)(!)?}/g, J);
                      } else if (v2 === 1)
                        G = H.endValue;
                      else {
                        var K = H.endValue - H.startValue;
                        G = H.startValue + K * I(v2, j2, K);
                      }
                      if (!l2 && G === H.currentValue)
                        continue;
                      if (H.currentValue = G, F === "tween")
                        q2 = G;
                      else {
                        var L;
                        if (A.Hooks.registered[F]) {
                          L = A.Hooks.getRoot(F);
                          var M = g(B2).rootPropertyValueCache[L];
                          M && (H.rootPropertyValue = M);
                        }
                        var N = A.setPropertyValue(B2, F, H.currentValue + (p < 9 && parseFloat(G) === 0 ? "" : H.unitType), H.rootPropertyValue, H.scrollData);
                        A.Hooks.registered[F] && (A.Normalizations.registered[L] ? g(B2).rootPropertyValueCache[L] = A.Normalizations.registered[L]("extract", null, N[1]) : g(B2).rootPropertyValueCache[L] = N[1]), N[0] === "transform" && (D2 = true);
                      }
                    }
                  j2.mobileHA && g(B2).transformCache.translate3d === d && (g(B2).transformCache.translate3d = "(0px, 0px, 0px)", D2 = true), D2 && A.flushTransformCache(B2);
                }
              }
              j2.display !== d && j2.display !== "none" && (y.State.calls[f2][2].display = false), j2.visibility !== d && j2.visibility !== "hidden" && (y.State.calls[f2][2].visibility = false), j2.progress && j2.progress.call(h3[1], h3[1], v2, Math.max(0, k2 + j2.duration - b2), k2, q2), v2 === 1 && n(f2);
            }
        }
        y.State.isTicking && C(m);
      }
      function n(a2, b2) {
        if (!y.State.calls[a2])
          return false;
        for (var c2 = y.State.calls[a2][0], e2 = y.State.calls[a2][1], f2 = y.State.calls[a2][2], h3 = y.State.calls[a2][4], i3 = false, j2 = 0, k2 = c2.length; j2 < k2; j2++) {
          var l2 = c2[j2].element;
          b2 || f2.loop || (f2.display === "none" && A.setPropertyValue(l2, "display", f2.display), f2.visibility === "hidden" && A.setPropertyValue(l2, "visibility", f2.visibility));
          var m2 = g(l2);
          if (f2.loop !== true && (o.queue(l2)[1] === d || !/\.velocityQueueEntryFlag/i.test(o.queue(l2)[1])) && m2) {
            m2.isAnimating = false, m2.rootPropertyValueCache = {};
            var n2 = false;
            o.each(A.Lists.transforms3D, function(a3, b3) {
              var c3 = /^scale/.test(b3) ? 1 : 0, e3 = m2.transformCache[b3];
              m2.transformCache[b3] !== d && new RegExp("^\\(" + c3 + "[^.]").test(e3) && (n2 = true, delete m2.transformCache[b3]);
            }), f2.mobileHA && (n2 = true, delete m2.transformCache.translate3d), n2 && A.flushTransformCache(l2), A.Values.removeClass(l2, "velocity-animating");
          }
          if (!b2 && f2.complete && !f2.loop && j2 === k2 - 1)
            try {
              f2.complete.call(e2, e2);
            } catch (r2) {
              setTimeout(function() {
                throw r2;
              }, 1);
            }
          h3 && f2.loop !== true && h3(e2), m2 && f2.loop === true && !b2 && (o.each(m2.tweensContainer, function(a3, b3) {
            if (/^rotate/.test(a3) && (parseFloat(b3.startValue) - parseFloat(b3.endValue)) % 360 == 0) {
              var c3 = b3.startValue;
              b3.startValue = b3.endValue, b3.endValue = c3;
            }
            /^backgroundPosition/.test(a3) && parseFloat(b3.endValue) === 100 && b3.unitType === "%" && (b3.endValue = 0, b3.startValue = 100);
          }), y(l2, "reverse", { loop: true, delay: f2.delay })), f2.queue !== false && o.dequeue(l2, f2.queue);
        }
        y.State.calls[a2] = false;
        for (var p2 = 0, q2 = y.State.calls.length; p2 < q2; p2++)
          if (y.State.calls[p2] !== false) {
            i3 = true;
            break;
          }
        i3 === false && (y.State.isTicking = false, delete y.State.calls, y.State.calls = []);
      }
      var o, p = function() {
        if (c.documentMode)
          return c.documentMode;
        for (var a2 = 7; a2 > 4; a2--) {
          var b2 = c.createElement("div");
          if (b2.innerHTML = "<!--[if IE " + a2 + "]><span></span><![endif]-->", b2.getElementsByTagName("span").length)
            return b2 = null, a2;
        }
        return d;
      }(), q = function() {
        var a2 = 0;
        return b.webkitRequestAnimationFrame || b.mozRequestAnimationFrame || function(b2) {
          var c2, d2 = new Date().getTime();
          return c2 = Math.max(0, 16 - (d2 - a2)), a2 = d2 + c2, setTimeout(function() {
            b2(d2 + c2);
          }, c2);
        };
      }(), r = function() {
        var a2 = b.performance || {};
        if (typeof a2.now != "function") {
          var c2 = a2.timing && a2.timing.navigationStart ? a2.timing.navigationStart : new Date().getTime();
          a2.now = function() {
            return new Date().getTime() - c2;
          };
        }
        return a2;
      }(), s = function() {
        var a2 = Array.prototype.slice;
        try {
          return a2.call(c.documentElement), a2;
        } catch (b2) {
          return function(b3, c2) {
            var d2 = this.length;
            if (typeof b3 != "number" && (b3 = 0), typeof c2 != "number" && (c2 = d2), this.slice)
              return a2.call(this, b3, c2);
            var e2, f2 = [], g2 = b3 >= 0 ? b3 : Math.max(0, d2 + b3), h3 = c2 < 0 ? d2 + c2 : Math.min(c2, d2), i3 = h3 - g2;
            if (i3 > 0)
              if (f2 = new Array(i3), this.charAt)
                for (e2 = 0; e2 < i3; e2++)
                  f2[e2] = this.charAt(g2 + e2);
              else
                for (e2 = 0; e2 < i3; e2++)
                  f2[e2] = this[g2 + e2];
            return f2;
          };
        }
      }(), t = function() {
        return Array.prototype.includes ? function(a2, b2) {
          return a2.includes(b2);
        } : Array.prototype.indexOf ? function(a2, b2) {
          return a2.indexOf(b2) >= 0;
        } : function(a2, b2) {
          for (var c2 = 0; c2 < a2.length; c2++)
            if (a2[c2] === b2)
              return true;
          return false;
        };
      }, u = { isNumber: function(a2) {
        return typeof a2 == "number";
      }, isString: function(a2) {
        return typeof a2 == "string";
      }, isArray: Array.isArray || function(a2) {
        return Object.prototype.toString.call(a2) === "[object Array]";
      }, isFunction: function(a2) {
        return Object.prototype.toString.call(a2) === "[object Function]";
      }, isNode: function(a2) {
        return a2 && a2.nodeType;
      }, isWrapped: function(a2) {
        return a2 && a2 !== b && u.isNumber(a2.length) && !u.isString(a2) && !u.isFunction(a2) && !u.isNode(a2) && (a2.length === 0 || u.isNode(a2[0]));
      }, isSVG: function(a2) {
        return b.SVGElement && a2 instanceof b.SVGElement;
      }, isEmptyObject: function(a2) {
        for (var b2 in a2)
          if (a2.hasOwnProperty(b2))
            return false;
        return true;
      } }, v = false;
      if (a.fn && a.fn.jquery ? (o = a, v = true) : o = b.Velocity.Utilities, p <= 8 && !v)
        throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
      if (p <= 7)
        return void (jQuery.fn.velocity = jQuery.fn.animate);
      var w = 400, x = "swing", y = { State: { isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(b.navigator.userAgent), isAndroid: /Android/i.test(b.navigator.userAgent), isGingerbread: /Android 2\.3\.[3-7]/i.test(b.navigator.userAgent), isChrome: b.chrome, isFirefox: /Firefox/i.test(b.navigator.userAgent), prefixElement: c.createElement("div"), prefixMatches: {}, scrollAnchor: null, scrollPropertyLeft: null, scrollPropertyTop: null, isTicking: false, calls: [], delayedElements: { count: 0 } }, CSS: {}, Utilities: o, Redirects: {}, Easings: {}, Promise: b.Promise, defaults: { queue: "", duration: w, easing: x, begin: d, complete: d, progress: d, display: d, visibility: d, loop: false, delay: false, mobileHA: true, _cacheValues: true, promiseRejectEmpty: true }, init: function(a2) {
        o.data(a2, "velocity", { isSVG: u.isSVG(a2), isAnimating: false, computedStyle: null, tweensContainer: null, rootPropertyValueCache: {}, transformCache: {} });
      }, hook: null, mock: false, version: { major: 1, minor: 5, patch: 2 }, debug: false, timestamp: true, pauseAll: function(a2) {
        var b2 = new Date().getTime();
        o.each(y.State.calls, function(b3, c2) {
          if (c2) {
            if (a2 !== d && (c2[2].queue !== a2 || c2[2].queue === false))
              return true;
            c2[5] = { resume: false };
          }
        }), o.each(y.State.delayedElements, function(a3, c2) {
          c2 && h2(c2, b2);
        });
      }, resumeAll: function(a2) {
        new Date().getTime();
        o.each(y.State.calls, function(b2, c2) {
          if (c2) {
            if (a2 !== d && (c2[2].queue !== a2 || c2[2].queue === false))
              return true;
            c2[5] && (c2[5].resume = true);
          }
        }), o.each(y.State.delayedElements, function(a3, c2) {
          c2 && i2(c2);
        });
      } };
      b.pageYOffset !== d ? (y.State.scrollAnchor = b, y.State.scrollPropertyLeft = "pageXOffset", y.State.scrollPropertyTop = "pageYOffset") : (y.State.scrollAnchor = c.documentElement || c.body.parentNode || c.body, y.State.scrollPropertyLeft = "scrollLeft", y.State.scrollPropertyTop = "scrollTop");
      var z = function() {
        function a2(a3) {
          return -a3.tension * a3.x - a3.friction * a3.v;
        }
        function b2(b3, c3, d2) {
          var e2 = { x: b3.x + d2.dx * c3, v: b3.v + d2.dv * c3, tension: b3.tension, friction: b3.friction };
          return { dx: e2.v, dv: a2(e2) };
        }
        function c2(c3, d2) {
          var e2 = { dx: c3.v, dv: a2(c3) }, f2 = b2(c3, 0.5 * d2, e2), g2 = b2(c3, 0.5 * d2, f2), h3 = b2(c3, d2, g2), i3 = 1 / 6 * (e2.dx + 2 * (f2.dx + g2.dx) + h3.dx), j2 = 1 / 6 * (e2.dv + 2 * (f2.dv + g2.dv) + h3.dv);
          return c3.x = c3.x + i3 * d2, c3.v = c3.v + j2 * d2, c3;
        }
        return function d2(a3, b3, e2) {
          var f2, g2, h3, i3 = { x: -1, v: 0, tension: null, friction: null }, j2 = [0], k2 = 0;
          for (a3 = parseFloat(a3) || 500, b3 = parseFloat(b3) || 20, e2 = e2 || null, i3.tension = a3, i3.friction = b3, f2 = e2 !== null, f2 ? (k2 = d2(a3, b3), g2 = k2 / e2 * 0.016) : g2 = 0.016; ; )
            if (h3 = c2(h3 || i3, g2), j2.push(1 + h3.x), k2 += 16, !(Math.abs(h3.x) > 1e-4 && Math.abs(h3.v) > 1e-4))
              break;
          return f2 ? function(a4) {
            return j2[a4 * (j2.length - 1) | 0];
          } : k2;
        };
      }();
      y.Easings = { linear: function(a2) {
        return a2;
      }, swing: function(a2) {
        return 0.5 - Math.cos(a2 * Math.PI) / 2;
      }, spring: function(a2) {
        return 1 - Math.cos(4.5 * a2 * Math.PI) * Math.exp(6 * -a2);
      } }, o.each([["ease", [0.25, 0.1, 0.25, 1]], ["ease-in", [0.42, 0, 1, 1]], ["ease-out", [0, 0, 0.58, 1]], ["ease-in-out", [0.42, 0, 0.58, 1]], ["easeInSine", [0.47, 0, 0.745, 0.715]], ["easeOutSine", [0.39, 0.575, 0.565, 1]], ["easeInOutSine", [0.445, 0.05, 0.55, 0.95]], ["easeInQuad", [0.55, 0.085, 0.68, 0.53]], ["easeOutQuad", [0.25, 0.46, 0.45, 0.94]], ["easeInOutQuad", [0.455, 0.03, 0.515, 0.955]], ["easeInCubic", [0.55, 0.055, 0.675, 0.19]], ["easeOutCubic", [0.215, 0.61, 0.355, 1]], ["easeInOutCubic", [0.645, 0.045, 0.355, 1]], ["easeInQuart", [0.895, 0.03, 0.685, 0.22]], ["easeOutQuart", [0.165, 0.84, 0.44, 1]], ["easeInOutQuart", [0.77, 0, 0.175, 1]], ["easeInQuint", [0.755, 0.05, 0.855, 0.06]], ["easeOutQuint", [0.23, 1, 0.32, 1]], ["easeInOutQuint", [0.86, 0, 0.07, 1]], ["easeInExpo", [0.95, 0.05, 0.795, 0.035]], ["easeOutExpo", [0.19, 1, 0.22, 1]], ["easeInOutExpo", [1, 0, 0, 1]], ["easeInCirc", [0.6, 0.04, 0.98, 0.335]], ["easeOutCirc", [0.075, 0.82, 0.165, 1]], ["easeInOutCirc", [0.785, 0.135, 0.15, 0.86]]], function(a2, b2) {
        y.Easings[b2[0]] = k.apply(null, b2[1]);
      });
      var A = y.CSS = { RegEx: { isHex: /^#([A-f\d]{3}){1,2}$/i, valueUnwrap: /^[A-z]+\((.*)\)$/i, wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/, valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi }, Lists: { colors: ["fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor"], transformsBase: ["translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ"], transforms3D: ["transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY"], units: ["%", "em", "ex", "ch", "rem", "vw", "vh", "vmin", "vmax", "cm", "mm", "Q", "in", "pc", "pt", "px", "deg", "grad", "rad", "turn", "s", "ms"], colorNames: { aliceblue: "240,248,255", antiquewhite: "250,235,215", aquamarine: "127,255,212", aqua: "0,255,255", azure: "240,255,255", beige: "245,245,220", bisque: "255,228,196", black: "0,0,0", blanchedalmond: "255,235,205", blueviolet: "138,43,226", blue: "0,0,255", brown: "165,42,42", burlywood: "222,184,135", cadetblue: "95,158,160", chartreuse: "127,255,0", chocolate: "210,105,30", coral: "255,127,80", cornflowerblue: "100,149,237", cornsilk: "255,248,220", crimson: "220,20,60", cyan: "0,255,255", darkblue: "0,0,139", darkcyan: "0,139,139", darkgoldenrod: "184,134,11", darkgray: "169,169,169", darkgrey: "169,169,169", darkgreen: "0,100,0", darkkhaki: "189,183,107", darkmagenta: "139,0,139", darkolivegreen: "85,107,47", darkorange: "255,140,0", darkorchid: "153,50,204", darkred: "139,0,0", darksalmon: "233,150,122", darkseagreen: "143,188,143", darkslateblue: "72,61,139", darkslategray: "47,79,79", darkturquoise: "0,206,209", darkviolet: "148,0,211", deeppink: "255,20,147", deepskyblue: "0,191,255", dimgray: "105,105,105", dimgrey: "105,105,105", dodgerblue: "30,144,255", firebrick: "178,34,34", floralwhite: "255,250,240", forestgreen: "34,139,34", fuchsia: "255,0,255", gainsboro: "220,220,220", ghostwhite: "248,248,255", gold: "255,215,0", goldenrod: "218,165,32", gray: "128,128,128", grey: "128,128,128", greenyellow: "173,255,47", green: "0,128,0", honeydew: "240,255,240", hotpink: "255,105,180", indianred: "205,92,92", indigo: "75,0,130", ivory: "255,255,240", khaki: "240,230,140", lavenderblush: "255,240,245", lavender: "230,230,250", lawngreen: "124,252,0", lemonchiffon: "255,250,205", lightblue: "173,216,230", lightcoral: "240,128,128", lightcyan: "224,255,255", lightgoldenrodyellow: "250,250,210", lightgray: "211,211,211", lightgrey: "211,211,211", lightgreen: "144,238,144", lightpink: "255,182,193", lightsalmon: "255,160,122", lightseagreen: "32,178,170", lightskyblue: "135,206,250", lightslategray: "119,136,153", lightsteelblue: "176,196,222", lightyellow: "255,255,224", limegreen: "50,205,50", lime: "0,255,0", linen: "250,240,230", magenta: "255,0,255", maroon: "128,0,0", mediumaquamarine: "102,205,170", mediumblue: "0,0,205", mediumorchid: "186,85,211", mediumpurple: "147,112,219", mediumseagreen: "60,179,113", mediumslateblue: "123,104,238", mediumspringgreen: "0,250,154", mediumturquoise: "72,209,204", mediumvioletred: "199,21,133", midnightblue: "25,25,112", mintcream: "245,255,250", mistyrose: "255,228,225", moccasin: "255,228,181", navajowhite: "255,222,173", navy: "0,0,128", oldlace: "253,245,230", olivedrab: "107,142,35", olive: "128,128,0", orangered: "255,69,0", orange: "255,165,0", orchid: "218,112,214", palegoldenrod: "238,232,170", palegreen: "152,251,152", paleturquoise: "175,238,238", palevioletred: "219,112,147", papayawhip: "255,239,213", peachpuff: "255,218,185", peru: "205,133,63", pink: "255,192,203", plum: "221,160,221", powderblue: "176,224,230", purple: "128,0,128", red: "255,0,0", rosybrown: "188,143,143", royalblue: "65,105,225", saddlebrown: "139,69,19", salmon: "250,128,114", sandybrown: "244,164,96", seagreen: "46,139,87", seashell: "255,245,238", sienna: "160,82,45", silver: "192,192,192", skyblue: "135,206,235", slateblue: "106,90,205", slategray: "112,128,144", snow: "255,250,250", springgreen: "0,255,127", steelblue: "70,130,180", tan: "210,180,140", teal: "0,128,128", thistle: "216,191,216", tomato: "255,99,71", turquoise: "64,224,208", violet: "238,130,238", wheat: "245,222,179", whitesmoke: "245,245,245", white: "255,255,255", yellowgreen: "154,205,50", yellow: "255,255,0" } }, Hooks: { templates: { textShadow: ["Color X Y Blur", "black 0px 0px 0px"], boxShadow: ["Color X Y Blur Spread", "black 0px 0px 0px 0px"], clip: ["Top Right Bottom Left", "0px 0px 0px 0px"], backgroundPosition: ["X Y", "0% 0%"], transformOrigin: ["X Y Z", "50% 50% 0px"], perspectiveOrigin: ["X Y", "50% 50%"] }, registered: {}, register: function() {
        for (var a2 = 0; a2 < A.Lists.colors.length; a2++) {
          var b2 = A.Lists.colors[a2] === "color" ? "0 0 0 1" : "255 255 255 1";
          A.Hooks.templates[A.Lists.colors[a2]] = ["Red Green Blue Alpha", b2];
        }
        var c2, d2, e2;
        if (p) {
          for (c2 in A.Hooks.templates)
            if (A.Hooks.templates.hasOwnProperty(c2)) {
              d2 = A.Hooks.templates[c2], e2 = d2[0].split(" ");
              var f2 = d2[1].match(A.RegEx.valueSplit);
              e2[0] === "Color" && (e2.push(e2.shift()), f2.push(f2.shift()), A.Hooks.templates[c2] = [e2.join(" "), f2.join(" ")]);
            }
        }
        for (c2 in A.Hooks.templates)
          if (A.Hooks.templates.hasOwnProperty(c2)) {
            d2 = A.Hooks.templates[c2], e2 = d2[0].split(" ");
            for (var g2 in e2)
              if (e2.hasOwnProperty(g2)) {
                var h3 = c2 + e2[g2], i3 = g2;
                A.Hooks.registered[h3] = [c2, i3];
              }
          }
      }, getRoot: function(a2) {
        var b2 = A.Hooks.registered[a2];
        return b2 ? b2[0] : a2;
      }, getUnit: function(a2, b2) {
        var c2 = (a2.substr(b2 || 0, 5).match(/^[a-z%]+/) || [])[0] || "";
        return c2 && t(A.Lists.units) ? c2 : "";
      }, fixColors: function(a2) {
        return a2.replace(/(rgba?\(\s*)?(\b[a-z]+\b)/g, function(a3, b2, c2) {
          return A.Lists.colorNames.hasOwnProperty(c2) ? (b2 || "rgba(") + A.Lists.colorNames[c2] + (b2 ? "" : ",1)") : b2 + c2;
        });
      }, cleanRootPropertyValue: function(a2, b2) {
        return A.RegEx.valueUnwrap.test(b2) && (b2 = b2.match(A.RegEx.valueUnwrap)[1]), A.Values.isCSSNullValue(b2) && (b2 = A.Hooks.templates[a2][1]), b2;
      }, extractValue: function(a2, b2) {
        var c2 = A.Hooks.registered[a2];
        if (c2) {
          var d2 = c2[0], e2 = c2[1];
          return b2 = A.Hooks.cleanRootPropertyValue(d2, b2), b2.toString().match(A.RegEx.valueSplit)[e2];
        }
        return b2;
      }, injectValue: function(a2, b2, c2) {
        var d2 = A.Hooks.registered[a2];
        if (d2) {
          var e2, f2 = d2[0], g2 = d2[1];
          return c2 = A.Hooks.cleanRootPropertyValue(f2, c2), e2 = c2.toString().match(A.RegEx.valueSplit), e2[g2] = b2, e2.join(" ");
        }
        return c2;
      } }, Normalizations: { registered: { clip: function(a2, b2, c2) {
        switch (a2) {
          case "name":
            return "clip";
          case "extract":
            var d2;
            return A.RegEx.wrappedValueAlreadyExtracted.test(c2) ? d2 = c2 : (d2 = c2.toString().match(A.RegEx.valueUnwrap), d2 = d2 ? d2[1].replace(/,(\s+)?/g, " ") : c2), d2;
          case "inject":
            return "rect(" + c2 + ")";
        }
      }, blur: function(a2, b2, c2) {
        switch (a2) {
          case "name":
            return y.State.isFirefox ? "filter" : "-webkit-filter";
          case "extract":
            var d2 = parseFloat(c2);
            if (!d2 && d2 !== 0) {
              var e2 = c2.toString().match(/blur\(([0-9]+[A-z]+)\)/i);
              d2 = e2 ? e2[1] : 0;
            }
            return d2;
          case "inject":
            return parseFloat(c2) ? "blur(" + c2 + ")" : "none";
        }
      }, opacity: function(a2, b2, c2) {
        if (p <= 8)
          switch (a2) {
            case "name":
              return "filter";
            case "extract":
              var d2 = c2.toString().match(/alpha\(opacity=(.*)\)/i);
              return c2 = d2 ? d2[1] / 100 : 1;
            case "inject":
              return b2.style.zoom = 1, parseFloat(c2) >= 1 ? "" : "alpha(opacity=" + parseInt(100 * parseFloat(c2), 10) + ")";
          }
        else
          switch (a2) {
            case "name":
              return "opacity";
            case "extract":
            case "inject":
              return c2;
          }
      } }, register: function() {
        function a2(a3, b3, c3) {
          if (A.getPropertyValue(b3, "boxSizing").toString().toLowerCase() === "border-box" === (c3 || false)) {
            var d2, e3, f2 = 0, g2 = a3 === "width" ? ["Left", "Right"] : ["Top", "Bottom"], h3 = ["padding" + g2[0], "padding" + g2[1], "border" + g2[0] + "Width", "border" + g2[1] + "Width"];
            for (d2 = 0; d2 < h3.length; d2++)
              e3 = parseFloat(A.getPropertyValue(b3, h3[d2])), isNaN(e3) || (f2 += e3);
            return c3 ? -f2 : f2;
          }
          return 0;
        }
        function b2(b3, c3) {
          return function(d2, e3, f2) {
            switch (d2) {
              case "name":
                return b3;
              case "extract":
                return parseFloat(f2) + a2(b3, e3, c3);
              case "inject":
                return parseFloat(f2) - a2(b3, e3, c3) + "px";
            }
          };
        }
        p && !(p > 9) || y.State.isGingerbread || (A.Lists.transformsBase = A.Lists.transformsBase.concat(A.Lists.transforms3D));
        for (var c2 = 0; c2 < A.Lists.transformsBase.length; c2++)
          !function() {
            var a3 = A.Lists.transformsBase[c2];
            A.Normalizations.registered[a3] = function(b3, c3, e3) {
              switch (b3) {
                case "name":
                  return "transform";
                case "extract":
                  return g(c3) === d || g(c3).transformCache[a3] === d ? /^scale/i.test(a3) ? 1 : 0 : g(c3).transformCache[a3].replace(/[()]/g, "");
                case "inject":
                  var f2 = false;
                  switch (a3.substr(0, a3.length - 1)) {
                    case "translate":
                      f2 = !/(%|px|em|rem|vw|vh|\d)$/i.test(e3);
                      break;
                    case "scal":
                    case "scale":
                      y.State.isAndroid && g(c3).transformCache[a3] === d && e3 < 1 && (e3 = 1), f2 = !/(\d)$/i.test(e3);
                      break;
                    case "skew":
                    case "rotate":
                      f2 = !/(deg|\d)$/i.test(e3);
                  }
                  return f2 || (g(c3).transformCache[a3] = "(" + e3 + ")"), g(c3).transformCache[a3];
              }
            };
          }();
        for (var e2 = 0; e2 < A.Lists.colors.length; e2++)
          !function() {
            var a3 = A.Lists.colors[e2];
            A.Normalizations.registered[a3] = function(b3, c3, e3) {
              switch (b3) {
                case "name":
                  return a3;
                case "extract":
                  var f2;
                  if (A.RegEx.wrappedValueAlreadyExtracted.test(e3))
                    f2 = e3;
                  else {
                    var g2, h3 = { black: "rgb(0, 0, 0)", blue: "rgb(0, 0, 255)", gray: "rgb(128, 128, 128)", green: "rgb(0, 128, 0)", red: "rgb(255, 0, 0)", white: "rgb(255, 255, 255)" };
                    /^[A-z]+$/i.test(e3) ? g2 = h3[e3] !== d ? h3[e3] : h3.black : A.RegEx.isHex.test(e3) ? g2 = "rgb(" + A.Values.hexToRgb(e3).join(" ") + ")" : /^rgba?\(/i.test(e3) || (g2 = h3.black), f2 = (g2 || e3).toString().match(A.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ");
                  }
                  return (!p || p > 8) && f2.split(" ").length === 3 && (f2 += " 1"), f2;
                case "inject":
                  return /^rgb/.test(e3) ? e3 : (p <= 8 ? e3.split(" ").length === 4 && (e3 = e3.split(/\s+/).slice(0, 3).join(" ")) : e3.split(" ").length === 3 && (e3 += " 1"), (p <= 8 ? "rgb" : "rgba") + "(" + e3.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")");
              }
            };
          }();
        A.Normalizations.registered.innerWidth = b2("width", true), A.Normalizations.registered.innerHeight = b2("height", true), A.Normalizations.registered.outerWidth = b2("width"), A.Normalizations.registered.outerHeight = b2("height");
      } }, Names: { camelCase: function(a2) {
        return a2.replace(/-(\w)/g, function(a3, b2) {
          return b2.toUpperCase();
        });
      }, SVGAttribute: function(a2) {
        var b2 = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";
        return (p || y.State.isAndroid && !y.State.isChrome) && (b2 += "|transform"), new RegExp("^(" + b2 + ")$", "i").test(a2);
      }, prefixCheck: function(a2) {
        if (y.State.prefixMatches[a2])
          return [y.State.prefixMatches[a2], true];
        for (var b2 = ["", "Webkit", "Moz", "ms", "O"], c2 = 0, d2 = b2.length; c2 < d2; c2++) {
          var e2;
          if (e2 = c2 === 0 ? a2 : b2[c2] + a2.replace(/^\w/, function(a3) {
            return a3.toUpperCase();
          }), u.isString(y.State.prefixElement.style[e2]))
            return y.State.prefixMatches[a2] = e2, [e2, true];
        }
        return [a2, false];
      } }, Values: { hexToRgb: function(a2) {
        var b2, c2 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, d2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
        return a2 = a2.replace(c2, function(a3, b3, c3, d3) {
          return b3 + b3 + c3 + c3 + d3 + d3;
        }), b2 = d2.exec(a2), b2 ? [parseInt(b2[1], 16), parseInt(b2[2], 16), parseInt(b2[3], 16)] : [0, 0, 0];
      }, isCSSNullValue: function(a2) {
        return !a2 || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(a2);
      }, getUnitType: function(a2) {
        return /^(rotate|skew)/i.test(a2) ? "deg" : /(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(a2) ? "" : "px";
      }, getDisplayType: function(a2) {
        var b2 = a2 && a2.tagName.toString().toLowerCase();
        return /^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(b2) ? "inline" : /^(li)$/i.test(b2) ? "list-item" : /^(tr)$/i.test(b2) ? "table-row" : /^(table)$/i.test(b2) ? "table" : /^(tbody)$/i.test(b2) ? "table-row-group" : "block";
      }, addClass: function(a2, b2) {
        if (a2)
          if (a2.classList)
            a2.classList.add(b2);
          else if (u.isString(a2.className))
            a2.className += (a2.className.length ? " " : "") + b2;
          else {
            var c2 = a2.getAttribute(p <= 7 ? "className" : "class") || "";
            a2.setAttribute("class", c2 + (c2 ? " " : "") + b2);
          }
      }, removeClass: function(a2, b2) {
        if (a2)
          if (a2.classList)
            a2.classList.remove(b2);
          else if (u.isString(a2.className))
            a2.className = a2.className.toString().replace(new RegExp("(^|\\s)" + b2.split(" ").join("|") + "(\\s|$)", "gi"), " ");
          else {
            var c2 = a2.getAttribute(p <= 7 ? "className" : "class") || "";
            a2.setAttribute("class", c2.replace(new RegExp("(^|s)" + b2.split(" ").join("|") + "(s|$)", "gi"), " "));
          }
      } }, getPropertyValue: function(a2, c2, e2, f2) {
        function h3(a3, c3) {
          var e3 = 0;
          if (p <= 8)
            e3 = o.css(a3, c3);
          else {
            var i4 = false;
            /^(width|height)$/.test(c3) && A.getPropertyValue(a3, "display") === 0 && (i4 = true, A.setPropertyValue(a3, "display", A.Values.getDisplayType(a3)));
            var j3 = function() {
              i4 && A.setPropertyValue(a3, "display", "none");
            };
            if (!f2) {
              if (c3 === "height" && A.getPropertyValue(a3, "boxSizing").toString().toLowerCase() !== "border-box") {
                var k3 = a3.offsetHeight - (parseFloat(A.getPropertyValue(a3, "borderTopWidth")) || 0) - (parseFloat(A.getPropertyValue(a3, "borderBottomWidth")) || 0) - (parseFloat(A.getPropertyValue(a3, "paddingTop")) || 0) - (parseFloat(A.getPropertyValue(a3, "paddingBottom")) || 0);
                return j3(), k3;
              }
              if (c3 === "width" && A.getPropertyValue(a3, "boxSizing").toString().toLowerCase() !== "border-box") {
                var l3 = a3.offsetWidth - (parseFloat(A.getPropertyValue(a3, "borderLeftWidth")) || 0) - (parseFloat(A.getPropertyValue(a3, "borderRightWidth")) || 0) - (parseFloat(A.getPropertyValue(a3, "paddingLeft")) || 0) - (parseFloat(A.getPropertyValue(a3, "paddingRight")) || 0);
                return j3(), l3;
              }
            }
            var m3;
            m3 = g(a3) === d ? b.getComputedStyle(a3, null) : g(a3).computedStyle ? g(a3).computedStyle : g(a3).computedStyle = b.getComputedStyle(a3, null), c3 === "borderColor" && (c3 = "borderTopColor"), e3 = p === 9 && c3 === "filter" ? m3.getPropertyValue(c3) : m3[c3], e3 !== "" && e3 !== null || (e3 = a3.style[c3]), j3();
          }
          if (e3 === "auto" && /^(top|right|bottom|left)$/i.test(c3)) {
            var n3 = h3(a3, "position");
            (n3 === "fixed" || n3 === "absolute" && /top|left/i.test(c3)) && (e3 = o(a3).position()[c3] + "px");
          }
          return e3;
        }
        var i3;
        if (A.Hooks.registered[c2]) {
          var j2 = c2, k2 = A.Hooks.getRoot(j2);
          e2 === d && (e2 = A.getPropertyValue(a2, A.Names.prefixCheck(k2)[0])), A.Normalizations.registered[k2] && (e2 = A.Normalizations.registered[k2]("extract", a2, e2)), i3 = A.Hooks.extractValue(j2, e2);
        } else if (A.Normalizations.registered[c2]) {
          var l2, m2;
          l2 = A.Normalizations.registered[c2]("name", a2), l2 !== "transform" && (m2 = h3(a2, A.Names.prefixCheck(l2)[0]), A.Values.isCSSNullValue(m2) && A.Hooks.templates[c2] && (m2 = A.Hooks.templates[c2][1])), i3 = A.Normalizations.registered[c2]("extract", a2, m2);
        }
        if (!/^[\d-]/.test(i3)) {
          var n2 = g(a2);
          if (n2 && n2.isSVG && A.Names.SVGAttribute(c2))
            if (/^(height|width)$/i.test(c2))
              try {
                i3 = a2.getBBox()[c2];
              } catch (q2) {
                i3 = 0;
              }
            else
              i3 = a2.getAttribute(c2);
          else
            i3 = h3(a2, A.Names.prefixCheck(c2)[0]);
        }
        return A.Values.isCSSNullValue(i3) && (i3 = 0), y.debug >= 2 && console.log("Get " + c2 + ": " + i3), i3;
      }, setPropertyValue: function(a2, c2, d2, e2, f2) {
        var h3 = c2;
        if (c2 === "scroll")
          f2.container ? f2.container["scroll" + f2.direction] = d2 : f2.direction === "Left" ? b.scrollTo(d2, f2.alternateValue) : b.scrollTo(f2.alternateValue, d2);
        else if (A.Normalizations.registered[c2] && A.Normalizations.registered[c2]("name", a2) === "transform")
          A.Normalizations.registered[c2]("inject", a2, d2), h3 = "transform", d2 = g(a2).transformCache[c2];
        else {
          if (A.Hooks.registered[c2]) {
            var i3 = c2, j2 = A.Hooks.getRoot(c2);
            e2 = e2 || A.getPropertyValue(a2, j2), d2 = A.Hooks.injectValue(i3, d2, e2), c2 = j2;
          }
          if (A.Normalizations.registered[c2] && (d2 = A.Normalizations.registered[c2]("inject", a2, d2), c2 = A.Normalizations.registered[c2]("name", a2)), h3 = A.Names.prefixCheck(c2)[0], p <= 8)
            try {
              a2.style[h3] = d2;
            } catch (l2) {
              y.debug && console.log("Browser does not support [" + d2 + "] for [" + h3 + "]");
            }
          else {
            var k2 = g(a2);
            k2 && k2.isSVG && A.Names.SVGAttribute(c2) ? a2.setAttribute(c2, d2) : a2.style[h3] = d2;
          }
          y.debug >= 2 && console.log("Set " + c2 + " (" + h3 + "): " + d2);
        }
        return [h3, d2];
      }, flushTransformCache: function(a2) {
        var b2 = "", c2 = g(a2);
        if ((p || y.State.isAndroid && !y.State.isChrome) && c2 && c2.isSVG) {
          var d2 = function(b3) {
            return parseFloat(A.getPropertyValue(a2, b3));
          }, e2 = { translate: [d2("translateX"), d2("translateY")], skewX: [d2("skewX")], skewY: [d2("skewY")], scale: d2("scale") !== 1 ? [d2("scale"), d2("scale")] : [d2("scaleX"), d2("scaleY")], rotate: [d2("rotateZ"), 0, 0] };
          o.each(g(a2).transformCache, function(a3) {
            /^translate/i.test(a3) ? a3 = "translate" : /^scale/i.test(a3) ? a3 = "scale" : /^rotate/i.test(a3) && (a3 = "rotate"), e2[a3] && (b2 += a3 + "(" + e2[a3].join(" ") + ") ", delete e2[a3]);
          });
        } else {
          var f2, h3;
          o.each(g(a2).transformCache, function(c3) {
            if (f2 = g(a2).transformCache[c3], c3 === "transformPerspective")
              return h3 = f2, true;
            p === 9 && c3 === "rotateZ" && (c3 = "rotate"), b2 += c3 + f2 + " ";
          }), h3 && (b2 = "perspective" + h3 + " " + b2);
        }
        A.setPropertyValue(a2, "transform", b2);
      } };
      A.Hooks.register(), A.Normalizations.register(), y.hook = function(a2, b2, c2) {
        var e2;
        return a2 = f(a2), o.each(a2, function(a3, f2) {
          if (g(f2) === d && y.init(f2), c2 === d)
            e2 === d && (e2 = A.getPropertyValue(f2, b2));
          else {
            var h3 = A.setPropertyValue(f2, b2, c2);
            h3[0] === "transform" && y.CSS.flushTransformCache(f2), e2 = h3;
          }
        }), e2;
      };
      var B = function() {
        function a2() {
          return k2 ? z2.promise || null : p2;
        }
        function e2(a3, e3) {
          function f2(f3) {
            var k4, n3;
            if (i3.begin && D2 === 0)
              try {
                i3.begin.call(r2, r2);
              } catch (V) {
                setTimeout(function() {
                  throw V;
                }, 1);
              }
            if (G === "scroll") {
              var p3, q3, w2, x3 = /^x$/i.test(i3.axis) ? "Left" : "Top", B2 = parseFloat(i3.offset) || 0;
              i3.container ? u.isWrapped(i3.container) || u.isNode(i3.container) ? (i3.container = i3.container[0] || i3.container, p3 = i3.container["scroll" + x3], w2 = p3 + o(a3).position()[x3.toLowerCase()] + B2) : i3.container = null : (p3 = y.State.scrollAnchor[y.State["scrollProperty" + x3]], q3 = y.State.scrollAnchor[y.State["scrollProperty" + (x3 === "Left" ? "Top" : "Left")]], w2 = o(a3).offset()[x3.toLowerCase()] + B2), j3 = { scroll: { rootPropertyValue: false, startValue: p3, currentValue: p3, endValue: w2, unitType: "", easing: i3.easing, scrollData: { container: i3.container, direction: x3, alternateValue: q3 } }, element: a3 }, y.debug && console.log("tweensContainer (scroll): ", j3.scroll, a3);
            } else if (G === "reverse") {
              if (!(k4 = g(a3)))
                return;
              if (!k4.tweensContainer)
                return void o.dequeue(a3, i3.queue);
              k4.opts.display === "none" && (k4.opts.display = "auto"), k4.opts.visibility === "hidden" && (k4.opts.visibility = "visible"), k4.opts.loop = false, k4.opts.begin = null, k4.opts.complete = null, v2.easing || delete i3.easing, v2.duration || delete i3.duration, i3 = o.extend({}, k4.opts, i3), n3 = o.extend(true, {}, k4 ? k4.tweensContainer : null);
              for (var E2 in n3)
                if (n3.hasOwnProperty(E2) && E2 !== "element") {
                  var F2 = n3[E2].startValue;
                  n3[E2].startValue = n3[E2].currentValue = n3[E2].endValue, n3[E2].endValue = F2, u.isEmptyObject(v2) || (n3[E2].easing = i3.easing), y.debug && console.log("reverse tweensContainer (" + E2 + "): " + JSON.stringify(n3[E2]), a3);
                }
              j3 = n3;
            } else if (G === "start") {
              k4 = g(a3), k4 && k4.tweensContainer && k4.isAnimating === true && (n3 = k4.tweensContainer);
              var H2 = function(e4, f4) {
                var g2, l2 = A.Hooks.getRoot(e4), m2 = false, p4 = f4[0], q4 = f4[1], r3 = f4[2];
                if (!(k4 && k4.isSVG || l2 === "tween" || A.Names.prefixCheck(l2)[1] !== false || A.Normalizations.registered[l2] !== d))
                  return void (y.debug && console.log("Skipping [" + l2 + "] due to a lack of browser support."));
                (i3.display !== d && i3.display !== null && i3.display !== "none" || i3.visibility !== d && i3.visibility !== "hidden") && /opacity|filter/.test(e4) && !r3 && p4 !== 0 && (r3 = 0), i3._cacheValues && n3 && n3[e4] ? (r3 === d && (r3 = n3[e4].endValue + n3[e4].unitType), m2 = k4.rootPropertyValueCache[l2]) : A.Hooks.registered[e4] ? r3 === d ? (m2 = A.getPropertyValue(a3, l2), r3 = A.getPropertyValue(a3, e4, m2)) : m2 = A.Hooks.templates[l2][1] : r3 === d && (r3 = A.getPropertyValue(a3, e4));
                var s3, t2, v3, w3 = false, x4 = function(a4, b2) {
                  var c2, d2;
                  return d2 = (b2 || "0").toString().toLowerCase().replace(/[%A-z]+$/, function(a5) {
                    return c2 = a5, "";
                  }), c2 || (c2 = A.Values.getUnitType(a4)), [d2, c2];
                };
                if (r3 !== p4 && u.isString(r3) && u.isString(p4)) {
                  g2 = "";
                  var z3 = 0, B3 = 0, C3 = [], D3 = [], E3 = 0, F3 = 0, G2 = 0;
                  for (r3 = A.Hooks.fixColors(r3), p4 = A.Hooks.fixColors(p4); z3 < r3.length && B3 < p4.length; ) {
                    var H3 = r3[z3], I3 = p4[B3];
                    if (/[\d\.-]/.test(H3) && /[\d\.-]/.test(I3)) {
                      for (var J3 = H3, K3 = I3, L3 = ".", N2 = "."; ++z3 < r3.length; ) {
                        if ((H3 = r3[z3]) === L3)
                          L3 = "..";
                        else if (!/\d/.test(H3))
                          break;
                        J3 += H3;
                      }
                      for (; ++B3 < p4.length; ) {
                        if ((I3 = p4[B3]) === N2)
                          N2 = "..";
                        else if (!/\d/.test(I3))
                          break;
                        K3 += I3;
                      }
                      var O3 = A.Hooks.getUnit(r3, z3), P3 = A.Hooks.getUnit(p4, B3);
                      if (z3 += O3.length, B3 += P3.length, O3 === P3)
                        J3 === K3 ? g2 += J3 + O3 : (g2 += "{" + C3.length + (F3 ? "!" : "") + "}" + O3, C3.push(parseFloat(J3)), D3.push(parseFloat(K3)));
                      else {
                        var Q3 = parseFloat(J3), R2 = parseFloat(K3);
                        g2 += (E3 < 5 ? "calc" : "") + "(" + (Q3 ? "{" + C3.length + (F3 ? "!" : "") + "}" : "0") + O3 + " + " + (R2 ? "{" + (C3.length + (Q3 ? 1 : 0)) + (F3 ? "!" : "") + "}" : "0") + P3 + ")", Q3 && (C3.push(Q3), D3.push(0)), R2 && (C3.push(0), D3.push(R2));
                      }
                    } else {
                      if (H3 !== I3) {
                        E3 = 0;
                        break;
                      }
                      g2 += H3, z3++, B3++, E3 === 0 && H3 === "c" || E3 === 1 && H3 === "a" || E3 === 2 && H3 === "l" || E3 === 3 && H3 === "c" || E3 >= 4 && H3 === "(" ? E3++ : (E3 && E3 < 5 || E3 >= 4 && H3 === ")" && --E3 < 5) && (E3 = 0), F3 === 0 && H3 === "r" || F3 === 1 && H3 === "g" || F3 === 2 && H3 === "b" || F3 === 3 && H3 === "a" || F3 >= 3 && H3 === "(" ? (F3 === 3 && H3 === "a" && (G2 = 1), F3++) : G2 && H3 === "," ? ++G2 > 3 && (F3 = G2 = 0) : (G2 && F3 < (G2 ? 5 : 4) || F3 >= (G2 ? 4 : 3) && H3 === ")" && --F3 < (G2 ? 5 : 4)) && (F3 = G2 = 0);
                    }
                  }
                  z3 === r3.length && B3 === p4.length || (y.debug && console.error('Trying to pattern match mis-matched strings ["' + p4 + '", "' + r3 + '"]'), g2 = d), g2 && (C3.length ? (y.debug && console.log('Pattern found "' + g2 + '" -> ', C3, D3, "[" + r3 + "," + p4 + "]"), r3 = C3, p4 = D3, t2 = v3 = "") : g2 = d);
                }
                g2 || (s3 = x4(e4, r3), r3 = s3[0], v3 = s3[1], s3 = x4(e4, p4), p4 = s3[0].replace(/^([+-\/*])=/, function(a4, b2) {
                  return w3 = b2, "";
                }), t2 = s3[1], r3 = parseFloat(r3) || 0, p4 = parseFloat(p4) || 0, t2 === "%" && (/^(fontSize|lineHeight)$/.test(e4) ? (p4 /= 100, t2 = "em") : /^scale/.test(e4) ? (p4 /= 100, t2 = "") : /(Red|Green|Blue)$/i.test(e4) && (p4 = p4 / 100 * 255, t2 = "")));
                if (/[\/*]/.test(w3))
                  t2 = v3;
                else if (v3 !== t2 && r3 !== 0)
                  if (p4 === 0)
                    t2 = v3;
                  else {
                    h3 = h3 || function() {
                      var d2 = { myParent: a3.parentNode || c.body, position: A.getPropertyValue(a3, "position"), fontSize: A.getPropertyValue(a3, "fontSize") }, e5 = d2.position === M.lastPosition && d2.myParent === M.lastParent, f5 = d2.fontSize === M.lastFontSize;
                      M.lastParent = d2.myParent, M.lastPosition = d2.position, M.lastFontSize = d2.fontSize;
                      var g3 = {};
                      if (f5 && e5)
                        g3.emToPx = M.lastEmToPx, g3.percentToPxWidth = M.lastPercentToPxWidth, g3.percentToPxHeight = M.lastPercentToPxHeight;
                      else {
                        var h4 = k4 && k4.isSVG ? c.createElementNS("http://www.w3.org/2000/svg", "rect") : c.createElement("div");
                        y.init(h4), d2.myParent.appendChild(h4), o.each(["overflow", "overflowX", "overflowY"], function(a4, b2) {
                          y.CSS.setPropertyValue(h4, b2, "hidden");
                        }), y.CSS.setPropertyValue(h4, "position", d2.position), y.CSS.setPropertyValue(h4, "fontSize", d2.fontSize), y.CSS.setPropertyValue(h4, "boxSizing", "content-box"), o.each(["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height"], function(a4, b2) {
                          y.CSS.setPropertyValue(h4, b2, "100%");
                        }), y.CSS.setPropertyValue(h4, "paddingLeft", "100em"), g3.percentToPxWidth = M.lastPercentToPxWidth = (parseFloat(A.getPropertyValue(h4, "width", null, true)) || 1) / 100, g3.percentToPxHeight = M.lastPercentToPxHeight = (parseFloat(A.getPropertyValue(h4, "height", null, true)) || 1) / 100, g3.emToPx = M.lastEmToPx = (parseFloat(A.getPropertyValue(h4, "paddingLeft")) || 1) / 100, d2.myParent.removeChild(h4);
                      }
                      return M.remToPx === null && (M.remToPx = parseFloat(A.getPropertyValue(c.body, "fontSize")) || 16), M.vwToPx === null && (M.vwToPx = parseFloat(b.innerWidth) / 100, M.vhToPx = parseFloat(b.innerHeight) / 100), g3.remToPx = M.remToPx, g3.vwToPx = M.vwToPx, g3.vhToPx = M.vhToPx, y.debug >= 1 && console.log("Unit ratios: " + JSON.stringify(g3), a3), g3;
                    }();
                    var S2 = /margin|padding|left|right|width|text|word|letter/i.test(e4) || /X$/.test(e4) || e4 === "x" ? "x" : "y";
                    switch (v3) {
                      case "%":
                        r3 *= S2 === "x" ? h3.percentToPxWidth : h3.percentToPxHeight;
                        break;
                      case "px":
                        break;
                      default:
                        r3 *= h3[v3 + "ToPx"];
                    }
                    switch (t2) {
                      case "%":
                        r3 *= 1 / (S2 === "x" ? h3.percentToPxWidth : h3.percentToPxHeight);
                        break;
                      case "px":
                        break;
                      default:
                        r3 *= 1 / h3[t2 + "ToPx"];
                    }
                  }
                switch (w3) {
                  case "+":
                    p4 = r3 + p4;
                    break;
                  case "-":
                    p4 = r3 - p4;
                    break;
                  case "*":
                    p4 *= r3;
                    break;
                  case "/":
                    p4 = r3 / p4;
                }
                j3[e4] = { rootPropertyValue: m2, startValue: r3, currentValue: r3, endValue: p4, unitType: t2, easing: q4 }, g2 && (j3[e4].pattern = g2), y.debug && console.log("tweensContainer (" + e4 + "): " + JSON.stringify(j3[e4]), a3);
              };
              for (var I2 in s2)
                if (s2.hasOwnProperty(I2)) {
                  var J2 = A.Names.camelCase(I2), K2 = function(b2, c2) {
                    var d2, f4, g2;
                    return u.isFunction(b2) && (b2 = b2.call(a3, e3, C2)), u.isArray(b2) ? (d2 = b2[0], !u.isArray(b2[1]) && /^[\d-]/.test(b2[1]) || u.isFunction(b2[1]) || A.RegEx.isHex.test(b2[1]) ? g2 = b2[1] : u.isString(b2[1]) && !A.RegEx.isHex.test(b2[1]) && y.Easings[b2[1]] || u.isArray(b2[1]) ? (f4 = c2 ? b2[1] : l(b2[1], i3.duration), g2 = b2[2]) : g2 = b2[1] || b2[2]) : d2 = b2, c2 || (f4 = f4 || i3.easing), u.isFunction(d2) && (d2 = d2.call(a3, e3, C2)), u.isFunction(g2) && (g2 = g2.call(a3, e3, C2)), [d2 || 0, f4, g2];
                  }(s2[I2]);
                  if (t(A.Lists.colors)) {
                    var L2 = K2[0], O2 = K2[1], P2 = K2[2];
                    if (A.RegEx.isHex.test(L2)) {
                      for (var Q2 = ["Red", "Green", "Blue"], R = A.Values.hexToRgb(L2), S = P2 ? A.Values.hexToRgb(P2) : d, T = 0; T < Q2.length; T++) {
                        var U = [R[T]];
                        O2 && U.push(O2), S !== d && U.push(S[T]), H2(J2 + Q2[T], U);
                      }
                      continue;
                    }
                  }
                  H2(J2, K2);
                }
              j3.element = a3;
            }
            j3.element && (A.Values.addClass(a3, "velocity-animating"), N.push(j3), k4 = g(a3), k4 && (i3.queue === "" && (k4.tweensContainer = j3, k4.opts = i3), k4.isAnimating = true), D2 === C2 - 1 ? (y.State.calls.push([N, r2, i3, null, z2.resolver, null, 0]), y.State.isTicking === false && (y.State.isTicking = true, m())) : D2++);
          }
          var h3, i3 = o.extend({}, y.defaults, v2), j3 = {};
          switch (g(a3) === d && y.init(a3), parseFloat(i3.delay) && i3.queue !== false && o.queue(a3, i3.queue, function(b2, c2) {
            if (c2 === true)
              return true;
            y.velocityQueueEntryFlag = true;
            var d2 = y.State.delayedElements.count++;
            y.State.delayedElements[d2] = a3;
            var e4 = function(a4) {
              return function() {
                y.State.delayedElements[a4] = false, b2();
              };
            }(d2);
            g(a3).delayBegin = new Date().getTime(), g(a3).delay = parseFloat(i3.delay), g(a3).delayTimer = { setTimeout: setTimeout(b2, parseFloat(i3.delay)), next: e4 };
          }), i3.duration.toString().toLowerCase()) {
            case "fast":
              i3.duration = 200;
              break;
            case "normal":
              i3.duration = w;
              break;
            case "slow":
              i3.duration = 600;
              break;
            default:
              i3.duration = parseFloat(i3.duration) || 1;
          }
          if (y.mock !== false && (y.mock === true ? i3.duration = i3.delay = 1 : (i3.duration *= parseFloat(y.mock) || 1, i3.delay *= parseFloat(y.mock) || 1)), i3.easing = l(i3.easing, i3.duration), i3.begin && !u.isFunction(i3.begin) && (i3.begin = null), i3.progress && !u.isFunction(i3.progress) && (i3.progress = null), i3.complete && !u.isFunction(i3.complete) && (i3.complete = null), i3.display !== d && i3.display !== null && (i3.display = i3.display.toString().toLowerCase(), i3.display === "auto" && (i3.display = y.CSS.Values.getDisplayType(a3))), i3.visibility !== d && i3.visibility !== null && (i3.visibility = i3.visibility.toString().toLowerCase()), i3.mobileHA = i3.mobileHA && y.State.isMobile && !y.State.isGingerbread, i3.queue === false)
            if (i3.delay) {
              var k3 = y.State.delayedElements.count++;
              y.State.delayedElements[k3] = a3;
              var n2 = function(a4) {
                return function() {
                  y.State.delayedElements[a4] = false, f2();
                };
              }(k3);
              g(a3).delayBegin = new Date().getTime(), g(a3).delay = parseFloat(i3.delay), g(a3).delayTimer = { setTimeout: setTimeout(f2, parseFloat(i3.delay)), next: n2 };
            } else
              f2();
          else
            o.queue(a3, i3.queue, function(a4, b2) {
              if (b2 === true)
                return z2.promise && z2.resolver(r2), true;
              y.velocityQueueEntryFlag = true, f2();
            });
          i3.queue !== "" && i3.queue !== "fx" || o.queue(a3)[0] === "inprogress" || o.dequeue(a3);
        }
        var j2, k2, p2, q2, r2, s2, v2, x2 = arguments[0] && (arguments[0].p || o.isPlainObject(arguments[0].properties) && !arguments[0].properties.names || u.isString(arguments[0].properties));
        u.isWrapped(this) ? (k2 = false, q2 = 0, r2 = this, p2 = this) : (k2 = true, q2 = 1, r2 = x2 ? arguments[0].elements || arguments[0].e : arguments[0]);
        var z2 = { promise: null, resolver: null, rejecter: null };
        if (k2 && y.Promise && (z2.promise = new y.Promise(function(a3, b2) {
          z2.resolver = a3, z2.rejecter = b2;
        })), x2 ? (s2 = arguments[0].properties || arguments[0].p, v2 = arguments[0].options || arguments[0].o) : (s2 = arguments[q2], v2 = arguments[q2 + 1]), !(r2 = f(r2)))
          return void (z2.promise && (s2 && v2 && v2.promiseRejectEmpty === false ? z2.resolver() : z2.rejecter()));
        var C2 = r2.length, D2 = 0;
        if (!/^(stop|finish|finishAll|pause|resume)$/i.test(s2) && !o.isPlainObject(v2)) {
          var E = q2 + 1;
          v2 = {};
          for (var F = E; F < arguments.length; F++)
            u.isArray(arguments[F]) || !/^(fast|normal|slow)$/i.test(arguments[F]) && !/^\d/.test(arguments[F]) ? u.isString(arguments[F]) || u.isArray(arguments[F]) ? v2.easing = arguments[F] : u.isFunction(arguments[F]) && (v2.complete = arguments[F]) : v2.duration = arguments[F];
        }
        var G;
        switch (s2) {
          case "scroll":
            G = "scroll";
            break;
          case "reverse":
            G = "reverse";
            break;
          case "pause":
            var H = new Date().getTime();
            return o.each(r2, function(a3, b2) {
              h2(b2, H);
            }), o.each(y.State.calls, function(a3, b2) {
              var c2 = false;
              b2 && o.each(b2[1], function(a4, e3) {
                var f2 = v2 === d ? "" : v2;
                return f2 !== true && b2[2].queue !== f2 && (v2 !== d || b2[2].queue !== false) || (o.each(r2, function(a5, d2) {
                  if (d2 === e3)
                    return b2[5] = { resume: false }, c2 = true, false;
                }), !c2 && void 0);
              });
            }), a2();
          case "resume":
            return o.each(r2, function(a3, b2) {
              i2(b2);
            }), o.each(y.State.calls, function(a3, b2) {
              var c2 = false;
              b2 && o.each(b2[1], function(a4, e3) {
                var f2 = v2 === d ? "" : v2;
                return f2 !== true && b2[2].queue !== f2 && (v2 !== d || b2[2].queue !== false) || (!b2[5] || (o.each(r2, function(a5, d2) {
                  if (d2 === e3)
                    return b2[5].resume = true, c2 = true, false;
                }), !c2 && void 0));
              });
            }), a2();
          case "finish":
          case "finishAll":
          case "stop":
            o.each(r2, function(a3, b2) {
              g(b2) && g(b2).delayTimer && (clearTimeout(g(b2).delayTimer.setTimeout), g(b2).delayTimer.next && g(b2).delayTimer.next(), delete g(b2).delayTimer), s2 !== "finishAll" || v2 !== true && !u.isString(v2) || (o.each(o.queue(b2, u.isString(v2) ? v2 : ""), function(a4, b3) {
                u.isFunction(b3) && b3();
              }), o.queue(b2, u.isString(v2) ? v2 : "", []));
            });
            var I = [];
            return o.each(y.State.calls, function(a3, b2) {
              b2 && o.each(b2[1], function(c2, e3) {
                var f2 = v2 === d ? "" : v2;
                if (f2 !== true && b2[2].queue !== f2 && (v2 !== d || b2[2].queue !== false))
                  return true;
                o.each(r2, function(c3, d2) {
                  if (d2 === e3)
                    if ((v2 === true || u.isString(v2)) && (o.each(o.queue(d2, u.isString(v2) ? v2 : ""), function(a4, b3) {
                      u.isFunction(b3) && b3(null, true);
                    }), o.queue(d2, u.isString(v2) ? v2 : "", [])), s2 === "stop") {
                      var h3 = g(d2);
                      h3 && h3.tweensContainer && (f2 === true || f2 === "") && o.each(h3.tweensContainer, function(a4, b3) {
                        b3.endValue = b3.currentValue;
                      }), I.push(a3);
                    } else
                      s2 !== "finish" && s2 !== "finishAll" || (b2[2].duration = 1);
                });
              });
            }), s2 === "stop" && (o.each(I, function(a3, b2) {
              n(b2, true);
            }), z2.promise && z2.resolver(r2)), a2();
          default:
            if (!o.isPlainObject(s2) || u.isEmptyObject(s2)) {
              if (u.isString(s2) && y.Redirects[s2]) {
                j2 = o.extend({}, v2);
                var J = j2.duration, K = j2.delay || 0;
                return j2.backwards === true && (r2 = o.extend(true, [], r2).reverse()), o.each(r2, function(a3, b2) {
                  parseFloat(j2.stagger) ? j2.delay = K + parseFloat(j2.stagger) * a3 : u.isFunction(j2.stagger) && (j2.delay = K + j2.stagger.call(b2, a3, C2)), j2.drag && (j2.duration = parseFloat(J) || (/^(callout|transition)/.test(s2) ? 1e3 : w), j2.duration = Math.max(j2.duration * (j2.backwards ? 1 - a3 / C2 : (a3 + 1) / C2), 0.75 * j2.duration, 200)), y.Redirects[s2].call(b2, b2, j2 || {}, a3, C2, r2, z2.promise ? z2 : d);
                }), a2();
              }
              var L = "Velocity: First argument (" + s2 + ") was not a property map, a known action, or a registered redirect. Aborting.";
              return z2.promise ? z2.rejecter(new Error(L)) : b.console && console.log(L), a2();
            }
            G = "start";
        }
        var M = { lastParent: null, lastPosition: null, lastFontSize: null, lastPercentToPxWidth: null, lastPercentToPxHeight: null, lastEmToPx: null, remToPx: null, vwToPx: null, vhToPx: null }, N = [];
        o.each(r2, function(a3, b2) {
          u.isNode(b2) && e2(b2, a3);
        }), j2 = o.extend({}, y.defaults, v2), j2.loop = parseInt(j2.loop, 10);
        var O = 2 * j2.loop - 1;
        if (j2.loop)
          for (var P = 0; P < O; P++) {
            var Q = { delay: j2.delay, progress: j2.progress };
            P === O - 1 && (Q.display = j2.display, Q.visibility = j2.visibility, Q.complete = j2.complete), B(r2, "reverse", Q);
          }
        return a2();
      };
      y = o.extend(B, y), y.animate = B;
      var C = b.requestAnimationFrame || q;
      if (!y.State.isMobile && c.hidden !== d) {
        var D = function() {
          c.hidden ? (C = function(a2) {
            return setTimeout(function() {
              a2(true);
            }, 16);
          }, m()) : C = b.requestAnimationFrame || q;
        };
        D(), c.addEventListener("visibilitychange", D);
      }
      return a.Velocity = y, a !== b && (a.fn.velocity = B, a.fn.velocity.defaults = y.defaults), o.each(["Down", "Up"], function(a2, b2) {
        y.Redirects["slide" + b2] = function(a3, c2, e2, f2, g2, h3) {
          var i3 = o.extend({}, c2), j2 = i3.begin, k2 = i3.complete, l2 = {}, m2 = { height: "", marginTop: "", marginBottom: "", paddingTop: "", paddingBottom: "" };
          i3.display === d && (i3.display = b2 === "Down" ? y.CSS.Values.getDisplayType(a3) === "inline" ? "inline-block" : "block" : "none"), i3.begin = function() {
            e2 === 0 && j2 && j2.call(g2, g2);
            for (var c3 in m2)
              if (m2.hasOwnProperty(c3)) {
                l2[c3] = a3.style[c3];
                var d2 = A.getPropertyValue(a3, c3);
                m2[c3] = b2 === "Down" ? [d2, 0] : [0, d2];
              }
            l2.overflow = a3.style.overflow, a3.style.overflow = "hidden";
          }, i3.complete = function() {
            for (var b3 in l2)
              l2.hasOwnProperty(b3) && (a3.style[b3] = l2[b3]);
            e2 === f2 - 1 && (k2 && k2.call(g2, g2), h3 && h3.resolver(g2));
          }, y(a3, m2, i3);
        };
      }), o.each(["In", "Out"], function(a2, b2) {
        y.Redirects["fade" + b2] = function(a3, c2, e2, f2, g2, h3) {
          var i3 = o.extend({}, c2), j2 = i3.complete, k2 = { opacity: b2 === "In" ? 1 : 0 };
          e2 !== 0 && (i3.begin = null), i3.complete = e2 !== f2 - 1 ? null : function() {
            j2 && j2.call(g2, g2), h3 && h3.resolver(g2);
          }, i3.display === d && (i3.display = b2 === "In" ? "auto" : "none"), y(this, k2, i3);
        };
      }), y;
    }(window.jQuery || window.Zepto || window, window, window ? window.document : void 0);
  });
})(velocity_min);
var Velocity = velocity_min.exports;
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object3, enumerableOnly) {
  var keys2 = Object.keys(object3);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object3);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object3, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source2), true).forEach(function(key) {
        _defineProperty(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = arguments[i2];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
function _objectWithoutProperties(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source2, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key))
        continue;
      target[key] = source2[key];
    }
  }
  return target;
}
var version = "1.14.0";
function userAgent(pattern2) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern2);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event2, fn2) {
  el.addEventListener(event2, fn2, !IE11OrLess && captureMode);
}
function off(el, event2, fn2) {
  el.removeEventListener(event2, fn2, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx2, includeCTX) {
  if (el) {
    ctx2 = ctx2 || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx2 && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx2) {
        return el;
      }
      if (el === ctx2)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name2, state) {
  if (el && name2) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name2);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
      el.className = (className + (state ? " " + name2 : "")).replace(R_SPACE, " ");
    }
  }
}
function css$1(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css$1(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx2, tagName, iterator) {
  if (ctx2) {
    var list = ctx2.getElementsByTagName(tagName), i2 = 0, n = list.length;
    if (iterator) {
      for (; i2 < n; i2++) {
        iterator(list[i2], i2);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top2, left2, bottom2, right2, height, width2;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top2 = elRect.top;
    left2 = elRect.left;
    bottom2 = elRect.bottom;
    right2 = elRect.right;
    height = elRect.height;
    width2 = elRect.width;
  } else {
    top2 = 0;
    left2 = 0;
    bottom2 = window.innerHeight;
    right2 = window.innerWidth;
    height = window.innerHeight;
    width2 = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css$1(container, "transform") !== "none" || relativeToNonStaticParent && css$1(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top2 -= containerRect.top + parseInt(css$1(container, "border-top-width"));
          left2 -= containerRect.left + parseInt(css$1(container, "border-left-width"));
          bottom2 = top2 + elRect.height;
          right2 = left2 + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top2 /= scaleY;
      left2 /= scaleX;
      width2 /= scaleX;
      height /= scaleY;
      bottom2 = top2 + height;
      right2 = left2 + width2;
    }
  }
  return {
    top: top2,
    left: left2,
    bottom: bottom2,
    right: right2,
    width: width2,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent2 = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent2) {
    var parentSideVal = getRect(parent2)[parentSide], visible2 = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible2 = elSideVal >= parentSideVal;
    } else {
      visible2 = elSideVal <= parentSideVal;
    }
    if (!visible2)
      return parent2;
    if (parent2 === getWindowScrollingElement())
      break;
    parent2 = getParentAutoScrollElement(parent2, false);
  }
  return false;
}
function getChild(el, childNum, options2, includeDragEl) {
  var currentChild = 0, i2 = 0, children = el.children;
  while (i2 < children.length) {
    if (children[i2].style.display !== "none" && children[i2] !== Sortable.ghost && (includeDragEl || children[i2] !== Sortable.dragged) && closest(children[i2], options2.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i2];
      }
      currentChild++;
    }
    i2++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css$1(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index$1(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i2 in arr) {
    if (!arr.hasOwnProperty(i2))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key])
        return Number(i2);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css$1(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css$1(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css$1(target, "transition", "");
        css$1(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css$1(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css$1(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css$1(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css$1(target, "transition", "");
          css$1(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options2) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options2.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin2) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin2)) {
        plugin2[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p) {
      if (p.pluginName === plugin2.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin2.pluginName, " more than once");
      }
    });
    plugins.push(plugin2);
  },
  pluginEvent: function pluginEvent2(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (sortable[plugin2.pluginName][eventNameGlobal]) {
        sortable[plugin2.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin2.pluginName] && sortable[plugin2.pluginName][eventName]) {
        sortable[plugin2.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options2) {
    plugins.forEach(function(plugin2) {
      var pluginName = plugin2.pluginName;
      if (!sortable.options[pluginName] && !plugin2.initializeByDefault)
        return;
      var initialized = new plugin2(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name2, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin2) {
      if (typeof plugin2.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin2.eventProperties.call(sortable[plugin2.pluginName], name2));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name2, value2) {
    var modifiedValue;
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (plugin2.optionListeners && typeof plugin2.optionListeners[name2] === "function") {
        modifiedValue = plugin2.optionListeners[name2].call(sortable[plugin2.pluginName], value2);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options2 = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name2, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name2, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options2[onName]) {
    options2[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name2) {
      _dispatchEvent({
        sortable,
        name: name2,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el, options2) {
  var elCSS = css$1(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options2), child2 = getChild(el, 1, options2), firstChildCSS = child1 && css$1(child1), secondChildCSS = child2 && css$1(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options2) {
  function toFn(value2, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value2 == null && (pull || sameGroup)) {
        return true;
      } else if (value2 == null || value2 === false) {
        return false;
      } else if (pull && value2 === "clone") {
        return value2;
      } else if (typeof value2 === "function") {
        return toFn(value2(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value2 === true || typeof value2 === "string" && value2 === otherGroup || value2.join && value2.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options2.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options2.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css$1(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css$1(ghostEl, "display", "");
  }
};
if (documentExists) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event2 = {};
      for (var i2 in evt) {
        if (evt.hasOwnProperty(i2)) {
          event2[i2] = evt[i2];
        }
      }
      event2.target = event2.rootEl = nearest;
      event2.preventDefault = void 0;
      event2.stopPropagation = void 0;
      nearest[expando]._onDragOver(event2);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options2) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options2 = _extends({}, options2);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name2 in defaults2) {
    !(name2 in options2) && (options2[name2] = defaults2[name2]);
  }
  _prepareGroup(options2);
  for (var fn2 in this) {
    if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
      this[fn2] = this[fn2].bind(this);
    }
  }
  this.nativeDraggable = options2.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options2.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options2.store && options2.store.get && this.sort(options2.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options2 = this.options, preventOnFilter = options2.preventOnFilter, type2 = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options2.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type2) && evt.button !== 0 || options2.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options2.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index$1(target);
    oldDraggableIndex = index$1(target, options2.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options2.handle && !closest(originalTarget, options2.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options2 = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options2.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options2.chosenClass, true);
      };
      options2.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent("delayStart", this, {
        evt
      });
      if (options2.delay && (!options2.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options2.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options2.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options2 = this.options;
      !fallback && toggleClass(dragEl, options2.dragClass, false);
      toggleClass(dragEl, options2.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent2 = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent2)
          break;
        parent2 = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent2) {
        do {
          if (parent2[expando]) {
            var inserted = void 0;
            inserted = parent2[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent2
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent2;
        } while (parent2 = parent2.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options2 = this.options, fallbackTolerance = options2.fallbackTolerance, fallbackOffset = options2.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css$1(ghostEl, "webkitTransform", cssMatrix);
        css$1(ghostEl, "mozTransform", cssMatrix);
        css$1(ghostEl, "msTransform", cssMatrix);
        css$1(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options2 = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css$1(ghostRelativeParent, "position") === "static" && css$1(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options2.ghostClass, false);
      toggleClass(ghostEl, options2.fallbackClass, true);
      toggleClass(ghostEl, options2.dragClass, true);
      css$1(ghostEl, "transition", "");
      css$1(ghostEl, "transform", "");
      css$1(ghostEl, "box-sizing", "border-box");
      css$1(ghostEl, "margin", 0);
      css$1(ghostEl, "top", rect.top);
      css$1(ghostEl, "left", rect.left);
      css$1(ghostEl, "width", rect.width);
      css$1(ghostEl, "height", rect.height);
      css$1(ghostEl, "opacity", "0.8");
      css$1(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css$1(ghostEl, "zIndex", "100000");
      css$1(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css$1(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options2 = _this.options;
    pluginEvent("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options2.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options2.setData && options2.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css$1(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css$1(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options2 = this.options, group = options2.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options2.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name2, extra) {
      pluginEvent(name2, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options2.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options2.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options2.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options2.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options2.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options2.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options2.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options2, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options2.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options2.swapThreshold, options2.invertedSwapThreshold == null ? options2.swapThreshold : options2.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index$1(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css$1(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options2 = this.options;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options2.draggable);
    pluginEvent("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options2.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css$1(document.body, "user-select", "");
    }
    css$1(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options2.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray() {
    var order2 = [], el, children = this.el.children, i2 = 0, n = children.length, options2 = this.options;
    for (; i2 < n; i2++) {
      el = children[i2];
      if (closest(el, options2.draggable, this.el, false)) {
        order2.push(el.getAttribute(options2.dataIdAttr) || _generateId(el));
      }
    }
    return order2;
  },
  sort: function sort(order2, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id2, i2) {
      var el = rootEl2.children[i2];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id2] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order2.forEach(function(id2) {
      if (items[id2]) {
        rootEl2.removeChild(items[id2]);
        rootEl2.appendChild(items[id2]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option(name2, value2) {
    var options2 = this.options;
    if (value2 === void 0) {
      return options2[name2];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name2, value2);
      if (typeof modifiedValue !== "undefined") {
        options2[name2] = modifiedValue;
      } else {
        options2[name2] = value2;
      }
      if (name2 === "group") {
        _prepareGroup(options2);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css$1(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css$1(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index$1(dragEl) < index$1(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
  while (i2--) {
    sum += str.charCodeAt(i2);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn2) {
  return setTimeout(fn2, 0);
}
function _cancelNextTick(id2) {
  return clearTimeout(id2);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css: css$1,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index: index$1,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin2) {
    if (!plugin2.prototype || !plugin2.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin2));
    }
    if (plugin2.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin2.utils);
    PluginManager.mount(plugin2);
  });
};
Sortable.create = function(el, options2) {
  return new Sortable(el, options2);
};
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options2, rootEl2, isFallback) {
  if (!options2.scroll)
    return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options2.scrollSensitivity, speed = options2.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options2.scroll;
    scrollCustomFn = options2.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width2 = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css$1(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width2 < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width2 < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right2 - x) <= sens && scrollPosX + width2 < scrollWidth) - (Math.abs(left2 - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom2 - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i2 = 0; i2 <= layersOut; i2++) {
        if (!autoScrolls[i2]) {
          autoScrolls[i2] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options2.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
function removeNode(node) {
  if (node.parentElement !== null) {
    node.parentElement.removeChild(node);
  }
}
function insertNodeAt(fatherNode, node, position) {
  const refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
  fatherNode.insertBefore(node, refNode);
}
function getConsole() {
  if (typeof window !== "undefined") {
    return window.console;
  }
  return global.console;
}
const console$1 = getConsole();
function cached(fn2) {
  const cache = Object.create(null);
  return function cachedFn(str) {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
}
const regex = /-(\w)/g;
const camelize = cached((str) => str.replace(regex, (_, c) => c.toUpperCase()));
const manageAndEmit$1 = ["Start", "Add", "Remove", "Update", "End"];
const emit$1 = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
const manage$1 = ["Move"];
const eventHandlerNames = [manage$1, manageAndEmit$1, emit$1].flatMap((events2) => events2).map((evt) => `on${evt}`);
const events = {
  manage: manage$1,
  manageAndEmit: manageAndEmit$1,
  emit: emit$1
};
function isReadOnly(eventName) {
  return eventHandlerNames.indexOf(eventName) !== -1;
}
const tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
function isHtmlTag(name2) {
  return tags.includes(name2);
}
function isTransition(name2) {
  return ["transition-group", "TransitionGroup"].includes(name2);
}
function isHtmlAttribute(value2) {
  return ["id", "class", "role", "style"].includes(value2) || value2.startsWith("data-") || value2.startsWith("aria-") || value2.startsWith("on");
}
function project(entries2) {
  return entries2.reduce((res, [key, value2]) => {
    res[key] = value2;
    return res;
  }, {});
}
function getComponentAttributes({ $attrs, componentData = {} }) {
  const attributes2 = project(Object.entries($attrs).filter(([key, _]) => isHtmlAttribute(key)));
  return __spreadValues2(__spreadValues2({}, attributes2), componentData);
}
function createSortableOption({ $attrs, callBackBuilder }) {
  const options2 = project(getValidSortableEntries($attrs));
  Object.entries(callBackBuilder).forEach(([eventType, eventBuilder]) => {
    events[eventType].forEach((event2) => {
      options2[`on${event2}`] = eventBuilder(event2);
    });
  });
  const draggable2 = `[data-draggable]${options2.draggable || ""}`;
  return __spreadProps2(__spreadValues2({}, options2), {
    draggable: draggable2
  });
}
function getValidSortableEntries(value2) {
  return Object.entries(value2).filter(([key, _]) => !isHtmlAttribute(key)).map(([key, value3]) => [camelize(key), value3]).filter(([key, _]) => !isReadOnly(key));
}
const getHtmlElementFromNode = ({ el }) => el;
const addContext = (domElement, context) => domElement.__draggable_context = context;
const getContext = (domElement) => domElement.__draggable_context;
class ComponentStructure {
  constructor({
    nodes: { header, default: defaultNodes, footer },
    root: root2,
    realList
  }) {
    this.defaultNodes = defaultNodes;
    this.children = [...header, ...defaultNodes, ...footer];
    this.externalComponent = root2.externalComponent;
    this.rootTransition = root2.transition;
    this.tag = root2.tag;
    this.realList = realList;
  }
  get _isRootComponent() {
    return this.externalComponent || this.rootTransition;
  }
  render(h2, attributes2) {
    const { tag, children, _isRootComponent } = this;
    const option2 = !_isRootComponent ? children : { default: () => children };
    return h2(tag, attributes2, option2);
  }
  updated() {
    const { defaultNodes, realList } = this;
    defaultNodes.forEach((node, index2) => {
      addContext(getHtmlElementFromNode(node), {
        element: realList[index2],
        index: index2
      });
    });
  }
  getUnderlyingVm(domElement) {
    return getContext(domElement);
  }
  getVmIndexFromDomIndex(domIndex, element) {
    const { defaultNodes } = this;
    const { length } = defaultNodes;
    const domChildren = element.children;
    const domElement = domChildren.item(domIndex);
    if (domElement === null) {
      return length;
    }
    const context = getContext(domElement);
    if (context) {
      return context.index;
    }
    if (length === 0) {
      return 0;
    }
    const firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
    const indexFirstDomListElement = [...domChildren].findIndex((element2) => element2 === firstDomListElement);
    return domIndex < indexFirstDomListElement ? 0 : length;
  }
}
function getSlot(slots, key) {
  const slotValue = slots[key];
  return slotValue ? slotValue() : [];
}
function computeNodes({ $slots, realList, getKey }) {
  const normalizedList = realList || [];
  const [header, footer] = ["header", "footer"].map((name2) => getSlot($slots, name2));
  const { item } = $slots;
  if (!item) {
    throw new Error("draggable element must have an item slot");
  }
  const defaultNodes = normalizedList.flatMap((element, index2) => item({ element, index: index2 }).map((node) => {
    node.key = getKey(element);
    node.props = __spreadProps2(__spreadValues2({}, node.props || {}), { "data-draggable": true });
    return node;
  }));
  if (defaultNodes.length !== normalizedList.length) {
    throw new Error("Item slot must have only one child");
  }
  return {
    header,
    footer,
    default: defaultNodes
  };
}
function getRootInformation(tag) {
  const transition = isTransition(tag);
  const externalComponent = !isHtmlTag(tag) && !transition;
  return {
    transition,
    externalComponent,
    tag: externalComponent ? resolveComponent(tag) : transition ? TransitionGroup : tag
  };
}
function computeComponentStructure({ $slots, tag, realList, getKey }) {
  const nodes = computeNodes({ $slots, realList, getKey });
  const root2 = getRootInformation(tag);
  return new ComponentStructure({ nodes, root: root2, realList });
}
function emit(evtName, evtData) {
  nextTick(() => this.$emit(evtName.toLowerCase(), evtData));
}
function manage(evtName) {
  return (evtData, originalElement) => {
    if (this.realList !== null) {
      return this[`onDrag${evtName}`](evtData, originalElement);
    }
  };
}
function manageAndEmit(evtName) {
  const delegateCallBack = manage.call(this, evtName);
  return (evtData, originalElement) => {
    delegateCallBack.call(this, evtData, originalElement);
    emit.call(this, evtName, evtData);
  };
}
let draggingElement = null;
const props = {
  list: {
    type: Array,
    required: false,
    default: null
  },
  modelValue: {
    type: Array,
    required: false,
    default: null
  },
  itemKey: {
    type: [String, Function],
    required: true
  },
  clone: {
    type: Function,
    default: (original) => {
      return original;
    }
  },
  tag: {
    type: String,
    default: "div"
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: false,
    default: null
  }
};
const emits = [
  "update:modelValue",
  "change",
  ...[...events.manageAndEmit, ...events.emit].map((evt) => evt.toLowerCase())
];
const draggableComponent = defineComponent({
  name: "draggable",
  inheritAttrs: false,
  props,
  emits,
  data() {
    return {
      error: false
    };
  },
  render() {
    try {
      this.error = false;
      const { $slots, $attrs, tag, componentData, realList, getKey } = this;
      const componentStructure = computeComponentStructure({
        $slots,
        tag,
        realList,
        getKey
      });
      this.componentStructure = componentStructure;
      const attributes2 = getComponentAttributes({ $attrs, componentData });
      return componentStructure.render(h, attributes2);
    } catch (err) {
      this.error = true;
      return h("pre", { style: { color: "red" } }, err.stack);
    }
  },
  created() {
    if (this.list !== null && this.modelValue !== null) {
      console$1.error("modelValue and list props are mutually exclusive! Please set one or another.");
    }
  },
  mounted() {
    if (this.error) {
      return;
    }
    const { $attrs, $el, componentStructure } = this;
    componentStructure.updated();
    const sortableOptions = createSortableOption({
      $attrs,
      callBackBuilder: {
        manageAndEmit: (event2) => manageAndEmit.call(this, event2),
        emit: (event2) => emit.bind(this, event2),
        manage: (event2) => manage.call(this, event2)
      }
    });
    const targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
    this._sortable = new Sortable(targetDomElement, sortableOptions);
    this.targetDomElement = targetDomElement;
    targetDomElement.__draggable_component__ = this;
  },
  updated() {
    this.componentStructure.updated();
  },
  beforeUnmount() {
    if (this._sortable !== void 0)
      this._sortable.destroy();
  },
  computed: {
    realList() {
      const { list } = this;
      return list ? list : this.modelValue;
    },
    getKey() {
      const { itemKey } = this;
      if (typeof itemKey === "function") {
        return itemKey;
      }
      return (element) => element[itemKey];
    }
  },
  watch: {
    $attrs: {
      handler(newOptionValue) {
        const { _sortable } = this;
        if (!_sortable)
          return;
        getValidSortableEntries(newOptionValue).forEach(([key, value2]) => {
          _sortable.option(key, value2);
        });
      },
      deep: true
    }
  },
  methods: {
    getUnderlyingVm(domElement) {
      return this.componentStructure.getUnderlyingVm(domElement) || null;
    },
    getUnderlyingPotencialDraggableComponent(htmElement) {
      return htmElement.__draggable_component__;
    },
    emitChanges(evt) {
      nextTick(() => this.$emit("change", evt));
    },
    alterList(onList) {
      if (this.list) {
        onList(this.list);
        return;
      }
      const newList = [...this.modelValue];
      onList(newList);
      this.$emit("update:modelValue", newList);
    },
    spliceList() {
      const spliceList = (list) => list.splice(...arguments);
      this.alterList(spliceList);
    },
    updatePosition(oldIndex2, newIndex2) {
      const updatePosition = (list) => list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
      this.alterList(updatePosition);
    },
    getRelatedContextFromMoveEvent({ to, related }) {
      const component2 = this.getUnderlyingPotencialDraggableComponent(to);
      if (!component2) {
        return { component: component2 };
      }
      const list = component2.realList;
      const context = { list, component: component2 };
      if (to !== related && list) {
        const destination = component2.getUnderlyingVm(related) || {};
        return __spreadValues2(__spreadValues2({}, destination), context);
      }
      return context;
    },
    getVmIndexFromDomIndex(domIndex) {
      return this.componentStructure.getVmIndexFromDomIndex(domIndex, this.targetDomElement);
    },
    onDragStart(evt) {
      this.context = this.getUnderlyingVm(evt.item);
      evt.item._underlying_vm_ = this.clone(this.context.element);
      draggingElement = evt.item;
    },
    onDragAdd(evt) {
      const element = evt.item._underlying_vm_;
      if (element === void 0) {
        return;
      }
      removeNode(evt.item);
      const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
      this.spliceList(newIndex2, 0, element);
      const added = { element, newIndex: newIndex2 };
      this.emitChanges({ added });
    },
    onDragRemove(evt) {
      insertNodeAt(this.$el, evt.item, evt.oldIndex);
      if (evt.pullMode === "clone") {
        removeNode(evt.clone);
        return;
      }
      const { index: oldIndex2, element } = this.context;
      this.spliceList(oldIndex2, 1);
      const removed = { element, oldIndex: oldIndex2 };
      this.emitChanges({ removed });
    },
    onDragUpdate(evt) {
      removeNode(evt.item);
      insertNodeAt(evt.from, evt.item, evt.oldIndex);
      const oldIndex2 = this.context.index;
      const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
      this.updatePosition(oldIndex2, newIndex2);
      const moved2 = { element: this.context.element, oldIndex: oldIndex2, newIndex: newIndex2 };
      this.emitChanges({ moved: moved2 });
    },
    computeFutureIndex(relatedContext, evt) {
      if (!relatedContext.element) {
        return 0;
      }
      const domChildren = [...evt.to.children].filter((el) => el.style["display"] !== "none");
      const currentDomIndex = domChildren.indexOf(evt.related);
      const currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);
      const draggedInList = domChildren.indexOf(draggingElement) !== -1;
      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
    },
    onDragMove(evt, originalEvent) {
      const { move, realList } = this;
      if (!move || !realList) {
        return true;
      }
      const relatedContext = this.getRelatedContextFromMoveEvent(evt);
      const futureIndex = this.computeFutureIndex(relatedContext, evt);
      const draggedContext = __spreadProps2(__spreadValues2({}, this.context), {
        futureIndex
      });
      const sendEvent = __spreadProps2(__spreadValues2({}, evt), {
        relatedContext,
        draggedContext
      });
      return move(sendEvent, originalEvent);
    },
    onDragEnd() {
      draggingElement = null;
    }
  }
});
const _sfc_main$v = defineComponent({
  name: "menuInput",
  data() {
    return {
      inputValue: "",
      isInput: false,
      quitLock: false
    };
  },
  props: {
    data: {
      type: Object,
      default: null
    },
    toClose: Number
  },
  inject: ["closeSignal"],
  watch: {
    "data.value"(val) {
      if (this.data.editType == "showTitle") {
        this.inputValue = val;
      }
    },
    "closeSignal.value"() {
      this.quitEdit();
    },
    toClose(val) {
      if (val > 0) {
        this.isInput = false;
      }
    }
  },
  methods: {
    doButtonExec(data) {
      if (data.buttonEdit) {
        data.buttonEdit.exec(data);
      }
    },
    getInputClass() {
      return {
        editInput: true
      };
    },
    getSpanStyle(data) {
      const style = {
        "margin-left": "1px"
      };
      data.label == "" ? style.color = "#cbcbcb" : null;
      return style;
    },
    getClass(data) {
      return {
        "input-area": true,
        "input-area-button": data.required || data.buttonEdit != null
      };
    },
    getCustomItemContentClass(item) {
      return {
        "cu-pop-item-div-title": true,
        editable: item.editType != "showTitle" && !this.isInput,
        editing: item.editType == "showTitle" || this.isInput,
        "editing-always-show": item.editType == "showTitle"
      };
    },
    inputBlur(item) {
      if (navigator.userAgent.indexOf("Firefox") > -1 && item.editType != "showTitle") {
        return;
      }
      setTimeout(() => {
        if (!this.quitLock) {
          this.quitEdit();
        }
      }, 10);
    },
    quitEdit() {
      this.quitLock = false;
      this.isInput = false;
    },
    doInput(item) {
      if (!item.required) {
        this.editUpdate(item);
      }
      this.$emit("input", item);
    },
    doClickInput(item) {
      this.quitLock = true;
      if (item.required) {
        if (this.inputValue == "") {
          this.$message({
            type: "info",
            message: "[" + item.requiredName + "]\u4E0D\u5141\u8BB8\u4E3A\u7A7A"
          });
          return;
        }
      }
      this.editUpdate(item);
      this.quitEdit();
    },
    editUpdate(item) {
      if (item.editType == "showTitle") {
        this.data.value = this.inputValue;
      } else {
        this.data.label = this.inputValue;
      }
      clearTimeout(this.editExecDelay);
      this.editExecDelay = setTimeout(() => {
        if (item.update) {
          item.update(item);
        }
      }, 300);
    },
    editThis(event2, item) {
      if (item.editType != "showTitle") {
        if (item.editable && !this.isInput) {
          this.isInput = true;
          let target = event2.currentTarget;
          this.inputValue = this.data.label;
          setTimeout(function() {
            target.querySelector("input").focus();
          }, 50);
          event2.stopPropagation();
        }
      }
    }
  },
  mounted() {
    if (this.data.editType == "showTitle") {
      this.inputValue = this.data.value;
    }
  }
});
const _withScopeId$6 = (n) => (pushScopeId("data-v-61de3ae0"), n = n(), popScopeId(), n);
const _hoisted_1$h = ["maxLength", "placeholder"];
const _hoisted_2$e = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode("i", { class: "awsui-iconfont" }, "\uE639", -1));
const _hoisted_3$e = [
  _hoisted_2$e
];
const _hoisted_4$b = ["innerHTML"];
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.getCustomItemContentClass(_ctx.data)),
    onMousedown: _cache[6] || (_cache[6] = ($event) => _ctx.editThis($event, _ctx.data)),
    style: normalizeStyle(_ctx.data.titleStyle)
  }, [
    _ctx.data.editType != "showTitle" ? withDirectives((openBlock(), createElementBlock("span", {
      key: 0,
      style: normalizeStyle(_ctx.getSpanStyle(_ctx.data))
    }, toDisplayString(_ctx.data.label == "" ? _ctx.data.placeholder : _ctx.data.label), 5)), [
      [vShow, !_ctx.isInput]
    ]) : createCommentVNode("v-if", true),
    _ctx.data.editable ? withDirectives((openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(_ctx.getClass(_ctx.data))
    }, [
      withDirectives(createElementVNode("input", {
        type: "text",
        maxLength: _ctx.data.maxLength ? _ctx.data.maxLength : 64,
        class: normalizeClass(_ctx.getInputClass(_ctx.data)),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
        placeholder: _ctx.data.placeholder,
        onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.inputBlur(_ctx.data, $event)),
        onInput: _cache[2] || (_cache[2] = ($event) => _ctx.doInput(_ctx.data)),
        onKeydown: _cache[3] || (_cache[3] = withKeys(($event) => _ctx.doClickInput(_ctx.data), ["enter"]))
      }, null, 42, _hoisted_1$h), [
        [
          vModelText,
          _ctx.inputValue,
          void 0,
          { trim: true }
        ]
      ]),
      _ctx.data.required ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "input-icon",
        onMousedown: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.doClickInput(_ctx.data), ["stop"]))
      }, _hoisted_3$e, 32)) : createCommentVNode("v-if", true),
      _ctx.data.buttonEdit != null ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "input-icon",
        onMousedown: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.doButtonExec(_ctx.data), ["stop"]))
      }, [
        createElementVNode("i", {
          class: "awsui-iconfont",
          innerHTML: _ctx.data.buttonEdit.icon
        }, null, 8, _hoisted_4$b)
      ], 32)) : createCommentVNode("v-if", true)
    ], 2)), [
      [vShow, _ctx.isInput || _ctx.data.editType == "showTitle"]
    ]) : createCommentVNode("v-if", true)
  ], 38);
}
var MenuInput = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$v], ["__scopeId", "data-v-61de3ae0"]]);
const _sfc_main$u = defineComponent({
  name: "ColorPickerBox",
  props: {
    modelValue: String,
    defaultColor: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: ""
    },
    className: String,
    placement: {
      type: String,
      default: "bottom"
    },
    callback: null
  },
  data() {
    return {
      openStatus: false,
      hoveColor: null,
      tColor: [
        "#000000",
        "#ffffff",
        "#eeece1",
        "#1e497b",
        "#4e81bb",
        "#e2534d",
        "#9aba60",
        "#8165a0",
        "#47acc5",
        "#f9974c"
      ],
      colorConfig: [
        ["#0d0d0d", "#808080"],
        ["#7f7f7f", "#f0f0f0"],
        ["#1c1a10", "#ddd8c3"],
        ["#0e243d", "#c6d9f0"],
        ["#233f5e", "#dae5f0"],
        ["#632623", "#f2dbdb"],
        ["#4d602c", "#eaf1de"],
        ["#3f3150", "#e6e0ec"],
        ["#1e5867", "#d9eef3"],
        ["#99490f", "#fee9da"]
      ],
      bColor: [
        "#c21401",
        "#ff1e02",
        "#ffc12a",
        "#ffff3a",
        "#90cf5b",
        "#00af57",
        "#00afee",
        "#0071be",
        "#00215f",
        "#72349d"
      ],
      html5Color: this.modelValue
    };
  },
  computed: {
    showPanelColor() {
      if (this.hoveColor) {
        return this.hoveColor;
      } else {
        return this.showColor;
      }
    },
    showColor() {
      let colorValue = this.modelValue ? this.modelValue : this.defaultColor;
      return colorValue == null || colorValue == "" ? "\u672A\u914D\u7F6E" : colorValue;
    },
    colorPanel() {
      let colorArr = [];
      for (let color of this.colorConfig) {
        colorArr.push(this.gradient(color[1], color[0], 5));
      }
      return colorArr;
    }
  },
  methods: {
    buildColorDiv() {
      let style = {
        "border": "1px solid #e9e9e9",
        "borderRadius": "2px"
      };
      if (this.showColor != null && this.showColor != "") {
        style["background-color"] = this.showColor;
      } else {
        style["backgroundColor"] = "#ffffff00";
        style["color"] = "#ffff12";
        style["font-size"] = "12px";
      }
      return style;
    },
    closePanel() {
      this.openStatus = false;
      setTimeout(() => {
        if (typeof this.callback === "function") {
          this.callback();
        }
      });
    },
    close() {
      this.openStatus = false;
    },
    updataValue(value2) {
      this.$emit("update:modelValue", value2);
      this.$emit("change", value2);
      this.closePanel();
    },
    handleDefaultColor() {
      this.updataValue(this.defaultColor);
    },
    parseColor(hexStr) {
      if (hexStr.length === 4) {
        hexStr = "#" + hexStr[1] + hexStr[1] + hexStr[2] + hexStr[2] + hexStr[3] + hexStr[3];
      }
      return hexStr;
    },
    rgbToHex(r, g, b) {
      let hex2 = (r << 16 | g << 8 | b).toString(16);
      return "#" + new Array(Math.abs(hex2.length - 7)).join("0") + hex2;
    },
    hexToRgb(hex2) {
      const hex22 = this.parseColor(hex2);
      let rgb = [];
      for (let i2 = 1; i2 < 7; i2 += 2) {
        rgb.push(parseInt("0x" + hex22.slice(i2, i2 + 2)));
      }
      return rgb;
    },
    gradient(startColor, endColor, step) {
      let sColor = this.hexToRgb(startColor);
      let eColor = this.hexToRgb(endColor);
      let rStep = (eColor[0] - sColor[0]) / step;
      let gStep = (eColor[1] - sColor[1]) / step;
      let bStep = (eColor[2] - sColor[2]) / step;
      let gradientColorArr = [];
      for (let i2 = 0; i2 < step; i2++) {
        gradientColorArr.push(this.rgbToHex(rStep * i2 + sColor[0], gStep * i2 + sColor[1], bStep * i2 + sColor[2]));
      }
      return gradientColorArr;
    }
  }
});
const _withScopeId$5 = (n) => (pushScopeId("data-v-43159467"), n = n(), popScopeId(), n);
const _hoisted_1$g = { class: "awsui-colorPicker" };
const _hoisted_2$d = { class: "awsui-colorPicker-box" };
const _hoisted_3$d = { class: "hd" };
const _hoisted_4$a = { class: "colorView" };
const _hoisted_5$8 = { class: "bd" };
const _hoisted_6$8 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("h3", null, "\u4E3B\u9898\u989C\u8272", -1));
const _hoisted_7$7 = { class: "tColor" };
const _hoisted_8$7 = ["onMouseover", "onClick"];
const _hoisted_9$7 = { class: "bColor" };
const _hoisted_10$4 = ["onMouseover", "onClick"];
const _hoisted_11$3 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("h3", null, "\u6807\u51C6\u989C\u8272", -1));
const _hoisted_12$3 = { class: "tColor" };
const _hoisted_13$3 = ["onMouseover", "onClick"];
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_input = resolveComponent("awsui-input");
  return openBlock(), createElementBlock("div", _hoisted_1$g, [
    createElementVNode("div", _hoisted_2$d, [
      createElementVNode("div", _hoisted_3$d, [
        createElementVNode("div", _hoisted_4$a, [
          createElementVNode("span", {
            class: "background",
            style: normalizeStyle(`background-color: ${_ctx.showPanelColor == null || _ctx.showPanelColor == "" ? "#ffffff00" : _ctx.showPanelColor};border: 1px solid #e9e9e9;border-radius: 2px;`)
          }, null, 4),
          createVNode(_component_awsui_input, {
            modelValue: _ctx.showPanelColor,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.showPanelColor = $event),
            readonly: "",
            className: `${_ctx.showPanelColor == "\u672A\u914D\u7F6E" ? "awsui-color-input-none" : ""} awsui-color-input`,
            placeholder: ""
          }, null, 8, ["modelValue", "className"])
        ]),
        createElementVNode("div", {
          class: "defaultColor",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleDefaultColor && _ctx.handleDefaultColor(...args)),
          onMouseover: _cache[2] || (_cache[2] = ($event) => _ctx.hoveColor = _ctx.value),
          onMouseout: _cache[3] || (_cache[3] = ($event) => _ctx.hoveColor = null)
        }, "\u6E05\u7A7A ", 32)
      ]),
      createElementVNode("div", _hoisted_5$8, [
        _hoisted_6$8,
        createElementVNode("ul", _hoisted_7$7, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.tColor, (color, index2) => {
            return openBlock(), createElementBlock("li", {
              class: "tColor_li",
              key: index2,
              style: normalizeStyle({ backgroundColor: color }),
              onMouseover: ($event) => _ctx.hoveColor = color,
              onMouseout: _cache[4] || (_cache[4] = ($event) => _ctx.hoveColor = null),
              onClick: ($event) => _ctx.updataValue(color)
            }, null, 44, _hoisted_8$7);
          }), 128))
        ]),
        createElementVNode("ul", _hoisted_9$7, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colorPanel, (item, index2) => {
            return openBlock(), createElementBlock("li", {
              class: "bColor_li",
              key: index2
            }, [
              createElementVNode("ul", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(item, (color, cindex) => {
                  return openBlock(), createElementBlock("li", {
                    class: "bColor_li_li",
                    key: cindex,
                    style: normalizeStyle({ backgroundColor: color }),
                    onMouseover: ($event) => _ctx.hoveColor = color,
                    onMouseout: _cache[5] || (_cache[5] = ($event) => _ctx.hoveColor = null),
                    onClick: ($event) => _ctx.updataValue(color)
                  }, null, 44, _hoisted_10$4);
                }), 128))
              ])
            ]);
          }), 128))
        ]),
        _hoisted_11$3,
        createElementVNode("ul", _hoisted_12$3, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.bColor, (color, index2) => {
            return openBlock(), createElementBlock("li", {
              class: "tColor_li",
              key: index2,
              style: normalizeStyle({ backgroundColor: color }),
              onMouseover: ($event) => _ctx.hoveColor = color,
              onMouseout: _cache[6] || (_cache[6] = ($event) => _ctx.hoveColor = null),
              onClick: ($event) => _ctx.updataValue(color)
            }, null, 44, _hoisted_13$3);
          }), 128))
        ])
      ])
    ])
  ]);
}
var colorPickerBox = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$u], ["__scopeId", "data-v-43159467"]]);
const eventMap = new Map();
const menuOpenComponents = ["colorPicker"];
const bindMenu = (el, binding, vnode, prevNode) => {
  const value2 = binding.value;
  if ((!value2.children || value2.children.length == 0) && !menuOpenComponents.includes(value2.type)) {
    return;
  }
  const that = binding.instance;
  if (that.rootOption != null && that.rootOption.reSetTarget != null) {
    el = that.rootOption.reSetTarget(el, that);
  }
  const nextTransmit = that.nextTransmit;
  const transmit = that.transmit;
  const doOpen = () => {
    const actived = that.rootOption == null || that.rootOption.activeShowMenu !== true || that.data.isActive;
    const isMenuOpenComponent = menuOpenComponents.includes(value2.type);
    nextTransmit.parentValue = that.data;
    if (value2.children != null && transmit.allowmenu !== false && actived || isMenuOpenComponent) {
      nextTransmit.popToTarget = el;
      nextTransmit.context = transmit.context;
      nextTransmit.showPop++;
    }
  };
  const openMenu = () => {
    if (that.visibleInit === false) {
      that.visibleInit = true;
      that.$nextTick(doOpen);
    } else {
      doOpen();
    }
  };
  if (eventMap.get(el) != null) {
    if (eventMap.get(el).openMenu != null) {
      el.removeEventListener("mouseenter", eventMap.get(el).openMenu, false);
    }
    if (eventMap.get(el).closeMenu != null) {
      el.removeEventListener("mouseleave", eventMap.get(el).closeMenu, false);
    }
  }
  el.addEventListener("mouseenter", openMenu, false);
  const closeMenu = () => {
    if (value2.children != null || menuOpenComponents.includes(value2.type)) {
      nextTransmit.parentValue = that.data;
      nextTransmit.closePop++;
    }
  };
  el.addEventListener("mouseleave", closeMenu, false);
  eventMap.set(el, {
    closeMenu,
    openMenu
  });
};
const _sfc_main$t = defineComponent({
  name: "popMenuItem",
  components: { MenuInput, colorPickerBox },
  directives: { bindMenu },
  emits: ["sortEnd", "sortStart", "sortMove", "liClick"],
  props: {
    data: {
      type: Object,
      default() {
        return {};
      }
    },
    close: Number,
    root: Boolean,
    transmit: {
      type: Object,
      default() {
        return {
          root: false
        };
      }
    }
  },
  setup(props2, context) {
    let currentInstance = getCurrentInstance();
    const { proxy: $this } = currentInstance;
    let initOnce = ref(true);
    let inputNumberClass = ref({
      inputNumberCls: true,
      inputNumberError: false
    });
    let nextTransmit = reactive({
      root: false,
      beforeLeaveMenuClose: props2.transmit.beforeLeaveMenuClose,
      showPop: 0,
      closePop: 0
    });
    const computedObj = {
      colorPickerValue: computed({
        get: () => {
          var _a;
          return (_a = props2.data.colorPicker) == null ? void 0 : _a.value;
        },
        set: (value2) => {
          const propsData = props2.data;
          if (propsData.colorPicker != null) {
            propsData.colorPicker.value = value2;
          }
          if (propsData.update) {
            propsData.update(value2);
          }
        }
      }),
      dataInputNumberSymbol: computed({
        get: () => {
          var _a;
          const propsData = props2.data;
          return (_a = propsData.colorPicker) == null ? void 0 : _a.value;
        },
        set: (value2) => {
          const propsData = props2.data;
          if (propsData.inputNumber != null) {
            propsData.inputNumber.symbol = value2;
          }
          if (value2 != null && propsData.update && !initOnce.value) {
            if (propsData.inputNumber && propsData.inputNumber.value != null) {
              propsData.update(propsData.inputNumber.value + value2, propsData.inputNumber.value);
            }
          }
        }
      }),
      dataInputNumberValue: computed({
        get: () => {
          var _a;
          const propsData = props2.data;
          return (_a = propsData.inputNumber) == null ? void 0 : _a.value;
        },
        set: (val) => {
          const propsData = props2.data;
          if (propsData.inputNumber != null) {
            propsData.inputNumber.value = val;
          }
          if (val == "") {
            methods.closeCheckMsg();
            if (propsData.update && !initOnce.value) {
              propsData.update(val, val);
            }
          }
          let result = methods.numFormat(val);
          if (result !== false && propsData.inputNumber != null) {
            propsData.inputNumber.value = result + "";
            if (methods.checkNum(val)) {
              if (propsData.update && !initOnce.value) {
                let numVal = val, newVal = val + "";
                if (propsData.inputNumber.options != null && propsData.inputNumber.options.length > 0) {
                  newVal += propsData.inputNumber.symbol;
                }
                propsData.update(newVal, numVal);
              }
            }
          }
        }
      }),
      isMenuOpenComponent: computed(() => {
        return menuOpenComponents.includes(props2.data.type);
      }),
      menuOpenComponentData: computed(() => {
        if (props2.data.type == "colorPicker") {
          let id2 = props2.data.id + "_colorPickerBox";
          return [{
            id: id2,
            isMenuOpenComponent: true,
            slot: "colorPickerBox"
          }];
        }
        return null;
      }),
      inputNumberWidth: computed(() => {
        if (props2.data.inputNumber.width) {
          return props2.data.inputNumber.width;
        }
        if (props2.data.inputNumber.options != null) {
          if (props2.data.inputNumber.options.length > 1) {
            return 47;
          } else {
            return 99;
          }
        }
        return 99;
      }),
      hasChild: computed(() => {
        return props2.data.children != null && props2.data.children.length > 0;
      }),
      sbtnClass: computed(() => {
        return {
          sbtn: true
        };
      }),
      titleClass: computed(() => {
        return {
          "cu-pop-item-div": true,
          topLine: props2.data.topLine == true,
          "cu-subMenuDiv": computedObj.hasChild.value || computedObj.isMenuOpenComponent.value
        };
      })
    };
    const showNumberTip = ref(false);
    const showNumberMsg = ref("");
    let delayId;
    const methods = {
      copyValue(data) {
        console.log(data.label);
      },
      splitNumberSuf(val) {
        const propsData = props2.data;
        if (typeof val == "string" && propsData.inputNumber && propsData.inputNumber.symbol == null && propsData.inputNumber.options != null && propsData.inputNumber.options.length > 0) {
          let symbol = val.replace(/\d+/, "");
          if (symbol == "" && propsData.inputNumber.options != null && propsData.inputNumber.options.length > 0) {
            if (propsData.inputNumber && propsData.inputNumber.options && propsData.inputNumber.options[0] && propsData.inputNumber.options[0].value != null) {
              symbol = propsData.inputNumber.options[0].value;
            }
          }
          propsData.inputNumber.symbol = symbol;
          propsData.inputNumber.value = val.replace(propsData.inputNumber.symbol, "");
        }
      },
      numFormat(val) {
        let num = parseInt(val);
        if (isNaN(num)) {
          return false;
        } else {
          return num;
        }
      },
      showCheckMsg: (opt) => {
        inputNumberClass.value.inputNumberError = true;
        clearTimeout(delayId);
        delayId = setTimeout(() => {
          showNumberTip.value = true;
          showNumberMsg.value = opt.message;
        }, 300);
      },
      closeCheckMsg: () => {
        inputNumberClass.value.inputNumberError = false;
        clearTimeout(delayId);
        showNumberTip.value = false;
      },
      checkNum(value2) {
        let val = value2;
        if (val == "") {
          methods.closeCheckMsg();
          return true;
        }
        const propsData = props2.data;
        if (propsData.inputNumber) {
          if (propsData.inputNumber.max != null) {
            if (parseInt(val, 10) > propsData.inputNumber.max) {
              methods.showCheckMsg({
                type: "info",
                message: "\u8BF7\u8F93\u5165\u4E0D\u5927\u4E8E" + $this.data.inputNumber.max + "\u7684\u6574\u6570"
              });
              return false;
            }
          }
          if (propsData.inputNumber.min != null) {
            if (parseInt(val, 10) < propsData.inputNumber.min) {
              methods.showCheckMsg({
                type: "info",
                message: "\u8BF7\u8F93\u5165\u4E0D\u5C0F\u4E8E" + $this.data.inputNumber.min + "\u7684\u6574\u6570"
              });
              return false;
            }
          }
        }
        methods.closeCheckMsg();
        return true;
      },
      itemLiClass(data) {
        let cls = {
          "cu-pop-menu-li": true,
          "cu-pop-menu-li-tip": false,
          "cu-pop-menu-li-drag": data.draggable != null ? data.draggable : false
        };
        if (data.type == "tip") {
          cls["cu-pop-menu-li-tip"] = true;
        }
        return cls;
      },
      buildLiStyle(data) {
        if (data.liStyle) {
          return data.liStyle;
        } else if (data.isMenuOpenComponent) {
          return {
            "height": "auto",
            "cursor": "default",
            "padding": "12px 13px 12px 14px",
            "min-width": "0px",
            "background": "white",
            "color": "inherit"
          };
        }
        return {};
      },
      getParentSlot(name2, $component) {
        if (name2 == null) {
          return false;
        }
        if (currentInstance != null && currentInstance.parent != null) {
          $component = $component ? $component : currentInstance.parent;
          let $parent = $component.parent;
          if ($parent != null) {
            if (Object.keys($parent.slots).length > 0 && $parent.slots[name2] != null) {
              context.slots[name2] = $parent.slots[name2];
            } else {
              this.getParentSlot(name2, $parent);
            }
          }
          return true;
        }
        return false;
      },
      childrenDragSort(event2, params) {
        if (params.menuList) {
          const propsData = props2.data;
          params.menuList.push(propsData);
        }
        context.emit("sortEnd", event2, params);
      },
      childrenDragStart(event2, params) {
        if (params.menuList) {
          const propsData = props2.data;
          params.menuList.push(propsData);
        }
        context.emit("sortStart", event2, params);
      },
      childrenDragMove(event2, params) {
        if (params.menuList) {
          const propsData = props2.data;
          params.menuList.push(propsData);
        }
        context.emit("sortMove", event2, params);
      },
      cuPopItemDivRightStyle(data) {
        let style = {};
        if (data.children != null && data.children.length > 0 && data.stext != null && data.stext != "") {
          style = { "margin-right": "22px" };
        }
        if (data.type == "colorPicker")
          ;
        return style;
      },
      bindVue(data) {
        return {
          vue: this,
          data
        };
      },
      btnClick() {
        const propsData = props2.data;
        if (propsData.btn && propsData.btn.exec) {
          propsData.btn.exec(propsData);
        }
      },
      parentTriggerClick(...args) {
        context.emit("liClick", ...args);
      },
      liClick($event) {
        const propsData = props2.data;
        let isCheckLi = propsData.checked != null;
        if (propsData.type == "tip") {
          this.copyValue(propsData);
        }
        context.emit("liClick", propsData, {
          root: props2.root,
          isCheckLi,
          event: $event
        });
      }
    };
    onMounted(() => {
      const propsData = props2.data;
      if (propsData && propsData.inputNumber) {
        methods.splitNumberSuf(propsData.inputNumber.value ? propsData.inputNumber.value : "");
      }
      nextTick(() => {
        initOnce.value = false;
      });
    });
    watch(() => props2.transmit.closePop, (suf) => {
      showNumberTip.value = false;
      nextTransmit.closePop++;
    });
    return __spreadValues2(__spreadValues2({
      initOnce,
      showNumberTip,
      showNumberMsg,
      inputNumberClass,
      nextTransmit
    }, methods), computedObj);
  }
});
const _hoisted_1$f = ["innerHTML"];
const _hoisted_2$c = ["name", "innerHTML"];
const _hoisted_3$c = {
  key: 1,
  class: "awsui-iconfont",
  name: "dragIcon"
};
const _hoisted_4$9 = {
  key: 4,
  class: "scheck"
};
const _hoisted_5$7 = { class: "awsui-iconfont" };
const _hoisted_6$7 = {
  key: 5,
  class: "stext"
};
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");
  const _component_menu_input = resolveComponent("menu-input");
  const _component_awsui_input = resolveComponent("awsui-input");
  const _component_awsui_select = resolveComponent("awsui-select");
  const _component_colorPickerBox = resolveComponent("colorPickerBox");
  const _component_popListDom = resolveComponent("popListDom");
  const _directive_bind_menu = resolveDirective("bind-menu");
  return withDirectives((openBlock(), createElementBlock("li", {
    class: normalizeClass(_ctx.itemLiClass(_ctx.data)),
    onClick: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.liClick && _ctx.liClick(...args), ["stop"])),
    style: normalizeStyle(_ctx.buildLiStyle(_ctx.data))
  }, [
    createCommentVNode('    v-if="getParentSlot(data.slot)"'),
    _ctx.data.slot != null && _ctx.data.slot.length > 0 ? renderSlot(_ctx.$slots, _ctx.data.slot, { key: 0 }) : _ctx.data.type == "tip" ? (openBlock(), createBlock(_component_el_tooltip, {
      key: 1,
      class: "item",
      effect: "dark",
      placement: "bottom",
      "visible-arrow": false
    }, {
      content: withCtx(() => [
        createElementVNode("div", {
          innerHTML: _ctx.data.value
        }, null, 8, _hoisted_1$f)
      ]),
      default: withCtx(() => [
        createElementVNode("span", null, toDisplayString(_ctx.data.label), 1)
      ]),
      _: 1
    })) : (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(_ctx.titleClass),
      style: normalizeStyle(_ctx.data.style)
    }, [
      !_ctx.transmit.childrenNoIcon ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: "icon-span",
        style: normalizeStyle(_ctx.data.iconStyle)
      }, [
        _ctx.data.icon != null ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: "awsui-iconfont",
          name: _ctx.data.draggable ? _ctx.showIcon : "",
          innerHTML: _ctx.data.icon
        }, null, 8, _hoisted_2$c)) : createCommentVNode("v-if", true),
        _ctx.data.draggable ? (openBlock(), createElementBlock("i", _hoisted_3$c, "\uE8E5")) : createCommentVNode("v-if", true)
      ], 4)) : createCommentVNode("v-if", true),
      _ctx.data.editable && _ctx.data.editType != "showTitle" ? (openBlock(), createBlock(_component_menu_input, {
        key: 1,
        data: _ctx.data
      }, null, 8, ["data"])) : (openBlock(), createElementBlock("div", {
        key: 2,
        class: "cu-pop-item-div-title",
        style: normalizeStyle(_ctx.data.titleStyle)
      }, [
        createElementVNode("span", null, toDisplayString(_ctx.data.label), 1)
      ], 4)),
      createElementVNode("div", {
        class: "cu-pop-item-div-right",
        style: normalizeStyle(_ctx.cuPopItemDivRightStyle(_ctx.data))
      }, [
        _ctx.data.editType == "showTitle" && _ctx.data.editable ? (openBlock(), createBlock(_component_menu_input, {
          key: 0,
          data: _ctx.data
        }, null, 8, ["data"])) : createCommentVNode("v-if", true),
        _ctx.data.type == "inputNumber" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createVNode(_component_el_tooltip, {
            modelValue: _ctx.showNumberTip,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.showNumberTip = $event),
            "popper-class": "rich-menu-numberTip",
            content: _ctx.showNumberMsg,
            manual: "true",
            effect: "light"
          }, {
            default: withCtx(() => [
              createVNode(_component_awsui_input, {
                modelValue: _ctx.dataInputNumberValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.dataInputNumberValue = $event),
                "max-length": _ctx.data.inputNumber.maxlength == null ? 4 : _ctx.data.inputNumber.maxlength,
                class: normalizeClass(_ctx.inputNumberClass),
                type: "number",
                placeholder: _ctx.data.inputNumber.placeholder == null ? "\u6574\u6570" : _ctx.data.inputNumber.placeholder,
                style: normalizeStyle({ width: _ctx.inputNumberWidth + "px" })
              }, createSlots({ _: 2 }, [
                _ctx.data.inputNumber.options != null && _ctx.data.inputNumber.options.length == 1 ? {
                  name: "append",
                  fn: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.data.inputNumber.options[0].value), 1)
                  ])
                } : void 0
              ]), 1032, ["modelValue", "max-length", "class", "placeholder", "style"])
            ]),
            _: 1
          }, 8, ["modelValue", "content"]),
          _ctx.data.inputNumber.options != null && _ctx.data.inputNumber.options.length > 1 ? (openBlock(), createBlock(_component_awsui_select, {
            key: 0,
            options: _ctx.data.inputNumber.options,
            style: normalizeStyle({ width: (_ctx.data.inputNumber.optionWidth ? _ctx.data.inputNumber.optionWidth : 52) + "px" }),
            modelValue: _ctx.dataInputNumberSymbol,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.dataInputNumberSymbol = $event),
            popperAppendToBody: false,
            className: "awsui-radius-no-left"
          }, null, 8, ["options", "style", "modelValue"])) : createCommentVNode("v-if", true)
        ], 64)) : _ctx.data.type == "colorPicker" ? (openBlock(), createElementBlock("div", {
          key: 2,
          style: normalizeStyle(`background-color: ${_ctx.data.colorPicker.value}`),
          class: "colorBtn awsui-colorPicker--small"
        }, null, 4)) : createCommentVNode("v-if", true),
        _ctx.data.btn != null ? withDirectives((openBlock(), createElementBlock("span", {
          key: 3,
          class: normalizeClass(_ctx.sbtnClass),
          onClick: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.btnClick && _ctx.btnClick(...args), ["stop"]))
        }, toDisplayString(_ctx.data.btn.label), 3)), [
          [vShow, _ctx.data.checked == true]
        ]) : createCommentVNode("v-if", true),
        _ctx.data.checked != null ? (openBlock(), createElementBlock("span", _hoisted_4$9, [
          withDirectives(createElementVNode("i", _hoisted_5$7, "\uE639", 512), [
            [vShow, _ctx.data.checked == true]
          ])
        ])) : createCommentVNode("v-if", true),
        _ctx.data.stext != null && _ctx.data.stext != "" ? (openBlock(), createElementBlock("span", _hoisted_6$7, toDisplayString(_ctx.data.stext), 1)) : createCommentVNode("v-if", true)
      ], 4)
    ], 6)),
    _ctx.isMenuOpenComponent ? (openBlock(), createBlock(_component_popListDom, {
      key: 3,
      menuList: _ctx.menuOpenComponentData,
      transmit: _ctx.nextTransmit
    }, {
      colorPickerBox: withCtx(() => [
        createVNode(_component_colorPickerBox, {
          modelValue: _ctx.colorPickerValue,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.colorPickerValue = $event),
          close: _ctx.close,
          more: false,
          size: "small"
        }, null, 8, ["modelValue", "close"])
      ]),
      _: 1
    }, 8, ["menuList", "transmit"])) : _ctx.hasChild ? (openBlock(), createBlock(_component_popListDom, {
      key: 4,
      menuList: _ctx.data.children,
      transmit: _ctx.nextTransmit,
      onLiClick: _ctx.parentTriggerClick,
      onSortMove: _ctx.childrenDragMove,
      onSortStart: _ctx.childrenDragStart,
      onSortEnd: _ctx.childrenDragSort
    }, createSlots({ _: 2 }, [
      renderList(_ctx.$slots, (index2, name2) => {
        return {
          name: name2,
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, name2)
          ])
        };
      })
    ]), 1032, ["menuList", "transmit", "onLiClick", "onSortMove", "onSortStart", "onSortEnd"])) : createCommentVNode("v-if", true)
  ], 6)), [
    [_directive_bind_menu, _ctx.data],
    [vShow, _ctx.data.hidden != true]
  ]);
}
var popMenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$t]]);
const openOrCloseDelay = 100;
const _sfc_main$s = defineComponent({
  name: "popListDom",
  components: {
    draggable: draggableComponent,
    popMenuItem
  },
  props: {
    menuList: {
      type: Array,
      default() {
        return [];
      }
    },
    transmit: {
      type: Object,
      default() {
        return {
          root: true,
          showPop: 0,
          closePop: 0
        };
      }
    }
  },
  emits: ["sortEnd", "sortStart", "sortMove", "liClick", "openState"],
  setup(props2, context) {
    let currentInstance = getCurrentInstance();
    let allowmenu = ref(true);
    let popStyle = ref({
      top: "",
      left: "",
      "transform-origin": "center top"
    });
    let rootDom = ref(null);
    let scrollbarDom = ref(null);
    let parentId = ref("");
    let openDelayId = 0;
    let rootAppendToBody = ref(false);
    let isDestroy = ref(false);
    let closeSignal = ref({ value: 0 });
    let nextTransmit = reactive({
      context: {
        top: 0,
        left: 0,
        rootOffset: {}
      },
      beforeLeaveMenuClose: props2.transmit.beforeLeaveMenuClose,
      showPop: 0,
      closePop: 0,
      root: false
    });
    let isScroll2 = ref(false);
    let hasChild = computed(() => {
      return props2.menuList.length > 0;
    });
    let popClass = computed(() => {
      return {
        "cu-pop-menuList": true,
        "cu-pop-menuList-root": props2.transmit.root
      };
    });
    const editMenuList = inject("editMenuList");
    let menuListComputed = computed({
      get() {
        return props2.menuList;
      },
      set(newValue) {
        editMenuList(newValue, {
          menuList: props2.menuList,
          transmit: props2.transmit
        });
      }
    });
    const openMenu = () => {
      if (!allowmenu.value) {
        return;
      }
      let $el = rootDom.value;
      nextTick(() => {
        if ($el != null) {
          $el.style.visibility = "visible";
        }
        Velocity($el, "stop");
        Velocity($el, {
          opacity: 1,
          scaleY: 1
        }, {
          duration: openOrCloseDelay,
          easing: "easeOutQuart"
        });
      });
      clearTimeout(openDelayId);
      const propsTransmit = props2.transmit;
      if (propsTransmit.parentValue) {
        if (propsTransmit.parentValue.childrenNoIcon) {
          nextTransmit.childrenNoIcon = true;
        }
        if (propsTransmit.parentValue.childrenNoIcon == null && propsTransmit.parentValue.children != null) {
          propsTransmit.parentValue.childrenNoIcon = true;
          for (let child of propsTransmit.parentValue.children) {
            if (child.icon != null) {
              propsTransmit.parentValue.childrenNoIcon = false;
              break;
            }
          }
        }
      }
      openDelayId = setTimeout(() => {
        if (props2.transmit.openPopExec) {
          props2.transmit.openPopExec();
        }
        context.emit("openState", {
          open: true,
          value: props2.transmit.parentValue,
          transmitContext: props2.transmit
        });
      }, openOrCloseDelay);
    };
    const closeMenu = () => {
      let $el = rootDom.value;
      nextTick(() => {
        Velocity($el, "stop");
        Velocity($el, { opacity: 0, scaleY: 0 }, {
          duration: openOrCloseDelay,
          easing: "easeInQuart"
        });
      });
      clearTimeout(openDelayId);
      openDelayId = setTimeout(() => {
        if ($el != null) {
          $el.style.visibility = "hidden";
        }
        closeSignal.value.value++;
        nextTransmit.closePop++;
        context.emit("openState", {
          open: false,
          value: props2.transmit.parentValue,
          transmitContext: props2.transmit
        });
        if (props2.transmit.closePopExec) {
          props2.transmit.closePopExec();
        }
      }, openOrCloseDelay);
    };
    const closeRootMenu = (e) => {
      if (props2.transmit.root) {
        let close2 = true;
        if (props2.transmit.beforeLeaveMenuClose) {
          close2 = props2.transmit.beforeLeaveMenuClose(e, currentInstance == null ? void 0 : currentInstance.proxy) !== false;
        }
        if (close2) {
          closeMenu();
        }
      }
    };
    const showMenuList = (transmitItem) => {
      const $el = rootDom.value;
      if ($el == null) {
        return;
      }
      let $ulEl = $el == null ? void 0 : $el.querySelector("ul");
      if ($ulEl == null) {
        $ulEl = $el;
      }
      const targetEl = transmitItem.popTarget;
      if (targetEl == null) {
        return;
      }
      if ($el.style.visibility == "visible" && props2.transmit.parentValue != null && parentId.value == props2.transmit.parentValue.id) {
        openMenu();
        return;
      }
      const getAbsolute = (type2) => {
        const transmitType = props2.transmit[type2];
        if (transmitType != null) {
          if (typeof transmitType == "function") {
            return transmitType(props2.transmit, transmitItem);
          } else {
            return transmitType;
          }
        }
        return 0;
      };
      let targetDomOffset = props2.transmit.root ? tools.getOffset(targetEl) : {
        top: targetEl.offsetTop,
        left: targetEl.offsetLeft,
        height: targetEl.offsetHeight,
        width: targetEl.offsetWidth
      };
      Object.assign(targetDomOffset, transmitItem.offset);
      targetDomOffset.height += getAbsolute("absoluteTop");
      $el.style.height = "auto";
      const menuDomHeight = $ulEl.offsetHeight, menuDomWidth = $el.offsetWidth;
      const windowScrollTop = document.getElementsByTagName("HTML")[0].scrollTop || document.getElementsByTagName("BODY")[0].scrollTop;
      const screenHeight = window.innerHeight;
      const windowScrollLeft = document.getElementsByTagName("HTML")[0].scrollLeft || document.getElementsByTagName("BODY")[0].scrollLeft;
      const screenWidth = window.innerWidth;
      let top2 = 0, left2 = 0;
      if (props2.transmit.root) {
        top2 = targetDomOffset.top + targetDomOffset.height;
        left2 = targetDomOffset.left - 3;
      } else {
        top2 = targetDomOffset.top;
        left2 = targetDomOffset.left + targetDomOffset.width;
        if (props2.transmit.context && nextTransmit.context) {
          nextTransmit.context.rootOffset = props2.transmit.context.rootOffset;
        }
      }
      let screenTop = top2, screenLeft = left2;
      if (props2.transmit.context != null) {
        if (props2.transmit.context && props2.transmit.context.top != null && props2.transmit.context.left != null) {
          screenTop = props2.transmit.context.top + top2;
          screenLeft = props2.transmit.context.left + left2;
        }
      }
      let isRl = false;
      let isUpAndDownNoSizeToShow = false;
      const downZoomHeight = windowScrollTop + screenHeight - screenTop;
      if (downZoomHeight < menuDomHeight) {
        const upZoomheight = screenTop - windowScrollTop - targetDomOffset.height;
        const calcShowUpTopCol = (toTop) => {
          if (toTop) {
            if (props2.transmit.root) {
              top2 = 0;
            } else {
              if (props2.transmit.context && props2.transmit.context.top != null) {
                top2 = 0 - props2.transmit.context.top;
              }
            }
          } else {
            top2 = top2 - menuDomHeight + (props2.transmit.root ? 0 - targetDomOffset.height : targetDomOffset.height);
            top2 = props2.transmit.root ? top2 < 0 ? 0 : top2 : top2;
          }
        };
        if (menuDomHeight <= upZoomheight) {
          calcShowUpTopCol(false);
        } else {
          if (props2.transmit.root) {
            isUpAndDownNoSizeToShow = true;
            const rightZoomWidth = screenWidth - (screenLeft + targetDomOffset.width);
            const leftZoomWidth = screenLeft;
            if (rightZoomWidth >= menuDomWidth) {
              left2 = screenLeft + targetDomOffset.width + 3;
            } else if (leftZoomWidth >= menuDomWidth) {
              left2 = screenLeft - menuDomWidth + 3;
            } else {
              if (rightZoomWidth >= leftZoomWidth) {
                left2 = screenWidth - menuDomWidth;
              } else if (rightZoomWidth < leftZoomWidth) {
                left2 = 0;
              }
            }
          }
          let overFlowHeight = (setHeight) => {
            if (screenHeight < setHeight) {
              setHeight = screenHeight - 9;
            }
            nextTick(() => {
              if ($el != null) {
                $el.style.height = setHeight + "px";
              }
              if (props2.transmit.parentValue && props2.transmit.parentValue.childrenAutoScroll) {
                scrollbarDom.value.$el.style.height = setHeight + "px";
                scrollbarDom.value.update();
              } else {
                if ($el != null) {
                  $el.style.overflow = "visible";
                }
              }
            });
          };
          calcShowUpTopCol(true);
          overFlowHeight(menuDomHeight);
        }
      }
      if (!isUpAndDownNoSizeToShow) {
        if (windowScrollLeft + screenWidth - screenLeft < menuDomWidth) {
          isRl = true;
          left2 = left2 - menuDomWidth + (props2.transmit.root ? targetDomOffset.width : 0 - targetDomOffset.width);
        }
      }
      if (props2.transmit.context && props2.transmit.context.top != null && props2.transmit.context.left != null) {
        if (nextTransmit.context) {
          nextTransmit.context.top = props2.transmit.context.top + top2;
          nextTransmit.context.left = props2.transmit.context.left + left2;
        }
      } else {
        if (nextTransmit.context) {
          nextTransmit.context.top = top2;
          nextTransmit.context.left = left2;
        }
      }
      let popStylePop = top2 + (isRl || !props2.transmit.root ? -3 : 0);
      let popStyleLeft = left2 + getAbsolute("absoluteLeft");
      popStyle.value.top = popStylePop + "px";
      popStyle.value.left = popStyleLeft + "px";
      if (props2.transmit.root && nextTransmit.context) {
        nextTransmit.context.rootOffset = {
          top: popStylePop,
          left: popStyleLeft
        };
      }
      if (props2.transmit.zIndex) {
        popStyle.value["z-index"] = props2.transmit.zIndex;
      }
      openMenu();
      if (props2.transmit.parentValue != null) {
        parentId.value = props2.transmit.parentValue.id == null ? "" : props2.transmit.parentValue.id;
      }
    };
    const dragStart2 = (obj, params) => {
      nextTransmit.allowmenu = false;
      nextTransmit.closePop++;
      params = params == null ? {} : params;
      if (params.menuList) {
        params.menuList.push(props2.menuList);
      } else {
        params.menuList = [props2.menuList];
      }
      context.emit("sortStart", obj, params);
    };
    const dragEnd = (obj, params) => {
      nextTransmit.allowmenu = true;
      params = params == null ? {} : params;
      if (params.menuList) {
        params.menuList.push(props2.menuList);
      } else {
        params.menuList = [props2.menuList];
      }
      context.emit("sortEnd", obj, params);
    };
    const checkMove = (obj, params) => {
      params = params == null ? {} : params;
      if (params.menuList) {
        params.menuList.push(props2.menuList);
      } else {
        params.menuList = [props2.menuList];
      }
      context.emit("sortMove", obj, params);
      if (obj.noMove) {
        return false;
      }
    };
    const parentTriggerClick = (clickData, params) => {
      if (params != null && params.isCheckLi) {
        if (!clickData.multiple) {
          for (let item of props2.menuList) {
            if (clickData.checkGroup == item.checkGroup) {
              let oldCheckState = item.checked;
              item.checked = item.id == clickData.id;
              if (oldCheckState != item.checked) {
                if (item.checked) {
                  if (item.check) {
                    item.check(clickData);
                  }
                } else {
                  if (item.uncheck) {
                    item.uncheck(clickData);
                  }
                }
              }
            }
          }
        } else {
          let oldCheckState = clickData.checked;
          clickData.checked = !clickData.checked;
          if (oldCheckState != clickData.checked) {
            if (clickData.checked) {
              if (clickData.check) {
                clickData.check(clickData);
              }
            } else {
              if (clickData.uncheck) {
                clickData.uncheck(clickData);
              }
            }
          }
        }
        params.isCheckLi = false;
      }
      if (params.menuList) {
        params.menuList.push(props2.menuList);
      } else {
        params.menuList = [props2.menuList];
      }
      context.emit("liClick", clickData, params);
    };
    watch(() => props2.transmit.showPop, () => {
      if (props2.transmit.parentValue && props2.transmit.parentValue.childrenAutoScroll) {
        isScroll2.value = true;
      }
      nextTick(() => {
        showMenuList({
          popTarget: props2.transmit.popToTarget,
          offset: props2.transmit.offset,
          closePop: 0,
          showPop: 0,
          context: { rootOffset: {} }
        });
      });
    });
    watch(() => props2.transmit.closePop, () => {
      closeMenu();
    });
    onMounted(() => {
    });
    onUnmounted(() => {
    });
    provide("closeSignal", closeSignal);
    return {
      allowmenu,
      popStyle,
      parentId,
      rootAppendToBody,
      isDestroy,
      closeSignal,
      nextTransmit,
      isScroll: isScroll2,
      rootDom,
      scrollbarDom,
      hasChild,
      popClass,
      menuListComputed,
      showMenuList,
      openMenu,
      closeMenu,
      closeRootMenu,
      dragStart: dragStart2,
      dragEnd,
      checkMove,
      parentTriggerClick
    };
  }
});
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_popMenuItem = resolveComponent("popMenuItem");
  const _component_draggable = resolveComponent("draggable");
  const _component_aws_scrollbar = resolveComponent("aws-scrollbar");
  return openBlock(), createElementBlock("div", {
    ref: "rootDom",
    class: normalizeClass(_ctx.popClass),
    style: normalizeStyle(_ctx.popStyle),
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.openMenu && _ctx.openMenu(...args)),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.closeRootMenu && _ctx.closeRootMenu(...args))
  }, [
    createVNode(_component_aws_scrollbar, {
      "is-scroll": _ctx.isScroll,
      class: "cu-pop-menu-scroll",
      ref: "scrollbarDom"
    }, {
      default: withCtx(() => [
        withDirectives(createVNode(_component_draggable, {
          tag: "ul",
          modelValue: _ctx.menuListComputed,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.menuListComputed = $event),
          move: _ctx.checkMove,
          onStart: _ctx.dragStart,
          onEnd: _ctx.dragEnd,
          draggable: ".cu-pop-menu-li-drag",
          "item-key": "id",
          class: "cu-pop-menu"
        }, {
          item: withCtx(({ element: child }) => [
            createVNode(_component_popMenuItem, {
              close: _ctx.closeSignal.value,
              data: child,
              transmit: _ctx.nextTransmit,
              onLiClick: _ctx.parentTriggerClick,
              onSortMove: _ctx.checkMove,
              onSortStart: _ctx.dragStart,
              onSortEnd: _ctx.dragEnd
            }, createSlots({ _: 2 }, [
              renderList(_ctx.$slots, (index2, name2) => {
                return {
                  name: name2,
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, name2)
                  ])
                };
              })
            ]), 1032, ["close", "data", "transmit", "onLiClick", "onSortMove", "onSortStart", "onSortEnd"])
          ]),
          _: 3
        }, 8, ["modelValue", "move", "onStart", "onEnd"]), [
          [vShow, _ctx.menuList.length > 0]
        ])
      ]),
      _: 3
    }, 8, ["is-scroll"])
  ], 38);
}
var PopListDom = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$s]]);
const _sfc_main$r = defineComponent({
  name: "AddressDialog",
  components: {
    AwsuiDialog,
    AwsuiButton
  },
  props: {
    setting: Object,
    dialogVisible: {
      type: Boolean,
      default: false
    },
    dialogReload: {
      type: Number,
      default: 0
    }
  },
  setup(props2, ctx2) {
    const { proxy: proxy2 } = getCurrentInstance();
    const isShow = computed({
      get: () => {
        return props2.dialogVisible;
      },
      set: (value2) => {
        ctx2.emit("update:dialogVisible", value2);
      }
    });
    const iframeOption2 = ref(JSON.parse(JSON.stringify(props2.setting)));
    let dialogHeight = ref(iframeOption2.value.dialogHeight ? iframeOption2.value.dialogHeight : "");
    let dialogWidth = ref(iframeOption2.value.dialogWidth ? iframeOption2.value.dialogWidth : "");
    onMounted(() => {
      initIfream(true);
    });
    watch(() => isShow.value, (newVal) => {
      if (newVal) {
        initIfream();
      }
    });
    const getValue2 = () => {
      return proxy2.$refs.awsuiAddress.iframeRef.getWin().getValue();
    };
    const diaConfirm = (data) => {
      let addressVal = getValue2().jsonValue;
      if (props2.setting.callback) {
        props2.setting.callback(addressVal);
      }
      isShow.value = false;
    };
    const diaCancel = () => {
      isShow.value = false;
    };
    const initIfream = (mount2) => {
      iframeOption2.value = JSON.parse(JSON.stringify(props2.setting));
      if (iframeOption2.value.dialogHeight == null && iframeOption2.value.height != null) {
        iframeOption2.value.dialogHeight = iframeOption2.value.height;
      }
      iframeOption2.value.height = "100%";
      iframeOption2.value.width = "100%";
      dialogHeight.value = iframeOption2.value.dialogHeight ? iframeOption2.value.dialogHeight : "";
      dialogWidth.value = iframeOption2.value.dialogWidth ? iframeOption2.value.dialogWidth : "";
      dialogHeight.value = /^\d+$/g.test(dialogHeight.value) ? dialogHeight.value + "px" : dialogHeight.value;
      dialogWidth.value = /^\d+$/g.test(dialogWidth.value) ? dialogWidth.value + "px" : dialogWidth.value;
    };
    return {
      isShow,
      iframeOption: iframeOption2,
      dialogHeight,
      dialogWidth,
      diaConfirm,
      getValue: getValue2,
      diaCancel,
      initIfream
    };
  }
});
const _hoisted_1$e = { class: "awsui-dialog" };
const _hoisted_2$b = { class: "dialog-footer" };
const _hoisted_3$b = /* @__PURE__ */ createTextVNode("\u786E\u5B9A ");
const _hoisted_4$8 = /* @__PURE__ */ createTextVNode("\u53D6\u6D88");
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_button = resolveComponent("awsui-button");
  const _component_awsui_dialog = resolveComponent("awsui-dialog");
  return openBlock(), createElementBlock("div", _hoisted_1$e, [
    createVNode(_component_awsui_dialog, {
      title: _ctx.setting.title,
      "append-to-body": "",
      modelValue: _ctx.isShow,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.isShow = $event),
      modal: true,
      "close-on-click-modal": false,
      iframeOption: _ctx.iframeOption,
      iframeReload: _ctx.dialogReload,
      ref: "awsuiAddress",
      width: _ctx.dialogWidth,
      height: _ctx.dialogHeight,
      class: "address-dialog"
    }, {
      footer: withCtx(() => [
        createElementVNode("div", _hoisted_2$b, [
          createVNode(_component_awsui_button, {
            id: "confirmBtn",
            type: "primary",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.diaConfirm())
          }, {
            default: withCtx(() => [
              _hoisted_3$b
            ]),
            _: 1
          }),
          createVNode(_component_awsui_button, { onClick: _ctx.diaCancel }, {
            default: withCtx(() => [
              _hoisted_4$8
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      _: 1
    }, 8, ["title", "modelValue", "iframeOption", "iframeReload", "width", "height"])
  ]);
}
var addressDialog = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r], ["__scopeId", "data-v-44634e8b"]]);
const vmObj$2 = {
  vm: null
};
const visible$2 = ref(false);
const reload$1 = ref(1);
const propsOptions$2 = reactive({
  data: {
    value: "",
    address: "",
    sid: "",
    appId: "",
    addressDomId: "",
    formData: "",
    width: 0,
    height: 0,
    cmd: "",
    title: ""
  },
  url: "",
  type: "post"
});
const openAddress = (options2) => {
  var _a;
  for (const item in propsOptions$2) {
    delete propsOptions$2[item];
  }
  Object.assign(propsOptions$2, options2);
  if (vmObj$2.vm == null) {
    const renderTest = defineComponent({
      render() {
        return h(addressDialog, {
          setting: propsOptions$2,
          dialogReload: reload$1.value,
          dialogVisible: visible$2.value,
          "onUpdate:dialogVisible": (value2) => {
            visible$2.value = value2;
          }
        });
      },
      setup(props2, context) {
        visible$2.value = false;
        return {
          visible: visible$2
        };
      }
    });
    vmObj$2.vm = createVNode(renderTest);
    render$Z(vmObj$2.vm, document.createElement("div"));
    document.getElementsByTagName("body")[0].appendChild((_a = vmObj$2.vm) == null ? void 0 : _a.el);
  }
  reload$1.value++;
  visible$2.value = true;
};
const closeAddress = () => {
  if (visible$2.value) {
    visible$2.value = false;
  }
};
var Address = {
  openAddress,
  closeAddress
};
const _sfc_main$q = defineComponent({
  name: "AwsuiAddress",
  props: {
    propsOptions: Object,
    modelValue: {
      type: String,
      default: ""
    }
  },
  setup(props2, ctx2) {
    const { proxy: proxy2 } = getCurrentInstance();
    const isShow = ref(false);
    const addressValue = ref([]);
    const configFormat = ref("");
    const dialogTitle = ref("");
    const otherDiaConfirm = ref(null);
    const readonly = props2.propsOptions.readonly;
    const disabled = props2.propsOptions.disabled;
    const urlAxios = axios;
    let tags2 = ref([]);
    watch(() => tags2.value, (newVal, oldValue) => {
      let setData = [];
      for (let i2 = 0; i2 < newVal.length; i2++) {
        setData.push(newVal[i2].value);
      }
      ctx2.emit("update:modelValue", setData);
    }, {
      deep: true
    });
    watch(() => {
      var _a;
      return (_a = props2.propsOptions) == null ? void 0 : _a.data.value;
    }, () => {
      mountMethod();
    });
    onMounted(() => {
      mountMethod();
    });
    const mountMethod = () => {
      var _a, _b, _c, _d, _e;
      if (((_a = props2.propsOptions) == null ? void 0 : _a.data) && ((_b = props2.propsOptions) == null ? void 0 : _b.data.value) && ((_c = props2.propsOptions) == null ? void 0 : _c.data.value) != "") {
        urlAxios.post({
          url: "jd",
          data: {
            cmd: "CLIENT_AWSUI_ADDRESS_VALUE",
            address: (_d = props2.propsOptions) == null ? void 0 : _d.data.address,
            addressDomId: "address",
            value: ((_e = props2.propsOptions) == null ? void 0 : _e.data.value) ? props2.propsOptions.data.value : "",
            formData: "{}",
            appId: ""
          }
        }).then(function(r) {
          if (r.result == "ok" && r.data.itemList && r.data.itemList.length > 0) {
            let tasDefalut = r.data.itemList;
            tasDefalut.forEach((item) => {
              item.text = item.name;
            });
            tags2.value = tasDefalut;
          }
        });
      }
    };
    const delComputed = computed({
      get: () => {
        if (tags2.value.length === 0) {
          return false;
        }
        return true;
      },
      set: (value2) => {
        ctx2.emit("update:modelValue", value2);
      }
    });
    const config2 = ref({
      filter: {
        addressType: "user",
        isAdvMode: true,
        addressSetting: {
          range: "department|position|role|team",
          delimiter: " ",
          choiceType: "",
          leafType: "user"
        },
        sourceField: "UID",
        targetField: "address",
        deptTargetField: ""
      },
      separator: " "
    });
    const defaultOptios = ref({
      data: {
        value: "zhf",
        address: JSON.stringify(config2.value),
        sid: proxy2.AWSPageContext.settingParam.sessionId,
        appId: "",
        addressDomId: "address",
        formData: "",
        cmd: "CLIENT_AWSUI_ADDRESSBOOK"
      },
      title: "\u4EBA\u5458",
      height: 556,
      disabled: false,
      readonly: false,
      maxRowNumber: false,
      url: proxy2.AWSPageContext.axiosBaseUrl + "w"
    });
    const open = () => {
      let propsOptions2 = {};
      let propsOptionsAssign = {};
      let propsOptionsAssigDefault = {};
      let propsOptionsAssignData = {};
      let propsOptionsAssignAdress = {};
      let propsOptionsAssignFilter = {};
      let propsOptionsAssignAddressSetting = {};
      propsOptionsAssign = props2.propsOptions;
      let addressOptios = JSON.parse(defaultOptios.value.data.address);
      let AssignAddress = JSON.parse(propsOptionsAssign.data.address);
      propsOptionsAssigDefault = Object.assign({}, defaultOptios.value, propsOptionsAssign);
      propsOptionsAssignData = Object.assign({}, defaultOptios.value.data, propsOptionsAssign.data);
      propsOptionsAssignAdress = Object.assign({}, addressOptios, AssignAddress);
      propsOptionsAssignFilter = Object.assign({}, addressOptios.filter, AssignAddress.filter);
      propsOptionsAssignAddressSetting = Object.assign({}, addressOptios.filter.addressSetting, AssignAddress.filter.addressSetting);
      propsOptionsAssignFilter.addressSetting = propsOptionsAssignAddressSetting;
      propsOptionsAssignAdress.filter = propsOptionsAssignFilter;
      propsOptionsAssignData.address = JSON.stringify(propsOptionsAssignAdress);
      propsOptionsAssigDefault.data = propsOptionsAssignData;
      propsOptions2 = propsOptionsAssigDefault;
      const customCallBack = propsOptions2.callback;
      propsOptions2.callback = (value2) => {
        tags2.value = value2;
        if (customCallBack) {
          customCallBack(value2);
        }
      };
      let delimiter = JSON.parse(props2.propsOptions.data.address).filter.addressSetting.delimiter;
      let tasDefalut = [];
      if (tags2.value && tags2.value.length) {
        if (tags2.value.length > 0) {
          for (let i2 = 0; i2 < tags2.value.length; i2++) {
            tasDefalut.push(tags2.value[i2].value);
          }
        }
      }
      propsOptions2.data.value = tasDefalut.join(delimiter);
      Address.openAddress(propsOptions2);
    };
    const passConfig = ref({
      filter: {
        addressSetting: {}
      }
    });
    const closeTag = (data, index2) => {
      for (let i2 = 0; i2 < tags2.value.length; i2++) {
        if (index2 == i2) {
          tags2.value.splice(i2, 1);
        }
      }
      if (props2.propsOptions.callback) {
        props2.propsOptions.callback(tags2.value);
      }
    };
    const delAll = () => {
      tags2.value.length = 0;
      if (props2.propsOptions.callback) {
        props2.propsOptions.callback(tags2.value);
      }
      proxy2.$emit("input", "");
      proxy2.$emit("change", "");
    };
    return {
      readonly,
      disabled,
      isShow,
      addressValue,
      configFormat,
      dialogTitle,
      otherDiaConfirm,
      passConfig,
      tags: tags2,
      delComputed,
      urlAxios,
      open,
      closeTag,
      delAll,
      mountMethod
    };
  }
});
const _hoisted_1$d = { class: "awsui-address-content" };
const _hoisted_2$a = ["innerHTML"];
const _hoisted_3$a = { class: "awsui-address-ico" };
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  return openBlock(), createElementBlock("div", null, [
    createElementVNode("div", {
      class: normalizeClass(["awsui-address", { "setAddressHeight": _ctx.propsOptions.maxRowNumber }])
    }, [
      createVNode(_component_el_scrollbar, null, {
        default: withCtx(() => [
          createElementVNode("div", _hoisted_1$d, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.tags, (tag, index2) => {
              return openBlock(), createBlock(_component_el_tag, {
                key: tag.text,
                size: "small",
                closable: "",
                onClose: ($event) => _ctx.closeTag(tag, index2),
                type: tag.type
              }, {
                default: withCtx(() => [
                  createElementVNode("i", {
                    class: "awsui-iconfont hover",
                    innerHTML: tag.icon
                  }, null, 8, _hoisted_2$a),
                  createElementVNode("span", null, toDisplayString(tag.text), 1)
                ]),
                _: 2
              }, 1032, ["onClose", "type"]);
            }), 128))
          ])
        ]),
        _: 1
      }),
      createElementVNode("div", _hoisted_3$a, [
        !_ctx.readonly && !_ctx.disabled ? withDirectives((openBlock(), createElementBlock("i", {
          key: 0,
          class: "awsui-iconfont awsui-iconfont-del",
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.delAll && _ctx.delAll(...args))
        }, "\uE62F", 512)), [
          [vShow, _ctx.delComputed]
        ]) : createCommentVNode("v-if", true),
        !_ctx.readonly && !_ctx.disabled ? (openBlock(), createElementBlock("i", {
          key: 1,
          class: "awsui-iconfont awsui-iconfont-add-ico",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.open && _ctx.open(...args)),
          ref: "addIco"
        }, "\uE680", 512)) : createCommentVNode("v-if", true)
      ])
    ], 2)
  ]);
}
var AwsuiAddress = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q], ["__scopeId", "data-v-f596d4cc"]]);
(function(mod) {
  mod(CodeMirror);
})(function(CodeMirror2) {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
  var Pos2 = CodeMirror2.Pos;
  var matching = { "(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<" };
  function bracketRegex(config2) {
    return config2 && config2.bracketRegex || /[(){}[\]]/;
  }
  function findMatchingBracket(cm, where, config2) {
    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
    var afterCursor = config2 && config2.afterCursor;
    if (afterCursor == null)
      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);
    var re = bracketRegex(config2);
    var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
    if (!match)
      return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (config2 && config2.strict && dir > 0 != (pos == where.ch))
      return null;
    var style = cm.getTokenTypeAt(Pos2(where.line, pos + 1));
    var found = scanForBracket(cm, Pos2(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config2);
    if (found == null)
      return null;
    return {
      from: Pos2(where.line, pos),
      to: found && found.pos,
      match: found && found.ch == match.charAt(0),
      forward: dir > 0
    };
  }
  function scanForBracket(cm, where, dir, style, config2) {
    var maxScanLen = config2 && config2.maxScanLineLength || 1e4;
    var maxScanLines = config2 && config2.maxScanLines || 1e3;
    var stack = [];
    var re = bracketRegex(config2);
    var lineEnd2 = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
    for (var lineNo2 = where.line; lineNo2 != lineEnd2; lineNo2 += dir) {
      var line = cm.getLine(lineNo2);
      if (!line)
        continue;
      var pos = dir > 0 ? 0 : line.length - 1, end2 = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen)
        continue;
      if (lineNo2 == where.line)
        pos = where.ch - (dir < 0 ? 1 : 0);
      for (; pos != end2; pos += dir) {
        var ch = line.charAt(pos);
        if (re.test(ch) && (style === void 0 || (cm.getTokenTypeAt(Pos2(lineNo2, pos + 1)) || "") == (style || ""))) {
          var match = matching[ch];
          if (match && match.charAt(1) == ">" == dir > 0)
            stack.push(ch);
          else if (!stack.length)
            return { pos: Pos2(lineNo2, pos), ch };
          else
            stack.pop();
        }
      }
    }
    return lineNo2 - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }
  function matchBrackets(cm, autoclear, config2) {
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, highlightNonMatching = config2 && config2.highlightNonMatching;
    var marks = [], ranges = cm.listSelections();
    for (var i2 = 0; i2 < ranges.length; i2++) {
      var match = ranges[i2].empty() && findMatchingBracket(cm, ranges[i2].head, config2);
      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos2(match.from.line, match.from.ch + 1), { className: style }));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
          marks.push(cm.markText(match.to, Pos2(match.to.line, match.to.ch + 1), { className: style }));
      }
    }
    if (marks.length) {
      if (ie_lt8 && cm.state.focused)
        cm.focus();
      var clear = function() {
        cm.operation(function() {
          for (var i3 = 0; i3 < marks.length; i3++)
            marks[i3].clear();
        });
      };
      if (autoclear)
        setTimeout(clear, 800);
      else
        return clear;
    }
  }
  function doMatchBrackets(cm) {
    cm.operation(function() {
      if (cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }
  function clearHighlighted(cm) {
    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
      cm.state.matchBrackets.currentlyHighlighted();
      cm.state.matchBrackets.currentlyHighlighted = null;
    }
  }
  CodeMirror2.defineOption("matchBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror2.Init) {
      cm.off("cursorActivity", doMatchBrackets);
      cm.off("focus", doMatchBrackets);
      cm.off("blur", clearHighlighted);
      clearHighlighted(cm);
    }
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
      cm.on("focus", doMatchBrackets);
      cm.on("blur", clearHighlighted);
    }
  });
  CodeMirror2.defineExtension("matchBrackets", function() {
    matchBrackets(this, true);
  });
  CodeMirror2.defineExtension("findMatchingBracket", function(pos, config2, oldConfig) {
    if (oldConfig || typeof config2 == "boolean") {
      if (!oldConfig) {
        config2 = config2 ? { strict: true } : null;
      } else {
        oldConfig.strict = config2;
        config2 = oldConfig;
      }
    }
    return findMatchingBracket(this, pos, config2);
  });
  CodeMirror2.defineExtension("scanForBracket", function(pos, dir, style, config2) {
    return scanForBracket(this, pos, dir, style, config2);
  });
});
(function(mod) {
  mod(CodeMirror);
})(function(CodeMirror2) {
  var tables;
  var defaultTable;
  var keywords2;
  var identifierQuote;
  var CONS = {
    QUERY_DIV: ";",
    ALIAS_KEYWORD: "AS"
  };
  var Pos2 = CodeMirror2.Pos, cmpPos = CodeMirror2.cmpPos;
  function isArray2(val) {
    return Object.prototype.toString.call(val) == "[object Array]";
  }
  function getKeywords(editor) {
    var mode = editor.doc.modeOption;
    if (mode === "awsAt")
      mode = "awsAt";
    return CodeMirror2.resolveMode(mode).keywords;
  }
  function getIdentifierQuote(editor) {
    var mode = editor.doc.modeOption;
    if (mode === "sql")
      mode = "text/x-sql";
    return CodeMirror2.resolveMode(mode).identifierQuote || "`";
  }
  function getText(item) {
    return typeof item == "string" ? item : item.text;
  }
  function wrapTable(name2, value2) {
    if (isArray2(value2))
      value2 = { columns: value2 };
    if (!value2.text)
      value2.text = name2;
    return value2;
  }
  function parseTables(input2) {
    var result = {};
    if (isArray2(input2)) {
      for (var i2 = input2.length - 1; i2 >= 0; i2--) {
        var item = input2[i2];
        result[getText(item).toUpperCase()] = wrapTable(getText(item), item);
      }
    } else if (input2) {
      for (var name2 in input2)
        result[name2.toUpperCase()] = wrapTable(name2, input2[name2]);
    }
    return result;
  }
  function getTable(name2) {
    return tables[name2.toUpperCase()];
  }
  function shallowClone(object3) {
    var result = {};
    for (var key in object3)
      if (object3.hasOwnProperty(key))
        result[key] = object3[key];
    return result;
  }
  function match(string2, word) {
    var len = string2.length;
    var sub = getText(word).substr(0, len);
    return string2.toUpperCase() === sub.toUpperCase();
  }
  function addMatches(result, search, wordlist, formatter2) {
    if (wordlist) {
      for (var word in wordlist)
        if (wordlist.hasOwnProperty(word)) {
          var keyObj = wordlist[word];
          if (keyObj && match(search, word)) {
            if (word.indexOf("@") === -1) {
              result.push(formatter2(keyObj.name, null, keyObj.id));
            } else {
              result.push(formatter2(keyObj.key + " - " + keyObj.title, null, keyObj.key));
            }
          }
        }
    }
  }
  function cleanName(name2) {
    if (name2.charAt(0) == ".") {
      name2 = name2.substr(1);
    }
    var nameParts = name2.split(identifierQuote + identifierQuote);
    for (var i2 = 0; i2 < nameParts.length; i2++)
      nameParts[i2] = nameParts[i2].replace(new RegExp(identifierQuote, "g"), "");
    return nameParts.join(identifierQuote);
  }
  function insertIdentifierQuotes(name2) {
    var nameParts = getText(name2).split(".");
    for (var i2 = 0; i2 < nameParts.length; i2++)
      nameParts[i2] = identifierQuote + nameParts[i2].replace(new RegExp(identifierQuote, "g"), identifierQuote + identifierQuote) + identifierQuote;
    var escaped = nameParts.join(".");
    if (typeof name2 == "string")
      return escaped;
    name2 = shallowClone(name2);
    name2.text = escaped;
    return name2;
  }
  function nameCompletion(cur, token, result, editor) {
    var useIdentifierQuotes = false;
    var nameParts = [];
    var start2 = token.start;
    var cont = true;
    while (cont) {
      cont = token.string.charAt(0) == ".";
      useIdentifierQuotes = useIdentifierQuotes || token.string.charAt(0) == identifierQuote;
      start2 = token.start;
      nameParts.unshift(cleanName(token.string));
      token = editor.getTokenAt(Pos2(cur.line, token.start));
      if (token.string == ".") {
        cont = true;
        token = editor.getTokenAt(Pos2(cur.line, token.start));
      }
    }
    var string2 = nameParts.join(".");
    addMatches(result, string2, tables, function(w) {
      return useIdentifierQuotes ? insertIdentifierQuotes(w) : w;
    });
    addMatches(result, string2, defaultTable, function(w) {
      return useIdentifierQuotes ? insertIdentifierQuotes(w) : w;
    });
    string2 = nameParts.pop();
    var table = nameParts.join(".");
    var alias = false;
    var aliasTable = table;
    if (!getTable(table)) {
      var oldTable = table;
      table = findTableByAlias(table, editor);
      if (table !== oldTable)
        alias = true;
    }
    var columns = getTable(table);
    if (columns && columns.columns)
      columns = columns.columns;
    if (columns) {
      addMatches(result, string2, columns, function(w) {
        var tableInsert = table;
        if (alias == true)
          tableInsert = aliasTable;
        if (typeof w == "string") {
          w = tableInsert + "." + w;
        } else {
          w = shallowClone(w);
          w.text = tableInsert + "." + w.text;
        }
        return useIdentifierQuotes ? insertIdentifierQuotes(w) : w;
      });
    }
    return start2;
  }
  function eachWord(lineText, f) {
    var words = lineText.split(/\s+/);
    for (var i2 = 0; i2 < words.length; i2++)
      if (words[i2])
        f(words[i2].replace(/[,;]/g, ""));
  }
  function findTableByAlias(alias, editor) {
    var doc = editor.doc;
    var fullQuery = doc.getValue();
    var aliasUpperCase = alias.toUpperCase();
    var previousWord = "";
    var table = "";
    var separator = [];
    var validRange = {
      start: Pos2(0, 0),
      end: Pos2(editor.lastLine(), editor.getLineHandle(editor.lastLine()).length)
    };
    var indexOfSeparator = fullQuery.indexOf(CONS.QUERY_DIV);
    while (indexOfSeparator != -1) {
      separator.push(doc.posFromIndex(indexOfSeparator));
      indexOfSeparator = fullQuery.indexOf(CONS.QUERY_DIV, indexOfSeparator + 1);
    }
    separator.unshift(Pos2(0, 0));
    separator.push(Pos2(editor.lastLine(), editor.getLineHandle(editor.lastLine()).text.length));
    var prevItem = null;
    var current = editor.getCursor();
    for (var i2 = 0; i2 < separator.length; i2++) {
      if ((prevItem == null || cmpPos(current, prevItem) > 0) && cmpPos(current, separator[i2]) <= 0) {
        validRange = { start: prevItem, end: separator[i2] };
        break;
      }
      prevItem = separator[i2];
    }
    if (validRange.start) {
      var query = doc.getRange(validRange.start, validRange.end, false);
      for (var i2 = 0; i2 < query.length; i2++) {
        var lineText = query[i2];
        eachWord(lineText, function(word) {
          var wordUpperCase = word.toUpperCase();
          if (wordUpperCase === aliasUpperCase && getTable(previousWord))
            table = previousWord;
          if (wordUpperCase !== CONS.ALIAS_KEYWORD)
            previousWord = word;
        });
        if (table)
          break;
      }
    }
    return table;
  }
  CodeMirror2.registerHelper("hint", "atformula", function(editor, options2) {
    tables = parseTables(options2 && options2.tables);
    var defaultTableName = options2 && options2.defaultTable;
    var disableKeywords = options2 && options2.disableKeywords;
    defaultTable = defaultTableName && getTable(defaultTableName);
    keywords2 = editor.keywords ? editor.keywords : getKeywords(editor);
    identifierQuote = getIdentifierQuote(editor);
    if (defaultTableName && !defaultTable)
      defaultTable = findTableByAlias(defaultTableName, editor);
    defaultTable = defaultTable || [];
    if (defaultTable.columns)
      defaultTable = defaultTable.columns;
    var cur = editor.getCursor();
    var result = [];
    var token = editor.getTokenAt(cur), start2, end2, search;
    if (token.end > cur.ch) {
      token.end = cur.ch;
      token.string = token.string.slice(0, cur.ch - token.start);
    }
    if (token.string.match(/^[.`"\w@]\w*$/)) {
      search = token.string;
      start2 = token.start;
      end2 = token.end;
    } else {
      start2 = end2 = cur.ch;
      search = "";
    }
    if (search.length === 0)
      return;
    if (search.charAt(0) == "." || search.charAt(0) == identifierQuote) {
      start2 = nameCompletion(cur, token, result, editor);
    } else {
      addMatches(result, search, defaultTable, function(w) {
        return { text: w, className: "CodeMirror-hint-table CodeMirror-hint-default-table" };
      });
      addMatches(result, search, tables, function(w) {
        if (typeof w === "object") {
          w.className = "CodeMirror-hint-table";
        } else {
          w = { text: w, className: "CodeMirror-hint-table" };
        }
        return w;
      });
      if (!disableKeywords)
        addMatches(result, search, keywords2, function(w, q, k) {
          return { text: w, className: "CodeMirror-hint-keyword", desc: q, key: k };
        });
    }
    return { list: result, from: Pos2(cur.line, start2), to: Pos2(cur.line, end2) };
  });
});
(function(mod) {
  mod(CodeMirror);
})(function(CodeMirror) {
  CodeMirror.defineMode("atformula", function(config2, parserConfig) {
    parserConfig.client || {};
    var atoms = parserConfig.atoms || { "false": true, "true": true, "null": true }, builtin = parserConfig.builtin || {}, keywords2 = parserConfig.keywords || {}, atKeywords = parserConfig.atKeywords || {};
    parserConfig.operatorChars || /^[*+\-%<>!=&|~^]/;
    var support = parserConfig.support || {};
    parserConfig.hooks || {};
    var dateSQL = parserConfig.dateSQL || { "date": true, "time": true, "timestamp": true };
    parserConfig.backslashStringEscapes !== false;
    var brackets2 = parserConfig.brackets || /^[\{}\(\)\[\]]/, punctuation = parserConfig.punctuation || /^[;.,:]/, bokeys = parserConfig.bokeys || {};
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (support.hexNumber && (ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/) || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {
        return "number";
      } else if (brackets2.test(ch)) {
        stream.eatWhile(brackets2);
        return "bracket";
      } else if (punctuation.test(ch)) {
        stream.eatWhile(punctuation);
        return "punctuation";
      } else {
        stream.eatWhile(/^[_\w\d]/);
        var word = stream.current();
        if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/)))
          return "number";
        if (atoms.hasOwnProperty(word))
          return "atom";
        if (builtin.hasOwnProperty(word))
          return "builtin";
        if (keywords2.hasOwnProperty(word))
          return "keyword";
        if (atKeywords.hasOwnProperty(word))
          return "keyword";
        if (bokeys.hasOwnProperty(word))
          return "param";
        return "test";
      }
    }
    function pushContext(stream, state, type2) {
      state.context = {
        prev: state.context,
        indent: stream.indentation(),
        col: stream.column(),
        type: type2
      };
    }
    function popContext(state) {
      state.indent = state.context.indent;
      state.context = state.context.prev;
    }
    return {
      startState: function() {
        return { tokenize: tokenBase, context: null };
      },
      token: function(stream, state) {
        if (stream.sol()) {
          if (state.context && state.context.align == null)
            state.context.align = false;
        }
        if (state.tokenize == tokenBase && stream.eatSpace())
          return null;
        var style = state.tokenize(stream, state);
        if (style == "comment")
          return style;
        if (state.context && state.context.align == null)
          state.context.align = true;
        var tok = stream.current();
        if (tok == "(")
          pushContext(stream, state, ")");
        else if (tok == "[")
          pushContext(stream, state, "]");
        else if (state.context && state.context.type == tok)
          popContext(state);
        return style;
      },
      indent: function(state, textAfter) {
        var cx = state.context;
        if (!cx)
          return CodeMirror.Pass;
        var closing = textAfter.charAt(0) == cx.type;
        if (cx.align)
          return cx.col + (closing ? 0 : 1);
        else
          return cx.indent + (closing ? 0 : config2.indentUnit);
      },
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : "--",
      closeBrackets: "()[]{}''\"\"``"
    };
  });
  (function() {
    let defaultAtExpressKeywords = "@AWS5SessionId() @AWS5WebURL(*url) @TaskSameHuman(*nextUserTaskDefId,isPerformer,taskInstId) @abs(*num) @activityDefDurationTime(taskInstId) @activityDefExt(taskInstId) @activityDefId(taskInstId) @activityDefName(taskInstId) @activityDefNo(taskInstId) @activityDefWarningTime(taskInstId) @and(*logical1,*logical2,logical3,logical4,logical5) @ascii(*str) @boItemPropVal(*boName,*fieldName,*prop) @calc(*expression) @char(*ascii) @clientIp @companyExt1(contextType,contextId) @companyExt2(contextType,contextId) @companyExt3(contextType,contextId) @companyExt4(contextType,contextId) @companyExt5(contextType,contextId) @companyId(contextType,contextId) @companyName(contextType,contextId) @companyNo(contextType,contextId) @companyType(contextType,contextId) @date() @date2Chinese(*date) @dateAdd(*datepart,*number,*date) @datetime() @dayOfMonth(date) @dayOfYear(date) @decode(*str) @departmentExt1(contextType,contextId) @departmentExt2(contextType,contextId) @departmentExt3(contextType,contextId) @departmentExt4(contextType,contextId) @departmentExt5(contextType,contextId) @departmentId(contextType,contextId) @departmentManager(isIgnoreMe,contextType,contextId) @departmentName(contextType,contextId) @departmentNo(contextType,contextId) @departmentPathId(contextType,contextId) @departmentPathName(contextType,contextId) @departmentType(contextType,contextId) @departmentZone(contextType,contextId) @deviceType() @dictValue(*dictKey,*itemNo,fieldName) @encode(*str) @equals(*str1,*str2) @execJXPath(*jxpath) @execJavaBean(*appId,*className,param) @form(*boName,*fieldName,processInstId) @formDefId() @formItemDefId() @formTheme @getAppName(appId) @getDWCondition(*fieldName,*fieldValue) @getHistoryTaskNum(@uid) @getJgdwType @getMyCreateTaskNum(@uid) @getProperty(*name,appId) @getTodoTaskNum(@uid) @gridAvg(*boName,*fieldName,sqlClause,processInstId) @gridCount(*boName,sqlClause,processInstId) @gridFirst(*boName,*fieldName,sqlClause,processInstId) @gridLast(*boName,*fieldName,sqlClause,processInstId) @gridMax(*boName,*fieldName,sqlClause,processInstId) @gridMin(*boName,*fieldName,sqlClause,processInstId) @gridSum(*boName,*fieldName,sqlClause,processInstId) @hour(datetime) @i18n(*key,*appId,lang) @if(*logical,*valueTrue,*valueFalse) @in(*str1,*str2,str3,str4,str5) @indexOf(*str1,*str2) @isActive(*appId) @isDepartmentManager(contextType,contextId) @isLeapYear(date) @isProcessEnd(contextType,contextId) @isSubProcess(contextType,contextId) @isTaskEnd(taskInstId) @lang() @lastIndexOf(*str1,*str2) @len(*str) @lessThan(*num1,*num2) @loadFile(*appId,*fileName) @lower(*str) @lpad(*str,*len,padStr) @max(*num1,*num2,num3,num4,num5) @md5(*str) @min(*num1,*num2,num3,num4,num5) @minute(datetime) @mod(*num1,*num2) @month(date) @monthBegin(date) @monthEnd(date) @nextDate(date) @nullValue(*str1,*str2) @numAdd(*num1,*num2,num3,num4,num5) @numDiv(*num1,*num2,scale) @numMul(*num1,*num2) @numSub(*num1,*num2,num3,num4,num5) @or(*logical1,*logical2,logical3,logical4,logical5) @parentForm(*boName,*parentBoName,*parentFieldName) @phonetic(*str) @portalUrl() @preDate(date) @processBusinessKey(contextType,contextId) @processComment(*activityId,*policy,contextType,contextId) @processCostTime(contextType,contextId) @processCreateTime(contextType,contextId) @processCreateUser(contextType,contextId) @processDefAppId(contextType,contextId) @processDefDurationTime(contextType,contextId) @processDefGroupId(contextType,contextId) @processDefGroupName(contextType,contextId) @processDefId(contextType,contextId) @processDefName(contextType,contextId) @processDefVersionId(contextType,contextId) @processDefWarningTime(contextType,contextId) @processEndTime(contextType,contextId) @processExpireTime(contextType,contextId) @processExt1(contextType,contextId) @processExt2(contextType,contextId) @processExt3(contextType,contextId) @processExt4(contextType,contextId) @processExt5(contextType,contextId) @processExt6(contextType,contextId) @processExt7(contextType,contextId) @processExt8(contextType,contextId) @processId(businessKey) @processParentId(contextType,contextId) @processParentTaskId(contextType,contextId) @processStartTime(contextType,contextId) @processStatus(contextType,contextId) @processTitle(contextType,contextId) @processVar(*varName,contextType,contextId) @quarter(date) @quarterBegin(date) @quarterEnd(date) @replace(*str,*oldStr,*newStr) @rmb(*num) @roleExt1(contextType,contextId) @roleExt2(contextType,contextId) @roleExt3(contextType,contextId) @roleExt4(contextType,contextId) @roleExt5(contextType,contextId) @roleName(contextType,contextId) @roleNameKey(contextType,contextId) @roleNoUsers(*no,delimiter) @roleUsers(*roleId,delimiter) @round(*num,scale) @rpad(*str,*len,padStr) @second(datetime) @sequence(varName,padLen,padStr) @sequenceMonth(varName,padLen,padStr) @sequenceYear(varName,padLen,padStr) @serverInstance() @serverProperty(*name) @sha256(*str,*password) @sid() @sqlClauseOfManager(*fieldName,isSubDepartment) @sqlSet(*sql,separator,cc) @sqlValue(*sql,cc) @strAdd(str1,str2) @substring(*str,begin,end) @sysProperty(name) @taskBeginTime(taskInstId) @taskCostTime(taskInstId) @taskDueTime(taskInstId) @taskEndTime(taskInstId) @taskExpireTime(taskInstId) @taskExt1(taskInstId) @taskExt2(taskInstId) @taskExt3(taskInstId) @taskExt4(taskInstId) @taskExt5(taskInstId) @taskExt6(taskInstId) @taskExt7(taskInstId) @taskExt8(taskInstId) @taskHumanType(taskInstId) @taskId() @taskOwner(taskInstId) @taskPreHumanTaskId(taskInstId) @taskPreTaskId(taskInstId) @taskPriority(taskInstId) @taskReadTime(taskInstId) @taskStatus(taskInstId) @taskTarget(taskInstId) @taskTitle(taskInstId) @teamUsers(*teamId,delimiter) @time(datetime) @timestemp() @trim(*str) @uid(uidAliasName,delimiter) @upper(*str) @urlDecode(*str) @urlEncode(*str,charset) @user(key,uidAliasName,delimiter) @userEmail(uidAliasName,delimiter) @userExt1(uidAliasName,delimiter) @userExt2(uidAliasName,delimiter) @userExt3(uidAliasName,delimiter) @userExt4(uidAliasName,delimiter) @userExt5(uidAliasName,delimiter) @userManager(uidAliasName,type,delimiter,includeSelf) @userMobile(uidAliasName,delimiter) @userName(uidAliasName,delimiter) @userNo(uidAliasName,delimiter) @userPhoto(uidAliasName) @userPositionLayer(uidAliasName,delimiter) @userPositionName(uidAliasName,delimiter) @userPositionNo(uidAliasName,delimiter) @userTel(uidAliasName,delimiter) @userUniqueId(uidAliasName,delimiter) @uuid() @weekDay(date) @weekOfYear(date) @year(date) ";
    let keywords = "SUM MAX MIN AVG COUNT ";
    let atParams = "";
    let isSeverKeys = false;
    let exPressData = typeof window.atExpressKeywords !== "undefined" ? window : window.settingParam && typeof window.settingParam.atExpressKeywords !== "undefined" ? window.settingParam : typeof settingParam !== "undefined" ? eval("settingParam") : null;
    if (exPressData != null && exPressData.atExpressKeywords != null) {
      defaultAtExpressKeywords = exPressData.atExpressKeywords;
      isSeverKeys = true;
    } else {
      keywords += defaultAtExpressKeywords.replace(/\(.*?\)/g, "");
    }
    let boKeywords = "";
    if (exPressData != null && exPressData.boExpressKeywords != null) {
      boKeywords = exPressData.boExpressKeywords;
    }
    function set(str) {
      var obj = {}, words = str.split(" ");
      for (var i2 = 0; i2 < words.length; ++i2)
        obj[words[i2]] = true;
      return obj;
    }
    function getKeyWords() {
      var obj = {};
      var jsonArr = {};
      if (isSeverKeys) {
        jsonArr = JSON.parse(defaultAtExpressKeywords);
        for (let i3 = 0; i3 < jsonArr.length; i3++) {
          var value2 = jsonArr[i3];
          obj[value2.key] = value2;
          keywords += value2.key.replace(/\(.*?\)/g, " ");
        }
      } else {
        obj = set(defaultAtExpressKeywords);
      }
      for (var i2 = 0; i2 < boKeywords.length; i2++) {
        obj[boKeywords[i2].id] = boKeywords[i2];
        keywords += boKeywords[i2].id + " ";
        if (boKeywords[i2].id.indexOf(".") > -1)
          keywords += boKeywords[i2].id.split(".")[1] + " ";
      }
      return obj;
    }
    CodeMirror.defineMIME("awsAt", {
      name: "atformula",
      keywords: getKeyWords(),
      atKeywords: set(keywords),
      atoms: set("false true null unknown"),
      operatorChars: /^[*+\-%<>!=&|^]/,
      bokeys: set(atParams)
    });
  })();
});
function createSpan(id2, name2, type2) {
  var span = document.createElement("span");
  span.setAttribute("awsui-qtip", "text:'" + id2 + "'");
  span.setAttribute("class", "CodeMirror-widget cm-field-" + type2);
  span.setAttribute("data-field", id2);
  span.innerHTML = '<span class="cm-field cm-field-' + type2 + '">' + name2 + "</span>";
  return span;
}
window.initFormulaEditor = function(str, editor) {
  var editorValue = [], n = [];
  if (str) {
    let str1 = [str];
    forEach(str1, function(t, trs) {
      var r = "", o = splitFunc(trs);
      forEach(o, function(editorValue2, s) {
        if (isNull(s))
          return;
        var o2, l = "BOITEMNAME", c;
        if (/^(@form\([0-9a-zA-Z._]+,[0-9a-zA-Z._]+\))/.test(s)) {
          c = s.replace("@form(", "").replace(")", "").replace(",", ".");
          window.formulaLabelMap && (o2 = window.formulaLabelMap[c]);
          if (isNull(o2)) {
            r += s;
            return;
          }
        } else if (/^(%_[0-9a-zA-Z._]+_%)/.test(s)) {
          c = s.replace("%_", "").replace("_%", "");
          window.formulaLabelMap && (o2 = window.formulaLabelMap[c]);
          if (isNull(o2)) {
            r += s;
            return;
          }
          l = "common_field";
        } else if (/^\\,/.test(s)) {
          o2 = ",";
        } else if (/^\\\(/.test(s)) {
          o2 = "(";
        } else if (/^\\\)/.test(s)) {
          o2 = ")";
        } else if (/^\\\\/.test(s)) {
          o2 = "\\";
        } else if (/^(\$\[[0-9a-zA-Z._]+\])/.test(s)) {
          c = s.replace("$[", "").replace("]", "");
          let contextData = editor.getOption("contextData");
          if (typeof contextData != "undefined" && typeof contextData.data != "undefined" && Array.isArray(contextData.data)) {
            var arr = contextData.data;
            for (var k = 0; k < arr.length; k++) {
              var arrElement = arr[k];
              if (typeof arrElement == "string" && arrElement.indexOf("$_BO_") > -1) {
                var id2 = arrElement.replace("$_BO_", "");
                if (id2 != null && window.formulaLabelMap[id2] != null) {
                  if (window.formulaLabelMap[id2][c] != null) {
                    o2 = window.formulaLabelMap[id2][c];
                    break;
                  }
                }
              }
            }
          }
          if (typeof o2 == "undefined") {
            window.formulaLabelMap && (o2 = window.formulaLabelMap[c]);
          }
          if (isNull(o2)) {
            r += s;
            return;
          }
          o2 = "$[" + o2 + "]";
          l = "source";
        } else if (/^(#\[[0-9a-zA-Z._]+\])/.test(s)) {
          c = s.replace("#[", "").replace("]", "");
          let contextData = editor.getOption("contextData");
          if (typeof contextData != "undefined" && typeof contextData.data != "undefined" && Array.isArray(contextData.data)) {
            var arr2 = contextData.data;
            for (var p = 0; p < arr2.length; p++) {
              var arrElement2 = arr2[p];
              if (typeof arrElement2 == "string" && arrElement2.indexOf("#_BO_") > -1) {
                let id3 = arrElement2.replace("#_BO_", "");
                if (id3 != null && window.formulaLabelMap[id3] != null) {
                  if (window.formulaLabelMap[id3][c] != null) {
                    o2 = window.formulaLabelMap[id3][c];
                    break;
                  }
                }
              }
            }
          }
          if (typeof o2 == "undefined") {
            c = s.replace("#[", "").replace("]", "");
            window.formulaLabelMap && (o2 = window.formulaLabelMap[c]);
          }
          if (isNull(o2)) {
            r += s;
            return;
          }
          o2 = "#[" + o2 + "]";
          l = "target";
        } else if (/^([0-9a-zA-Z._]+,[0-9a-zA-Z._]+)/.test(s)) {
          c = s.replace(",", ".");
          window.formulaLabelMap && (o2 = window.formulaLabelMap[c]);
          if (isNull(o2)) {
            r += s;
            return;
          }
          l = "BOITEMNAME_PARAM";
        } else if (/^(@processVar\([\u4e00-\u9fa5_a-zA-Z0-9]+\))/.test(s)) {
          o2 = s.replace("@processVar(", "").replace(")", "");
          if (isNull(o2)) {
            r += s;
            return;
          }
          l = "common_field";
        } else if (/^(@env\([\u4e00-\u9fa5_a-zA-Z0-9]+[\,(ext1|ext2|ext3)]*\))/.test(s)) {
          o2 = s.replace("@env(", "").replace(")", "");
          if (isNull(o2)) {
            r += s;
            return;
          }
          l = "ccVar";
        } else if (/^(@[uid|companyId|departmentId|roleId|teamId]+\([0-9,A-z._-]+\))/.test(s)) {
          c = s;
          window.formulaLabelMap && (o2 = window.formulaLabelMap[c]);
          if (isNull(o2)) {
            r += s;
            return;
          }
          if (s.indexOf("uid") > -1) {
            l = "User";
          } else if (s.indexOf("companyId") > -1) {
            l = "Company";
          } else if (s.indexOf("departmentId") > -1) {
            l = "Department";
          } else if (s.indexOf("roleId") > -1) {
            l = "Role";
          } else if (s.indexOf("teamId") > -1) {
            l = "Team";
          }
        } else {
          r += s;
          return;
        }
        let h2 = window.CodeMirror.Pos(t, r.length);
        r += s;
        var p = window.CodeMirror.Pos(t, r.length);
        n.push({ from: h2, to: p, field: s, invalid: l, label: o2 });
      }), editorValue.push(r);
    });
  }
  editor.setValue(editorValue.join("\n")), forEach(n, function(t, i2) {
    markField(i2, editor);
  });
};
function markField(e, editor) {
  editor.markText(e.from, e.to, {
    handleMouseEvents: true,
    atomic: true,
    replacedWith: createSpan(e.field, e.label, e.invalid)
  });
  window.CodeMirror.signal(editor.doc.cm, "endCompletion", editor.doc.cm);
}
function forEach(t, e) {
  if (Array.isArray(t))
    for (var i2 = 0, a = t.length; i2 < a && e.apply(t[i2], [i2, t[i2]]) !== false; i2++)
      ;
  else if (t && typeof t == "object") {
    for (var n in t)
      if (Object.prototype.hasOwnProperty.call(t, n) && e.apply(t[n], [n, t[n]]) === false)
        break;
  }
}
function isNull(t) {
  return t == null;
}
function splitFunc(str) {
  let splitReg = /(@form\([0-9a-zA-Z._]+,[0-9a-zA-Z._]+\))|(%_[0-9a-zA-Z._]+_%)|(\$\[[0-9a-zA-Z._]+\])|(#\[[0-9a-zA-Z._]+\])|(@form\(|@gridFirst\(|@gridLast\(|@gridSum\(|@gridAvg\(|@gridMax\(|@gridMin\()+([0-9a-zA-Z._]+,[0-9a-zA-Z._]+(?=,|\)))|(\\,|\\\(|\\\)|\\\\)|(@processVar\([\u4e00-\u9fa5_a-zA-Z0-9]+\))|(@env\([\u4e00-\u9fa5_a-zA-Z0-9]+[\,(ext1|ext2|ext3)]*\))|(@[uid|companyId|departmentId|roleId|teamId]+\([0-9,A-z._-]+\))/g;
  if (window.navigator.userAgent.indexOf("MSIE") > -1 || window.navigator.userAgent.indexOf("Trident") > -1) {
    let array3 = [], matches2 = str.match(splitReg);
    if (matches2.length == 0) {
      array3.push(str);
    } else {
      let toUseStr = str;
      for (let matStr of matches2) {
        toUseStr.replace(matStr, (reStr, index2, allStr) => {
          if (index2 > 0) {
            array3.push(allStr.substring(0, index2));
          }
          array3.push(matStr);
          toUseStr = allStr.substring(index2 + reStr.length);
        });
      }
      if (toUseStr.length > 0) {
        array3.push(toUseStr);
      }
    }
    return array3;
  } else {
    return str.split(splitReg).filter(Boolean);
  }
}
const _sfc_main$p = defineComponent({
  components: {
    AwsuiDialog,
    AwsuiButton
  },
  name: "AwsuiFormula",
  props: {
    setting: Object,
    dialogVisible: {
      type: Boolean,
      default: false
    },
    dialogReload: {
      type: Number,
      default: 0
    },
    modelValue: {
      type: String,
      default: ""
    }
  },
  setup(props2, ctx2) {
    const { proxy: proxy2 } = getCurrentInstance();
    const iframeOption = props2.setting;
    console.log(props2.setting, "console.log(iframeOption)console.log(iframeOption)");
    const currentContent2 = computed({
      get: () => {
        return props2.modelValue;
      },
      set: (value2) => {
        ctx2.emit("update:modelValue", value2);
      }
    });
    const dialogVisibles = computed({
      get: () => {
        return props2.dialogVisible;
      },
      set: (value2) => {
        ctx2.emit("update:dialogVisible", value2);
      }
    });
    const getOpt2 = () => {
      let opt = Object.assign({}, proxy2.options, proxy2.option);
      opt.defaultValue = currentContent2.value;
      return opt;
    };
    const dialogConfirm2 = (value2) => {
      if (value2 != null) {
        currentContent2.value = value2;
        return;
      }
      dialogVisibles.value = false;
      if (props2.setting.callback) {
        props2.setting.callback(getValue2());
      }
    };
    const getValue2 = () => {
      return proxy2.$refs.awsuiDialog.iframeRef.getWin().getVal();
    };
    const dialogCancel2 = () => {
      dialogVisibles.value = false;
    };
    return {
      currentContent: currentContent2,
      dialogVisibles,
      iframeOption,
      getOpt: getOpt2,
      dialogConfirm: dialogConfirm2,
      dialogCancel: dialogCancel2
    };
  }
});
const _hoisted_1$c = { class: "dialog-footer" };
const _hoisted_2$9 = /* @__PURE__ */ createTextVNode("\u786E\u5B9A ");
const _hoisted_3$9 = /* @__PURE__ */ createTextVNode("\u53D6\u6D88");
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_button = resolveComponent("awsui-button");
  const _component_awsui_dialog = resolveComponent("awsui-dialog");
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_awsui_dialog, {
      modelValue: _ctx.dialogVisibles,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.dialogVisibles = $event),
      iframeOption: _ctx.iframeOption,
      iframeReload: _ctx.dialogReload,
      title: _ctx.setting.dialogTitle == null ? "\u516C\u5F0F\u7F16\u8F91" : _ctx.setting.dialogTitle,
      ref: "awsuiDialog",
      width: "90%",
      class: "awsui-formula-dialog"
    }, {
      footer: withCtx(() => [
        createCommentVNode('      slot="footer"'),
        createElementVNode("div", _hoisted_1$c, [
          createVNode(_component_awsui_button, {
            id: "confirmBtn",
            type: "primary",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.dialogConfirm())
          }, {
            default: withCtx(() => [
              _hoisted_2$9
            ]),
            _: 1
          }),
          createVNode(_component_awsui_button, { onClick: _ctx.dialogCancel }, {
            default: withCtx(() => [
              _hoisted_3$9
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      _: 1
    }, 8, ["modelValue", "iframeOption", "iframeReload", "title"])
  ]);
}
var formulaDialog = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p], ["__scopeId", "data-v-585b2fb2"]]);
const vmObj$1 = {
  vm: null
};
const visible$1 = ref(false);
const reload = ref(0);
const propsOptions$1 = reactive({
  url: "",
  data: {
    sid: "",
    cmd: "",
    contextData: ""
  },
  callback: (acList) => {
    console.log(22);
  }
});
const openFormula = (options2) => {
  var _a;
  if (vmObj$1.vm == null) {
    const renderTest = defineComponent({
      render() {
        return h(formulaDialog, {
          setting: propsOptions$1,
          dialogVisible: visible$1.value,
          dialogReload: reload.value,
          "onUpdate:dialogVisible": (value2) => {
            visible$1.value = value2;
          }
        });
      },
      setup(props2, context) {
        visible$1.value = false;
        return {
          visible: visible$1
        };
      }
    });
    vmObj$1.vm = createVNode(renderTest);
    render$Z(vmObj$1.vm, document.createElement("div"));
    document.getElementsByTagName("body")[0].appendChild((_a = vmObj$1.vm) == null ? void 0 : _a.el);
  }
  Object.assign(propsOptions$1, options2);
  visible$1.value = true;
  nextTick(() => {
    reload.value++;
  });
};
const closeFormula = () => {
  if (visible$1.value) {
    visible$1.value = false;
  }
};
var formulaData = {
  openFormula,
  closeFormula
};
const _sfc_main$o = defineComponent({
  name: "AwsuiFormula",
  components: {
    AwsuiCodemirror
  },
  props: {
    content: {
      type: String,
      default: ""
    },
    option: {
      type: Object
    },
    value: {
      type: String
    },
    placeholder: {
      type: String
    },
    dialogTitle: {
      type: String,
      default: "\u516C\u5F0F\u7F16\u8F91"
    },
    modelValue: {
      type: String,
      default: ""
    },
    readonly: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue", "input"],
  setup(props, ctx) {
    const { proxy } = getCurrentInstance();
    const currentContent = computed({
      get: () => {
        return props.modelValue;
      },
      set: (value2) => {
        ctx.emit("update:modelValue", value2);
      }
    });
    const dialogOnce = ref(false);
    const options = ref({
      height: "26px",
      theme: "aws-formula",
      foldGutter: true,
      singleCursorHeightPerLine: false,
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      matchBrackets: true,
      mode: { name: "awsAt" },
      defaultTable: [1, 2, 3],
      autofocus: false,
      lineWrapping: true
    });
    const getSid = () => {
      let sid = getOpt.value.sid;
      if (sid === void 0) {
        if (proxy.AWSPageContext.settingParam && proxy.AWSPageContext.settingParam.sessionId) {
          sid = proxy.AWSPageContext.settingParam.sessionId;
        }
        if (sid === void 0) {
          sid = proxy.awsuiTools.getConstByName("settingParam", {}).sid.sessionId;
        }
      }
      return sid;
    };
    const getPath = () => {
      return eval("axiosBaseUrl") + "w";
    };
    const dialogReload = ref(1);
    const otherInstanceVue = ref(null);
    const dialogVisible = ref(false);
    let codeMirrorInstance = null;
    const width = ref("850px");
    watch(() => currentContent.value, (nval, oval) => {
      proxy.$emit("input", nval);
    });
    const getContextDataStr = (value2 = "") => {
      let contextData = getOpt.value.contextData;
      if (contextData != null) {
        contextData = JSON.parse(JSON.stringify(contextData));
      } else {
        contextData = {};
      }
      if (contextData.appId == null) {
        contextData.appId = proxy.AWSPageContext.settingParam.appId;
      }
      contextData.defaultValue = value2;
      return JSON.stringify(contextData);
    };
    const onCmReady = (cms, value2) => {
      codeMirrorInstance = cms != null ? cms : codeMirrorInstance;
      if (codeMirrorInstance == null) {
        return;
      }
      let opt = getOpt.value;
      if (proxy.readonly === true) {
        codeMirrorInstance.setOption("readOnly", "nocursor");
      }
      codeMirrorInstance.setSize(null, opt.height);
      codeMirrorInstance.setOption("isSupportReturn", false);
      value2 = value2 == null ? currentContent.value : value2;
      let params = {
        url: "jd",
        data: {
          sid: getSid(),
          contextData: getContextDataStr(),
          content: value2,
          cmd: "CLIENT_M_FORMULA_EDITOR_PARSE_CONTENT"
        }
      };
      proxy.awsuiaxios.post(params).then((r) => {
        if (r.result === "ok") {
          if (r.data.formulaLabelMapCache !== void 0) {
            var formulaLabelMapCache = r.data.formulaLabelMapCache;
            if (formulaLabelMapCache != null) {
              var tmp = Object.assign({}, window.formulaLabelMap, formulaLabelMapCache);
              window.formulaLabelMap = tmp;
              window.initFormulaEditor(currentContent.value, codeMirrorInstance, opt.type);
            }
          }
        }
      });
    };
    const refresh = () => {
      onCmReady(codeMirrorInstance);
    };
    const getOpt = computed(() => {
      let opt = Object.assign({}, proxy.options, proxy.option);
      opt.defaultValue = currentContent.value;
      return opt;
    });
    const openDialog = (assignOpt, otherInstanceVue2) => {
      if (proxy.readonly) {
        return;
      }
      if (proxy.disabled === true || proxy.readonly === true) {
        return;
      }
      if (proxy.readonly !== true && proxy.disabled !== true) {
        dialogVisible.value = true;
      }
      const iframeOption = {
        url: getOpt.value.url == null || getOpt.value.url == "" ? proxy.awsuiTools.getConstByName("axiosBaseUrl", "./") + "w" : getOpt.value.url,
        dialogTitle: props.dialogTitle,
        data: {
          sid: getSid(),
          cmd: "CLIENT_M_FORMULA_EDITOR_MAIN_PAGE",
          contextData: getContextDataStr(currentContent.value)
        },
        callback: (value2) => {
          currentContent.value = value2;
          onCmReady(null, value2);
          proxy.$emit("input", value2);
        }
      };
      formulaData.openFormula(iframeOption);
    };
    const dialogConfirm = (value2) => {
      if (value2 != null) {
        currentContent.value = value2;
        return;
      }
      dialogConfirm(getValue());
      otherInstanceVue.value = null;
      dialogVisible.value = false;
    };
    const getValue = () => {
      return proxy.$refs.awsuiDialog.iframeRef.getWin().getVal();
    };
    const dialogCancel = () => {
      dialogVisible.value = false;
    };
    return {
      options,
      currentContent,
      otherInstanceVue,
      dialogVisible,
      dialogOnce,
      width,
      dialogReload,
      onCmReady,
      refresh,
      getSid,
      getPath,
      getOpt,
      openDialog,
      dialogConfirm,
      dialogCancel
    };
  }
});
const _hoisted_1$b = { class: "awsui-formula-component" };
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_codemirror = resolveComponent("awsui-codemirror");
  return openBlock(), createElementBlock("div", _hoisted_1$b, [
    createElementVNode("div", {
      class: normalizeClass(["awsui-formula", { "awsui-disabled": _ctx.disabled }])
    }, [
      createCommentVNode('      @ready="onCmReady"'),
      createVNode(_component_awsui_codemirror, {
        ref: "codemirror",
        modelValue: _ctx.currentContent,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.currentContent = $event),
        placeholder: _ctx.placeholder,
        options: _ctx.options,
        onReady: _ctx.onCmReady,
        class: normalizeClass({ "awsui-codemirroe-disabled": _ctx.disabled })
      }, null, 8, ["modelValue", "placeholder", "options", "onReady", "class"]),
      createElementVNode("i", {
        class: normalizeClass(["awsui-iconfont", { "awsui-formula-btn-readonly": _ctx.readonly || _ctx.disabled }]),
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.openDialog())
      }, "\uE78F", 2)
    ], 2)
  ]);
}
var AwsuiFormula = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o], ["__scopeId", "data-v-7642d37e"]]);
const _sfc_main$n = defineComponent({
  name: "RichMenu",
  components: { PopListDom },
  directives: { bindMenu },
  props: {
    menuList: {
      type: Array,
      default() {
        return [];
      }
    },
    tag: {
      type: String,
      default() {
        return "div";
      }
    },
    data: {
      type: Object,
      default() {
        return {};
      }
    },
    rootOption: {
      type: Object,
      default() {
        return {};
      }
    },
    allowMenu: Boolean,
    close: Number
  },
  emits: ["sortEnd", "sortStart", "sortMove", "liClick", "dragAfterEditChildrenMenuList", "openEvent"],
  setup(props2, context) {
    let nextTransmit = reactive({
      root: props2.rootOption.isRight === true ? false : true,
      showPop: 0,
      beforeLeaveMenuClose: props2.rootOption.beforeLeaveMenuClose,
      absoluteLeft: props2.rootOption.absoluteLeft,
      absoluteTop: props2.rootOption.absoluteTop,
      closePop: 0
    });
    let transmit = reactive({
      allowmenu: true,
      context: {},
      showPop: 0,
      closePop: 0
    });
    let visibleInit = ref(false);
    const methods = {
      parentTriggerClick(...args) {
        if (args[0] && args[0].exec) {
          args[0].exec(...args);
        }
        context.emit("liClick", ...args);
      },
      childrenDragSort(event2, params) {
        context.emit("sortEnd", event2, params);
      },
      childrenDragStart(event2, params) {
        context.emit("sortStart", event2, params);
      },
      childrenDragMove(event2, params) {
        context.emit("sortMove", event2, params);
      },
      dragAfterEditChildrenMenuList(...args) {
        context.emit("dragAfterEditChildrenMenuList", ...args);
      },
      openState(...args) {
        context.emit("openEvent", ...args);
      }
    };
    provide("editMenuList", methods.dragAfterEditChildrenMenuList);
    watch(() => props2.close, () => {
      nextTransmit.closePop++;
    });
    watch(() => props2.allowMenu, (val) => {
      transmit.allowmenu = val;
    });
    return __spreadValues2({
      nextTransmit,
      transmit,
      visibleInit
    }, methods);
  }
});
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_popListDom = resolveComponent("popListDom");
  const _directive_bind_menu = resolveDirective("bind-menu");
  return withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), normalizeProps(guardReactiveProps(_ctx.$attrs)), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default"),
      (openBlock(), createBlock(Teleport, {
        to: "body",
        disabled: false
      }, [
        _ctx.menuList.length > 0 && _ctx.visibleInit ? (openBlock(), createBlock(_component_popListDom, {
          key: 0,
          menuList: _ctx.menuList,
          transmit: _ctx.nextTransmit,
          onLiClick: _ctx.parentTriggerClick,
          onSortMove: _ctx.childrenDragMove,
          onSortStart: _ctx.childrenDragStart,
          onSortEnd: _ctx.childrenDragSort,
          onOpenState: _ctx.openState
        }, createSlots({ _: 2 }, [
          renderList(_ctx.$slots, (index2, name2) => {
            return {
              name: name2,
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, name2)
              ])
            };
          })
        ]), 1032, ["menuList", "transmit", "onLiClick", "onSortMove", "onSortStart", "onSortEnd", "onOpenState"])) : createCommentVNode("v-if", true)
      ]))
    ]),
    _: 3
  }, 16)), [
    [_directive_bind_menu, { children: _ctx.menuList }]
  ]);
}
var richMenu = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
richMenu.install = (app) => {
  app.component(PopListDom.name, PopListDom);
  app.component(richMenu.name, richMenu);
};
const _sfc_main$m = defineComponent({
  name: "TabMenu",
  components: {
    draggable: draggableComponent
  },
  props: {
    option: {
      type: Object,
      default() {
        return {};
      }
    },
    close: Number,
    menuData: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  emits: ["sortEnd", "openState", "liClick", "dragSetValue", "childrenSortMove", "childrenSortEnd", "childrenSortStart", "dragAfterEditChildrenMenuList"],
  setup(props2, context) {
    let centerWidth = ref("");
    let currentOption = ref({
      activeShowMenu: true
    });
    let isHoverObj = reactive({});
    let allowmenu = ref(true);
    let menuList = reactive([]);
    let nextTransmit = reactive({
      root: true,
      showPop: 0,
      closePop: 0,
      context: {
        rootOffset: {}
      }
    });
    const propsMenuData = props2.menuData;
    watch(() => props2.close, () => {
      nextTransmit.closePop++;
    });
    const methods = {
      dragAfterEditChildrenMenuList(...args) {
        context.emit("dragAfterEditChildrenMenuList", ...args);
      },
      childrenDragSort(...args) {
        context.emit("childrenSortEnd", ...args);
      },
      childrenDragStart(...args) {
        context.emit("childrenSortStart", ...args);
      },
      childrenDragMove(...args) {
        context.emit("childrenSortMove", ...args);
      },
      buildCenterStyle() {
        return {
          width: centerWidth.value
        };
      },
      dragStart() {
        allowmenu.value = false;
        nextTransmit.closePop++;
      },
      dragEnd(...arg) {
        allowmenu.value = true;
        context.emit("sortEnd", ...arg);
      },
      checkMove(obj) {
        if (obj.related.classList.contains("nodrag")) {
          return false;
        }
      },
      openEvent(params) {
        isHoverObj[params.value.id] = params.open;
        context.emit("openState", params);
      },
      showMenu(obj) {
        nextTransmit.popToTarget = obj.target;
        menuList = obj.data.children;
        nextTransmit.parentValue = obj.data;
        nextTransmit.showPop++;
        isHoverObj[obj.data.id] = true;
      },
      hasChild(child) {
        return child.children != null && child.children.length > 0;
      },
      titleClass(child) {
        let activeShowMenu = currentOption.value.activeShowMenu;
        return {
          "cu-item-div": true,
          "cu-subMenuDiv": this.hasChild(child),
          "cu-item-isActive": child.isActive,
          "cu-suMenuDivHover": (!activeShowMenu || child.isActive) && isHoverObj[child.id == null ? "" : child.id],
          "cu-suNoH": (!activeShowMenu || child.isActive) && !isHoverObj[child.id == null ? "" : child.id],
          "cu-nodownH": activeShowMenu && !child.isActive,
          drag: props2.option.draggable
        };
      },
      getLiClass(item, type2) {
        let classObj;
        if (type2 == "center") {
          classObj = { "cu-item": true, "cu-item-tabMenu-center": true };
        } else {
          classObj = {
            "cu-item": true,
            nodrag: true,
            "cu-btn": item.uiType == "button",
            "menuitem-right": type2 == "right",
            icon: item.uiType == "icon",
            afterLine: item.showRLine
          };
        }
        if (item.option && item.option.class) {
          classObj = Object.assign(classObj, item.option.class);
        }
        return classObj;
      },
      clickBtn(clickData) {
        this.liClick(clickData);
      },
      menuClick(clickData, event2) {
        if (!clickData.isActive && propsMenuData.menuList) {
          for (let data of propsMenuData.menuList) {
            if (data.isActive) {
              nextTick(() => {
                data.isActive = false;
              });
            }
          }
          nextTick(() => {
            clickData.isActive = true;
          });
        }
        methods.liClick(clickData);
      },
      liClick(clickData, params) {
        if (clickData.exec) {
          clickData.exec(clickData, params);
        }
        context.emit("liClick", clickData, params);
      },
      findMenu(id2) {
        if (propsMenuData.menuList) {
          for (let item of propsMenuData.menuList) {
            if (item.id == id2) {
              return item;
            }
          }
        }
      },
      resize(isUpScroll) {
        elScrollbar.value.update();
      }
    };
    let elScrollbar = ref(null);
    let cuMenuLeft = ref(null);
    let cuMenuRight = ref(null);
    onBeforeMount(() => {
      Object.assign(currentOption, props2.option);
    });
    onMounted(() => {
      nextTransmit.absoluteLeft = () => {
        if (elScrollbar.value != null) {
          return 90 - elScrollbar.value.$el.querySelector(".el-scrollbar__wrap").scrollLeft;
        }
        return 0;
      };
      nextTransmit.absoluteTop = (tran, obj) => {
        let targetEl = obj.popTarget;
        if (targetEl == null) {
          return 0;
        }
        return -targetEl.offsetTop;
      };
      methods.resize(false);
    });
    onUpdated(() => {
      methods.resize();
    });
    return __spreadValues2({
      centerWidth,
      isHoverObj,
      currentOption,
      allowmenu,
      menuList,
      nextTransmit,
      cuMenuRight,
      cuMenuLeft,
      elScrollbar,
      getLeftBtn: computed(() => {
        if (propsMenuData && propsMenuData.left) {
          return propsMenuData.left;
        }
        return [];
      }),
      getRightBtn: computed(() => {
        if (propsMenuData && propsMenuData.right) {
          let rightBtn = [].concat(propsMenuData.right);
          return rightBtn.reverse();
        }
        return [];
      }),
      menuDataMenuList: computed({
        get: () => propsMenuData.menuList,
        set: (value2) => {
          context.emit("dragSetValue", value2);
        }
      }),
      generGroupValue: computed(() => {
        return "dragGroup-tabMenu" + getCurrentInstance().appContext.config.globalProperties.awsuiTools.getCountIndex("dragGroup-tabMenu");
      })
    }, methods);
  }
});
const _hoisted_1$a = { class: "cu-menuDiv" };
const _hoisted_2$8 = {
  class: "cu-menu",
  ref: "cuMenuLeft"
};
const _hoisted_3$8 = ["onClick", "innerHTML"];
const _hoisted_4$7 = ["onClick"];
const _hoisted_5$6 = {
  key: 1,
  class: "line"
};
const _hoisted_6$6 = ["innerHTML"];
const _hoisted_7$6 = {
  class: "cu-menu right",
  ref: "cuMenuRight"
};
const _hoisted_8$6 = ["innerHTML", "onClick"];
const _hoisted_9$6 = {
  key: 1,
  class: "line"
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_button = resolveComponent("awsui-button");
  const _component_awsui_input = resolveComponent("awsui-input");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  const _component_rich_menu = resolveComponent("rich-menu");
  const _component_draggable = resolveComponent("draggable");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  return openBlock(), createElementBlock("div", _hoisted_1$a, [
    createElementVNode("ul", _hoisted_2$8, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getLeftBtn, (item) => {
        return withDirectives((openBlock(), createElementBlock("li", {
          class: normalizeClass(_ctx.getLiClass(item, "left")),
          key: item.id,
          style: normalizeStyle(item.listyle)
        }, [
          createVNode(_component_el_tooltip, {
            class: "item",
            effect: "dark",
            appendToBody: true,
            content: item.tip,
            placement: "bottom",
            disabled: item.tip == null
          }, {
            default: withCtx(() => [
              createElementVNode("div", null, [
                item.uiType == "button" ? (openBlock(), createBlock(_component_awsui_button, {
                  key: 0,
                  style: normalizeStyle(item.dstyle),
                  type: item.option.type == null ? "primary" : item.option.type,
                  onClick: ($event) => _ctx.clickBtn(item)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(item.option.label), 1)
                  ]),
                  _: 2
                }, 1032, ["style", "type", "onClick"])) : item.uiType == "icon" ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass({ "icon-circle": item.option.circle }),
                  style: normalizeStyle(item.option.spanStyle)
                }, [
                  createElementVNode("i", {
                    class: "awsui-iconfont",
                    style: normalizeStyle(item.dstyle),
                    onClick: ($event) => _ctx.clickBtn(item),
                    innerHTML: item.option.icon
                  }, null, 12, _hoisted_3$8)
                ], 6)) : item.uiType == "input" ? (openBlock(), createBlock(_component_awsui_input, {
                  key: 2,
                  style: normalizeStyle(item.dstyle),
                  modelValue: item.value,
                  "onUpdate:modelValue": ($event) => item.value = $event,
                  onClick: ($event) => _ctx.clickBtn(item)
                }, null, 8, ["style", "modelValue", "onUpdate:modelValue", "onClick"])) : item.uiType == "title" ? (openBlock(), createElementBlock("div", {
                  key: 3,
                  style: normalizeStyle(item.dstyle),
                  class: "cu-item-title",
                  onClick: ($event) => _ctx.clickBtn(item)
                }, toDisplayString(item.title), 13, _hoisted_4$7)) : createCommentVNode("v-if", true)
              ])
            ]),
            _: 2
          }, 1032, ["content", "disabled"]),
          item.uiType == "template" ? renderSlot(_ctx.$slots, item.option.name, {
            key: 0,
            data: item
          }) : createCommentVNode("v-if", true),
          item.showRLine ? (openBlock(), createElementBlock("div", _hoisted_5$6)) : createCommentVNode("v-if", true)
        ], 6)), [
          [vShow, !item.hidden]
        ]);
      }), 128))
    ], 512),
    createVNode(_component_el_scrollbar, {
      style: normalizeStyle(_ctx.buildCenterStyle()),
      ref: "elScrollbar",
      class: "cu-item-tabMenu-center-div"
    }, {
      default: withCtx(() => [
        createVNode(_component_draggable, {
          modelValue: _ctx.menuDataMenuList,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.menuDataMenuList = $event),
          class: "cu-menu",
          tag: "ul",
          group: _ctx.generGroupValue,
          disabled: !_ctx.option.draggable,
          filter: ".nodrag",
          ref: "cu-menu-center",
          animation: "300",
          move: _ctx.checkMove,
          onStart: _ctx.dragStart,
          onEnd: _ctx.dragEnd,
          "item-key": "id"
        }, {
          item: withCtx(({ element: child }) => [
            createVNode(_component_rich_menu, {
              "menu-list": child.children,
              data: child,
              tag: "li",
              close: _ctx.close,
              class: normalizeClass(_ctx.getLiClass(child, "center")),
              rootOption: _ctx.currentOption,
              onSortEnd: _ctx.childrenDragSort,
              onSortStart: _ctx.childrenDragStart,
              onSortMove: _ctx.childrenDragMove,
              onDragAfterEditChildrenMenuList: _ctx.dragAfterEditChildrenMenuList,
              onOpenEvent: _ctx.openEvent,
              onClick: ($event) => _ctx.menuClick(child, $event)
            }, {
              default: withCtx(() => [
                createElementVNode("div", {
                  class: normalizeClass(_ctx.titleClass(child)),
                  style: normalizeStyle(_ctx.option.liDivStyle)
                }, [
                  child.icon ? (openBlock(), createElementBlock("i", {
                    key: 0,
                    class: "awsui-iconfont",
                    style: normalizeStyle(child.iconStyle),
                    innerHTML: child.icon
                  }, null, 12, _hoisted_6$6)) : createCommentVNode("v-if", true),
                  createTextVNode(" " + toDisplayString(child.label), 1)
                ], 6)
              ]),
              _: 2
            }, 1032, ["menu-list", "data", "close", "class", "rootOption", "onSortEnd", "onSortStart", "onSortMove", "onDragAfterEditChildrenMenuList", "onOpenEvent", "onClick"])
          ]),
          _: 1
        }, 8, ["modelValue", "group", "disabled", "move", "onStart", "onEnd"])
      ]),
      _: 1
    }, 8, ["style"]),
    createElementVNode("ul", _hoisted_7$6, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getRightBtn, (item) => {
        return withDirectives((openBlock(), createElementBlock("li", {
          class: normalizeClass(_ctx.getLiClass(item, "right")),
          key: item.id,
          style: normalizeStyle(item.listyle)
        }, [
          createVNode(_component_el_tooltip, {
            class: "item",
            effect: "dark",
            appendToBody: true,
            content: item.tip,
            placement: "bottom",
            disabled: item.tip == null
          }, {
            default: withCtx(() => [
              createElementVNode("div", null, [
                item.uiType == "button" ? (openBlock(), createBlock(_component_awsui_button, {
                  key: 0,
                  style: normalizeStyle(item.dstyle),
                  type: item.option.type == null ? "primary" : item.option.type,
                  onClick: ($event) => _ctx.clickBtn(item)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(item.option.label), 1)
                  ]),
                  _: 2
                }, 1032, ["style", "type", "onClick"])) : item.uiType == "icon" ? (openBlock(), createElementBlock("i", {
                  key: 1,
                  class: "awsui-iconfont",
                  style: normalizeStyle(item.dstyle),
                  innerHTML: item.option.icon,
                  onClick: ($event) => _ctx.clickBtn(item)
                }, null, 12, _hoisted_8$6)) : createCommentVNode("v-if", true)
              ])
            ]),
            _: 2
          }, 1032, ["content", "disabled"]),
          item.uiType == "template" ? renderSlot(_ctx.$slots, item.option && item.option.name ? item.option.name : "rightCustom", {
            key: 0,
            data: item
          }) : createCommentVNode("v-if", true),
          item.showRLine ? (openBlock(), createElementBlock("div", _hoisted_9$6)) : createCommentVNode("v-if", true)
        ], 6)), [
          [vShow, !item.hidden]
        ]);
      }), 128))
    ], 512)
  ]);
}
var tabMenu = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m]]);
tabMenu.install = (app) => {
  app.component(PopListDom.name, PopListDom);
  app.component(tabMenu.name, tabMenu);
};
const _sfc_main$l = defineComponent({
  name: "CustomMenu",
  components: {
    draggable: draggableComponent
  },
  props: {
    menuData: {
      type: Object,
      default() {
        return {
          menuList: []
        };
      }
    },
    showMenu: {
      type: Boolean,
      default: () => true
    },
    close: Number,
    option: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  emits: ["dragSetValue", "liClick", "openState", "sortMove", "sortEnd", "sortStart", "childrenSortMove", "childrenSortEnd", "childrenSortStart", "dragAfterEditChildrenMenuList"],
  setup(props2, context) {
    const propsOption = props2.option;
    let open = ref(false);
    let isHoverObj = reactive({});
    let allowmenu = ref(true);
    let closeMenu = ref(0);
    let menuList = reactive([]);
    let currentOption = reactive({});
    Object.assign(currentOption, propsOption);
    const propsMenuData = props2.menuData;
    let toShowMenu = computed(() => {
      return props2.showMenu && allowmenu;
    });
    const methods = {
      childrenDragSort(...args) {
        context.emit("childrenSortEnd", ...args);
      },
      childrenDragStart(...args) {
        context.emit("childrenSortStart", ...args);
      },
      childrenDragMove(...args) {
        context.emit("childrenSortMove", ...args);
      },
      dragAfterEditChildrenMenuList(...args) {
        context.emit("dragAfterEditChildrenMenuList", ...args);
      },
      dragStart(obj) {
        allowmenu.value = false;
        closeMenu.value++;
        context.emit("sortStart", obj);
      },
      dragEnd(...arg) {
        allowmenu.value = true;
        context.emit("sortEnd", ...arg);
      },
      checkMove(obj) {
        if (obj.relatedContext.element && obj.relatedContext.element.fixed == "last") {
          return false;
        }
        context.emit("sortMove", obj);
        if (obj.noMove) {
          return false;
        }
      },
      openEvent(params) {
        isHoverObj[params.value.id] = params.open;
        context.emit("openState", params);
      },
      menuClick(item, event2) {
        if (item.exec) {
          item.exec(item, {
            event: event2
          });
        }
      },
      getCustomRootClass() {
        if (propsOption && propsOption.customClass) {
          if (typeof propsOption.customClass == "function") {
            return propsOption.customClass();
          }
          return propsOption.customClass;
        }
        return {};
      },
      buildStateCls(data) {
        return {
          "custom-item": true,
          "dontDrag": !propsOption.draggable || data.drag === false,
          "dontShowMenu": allowmenu.value === false || !methods.hasChild(data),
          "focusMenu": allowmenu.value !== false && isHoverObj[data.id == null ? "" : data.id]
        };
      },
      getCustomRootStyle() {
        if (propsOption && propsOption.customStyle) {
          if (typeof propsOption.customStyle == "function") {
            return propsOption.customStyle();
          }
          return propsOption.customStyle;
        }
        return {};
      },
      hasChild(child) {
        return child.children != null && child.children.length > 0;
      },
      getCustomItemClass(item) {
        let customItemClass = methods.buildStateCls(item);
        if (propsOption && propsOption.customItemClass) {
          Object.assign(customItemClass, propsOption.customItemClass);
        }
        Object.assign(customItemClass, item.itemMenuClass);
        return customItemClass;
      },
      getCustomItemStyle(item) {
        let style = {};
        if (propsOption && propsOption.customItemStyle) {
          Object.assign(style, propsOption.customItemStyle);
        }
        Object.assign(style, item.itemMenuStyle);
        return style;
      },
      changeToJSIcon(iconStr) {
        if (iconStr == null || iconStr.length == 0) {
          return "";
        }
        if (iconStr.length > 2) {
          iconStr = iconStr.toLowerCase();
          if (iconStr.indexOf("&#x") > -1) {
            iconStr = iconStr.replace(/&#x([\d\w]*);*/i, "%u$1");
          }
          if (iconStr.indexOf("\\e") > -1) {
            iconStr = iconStr.replace("\\", "%u");
          }
          return unescape(iconStr);
        } else {
          return iconStr;
        }
      },
      liClick(clickData, params) {
        if (clickData.exec) {
          clickData.exec(clickData, params);
        }
        context.emit("liClick", clickData, params);
      }
    };
    watch(() => props2.close, () => {
      closeMenu.value++;
    });
    return __spreadValues2({
      menuList,
      isHoverObj,
      allowmenu,
      closeMenu,
      open,
      currentOption,
      menuDataMenuList: computed({
        get: () => propsMenuData.menuList,
        set: (value2) => {
          context.emit("dragSetValue", value2);
        }
      }),
      toShowMenu
    }, methods);
  }
});
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_rich_menu = resolveComponent("rich-menu");
  const _component_draggable = resolveComponent("draggable");
  return openBlock(), createBlock(_component_draggable, {
    modelValue: _ctx.menuDataMenuList,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.menuDataMenuList = $event),
    class: normalizeClass(_ctx.getCustomRootClass()),
    style: normalizeStyle(_ctx.getCustomRootStyle()),
    animation: "300",
    filter: ".dontDrag",
    disabled: !_ctx.option.draggable,
    move: _ctx.checkMove,
    onStart: _ctx.dragStart,
    onEnd: _ctx.dragEnd,
    "item-key": "id"
  }, {
    item: withCtx(({ element: child, index: index2 }) => [
      child.type == "itemAfter" ? renderSlot(_ctx.$slots, "itemAfter", { key: 0 }) : (openBlock(), createBlock(_component_rich_menu, {
        key: 1,
        "menu-list": child.children,
        class: normalizeClass(_ctx.getCustomItemClass(child)),
        style: normalizeStyle(_ctx.getCustomItemStyle(child)),
        close: _ctx.closeMenu,
        data: child,
        allowMenu: _ctx.allowmenu,
        rootOption: _ctx.currentOption,
        onSortEnd: _ctx.childrenDragSort,
        onSortStart: _ctx.childrenDragStart,
        onSortMove: _ctx.childrenDragMove,
        onOpenEvent: _ctx.openEvent,
        onDragAfterEditChildrenMenuList: _ctx.dragAfterEditChildrenMenuList,
        onClick: ($event) => _ctx.menuClick(child, $event)
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {
            data: { child, index: index2 }
          })
        ]),
        _: 2
      }, 1032, ["menu-list", "class", "style", "close", "data", "allowMenu", "rootOption", "onSortEnd", "onSortStart", "onSortMove", "onOpenEvent", "onDragAfterEditChildrenMenuList", "onClick"]))
    ]),
    _: 3
  }, 8, ["modelValue", "class", "style", "disabled", "move", "onStart", "onEnd"]);
}
var CustomMenu = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
const _sfc_main$k = defineComponent({
  name: "ItemMenu",
  components: { CustomMenu },
  props: {
    close: Number,
    menuData: {
      type: Object,
      default() {
        return {
          menuList: []
        };
      }
    }
  },
  emits: ["dragSetValue", "liClick", "openState", "sortMove", "sortEnd", "sortStart", "childrenSortMove", "childrenSortEnd", "childrenSortStart", "dragAfterEditChildrenMenuList"],
  setup(props2, context) {
    let rootDom = ref(null);
    let elWidth = ref(-1);
    let itemMenuOption = reactive({
      draggable: true,
      customClass: {
        "ck-menu": true
      },
      customItemStyle: {},
      customItemClass: {
        "ck-menu-item": true
      }
    });
    let itemMenuCalcWidth = (elWidth2) => {
      let propsOptionMinWidth = 130;
      let colNum = Math.floor(elWidth2 / propsOptionMinWidth);
      if (colNum > 0 && itemMenuOption.customItemStyle) {
        itemMenuOption.customItemStyle.width = "calc(" + 100 / colNum + "% - 6px)";
      }
    };
    const changeToJSIcon = (iconStr) => {
      if (iconStr == null || iconStr.length == 0) {
        return "";
      }
      if (iconStr.length > 2) {
        iconStr = iconStr.toLowerCase();
        if (iconStr.indexOf("&#x") > -1) {
          iconStr = iconStr.replace(/&#x([\d\w]*);*/i, "%u$1");
        }
        if (iconStr.indexOf("\\e") > -1) {
          iconStr = iconStr.replace("\\", "%u");
        }
        return unescape(iconStr);
      } else {
        return iconStr;
      }
    };
    onMounted(() => {
      nextTick(() => {
        elWidth.value = rootDom.value.children[0].clientWidth;
      });
    });
    onUpdated(() => {
      elWidth.value = rootDom.value.children[0].clientWidth;
    });
    watch(() => elWidth.value, (value2) => {
      itemMenuCalcWidth(value2);
    });
    const methods = {
      dragAfterEditChildrenMenuList(...args) {
        context.emit("dragAfterEditChildrenMenuList", ...args);
      },
      childrenDragSort(...args) {
        context.emit("childrenSortEnd", ...args);
      },
      childrenDragStart(...args) {
        context.emit("childrenSortStart", ...args);
      },
      childrenDragMove(...args) {
        context.emit("childrenSortMove", ...args);
      },
      dragSetValue(...args) {
        context.emit("dragSetValue", ...args);
      },
      liClick(...args) {
        context.emit("liClick", ...args);
      },
      openState(...args) {
        context.emit("openState", ...args);
      },
      sortMove(...args) {
        context.emit("sortMove", ...args);
      },
      sortEnd(...args) {
        context.emit("sortEnd", ...args);
      },
      sortStart(...args) {
        context.emit("sortStart", ...args);
      }
    };
    return __spreadProps2(__spreadValues2({}, methods), {
      rootDom,
      elWidth,
      changeToJSIcon,
      itemMenuCalcWidth,
      itemMenuOption
    });
  }
});
const _hoisted_1$9 = { ref: "rootDom" };
const _hoisted_2$7 = ["innerHTML"];
const _hoisted_3$7 = ["i"];
const _hoisted_4$6 = ["innerHTML"];
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_custom_menu = resolveComponent("custom-menu");
  return openBlock(), createElementBlock(Fragment, null, [
    createCommentVNode('  <template v-if="$attrs.appendTo != null">'),
    createCommentVNode('    <teleport to="$attrs.appendTo">'),
    createCommentVNode("      <slot></slot>"),
    createCommentVNode("    </teleport>"),
    createCommentVNode("  </template>"),
    createCommentVNode("  <template v-else>"),
    createCommentVNode("    <slot></slot>"),
    createCommentVNode("  </template>"),
    createElementVNode("div", _hoisted_1$9, [
      createVNode(_component_custom_menu, {
        menuData: _ctx.menuData,
        close: _ctx.close,
        onDragSetValue: _ctx.dragSetValue,
        onLiClick: _ctx.liClick,
        onOpenState: _ctx.openState,
        onSortMove: _ctx.sortMove,
        onSortEnd: _ctx.sortEnd,
        onSortStart: _ctx.sortStart,
        onDragAfterEditChildrenMenuList: _ctx.dragAfterEditChildrenMenuList,
        onChildrenSortEnd: _ctx.childrenDragSort,
        onChildrenSortStart: _ctx.childrenDragStart,
        onChildrenSortMove: _ctx.childrenDragMove,
        option: _ctx.itemMenuOption
      }, {
        default: withCtx(({ data: { child, index: index2 } }) => [
          child.html != null ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: child.html
          }, null, 8, _hoisted_2$7)) : (openBlock(), createElementBlock("div", {
            key: 1,
            class: "cu-menu-item-content",
            i: index2
          }, [
            child.icon != null && child.icon != "" ? (openBlock(), createElementBlock("i", {
              key: 0,
              class: "awsui-iconfont custom-menu-i",
              innerHTML: child.icon
            }, null, 8, _hoisted_4$6)) : createCommentVNode("v-if", true),
            createTextVNode(" " + toDisplayString(child.label), 1)
          ], 8, _hoisted_3$7))
        ]),
        _: 1
      }, 8, ["menuData", "close", "onDragSetValue", "onLiClick", "onOpenState", "onSortMove", "onSortEnd", "onSortStart", "onDragAfterEditChildrenMenuList", "onChildrenSortEnd", "onChildrenSortStart", "onChildrenSortMove", "option"])
    ], 512)
  ], 2112);
}
var itemMenu = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
itemMenu.install = (app) => {
  app.component(PopListDom.name, PopListDom);
  app.component(itemMenu.name, itemMenu);
};
CustomMenu.install = (app) => {
  app.component(PopListDom.name, PopListDom);
  app.component(CustomMenu.name, CustomMenu);
};
const _sfc_main$j = defineComponent({
  name: "awsScrollbar",
  props: {
    isScroll: {
      type: Boolean,
      default: true
    }
  },
  components: { ElScrollbar },
  setup() {
    let scrollBar2 = ref(null);
    getCurrentInstance();
    return {
      scrollBar: scrollBar2,
      update() {
        scrollBar2.value.update();
      },
      filterAttrs: (attrs) => {
        return attrs;
      }
    };
  }
});
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  return _ctx.isScroll ? (openBlock(), createBlock(_component_el_scrollbar, mergeProps({ key: 0 }, _ctx.$attrs, { ref: "scrollBar" }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16)) : (openBlock(), createElementBlock("div", normalizeProps(mergeProps({ key: 1 }, _ctx.$attrs)), [
    renderSlot(_ctx.$slots, "default")
  ], 16));
}
var scrollBar = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
scrollBar.install = (app) => {
  app.component(scrollBar.name, scrollBar);
};
const _sfc_main$i = defineComponent({
  name: "AwsuiPopover",
  data: () => {
    return {};
  }
});
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popover = resolveComponent("el-popover");
  return openBlock(), createBlock(_component_el_popover, normalizeProps(guardReactiveProps(_ctx.$attrs)), createSlots({ _: 2 }, [
    renderList(_ctx.$slots, (index2, name2) => {
      return {
        name: name2,
        fn: withCtx(() => [
          renderSlot(_ctx.$slots, name2)
        ])
      };
    })
  ]), 1040);
}
var AwsuiPopover = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
AwsuiPopover.install = (app) => {
  app.component(AwsuiPopover.name, AwsuiPopover);
};
const _sfc_main$h = defineComponent({
  name: "AwsuiIconPicker",
  props: {
    defaultOptions: {
      type: Object,
      default: function() {
        return {
          type: "background",
          iconfontArray: []
        };
      }
    },
    colorList: {
      type: Array,
      default: function() {
        return ["#dc4f39", "#ff9421", "#009b52", "#287FF4", "#009688", "#6600d5", "#0b0e7b", "#666666", "#e6e8ea"];
      }
    },
    modelValue: {
      type: Object,
      default() {
        return {
          icon: "&#xe68c;",
          color: "#dc4f39"
        };
      }
    }
  },
  emits: ["update:modelValue", "change", "status"],
  setup(props2, { emit: emit2 }) {
    const { proxy: $this } = getCurrentInstance();
    let isDingDingDaIconfont = ref(props2.defaultOptions.isDingDingDaIconfont);
    let currentValue = ref(props2.modelValue);
    let visible2 = ref(false);
    let status = ref("hide");
    let colorActive = ref(null);
    let hoverBackIndex = ref(null);
    let iconValue = ref(props2.defaultOptions.icon !== void 0 ? props2.defaultOptions.icon : isDingDingDaIconfont.value ? $this.AWSPageContext.iconfontMap.dingding[0][1] : $this.AWSPageContext.iconfontMap.default[0][1]);
    let colorValue = ref(props2.defaultOptions.color !== void 0 ? props2.defaultOptions.color : props2.colorList[0]);
    const methods = reactive({
      colorActivefun: (color) => {
        if (props2.defaultOptions.disabled) {
          return false;
        } else {
          colorActive.value = color;
          colorValue.value = color;
        }
      },
      iconActivefun: (icon) => {
        if (props2.defaultOptions.disabled) {
          return false;
        } else {
          iconValue.value = icon;
          if (props2.defaultOptions.close) {
            visible2.value = false;
          }
        }
      },
      mouseoverBack: (index2) => {
        hoverBackIndex.value = index2;
      },
      mouseleaveBack: () => {
        hoverBackIndex.value = null;
      },
      setValue: () => {
        iconValue.value = currentValue.value.icon;
        colorValue.value = currentValue.value.color;
      },
      showHandle: () => {
        status.value = "show";
        emit2("status", status.value);
      },
      hideHandle: () => {
        status.value = "hide";
        emit2("status", status.value);
      },
      getIconFontList: computed(() => {
        if (props2.defaultOptions.iconfontArray === void 0) {
          const result = Object.assign(props2.defaultOptions, {
            iconfontArray: isDingDingDaIconfont.value ? $this.AWSPageContext.iconfontMap.dingding : $this.AWSPageContext.iconfontMap.default
          });
          return result;
        } else {
          return props2.defaultOptions;
        }
      }),
      colorList: computed(() => {
        const result = props2.colorList;
        if (isDingDingDaIconfont.value) {
          const arr = result.slice(0, result.length - 1);
          return arr;
        } else {
          return result;
        }
      })
    });
    onMounted(() => {
    });
    watch(() => props2.modelValue, (val) => {
      iconValue.value = val.icon;
      colorValue.value = val.color ? val.color : "#e6e8ea";
    }, {
      immediate: true
    });
    watch(() => iconValue.value, () => {
      emit2("update:modelValue", {
        icon: iconValue.value,
        color: colorValue.value
      });
      emit2("change", {
        icon: iconValue.value,
        color: colorValue.value
      });
    });
    watch(() => colorValue.value, () => {
      emit2("update:modelValue", {
        icon: iconValue.value,
        color: colorValue.value
      });
      emit2("change", {
        icon: iconValue.value,
        color: colorValue.value
      });
    });
    return __spreadValues2({
      isDingDingDaIconfont,
      currentValue,
      status,
      visible: visible2,
      colorActive,
      hoverBackIndex,
      iconValue,
      colorValue
    }, toRefs(methods));
  }
});
const _withScopeId$4 = (n) => (pushScopeId("data-v-38020b76"), n = n(), popScopeId(), n);
const _hoisted_1$8 = {
  key: 0,
  class: "picker-box"
};
const _hoisted_2$6 = { class: "color-region" };
const _hoisted_3$6 = ["onClick"];
const _hoisted_4$5 = { class: "awsui-iconfont sign-c" };
const _hoisted_5$5 = { class: "icon-region" };
const _hoisted_6$5 = ["onMouseover", "onClick"];
const _hoisted_7$5 = ["innerHTML"];
const _hoisted_8$5 = { class: "picker-box" };
const _hoisted_9$5 = { class: "color-region" };
const _hoisted_10$3 = ["onClick"];
const _hoisted_11$2 = { class: "awsui-iconfont sign-c" };
const _hoisted_12$2 = { class: "icon-region" };
const _hoisted_13$2 = ["onMouseover", "onClick"];
const _hoisted_14$2 = ["innerHTML"];
const _hoisted_15$2 = {
  key: 0,
  class: "picker-box"
};
const _hoisted_16$2 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("p", { class: "picker-title" }, "\u8BBE\u8BA1\u56FE\u6807", -1));
const _hoisted_17$2 = { class: "color-region" };
const _hoisted_18$2 = ["onClick"];
const _hoisted_19$2 = { class: "awsui-iconfont sign-c" };
const _hoisted_20$2 = { class: "icon-region" };
const _hoisted_21$2 = ["onMouseover", "onClick"];
const _hoisted_22$2 = ["innerHTML"];
const _hoisted_23$2 = { class: "picker-box" };
const _hoisted_24$2 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("p", { class: "picker-title" }, "\u8BBE\u8BA1\u56FE\u6807", -1));
const _hoisted_25$2 = { class: "color-region" };
const _hoisted_26$2 = ["onClick"];
const _hoisted_27$2 = { class: "awsui-iconfont sign-c" };
const _hoisted_28$1 = { class: "icon-region" };
const _hoisted_29$1 = ["onMouseover", "onClick"];
const _hoisted_30$1 = ["innerHTML"];
const _hoisted_31$1 = ["src"];
const _hoisted_32$1 = ["innerHTML"];
const _hoisted_33$1 = ["src"];
const _hoisted_34$1 = ["innerHTML"];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popover = resolveComponent("el-popover");
  return _ctx.defaultOptions.show ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(["awsui-icon-picker-wrap", [_ctx.defaultOptions.customClass, { "awsui-dingding-icon-picker-wrap": _ctx.isDingDingDaIconfont }]]),
    style: normalizeStyle({ width: _ctx.getIconFontList.fatherWidth ? _ctx.getIconFontList.fatherWidth : "" })
  }, [
    createCommentVNode(" type\u4E3Abackground "),
    _ctx.defaultOptions.type === "background" ? (openBlock(), createElementBlock("div", _hoisted_1$8, [
      createCommentVNode(" \u989C\u8272\u533A "),
      createElementVNode("div", _hoisted_2$6, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colorList, (item, index2) => {
          return openBlock(), createElementBlock("span", {
            class: "color-item",
            key: index2,
            style: normalizeStyle({ backgroundColor: item }),
            onClick: ($event) => _ctx.colorActivefun(item)
          }, [
            withDirectives(createElementVNode("i", _hoisted_4$5, "\uE639", 512), [
              [vShow, item === _ctx.colorActive || item === _ctx.colorValue]
            ])
          ], 12, _hoisted_3$6);
        }), 128))
      ]),
      createCommentVNode(" \u56FE\u6807\u533A "),
      createElementVNode("div", _hoisted_5$5, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.defaultOptions.iconfontArray, (item, index2) => {
          return openBlock(), createElementBlock("span", {
            class: "icon-item",
            key: index2,
            onMouseover: ($event) => _ctx.mouseoverBack(index2),
            onClick: ($event) => _ctx.iconActivefun(item[1]),
            onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.mouseleaveBack && _ctx.mouseleaveBack(...args)),
            style: normalizeStyle({ backgroundColor: index2 == _ctx.hoverBackIndex || item[1] === _ctx.iconValue ? _ctx.colorValue : "#fff" })
          }, [
            createElementVNode("i", {
              class: "awsui-iconfont sign-i",
              innerHTML: item[1],
              style: normalizeStyle({ color: index2 == _ctx.hoverBackIndex || item[1] === _ctx.iconValue ? _ctx.colorValue === "#e6e8ea" ? "#202124" : "#fff" : _ctx.colorValue === "#e6e8ea" ? "#202124" : "#666" })
            }, null, 12, _hoisted_7$5)
          ], 44, _hoisted_6$5);
        }), 128))
      ])
    ])) : _ctx.defaultOptions.type === "icon" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      createCommentVNode(" type\u4E3AIcon "),
      createElementVNode("div", _hoisted_8$5, [
        createCommentVNode(" \u989C\u8272\u533A "),
        createElementVNode("div", _hoisted_9$5, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colorList, (item, index2) => {
            return openBlock(), createElementBlock("span", {
              class: "color-item",
              key: index2,
              style: normalizeStyle({ backgroundColor: item }),
              onClick: ($event) => _ctx.colorActivefun(item)
            }, [
              withDirectives(createElementVNode("i", _hoisted_11$2, "\uE639", 512), [
                [vShow, item === _ctx.colorActive || item === _ctx.colorValue]
              ])
            ], 12, _hoisted_10$3);
          }), 128))
        ]),
        createCommentVNode(" \u56FE\u6807\u533A "),
        createElementVNode("div", _hoisted_12$2, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.defaultOptions.iconfontArray, (item, index2) => {
            return openBlock(), createElementBlock("span", {
              class: "icon-item",
              key: index2,
              onMouseover: ($event) => _ctx.mouseoverBack(index2),
              onClick: ($event) => _ctx.iconActivefun(item[1]),
              onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.mouseleaveBack && _ctx.mouseleaveBack(...args)),
              style: normalizeStyle({ backgroundColor: index2 == _ctx.hoverBackIndex || item[1] === _ctx.iconValue ? _ctx.colorValue === "#e6e8ea" ? "#666666" : "#e9e9e9" : _ctx.colorValue === "#e6e8ea" ? "#95a3b3" : "#fff", border: index2 == _ctx.hoverBackIndex || item[1] === _ctx.iconValue ? _ctx.colorValue === "#e6e8ea" ? "1px solid #666666" : "1px solid #d2d2d2" : "none" })
            }, [
              createElementVNode("i", {
                class: "awsui-iconfont sign-i",
                innerHTML: item[1],
                style: normalizeStyle({ color: _ctx.colorValue })
              }, null, 12, _hoisted_14$2)
            ], 44, _hoisted_13$2);
          }), 128))
        ])
      ])
    ], 2112)) : createCommentVNode("v-if", true)
  ], 6)) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(["awsui-icon-picker", [_ctx.defaultOptions.customClass]]),
    style: normalizeStyle({ width: _ctx.getIconFontList.fatherWidth ? _ctx.getIconFontList.fatherWidth : _ctx.getIconFontList.type === "background" ? "80px" : "30px" })
  }, [
    createVNode(_component_el_popover, {
      "popper-class": _ctx.isDingDingDaIconfont ? "ding_icon_picker_popover" : "icon_picker_popover",
      visible: _ctx.visible,
      "onUpdate:visible": _cache[4] || (_cache[4] = ($event) => _ctx.visible = $event),
      onShow: _ctx.showHandle,
      onHide: _ctx.hideHandle
    }, {
      reference: withCtx(() => [
        _ctx.defaultOptions.type === "background" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "awsui-icon-picker-box1",
          style: normalizeStyle({
            backgroundColor: _ctx.colorValue,
            width: _ctx.defaultOptions.fatherWidth ? _ctx.defaultOptions.fatherWidth + "px" : "80px",
            height: _ctx.defaultOptions.fatherWidth ? _ctx.defaultOptions.fatherWidth + "px" : "80px"
          })
        }, [
          _ctx.defaultOptions.format ? (openBlock(), createElementBlock("img", {
            key: 0,
            style: { "width": "40px" },
            src: _ctx.iconValue,
            alt: ""
          }, null, 8, _hoisted_31$1)) : (openBlock(), createElementBlock("i", {
            key: 1,
            class: "awsui-iconfont",
            style: normalizeStyle({
              color: _ctx.colorValue === "#e6e8ea" ? "#202124" : "#fff",
              fontSize: _ctx.defaultOptions.iconFontSize ? _ctx.defaultOptions.iconFontSize + "px" : "30px"
            }),
            innerHTML: _ctx.iconValue
          }, null, 12, _hoisted_32$1))
        ], 4)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: "awsui-icon-picker-box2",
          style: normalizeStyle({ backgroundColor: _ctx.colorValue === "#e6e8ea" ? "#666666" : "#f8f8f8", width: _ctx.defaultOptions.fatherWidth ? _ctx.defaultOptions.fatherWidth + "px" : "30px", height: _ctx.defaultOptions.fatherWidth ? _ctx.defaultOptions.fatherWidth + "px" : "30px" })
        }, [
          _ctx.defaultOptions.format ? (openBlock(), createElementBlock("img", {
            key: 0,
            style: { "width": "20px" },
            src: _ctx.iconValue,
            alt: ""
          }, null, 8, _hoisted_33$1)) : (openBlock(), createElementBlock("i", {
            key: 1,
            class: "awsui-iconfont",
            style: normalizeStyle({ fontSize: _ctx.defaultOptions.iconFontSize ? _ctx.defaultOptions.iconFontSize + "px" : "16px", color: _ctx.colorValue }),
            innerHTML: _ctx.iconValue
          }, null, 12, _hoisted_34$1))
        ], 4))
      ]),
      default: withCtx(() => [
        _ctx.defaultOptions.type === "background" ? (openBlock(), createElementBlock("div", _hoisted_15$2, [
          _hoisted_16$2,
          createCommentVNode(" \u989C\u8272\u533A "),
          createElementVNode("div", _hoisted_17$2, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colorList, (item, index2) => {
              return openBlock(), createElementBlock("span", {
                class: "color-item",
                key: index2,
                style: normalizeStyle({ backgroundColor: item }),
                onClick: ($event) => _ctx.colorActivefun(item)
              }, [
                withDirectives(createElementVNode("i", _hoisted_19$2, "\uE639", 512), [
                  [vShow, item === _ctx.colorActive || item === _ctx.colorValue]
                ])
              ], 12, _hoisted_18$2);
            }), 128))
          ]),
          createCommentVNode(" \u56FE\u6807\u533A "),
          createElementVNode("div", _hoisted_20$2, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.defaultOptions.iconfontArray, (item, index2) => {
              return openBlock(), createElementBlock("span", {
                class: "icon-item",
                key: index2,
                onMouseover: ($event) => _ctx.mouseoverBack(index2),
                onClick: ($event) => _ctx.iconActivefun(item[1]),
                onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.mouseleaveBack && _ctx.mouseleaveBack(...args)),
                style: normalizeStyle({ backgroundColor: index2 == _ctx.hoverBackIndex || item[1] === _ctx.iconValue ? _ctx.colorValue : "#fff" })
              }, [
                createElementVNode("i", {
                  class: "awsui-iconfont sign-i",
                  innerHTML: item[1],
                  style: normalizeStyle({ color: index2 == _ctx.hoverBackIndex || item[1] === _ctx.iconValue ? _ctx.colorValue === "#e6e8ea" ? "#202124" : "#fff" : _ctx.colorValue === "#e6e8ea" ? "#202124" : "#666" })
                }, null, 12, _hoisted_22$2)
              ], 44, _hoisted_21$2);
            }), 128))
          ])
        ])) : _ctx.defaultOptions.type === "icon" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createCommentVNode(" type\u4E3AIcon "),
          createElementVNode("div", _hoisted_23$2, [
            _hoisted_24$2,
            createCommentVNode(" \u989C\u8272\u533A "),
            createElementVNode("div", _hoisted_25$2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colorList, (item, index2) => {
                return openBlock(), createElementBlock("span", {
                  class: "color-item",
                  key: index2,
                  style: normalizeStyle({ backgroundColor: item }),
                  onClick: ($event) => _ctx.colorActivefun(item)
                }, [
                  withDirectives(createElementVNode("i", _hoisted_27$2, "\uE639", 512), [
                    [vShow, item === _ctx.colorActive || item === _ctx.colorValue]
                  ])
                ], 12, _hoisted_26$2);
              }), 128))
            ]),
            createCommentVNode(" \u56FE\u6807\u533A "),
            createElementVNode("div", _hoisted_28$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.defaultOptions.iconfontArray, (item, index2) => {
                return openBlock(), createElementBlock("span", {
                  class: "icon-item",
                  key: index2,
                  onMouseover: ($event) => _ctx.mouseoverBack(index2),
                  onClick: ($event) => _ctx.iconActivefun(item[1]),
                  onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.mouseleaveBack && _ctx.mouseleaveBack(...args)),
                  style: normalizeStyle({ backgroundColor: index2 == _ctx.hoverBackIndex || item[1] === _ctx.iconValue ? _ctx.colorValue === "#e6e8ea" ? "#666666" : "#e9e9e9" : _ctx.colorValue === "#e6e8ea" ? "#95a3b3" : "#fff", border: index2 == _ctx.hoverBackIndex || item[1] === _ctx.iconValue ? _ctx.colorValue === "#e6e8ea" ? "1px solid #666666" : "1px solid #d2d2d2" : "none" })
                }, [
                  createElementVNode("i", {
                    class: "awsui-iconfont sign-i",
                    innerHTML: item[1],
                    style: normalizeStyle({ color: _ctx.colorValue })
                  }, null, 12, _hoisted_30$1)
                ], 44, _hoisted_29$1);
              }), 128))
            ])
          ])
        ], 2112)) : createCommentVNode("v-if", true)
      ]),
      _: 1
    }, 8, ["popper-class", "visible", "onShow", "onHide"])
  ], 6));
}
var AwsuiIconPicker = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h], ["__scopeId", "data-v-38020b76"]]);
AwsuiIconPicker.install = (app) => {
  app.component(AwsuiIconPicker.name, AwsuiIconPicker);
};
const _sfc_main$g = defineComponent({
  name: "AwsuiTree"
});
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tree = resolveComponent("el-tree");
  return openBlock(), createBlock(_component_el_tree, { class: "awsui-tree" }, createSlots({ _: 2 }, [
    renderList(_ctx.$slots, (index2, name2) => {
      return {
        name: name2,
        fn: withCtx(() => [
          renderSlot(_ctx.$slots, name2)
        ])
      };
    })
  ]), 1024);
}
var AwsuiTree = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
AwsuiTree.install = (app) => {
  app.component(AwsuiTree.name, AwsuiTree);
};
const _sfc_main$f = defineComponent({
  name: "AwsAppInfo",
  props: ["sid", "appId", "id", "modelType", "hideManage", "showUid", "permTypeScope", "emptyText"],
  data() {
    return {
      isManager: false,
      appIcon: "",
      appIconFontCode: "",
      appIconFontColor: "",
      appName: "",
      appVersionNo: "",
      createTime: "",
      createUser: "",
      appDeveloperName: "",
      updateTime: "",
      updateUser: "",
      teamMembers: "",
      isShowRoleTable: "none",
      isShowOptHistory: "none",
      asideWidth: "70px",
      headerHeight: "18px",
      isShowTableHeader: false,
      optHistoryCopy: [],
      optHistory: [],
      isReadOnlyAppAuth: false,
      emptyInfo: "\u672A\u8BBE\u7F6E\u5F52\u5C5E\u5E94\u7528"
    };
  },
  mounted() {
    this.getAppInfo();
  },
  watch: {
    isManager: {
      handler: function() {
        let $this = this;
        let manager = $this.isManager;
        this.$emit("change", manager);
      },
      immediate: true
    },
    appId: {
      handler: function() {
        let $this = this;
        $this.getAppInfo();
      },
      immediate: true
    },
    emptyText: {
      handler: function(val) {
        this.emptyInfo = val;
      },
      immediate: true
    }
  },
  methods: {
    getSwitchState(data) {
      this.isManager = data;
      this.$emit("change", data);
    },
    showMore() {
      this.optHistory = JSON.parse(JSON.stringify(this.optHistoryCopy));
    },
    getAppInfo() {
      var that = this;
      if (that.appId == void 0 || that.appId == "") {
        return false;
      }
      let data = {
        url: "./jd",
        data: {
          sid: that.sid,
          appId: that.appId,
          id: that.id,
          type: that.modelType,
          permTypeScope: that.permTypeScope == void 0 ? "" : that.permTypeScope,
          cmd: "CONSOLE_M_METADATA_GET_INFO"
        }
      };
      that.awsuiaxios.post(data).then(function(ro) {
        if (ro.result == "ok") {
          let data2 = ro.data.data;
          that.isManager = data2.managedCheck;
          that.appIcon = data2.appIcon;
          that.appIconFontCode = data2.appIconFontCode;
          that.appIconFontColor = data2.appIconFontColor;
          that.appName = data2.appName;
          that.appVersionNo = data2.appVersionNo;
          that.createTime = data2.createTime;
          that.createUser = data2.createUser;
          that.appDeveloperName = data2.appDeveloperName;
          that.updateTime = data2.updateTime;
          that.updateUser = data2.updateUser;
          that.teamMembers = data2.teamMembers;
          if (typeof data2.optHistory != "undefined" && data2.optHistory.length > 0) {
            that.optHistory = JSON.parse(JSON.stringify(data2.optHistory)).splice(0, 3);
            that.optHistoryCopy = JSON.parse(JSON.stringify(data2.optHistory));
          }
          that.isReadOnlyAppAuth = data2.isReadOnlyAppAuth;
          if (!data2.isReadOnlyAppAuth) {
            that.isReadOnlyAppAuth = !data2.managedCheckEdit;
          }
          if (typeof data2.optHistory != "undefined") {
            if (data2.optHistory.length == 0) {
              that.isShowOptHistory = "none";
            } else {
              that.isShowOptHistory = "";
            }
          }
        }
      }).catch((error) => {
        console.log(error);
      });
    }
  }
});
const _withScopeId$3 = (n) => (pushScopeId("data-v-496a5526"), n = n(), popScopeId(), n);
const _hoisted_1$7 = { class: "app-info" };
const _hoisted_2$5 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "app-info-title" }, "\u5E94\u7528\u4FE1\u606F", -1));
const _hoisted_3$5 = { class: "app-img-div" };
const _hoisted_4$4 = ["src"];
const _hoisted_5$4 = { class: "app-icon" };
const _hoisted_6$4 = ["innerHTML"];
const _hoisted_7$4 = { class: "app-name" };
const _hoisted_8$4 = {
  key: 0,
  class: "manageTxt"
};
const _hoisted_9$4 = { class: "" };
const _hoisted_10$2 = {
  key: 0,
  class: "txt-right"
};
const _hoisted_11$1 = {
  key: 1,
  class: "txt-right"
};
const _hoisted_12$1 = { class: "" };
const _hoisted_13$1 = {
  key: 0,
  class: "txt-right"
};
const _hoisted_14$1 = {
  key: 1,
  class: "txt-right"
};
const _hoisted_15$1 = { class: "cc-dev-main-nodata" };
const _hoisted_16$1 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "app-info-title" }, "DevOps", -1));
const _hoisted_17$1 = { class: "dev-collapse-title" };
const _hoisted_18$1 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("i", { class: "awsui-iconfont" }, "\uE663", -1));
const _hoisted_19$1 = { class: "dev-sec txt-right" };
const _hoisted_20$1 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "clearfix" }, [
  /* @__PURE__ */ createElementVNode("span", null, "\u6210\u5458")
], -1));
const _hoisted_21$1 = {
  key: 0,
  class: ""
};
const _hoisted_22$1 = {
  key: 1,
  class: ""
};
const _hoisted_23$1 = { class: "txt-right" };
const _hoisted_24$1 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "clearfix" }, [
  /* @__PURE__ */ createElementVNode("span", null, "\u89D2\u8272/\u5C97\u4F4D")
], -1));
const _hoisted_25$1 = { class: "" };
const _hoisted_26$1 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", {
  class: "cc-dev-main-nodata",
  style: { "border": "1px solid #ececec", "border-radius": "4px", "width": "100%", "text-align": "center" }
}, " \u6682\u65E0\u6570\u636E ", -1));
const _hoisted_27$1 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "app-info-title" }, "\u6700\u8FD1\u4FEE\u6539", -1));
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_header = resolveComponent("el-header");
  const _component_el_aside = resolveComponent("el-aside");
  const _component_el_col = resolveComponent("el-col");
  const _component_el_switch = resolveComponent("el-switch");
  const _component_el_row = resolveComponent("el-row");
  const _component_el_divider = resolveComponent("el-divider");
  const _component_el_main = resolveComponent("el-main");
  const _component_el_container = resolveComponent("el-container");
  const _component_el_card = resolveComponent("el-card");
  const _component_el_collapse_item = resolveComponent("el-collapse-item");
  const _component_el_collapse = resolveComponent("el-collapse");
  const _component_el_table_column = resolveComponent("el-table-column");
  const _component_el_table = resolveComponent("el-table");
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    createVNode(_component_el_container, null, {
      default: withCtx(() => [
        createVNode(_component_el_header, { height: _ctx.headerHeight }, {
          default: withCtx(() => [
            _hoisted_2$5,
            createCommentVNode(' <el-divider class="default-divider"></el-divider>')
          ]),
          _: 1
        }, 8, ["height"]),
        createVNode(_component_el_main, { class: "cc-dev-main-card" }, {
          default: withCtx(() => [
            _ctx.appId != void 0 && _ctx.appId != "" ? (openBlock(), createBlock(_component_el_container, { key: 0 }, {
              default: withCtx(() => [
                createVNode(_component_el_aside, { width: _ctx.asideWidth }, {
                  default: withCtx(() => [
                    withDirectives(createElementVNode("div", _hoisted_3$5, [
                      createElementVNode("img", {
                        class: "app-img",
                        src: _ctx.appIcon
                      }, null, 8, _hoisted_4$4)
                    ], 512), [
                      [vShow, _ctx.appIconFontCode == ""]
                    ]),
                    withDirectives(createElementVNode("div", _hoisted_5$4, [
                      createElementVNode("i", {
                        class: "awsui-iconfont",
                        style: normalizeStyle(_ctx.appIconFontColor),
                        innerHTML: _ctx.appIconFontCode
                      }, null, 12, _hoisted_6$4)
                    ], 512), [
                      [vShow, _ctx.appIconFontCode != ""]
                    ])
                  ]),
                  _: 1
                }, 8, ["width"]),
                createVNode(_component_el_main, { class: "cc-dev-main" }, {
                  default: withCtx(() => [
                    createVNode(_component_el_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_el_col, { span: 12 }, {
                          default: withCtx(() => [
                            createElementVNode("div", _hoisted_7$4, toDisplayString(_ctx.appName), 1)
                          ]),
                          _: 1
                        }),
                        _ctx.hideManage == void 0 || !_ctx.hideManage ? (openBlock(), createBlock(_component_el_col, {
                          key: 0,
                          span: 12,
                          style: { "height": "25px" }
                        }, {
                          default: withCtx(() => [
                            _ctx.isManager ? (openBlock(), createElementBlock("span", _hoisted_8$4, "\u8BE5\u6A21\u578B\u5728QAS\u548CPRD\u73AF\u5883\u53D7\u7BA1\uFF0C\u4E0D\u5141\u8BB8\u5220\u9664\u548C\u4FEE\u6539")) : createCommentVNode("v-if", true),
                            createVNode(_component_el_switch, {
                              class: "manageSwitch",
                              "active-color": "#d9422f",
                              "inactive-color": "#009688",
                              "active-text": "\u53D7\u7BA1",
                              "inactive-text": "\u4E0D\u53D7\u7BA1",
                              size: "small",
                              modelValue: _ctx.isManager,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.isManager = $event),
                              disabled: _ctx.isReadOnlyAppAuth,
                              onChange: _ctx.getSwitchState
                            }, null, 8, ["modelValue", "disabled", "onChange"])
                          ]),
                          _: 1
                        })) : createCommentVNode("v-if", true)
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_divider, { class: "app-info-divider" }),
                    createVNode(_component_el_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_el_col, { span: 13 }, {
                          default: withCtx(() => [
                            createElementVNode("div", _hoisted_9$4, "\u5E94\u7528ID\uFF1A" + toDisplayString(_ctx.appId) + "(" + toDisplayString(_ctx.appVersionNo) + ")", 1)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_col, { span: 11 }, {
                          default: withCtx(() => [
                            _ctx.createUser != "" ? (openBlock(), createElementBlock("div", _hoisted_10$2, "\u521B\u5EFA\u4EBA\uFF1A" + toDisplayString(_ctx.createTime) + " (" + toDisplayString(_ctx.createUser) + ")", 1)) : _ctx.createUser == "" ? (openBlock(), createElementBlock("div", _hoisted_11$1, "\u521B\u5EFA\u65F6\u95F4\uFF1A" + toDisplayString(_ctx.createTime), 1)) : createCommentVNode("v-if", true)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    createVNode(_component_el_row, null, {
                      default: withCtx(() => [
                        createVNode(_component_el_col, { span: 13 }, {
                          default: withCtx(() => [
                            createElementVNode("div", _hoisted_12$1, "\u5F00\u53D1\u5546\uFF1A" + toDisplayString(_ctx.appDeveloperName), 1)
                          ]),
                          _: 1
                        }),
                        createVNode(_component_el_col, { span: 11 }, {
                          default: withCtx(() => [
                            _ctx.updateUser != "" ? (openBlock(), createElementBlock("div", _hoisted_13$1, "\u4FEE\u6539\u4EBA\uFF1A" + toDisplayString(_ctx.updateTime) + " (" + toDisplayString(_ctx.updateUser) + ")", 1)) : _ctx.updateUser == "" ? (openBlock(), createElementBlock("div", _hoisted_14$1, "\u4FEE\u6539\u65F6\u95F4\uFF1A" + toDisplayString(_ctx.updateTime), 1)) : createCommentVNode("v-if", true)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })) : _ctx.appId == void 0 || _ctx.appId == "" ? (openBlock(), createBlock(_component_el_container, { key: 1 }, {
              default: withCtx(() => [
                createElementVNode("div", _hoisted_15$1, toDisplayString(_ctx.emptyInfo), 1)
              ]),
              _: 1
            })) : createCommentVNode("v-if", true)
          ]),
          _: 1
        })
      ]),
      _: 1
    }),
    createVNode(_component_el_container, null, {
      default: withCtx(() => [
        createVNode(_component_el_header, { height: _ctx.headerHeight }, {
          default: withCtx(() => [
            _hoisted_16$1,
            createCommentVNode('<el-divider class="default-divider"></el-divider>')
          ]),
          _: 1
        }, 8, ["height"]),
        createVNode(_component_el_main, { class: "cc-dev-main" }, {
          default: withCtx(() => [
            _ctx.appId != void 0 && _ctx.appId != "" ? (openBlock(), createBlock(_component_el_container, { key: 0 }, {
              default: withCtx(() => [
                createVNode(_component_el_main, { class: "cc-dev-main" }, {
                  default: withCtx(() => [
                    createVNode(_component_el_card, {
                      class: "box-card dev-ops",
                      shadow: "never"
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.teamMembers, (item, index2) => {
                          return openBlock(), createBlock(_component_el_collapse, {
                            accordion: "",
                            key: index2
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_el_collapse_item, null, {
                                title: withCtx(() => [
                                  createElementVNode("div", _hoisted_17$1, [
                                    _hoisted_18$1,
                                    createTextVNode(" " + toDisplayString(item.teamName) + " ", 1),
                                    createElementVNode("div", _hoisted_19$1, toDisplayString(item.permTxt), 1)
                                  ])
                                ]),
                                default: withCtx(() => [
                                  item.members.length > 0 ? (openBlock(), createBlock(_component_el_card, {
                                    key: 0,
                                    class: "box-card dev-card"
                                  }, {
                                    header: withCtx(() => [
                                      _hoisted_20$1
                                    ]),
                                    default: withCtx(() => [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(item.members, (user, index3) => {
                                        return openBlock(), createElementBlock("div", {
                                          key: index3,
                                          class: "text dev-item"
                                        }, [
                                          createVNode(_component_el_row, null, {
                                            default: withCtx(() => [
                                              createVNode(_component_el_col, { span: 12 }, {
                                                default: withCtx(() => [
                                                  _ctx.showUid != void 0 && _ctx.showUid ? (openBlock(), createElementBlock("div", _hoisted_21$1, toDisplayString(user.userName) + "/" + toDisplayString(user.userId), 1)) : (openBlock(), createElementBlock("div", _hoisted_22$1, toDisplayString(user.userName), 1))
                                                ]),
                                                _: 2
                                              }, 1024),
                                              createVNode(_component_el_col, { span: 12 }, {
                                                default: withCtx(() => [
                                                  createElementVNode("div", _hoisted_23$1, toDisplayString(user.departmentName), 1)
                                                ]),
                                                _: 2
                                              }, 1024)
                                            ]),
                                            _: 2
                                          }, 1024)
                                        ]);
                                      }), 128))
                                    ]),
                                    _: 2
                                  }, 1024)) : createCommentVNode("v-if", true),
                                  item.roles.length > 0 ? (openBlock(), createBlock(_component_el_card, {
                                    key: 1,
                                    class: "box-card dev-card",
                                    style: { "margin-top": "20px" }
                                  }, {
                                    header: withCtx(() => [
                                      _hoisted_24$1
                                    ]),
                                    default: withCtx(() => [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(item.roles, (user, index3) => {
                                        return openBlock(), createElementBlock("div", {
                                          key: index3,
                                          class: "text dev-item"
                                        }, [
                                          createVNode(_component_el_row, null, {
                                            default: withCtx(() => [
                                              createVNode(_component_el_col, { span: 24 }, {
                                                default: withCtx(() => [
                                                  createElementVNode("div", _hoisted_25$1, toDisplayString(user.userName), 1)
                                                ]),
                                                _: 2
                                              }, 1024)
                                            ]),
                                            _: 2
                                          }, 1024)
                                        ]);
                                      }), 128))
                                    ]),
                                    _: 2
                                  }, 1024)) : createCommentVNode("v-if", true)
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            _: 2
                          }, 1024);
                        }), 128))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })) : _ctx.appId == void 0 || _ctx.appId == "" ? (openBlock(), createBlock(_component_el_container, { key: 1 }, {
              default: withCtx(() => [
                _hoisted_26$1
              ]),
              _: 1
            })) : createCommentVNode("v-if", true)
          ]),
          _: 1
        })
      ]),
      _: 1
    }),
    createVNode(_component_el_container, {
      style: normalizeStyle({ display: _ctx.isShowOptHistory })
    }, {
      default: withCtx(() => [
        createVNode(_component_el_header, { height: _ctx.headerHeight }, {
          default: withCtx(() => [
            _hoisted_27$1
          ]),
          _: 1
        }, 8, ["height"]),
        createVNode(_component_el_main, null, {
          default: withCtx(() => [
            createVNode(_component_el_table, {
              data: _ctx.optHistory,
              style: { "width": "100%" },
              "show-header": _ctx.isShowTableHeader
            }, {
              default: withCtx(() => [
                createVNode(_component_el_table_column, { prop: "updateUser" }),
                createVNode(_component_el_table_column, {
                  prop: "updateTime",
                  width: "160"
                })
              ]),
              _: 1
            }, 8, ["data", "show-header"])
          ]),
          _: 1
        }),
        withDirectives(createElementVNode("p", {
          class: "show-all",
          style: { "cursor": "pointer", "text-align": "center" },
          onMouseover: _cache[1] || (_cache[1] = (...args) => _ctx.showMore && _ctx.showMore(...args))
        }, "\u52A0\u8F7D\u66F4\u591A", 544), [
          [vShow, _ctx.optHistoryCopy.length > 3 && _ctx.optHistory.length < _ctx.optHistoryCopy.length]
        ])
      ]),
      _: 1
    }, 8, ["style"])
  ]);
}
var AwsAppInfo = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f], ["__scopeId", "data-v-496a5526"]]);
AwsAppInfo.install = (app) => {
  app.component(AwsAppInfo.name, AwsAppInfo);
};
const _sfc_main$e = defineComponent({
  name: "AwsAppSelect",
  props: {
    sid: String,
    width: String,
    filter: String,
    placeholder: String,
    disabled: Boolean,
    value: {}
  },
  data() {
    return {
      optionsCopy: [],
      options: []
    };
  },
  mounted() {
    this.getAppOptions();
  },
  computed: {
    selectValue: {
      get() {
        return this.value;
      },
      set(val) {
        this.$emit("input", val);
      }
    }
  },
  methods: {
    dataFilter(val) {
      this.defaultSelectValue = val;
      if (val) {
        this.options = this.optionsCopy.filter((item) => {
          if (item.label.indexOf(val) > -1 || item.appId.toUpperCase().indexOf(val.toUpperCase()) > -1) {
            return true;
          }
        });
      } else {
        this.options = this.optionsCopy;
      }
    },
    getAppOptions() {
      var that = this;
      let data = {
        url: "./jd",
        data: {
          sid: that.sid,
          param: that.filter,
          cmd: "CONSOLE_M_METADATA_GET_OPTIONS"
        }
      };
      that.awsuiaxios.post(data).then((ro) => {
        if (ro.result == "ok") {
          let data2 = ro.data;
          that.options = data2.data;
          that.optionsCopy = data2.data;
        }
      }).catch((error) => {
        console.log(error);
      });
    },
    getValue(data) {
      if (typeof data == "string") {
        this.$emit("getResult", data);
        this.$emit("change", data);
      }
    },
    setValueNull() {
      this.selectValue = "";
      this.options = this.optionsCopy;
    }
  }
});
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_select = resolveComponent("awsui-select");
  return openBlock(), createElementBlock("div", {
    class: "awsui-select app-select",
    style: normalizeStyle([{ width: _ctx.width }, { "display": "inline-block" }])
  }, [
    createVNode(_component_awsui_select, {
      modelValue: _ctx.selectValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selectValue = $event),
      onClear: _ctx.setValueNull,
      clearable: "",
      filterable: "",
      custom: "",
      placeholder: _ctx.placeholder,
      onChange: _ctx.getValue,
      options: _ctx.options,
      disabled: _ctx.disabled,
      "no-data-text": "\u6682\u65E0\u5E94\u7528",
      "no-match-text": "\u6CA1\u6709\u641C\u7D22\u5230\u5339\u914D\u7ED3\u679C"
    }, null, 8, ["modelValue", "onClear", "placeholder", "onChange", "options", "disabled"])
  ], 4);
}
var AwsAppSelect = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e], ["__scopeId", "data-v-94702534"]]);
AwsAppSelect.install = (app) => {
  app.component(AwsAppSelect.name, AwsAppSelect);
};
const _sfc_main$d = defineComponent({
  name: "AwsuiDownSelectItem",
  props: {
    modelValue: [String, Boolean, Number, Array],
    type: {
      type: String,
      default: "default"
    },
    prohibit: {
      type: Boolean,
      default: false
    },
    width: {
      type: String,
      default: "200"
    },
    itemwidth: {
      type: String,
      default: "120"
    },
    height: {
      type: String
    },
    maxheight: {
      type: String
    },
    title: {
      type: String,
      default: "\u52FE\u9009\u8DF3\u8F6C\u8303\u56F4"
    },
    options: {
      type: Array,
      default: () => {
        return [];
      }
    },
    selectContent: {
      type: String,
      default: "\u8BF7\u9009\u62E9"
    }
  },
  setup(props2, context) {
    let wrapperheight = ref(-1);
    let selectindex = ref(-1);
    let optionwrapper = ref(true);
    let checkList = reactive([]);
    let sCon = ref("");
    let pronbit = ref(null);
    let wrapper = ref(null);
    const methods = {
      init() {
        const propsOptions2 = props2.options;
        if (props2.type === "radio") {
          if (props2.modelValue !== "" || props2.modelValue === false || props2.modelValue === true) {
            propsOptions2.filter((item, index2) => {
              if (item.value == props2.modelValue) {
                selectindex.value = index2;
                sCon.value = item.label;
                context.emit("input", props2.modelValue);
              }
            });
            return false;
          }
          if (props2.modelValue == "") {
            selectindex.value = -1;
            sCon.value = props2.selectContent;
            context.emit("input", props2.modelValue);
          }
        }
        if (props2.type === "checkbox") {
          checkList = props2.modelValue;
          let conarr = [];
          propsOptions2.filter((item) => {
            checkList.filter((val) => {
              if (item.value == val) {
                conarr.push(item.label);
              }
            });
          });
          if (conarr.length == 0) {
            sCon.value = props2.selectContent;
          } else {
            sCon.value = conarr.join(",");
          }
          context.emit("update:modelValue", checkList);
        }
      },
      triggerOption() {
        if (props2.prohibit == true) {
          return false;
        }
        optionwrapper.value = true;
        const bodyDom = document.querySelector("body");
        if (bodyDom != null && pronbit.value != null && wrapper.value != null) {
          let autoHeight = bodyDom.offsetHeight - (bodyDom.offsetHeight - pronbit.value.getBoundingClientRect().top);
          if (autoHeight - wrapperheight.value > 0) {
            wrapper.value.style.left = pronbit.value.getBoundingClientRect().left + "px";
            wrapper.value.style.bottom = bodyDom.offsetHeight - pronbit.value.getBoundingClientRect().top + "px";
            wrapper.value.style.top = "initial";
          } else {
            wrapper.value.style.left = pronbit.value.getBoundingClientRect().left + "px";
            wrapper.value.style.top = autoHeight + 24 + "px";
            wrapper.value.style.bottom = "initial";
          }
        }
      },
      change(value2) {
        const propsOptions2 = props2.options;
        let conarr = [];
        propsOptions2.filter((item) => {
          value2.filter((val) => {
            if (item.value == val) {
              conarr.push(item.label);
            }
          });
        });
        if (value2.length > 0) {
          sCon.value = conarr.join();
        } else {
          sCon.value = props2.selectContent;
        }
        context.emit("update:modelValue", value2);
        context.emit("clickOption", value2);
      },
      choose(item, event2, index2) {
        selectindex.value = index2;
        sCon.value = item.label;
        context.emit("update:modelValue", item.value);
        context.emit("clickOption", item.value);
        optionwrapper.value = false;
      },
      leaveOption() {
        optionwrapper.value = false;
      }
    };
    watch(() => props2.modelValue, () => {
      methods.init();
    });
    onMounted(() => {
      if (wrapper.value != null) {
        wrapperheight.value = wrapper.value.offsetHeight;
        optionwrapper.value = false;
        methods.init();
      }
    });
    return __spreadProps2(__spreadValues2({
      pronbit,
      wrapper,
      wrapperheight,
      selectindex,
      optionwrapper,
      checkList,
      sCon
    }, methods), {
      style: computed(() => {
        let style = {};
        if (props2.width) {
          style.width = props2.width + "px";
        }
        if (props2.height) {
          style.height = props2.height + "px";
        }
        if (props2.maxheight) {
          style.maxHeight = props2.maxheight + "px";
        }
        return style;
      }),
      itemstyle: computed(() => {
        let itemstyle = {};
        if (props2.itemwidth) {
          if (props2.itemwidth.indexOf("%") != -1) {
            itemstyle.width = props2.itemwidth;
          } else {
            itemstyle.width = props2.itemwidth + "px";
          }
        }
        return itemstyle;
      })
    });
  }
});
const _hoisted_1$6 = { class: "awsui-down-select-item__select-content" };
const _hoisted_2$4 = {
  key: 0,
  class: "awsui-iconfont",
  style: { "font-size": "12px", "position": "absolute", "right": "10px" }
};
const _hoisted_3$4 = {
  key: 0,
  style: { "text-align": "center", "color": "#999", "font-size": "14px", "margin": "0", "padding": "10px 0" }
};
const _hoisted_4$3 = { key: 1 };
const _hoisted_5$3 = { class: "awsui-down-select-title" };
const _hoisted_6$3 = { key: 2 };
const _hoisted_7$3 = ["onClick"];
const _hoisted_8$3 = ["innerHTML"];
const _hoisted_9$3 = {
  class: "awsui-iconfont",
  style: { "font-size": "12px", "position": "absolute", "right": "8px" }
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["awsui-down-select-item__wrap", { prohibits: _ctx.prohibit }]),
    style: normalizeStyle(_ctx.itemstyle),
    ref: "pronbit"
  }, [
    createElementVNode("span", {
      class: "awsui-down-select-item__select",
      onMouseover: _cache[0] || (_cache[0] = (...args) => _ctx.triggerOption && _ctx.triggerOption(...args)),
      onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.leaveOption && _ctx.leaveOption(...args))
    }, [
      createElementVNode("div", _hoisted_1$6, [
        createTextVNode(toDisplayString(_ctx.sCon) + " ", 1),
        !(_ctx.sCon === "--") ? (openBlock(), createElementBlock("i", _hoisted_2$4, "\uE716")) : createCommentVNode("v-if", true)
      ])
    ], 32),
    (openBlock(), createBlock(Teleport, { to: "body" }, [
      createVNode(Transition, { name: "fade" }, {
        default: withCtx(() => [
          withDirectives(createElementVNode("div", {
            ref: "wrapper",
            class: "awsui-down-select-item__list",
            onMouseover: _cache[3] || (_cache[3] = (...args) => _ctx.triggerOption && _ctx.triggerOption(...args)),
            onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.leaveOption && _ctx.leaveOption(...args)),
            style: normalizeStyle(_ctx.style)
          }, [
            renderSlot(_ctx.$slots, "default"),
            _ctx.options.length === 0 ? (openBlock(), createElementBlock("p", _hoisted_3$4, "\u65E0\u6570\u636E")) : createCommentVNode("v-if", true),
            _ctx.type == "checkbox" ? (openBlock(), createElementBlock("div", _hoisted_4$3, [
              createElementVNode("div", _hoisted_5$3, toDisplayString(_ctx.title), 1),
              createVNode(_component_el_checkbox_group, {
                modelValue: _ctx.checkList,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.checkList = $event),
                onChange: _ctx.change
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (item) => {
                    return openBlock(), createBlock(_component_el_checkbox, {
                      label: item.value,
                      key: item.label,
                      checked: item.checked,
                      disabled: item.disabled
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(item.label), 1)
                      ]),
                      _: 2
                    }, 1032, ["label", "checked", "disabled"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "onChange"])
            ])) : _ctx.type == "radio" ? (openBlock(), createElementBlock("div", _hoisted_6$3, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (item, index2) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass(["awsui-down-select-item_option-item", { hover: index2 === _ctx.selectindex }]),
                  key: index2,
                  onClick: ($event) => _ctx.choose(item, $event, index2)
                }, [
                  createElementVNode("span", {
                    innerHTML: item.label
                  }, null, 8, _hoisted_8$3),
                  withDirectives(createElementVNode("i", _hoisted_9$3, "\uE639", 512), [
                    [vShow, _ctx.selectindex === index2]
                  ])
                ], 10, _hoisted_7$3);
              }), 128))
            ])) : createCommentVNode("v-if", true)
          ], 36), [
            [vShow, _ctx.optionwrapper]
          ])
        ]),
        _: 3
      })
    ]))
  ], 6);
}
var AwsuiDownSelectItem = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
AwsuiDownSelectItem.install = (app) => {
  app.component(AwsuiDownSelectItem.name, AwsuiDownSelectItem);
};
const _sfc_main$c = defineComponent({
  name: "AwsuiDownSelect",
  props: {
    width: {
      type: String,
      default: "350"
    },
    direction: {
      type: String,
      default: "right"
    }
  },
  setup(props2, context) {
    const propsWidth = props2.width;
    const propsDirection = props2.direction;
    let downselect = ref(null);
    const methods = {
      getinit() {
        if (downselect.value == null) {
          return;
        }
        let select_width = downselect.value.querySelectorAll(".awsui-down-select-item__wrap");
        for (var i2 = 0; i2 < select_width.length; i2++) {
          let selectDom = select_width[i2];
          if (propsDirection == "right") {
            selectDom.style.zIndex = -i2 + 100;
            selectDom.style.marginLeft = "-14px";
            select_width[0].style.marginLeft = "0";
            if (i2 != select_width.length - 1) {
              selectDom.classList.add("awsui-down-select-bg-right");
            }
            if (i2 != 0) {
              selectDom.classList.add("awsui-down-select-border-left");
            }
          }
          if (propsDirection == "left") {
            selectDom.style.zIndex = i2;
            selectDom.style.marginRight = "-14px";
            if (i2 != 0) {
              selectDom.classList.add("awsui-down-select-bg-left");
            }
            if (i2 != select_width.length - 1) {
              selectDom.classList.add("awsui-down-select-border-right");
            }
          }
        }
      }
    };
    onMounted(() => {
      methods.getinit();
    });
    return __spreadProps2(__spreadValues2({}, methods), {
      downselect,
      style: computed(() => {
        let style = {};
        if (propsWidth) {
          if (propsWidth.indexOf("%") != -1) {
            style.width = propsWidth;
          } else {
            style.width = propsWidth + "px";
          }
        }
        return style;
      })
    });
  }
});
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "awsui-down-select",
    style: normalizeStyle(_ctx.style),
    ref: "downselect"
  }, [
    renderSlot(_ctx.$slots, "default"),
    createCommentVNode('    <div v-if="tips"'),
    createCommentVNode('         style="color: #F56C6C;padding-left: 5px;font-size: 12px;line-height: 1;">{{ tips }}'),
    createCommentVNode("    </div>")
  ], 4);
}
var AwsuiDownSelect = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
AwsuiDownSelect.install = (app) => {
  app.component(AwsuiDownSelect.name, AwsuiDownSelect);
};
const _sfc_main$b = defineComponent({
  name: "AwsuiForm",
  setup() {
    let instance = getCurrentInstance();
    const methods = {
      validate(...args) {
        if (instance != null) {
          instance.refs["Form"].validate(...args);
        }
      },
      clearValidate(...args) {
        if (instance != null) {
          instance.refs["Form"].clearValidate(...args);
        }
      },
      validateField(...args) {
        if (instance != null) {
          instance.refs["Form"].validateField(...args);
        }
      },
      resetFields(...args) {
        if (instance != null) {
          instance.refs["Form"].resetFields(...args);
        }
      }
    };
    return __spreadValues2({}, methods);
  }
});
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_form = resolveComponent("el-form");
  return openBlock(), createBlock(_component_el_form, mergeProps(_ctx.$attrs, {
    ref: "Form",
    onSubmit: _cache[0] || (_cache[0] = withModifiers(() => {
    }, ["prevent"])),
    class: "awsui-form"
  }), createSlots({ _: 2 }, [
    renderList(_ctx.$slots, (index2, name2) => {
      return {
        name: name2,
        fn: withCtx(() => [
          renderSlot(_ctx.$slots, name2)
        ])
      };
    })
  ]), 1040);
}
var Form = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
Form.install = (app) => {
  app.component(Form.name, Form);
};
const _sfc_main$a = defineComponent({
  name: "AwsuiFormItem",
  data: () => {
    return {};
  }
});
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_form_item = resolveComponent("el-form-item");
  return openBlock(), createBlock(_component_el_form_item, normalizeProps(guardReactiveProps(_ctx.$attrs)), createSlots({ _: 2 }, [
    renderList(_ctx.$slots, (index2, name2) => {
      return {
        name: name2,
        fn: withCtx(() => [
          renderSlot(_ctx.$slots, name2)
        ])
      };
    })
  ]), 1040);
}
var AwsuiFormItem = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
AwsuiFormItem.install = (app) => {
  app.component(AwsuiFormItem.name, AwsuiFormItem);
};
iframe.install = (app) => {
  app.component(iframe.name, iframe);
};
const _sfc_main$9 = defineComponent({
  name: "AwsuiLayout",
  props: {
    direction: {
      type: String,
      default: ""
    }
  },
  setup(props2, { slots }) {
    const isVertical = computed(() => {
      if (props2.direction === "vertical") {
        return true;
      } else if (props2.direction === "horizontal") {
        return false;
      }
      if (slots && slots.default) {
        const vNodes = slots.default();
        return vNodes.some((vNode) => {
          const tag = vNode.type.name;
          return tag === "AwsuiHeader" || tag === "AwsuiFooter";
        });
      } else {
        return false;
      }
    });
    return {
      isVertical
    };
  }
});
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("section", {
    class: normalizeClass(["el-container", { "is-vertical": _ctx.isVertical }])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var AwsuiLayout = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
AwsuiLayout.install = (app) => {
  app.component(AwsuiLayout.name, AwsuiLayout);
};
const _sfc_main$8 = defineComponent({
  name: "AwsuiHeader",
  componentName: "AwsuiHeader",
  props: {
    height: {
      type: String,
      default: "60px"
    }
  }
});
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    class: "awsui-header",
    style: normalizeStyle({ height: _ctx.height })
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 4);
}
var AwsuiHeader = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-c0d2ed74"]]);
AwsuiHeader.install = (app) => {
  app.component(AwsuiHeader.name, AwsuiHeader);
};
const _sfc_main$7 = defineComponent({
  name: "AwsuiFooter",
  componentName: "AwsuiFooter",
  props: {
    height: {
      type: String,
      default: "60px"
    }
  }
});
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("footer", {
    class: "awsui-footer",
    style: normalizeStyle({ height: _ctx.height })
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 4);
}
var AwsuiFooter = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-0c17d6f4"]]);
AwsuiFooter.install = (app) => {
  app.component(AwsuiFooter.name, AwsuiFooter);
};
const _sfc_main$6 = defineComponent({
  name: "AwsuiMain",
  componentName: "AwsuiMain"
});
const _hoisted_1$5 = { class: "awsui-main" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("main", _hoisted_1$5, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ]);
}
var AwsuiMain = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-2a3a7406"]]);
AwsuiMain.install = (app) => {
  app.component(AwsuiMain.name, AwsuiMain);
};
const _sfc_main$5 = defineComponent({
  name: "AwsuiAside",
  componentName: "AwsuiAside",
  props: {
    width: {
      type: String,
      default: "300px"
    }
  }
});
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("aside", {
    class: "awsui-aside",
    style: normalizeStyle({ width: _ctx.width })
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 4);
}
var AwsuiAside = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-9d4f20bc"]]);
AwsuiAside.install = (app) => {
  app.component(AwsuiAside.name, AwsuiAside);
};
const AwsuiCol = defineComponent({
  name: "AwsuiCol",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    span: {
      type: Number,
      default: 24
    },
    offset: {
      type: Number,
      default: 0
    },
    pull: {
      type: Number,
      default: 0
    },
    push: {
      type: Number,
      default: 0
    },
    xs: {
      type: [Number, Object],
      default: () => ({})
    },
    sm: {
      type: [Number, Object],
      default: () => ({})
    },
    md: {
      type: [Number, Object],
      default: () => ({})
    },
    lg: {
      type: [Number, Object],
      default: () => ({})
    },
    xl: {
      type: [Number, Object],
      default: () => ({})
    }
  },
  setup(props2, { slots }) {
    const { gutter } = inject("ElRow", { gutter: { value: 0 } });
    const style = computed(() => {
      if (gutter.value) {
        return {
          paddingLeft: gutter.value / 2 + "px",
          paddingRight: gutter.value / 2 + "px"
        };
      }
      return {};
    });
    const classList = computed(() => {
      const ret = [];
      const pos = ["span", "offset", "pull", "push"];
      pos.forEach((prop) => {
        const size = props2[prop];
        if (typeof size === "number" && size > 0) {
          ret.push(prop !== "span" ? `el-col-${prop}-${props2[prop]}` : `el-col-${props2[prop]}`);
        }
      });
      const sizes = ["xs", "sm", "md", "lg", "xl"];
      sizes.forEach((size) => {
        if (typeof props2[size] === "number" && props2[size] > 0) {
          ret.push(`el-col-${size}-${props2[size]}`);
        } else if (typeof props2[size] === "object" && JSON.stringify(props2[size]) !== "{}") {
          const sizeProps = props2[size];
          Object.keys(sizeProps).forEach((prop) => {
            ret.push(prop !== "span" ? `el-col-${size}-${prop}-${sizeProps[prop]}` : `el-col-${size}-${sizeProps[prop]}`);
          });
        }
      });
      if (gutter.value) {
        ret.push("is-guttered");
      }
      return ret;
    });
    return () => {
      var _a;
      return h(props2.tag, {
        class: ["el-col", classList.value],
        style: style.value
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
AwsuiCol.install = (app) => {
  app.component(AwsuiCol.name, AwsuiCol);
};
var AwsuiRow = defineComponent({
  name: "AwsuiRow",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    gutter: {
      type: Number,
      default: 0
    },
    type: {
      type: String,
      default: ""
    },
    justify: {
      type: String,
      default: "start"
    },
    align: {
      type: String,
      default: "top"
    }
  },
  setup(props2, { slots }) {
    const gutter = computed(() => props2.gutter);
    provide("ElRow", {
      gutter
    });
    const style = computed(() => {
      const ret = {
        marginLeft: "",
        marginRight: ""
      };
      if (props2.gutter) {
        ret.marginLeft = `-${props2.gutter / 2}px`;
        ret.marginRight = ret.marginLeft;
      }
      return ret;
    });
    return () => {
      var _a;
      return h(props2.tag, {
        class: [
          "el-row",
          props2.justify !== "start" ? `is-justify-${props2.justify}` : "",
          props2.align !== "top" ? `is-align-${props2.align}` : "",
          props2.type === "flex" ? "el-row--flex" : ""
        ],
        style: style.value
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
AwsuiRow.install = (app) => {
  app.component(AwsuiRow.name, AwsuiRow);
};
const _sfc_main$4 = defineComponent({
  name: "AwsuiSwitch",
  components: {
    "el-tooltip": ElTooltip,
    "el-switch": ElSwitch
  },
  props: {
    width: {
      type: [String, Number],
      default: 40
    },
    left: {
      type: Boolean,
      default: false
    },
    right: {
      type: Boolean,
      default: false
    },
    inner: {
      type: Boolean,
      default: false
    },
    switchery: {
      type: Boolean,
      default: false
    },
    activeColor: {
      type: String,
      default: "#409EFF"
    },
    inactiveColor: {
      type: String,
      default: "#C0CCDA"
    },
    activeText: {
      type: String,
      default: ""
    },
    inactiveText: {
      type: String,
      default: ""
    },
    activeValue: {
      type: [String, Number, Boolean],
      default: true
    },
    inactiveValue: {
      type: [String, Number, Boolean],
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    extend: {
      type: Boolean,
      default: false
    },
    className: {
      type: String,
      default: ""
    },
    modelValue: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: ""
    }
  },
  emits: ["update:modelValue"],
  setup(props2, cxt) {
    const switchDisabled = computed(() => {
      const ia = inject("awsuiForm", "");
      return props2.disabled || (ia || {}).disabled;
    });
    const switchSize = computed(() => {
      return props2.size;
    });
    return {
      switchDisabled,
      switchSize,
      value: computed({
        get: () => {
          return props2.modelValue;
        },
        set: (val) => {
          cxt.emit("update:modelValue", val);
        }
      })
    };
  }
});
const _hoisted_1$4 = { class: "awsui-component" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_switch = resolveComponent("el-switch");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    _ctx.extend ? (openBlock(), createBlock(_component_el_tooltip, {
      key: 0,
      content: "Switch value: " + _ctx.value,
      placement: "top"
    }, {
      default: withCtx(() => [
        createVNode(_component_el_switch, mergeProps({
          modelValue: _ctx.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.value = $event)
        }, _ctx.$attrs, {
          class: ["awsui-switch", [
            _ctx.switchSize ? "awsui-switch-" + _ctx.switchSize : "",
            _ctx.className ? _ctx.className : "",
            {
              "inner": _ctx.inner,
              "left": _ctx.left,
              "right": _ctx.right,
              "switchery": _ctx.switchery
            }
          ]],
          width: Number(_ctx.width),
          "active-color": _ctx.activeColor,
          "inactive-color": _ctx.inactiveColor,
          "active-text": _ctx.right || _ctx.inner ? _ctx.inner ? _ctx.value ? " " : _ctx.inactiveText : _ctx.value ? _ctx.activeText : _ctx.inactiveText : "",
          "inactive-text": _ctx.left || _ctx.inner ? _ctx.inner ? _ctx.value ? _ctx.activeText : " " : _ctx.value ? _ctx.activeText : _ctx.inactiveText : "",
          disabled: _ctx.switchDisabled,
          "active-value": _ctx.activeValue,
          "inactive-value": _ctx.inactiveValue
        }), null, 16, ["modelValue", "class", "width", "active-color", "inactive-color", "active-text", "inactive-text", "disabled", "active-value", "inactive-value"])
      ]),
      _: 1
    }, 8, ["content"])) : (openBlock(), createBlock(_component_el_switch, mergeProps({
      key: 1,
      modelValue: _ctx.value,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.value = $event)
    }, _ctx.$attrs, {
      class: ["awsui-switch", [
        _ctx.switchSize ? "awsui-switch-" + _ctx.switchSize : "",
        _ctx.className ? "awsui-switch-custom " + _ctx.className : "",
        {
          "inner": _ctx.inner,
          "left": _ctx.left,
          "right": _ctx.right,
          "switchery": _ctx.switchery
        }
      ]],
      width: Number(_ctx.width),
      "active-color": _ctx.activeColor,
      "inactive-color": _ctx.inactiveColor,
      "active-text": _ctx.right || _ctx.inner ? _ctx.inner ? _ctx.value ? " " : _ctx.inactiveText : _ctx.value ? _ctx.activeText : _ctx.inactiveText : "",
      "inactive-text": _ctx.left || _ctx.inner ? _ctx.inner ? _ctx.value ? _ctx.activeText : " " : _ctx.value ? _ctx.activeText : _ctx.inactiveText : "",
      disabled: _ctx.switchDisabled
    }), null, 16, ["modelValue", "class", "width", "active-color", "inactive-color", "active-text", "inactive-text", "disabled"]))
  ]);
}
var AwsuiSwitch = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
AwsuiSwitch.install = (app) => {
  app.component(AwsuiSwitch.name, AwsuiSwitch);
};
var intro = { exports: {} };
/*!
 * Intro.js v4.1.0
 * https://introjs.com
 *
 * Copyright (C) 2012-2021 Afshin Mehrabani (@afshinmeh).
 * https://raw.githubusercontent.com/usablica/intro.js/master/license.md
 *
 * Date: Fri, 18 Jun 2021 10:48:16 GMT
 */
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    function mergeOptions2(obj1, obj2) {
      var obj3 = {};
      var attrname;
      for (attrname in obj1) {
        obj3[attrname] = obj1[attrname];
      }
      for (attrname in obj2) {
        obj3[attrname] = obj2[attrname];
      }
      return obj3;
    }
    var stamp = function() {
      var keys3 = {};
      return function stamp2(obj) {
        var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "introjs-stamp";
        keys3[key] = keys3[key] || 0;
        if (obj[key] === void 0) {
          obj[key] = keys3[key]++;
        }
        return obj[key];
      };
    }();
    function forEach3(arr, forEachFnc, completeFnc) {
      if (arr) {
        for (var i2 = 0, len = arr.length; i2 < len; i2++) {
          forEachFnc(arr[i2], i2);
        }
      }
      if (typeof completeFnc === "function") {
        completeFnc();
      }
    }
    var DOMEvent = function() {
      function DOMEvent2() {
        var events_key = "introjs_event";
        this._id = function(obj, type2, listener, context) {
          return type2 + stamp(listener) + (context ? "_".concat(stamp(context)) : "");
        };
        this.on = function(obj, type2, listener, context, useCapture) {
          var id3 = this._id.apply(this, arguments);
          var handler = function handler2(e) {
            return listener.call(context || obj, e || window.event);
          };
          if ("addEventListener" in obj) {
            obj.addEventListener(type2, handler, useCapture);
          } else if ("attachEvent" in obj) {
            obj.attachEvent("on".concat(type2), handler);
          }
          obj[events_key] = obj[events_key] || {};
          obj[events_key][id3] = handler;
        };
        this.off = function(obj, type2, listener, context, useCapture) {
          var id3 = this._id.apply(this, arguments);
          var handler = obj[events_key] && obj[events_key][id3];
          if (!handler) {
            return;
          }
          if ("removeEventListener" in obj) {
            obj.removeEventListener(type2, handler, useCapture);
          } else if ("detachEvent" in obj) {
            obj.detachEvent("on".concat(type2), handler);
          }
          obj[events_key][id3] = null;
        };
      }
      return new DOMEvent2();
    }();
    var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : {};
    function createCommonjsModule(fn2, module2) {
      return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
    }
    var check = function(it) {
      return it && it.Math == Math && it;
    };
    var global_1 = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal$1 == "object" && commonjsGlobal$1) || function() {
      return this;
    }() || Function("return this")();
    var fails = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
    var descriptors = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    var f$4 = NASHORN_BUG ? function propertyIsEnumerable2(V) {
      var descriptor = getOwnPropertyDescriptor$1(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
    var objectPropertyIsEnumerable = {
      f: f$4
    };
    var createPropertyDescriptor = function(bitmap, value2) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value2
      };
    };
    var toString3 = {}.toString;
    var classofRaw = function(it) {
      return toString3.call(it).slice(8, -1);
    };
    var split = "".split;
    var indexedObject = fails(function() {
      return !Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classofRaw(it) == "String" ? split.call(it, "") : Object(it);
    } : Object;
    var requireObjectCoercible = function(it) {
      if (it == void 0)
        throw TypeError("Can't call method on " + it);
      return it;
    };
    var toIndexedObject = function(it) {
      return indexedObject(requireObjectCoercible(it));
    };
    var isObject2 = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
    var toPrimitive = function(input2, PREFERRED_STRING) {
      if (!isObject2(input2))
        return input2;
      var fn2, val;
      if (PREFERRED_STRING && typeof (fn2 = input2.toString) == "function" && !isObject2(val = fn2.call(input2)))
        return val;
      if (typeof (fn2 = input2.valueOf) == "function" && !isObject2(val = fn2.call(input2)))
        return val;
      if (!PREFERRED_STRING && typeof (fn2 = input2.toString) == "function" && !isObject2(val = fn2.call(input2)))
        return val;
      throw TypeError("Can't convert object to primitive value");
    };
    var toObject2 = function(argument) {
      return Object(requireObjectCoercible(argument));
    };
    var hasOwnProperty2 = {}.hasOwnProperty;
    var has$12 = Object.hasOwn || function hasOwn2(it, key) {
      return hasOwnProperty2.call(toObject2(it), key);
    };
    var document$1 = global_1.document;
    var EXISTS = isObject2(document$1) && isObject2(document$1.createElement);
    var documentCreateElement = function(it) {
      return EXISTS ? document$1.createElement(it) : {};
    };
    var ie8DomDefine = !descriptors && !fails(function() {
      return Object.defineProperty(documentCreateElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var f$3 = descriptors ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O, P) {
      O = toIndexedObject(O);
      P = toPrimitive(P, true);
      if (ie8DomDefine)
        try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
      if (has$12(O, P))
        return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
    };
    var objectGetOwnPropertyDescriptor = {
      f: f$3
    };
    var anObject = function(it) {
      if (!isObject2(it)) {
        throw TypeError(String(it) + " is not an object");
      }
      return it;
    };
    var $defineProperty = Object.defineProperty;
    var f$2 = descriptors ? $defineProperty : function defineProperty3(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (ie8DomDefine)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw TypeError("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
    var objectDefineProperty = {
      f: f$2
    };
    var createNonEnumerableProperty = descriptors ? function(object3, key, value2) {
      return objectDefineProperty.f(object3, key, createPropertyDescriptor(1, value2));
    } : function(object3, key, value2) {
      object3[key] = value2;
      return object3;
    };
    var setGlobal = function(key, value2) {
      try {
        createNonEnumerableProperty(global_1, key, value2);
      } catch (error) {
        global_1[key] = value2;
      }
      return value2;
    };
    var SHARED = "__core-js_shared__";
    var store$1 = global_1[SHARED] || setGlobal(SHARED, {});
    var sharedStore = store$1;
    var functionToString = Function.toString;
    if (typeof sharedStore.inspectSource != "function") {
      sharedStore.inspectSource = function(it) {
        return functionToString.call(it);
      };
    }
    var inspectSource = sharedStore.inspectSource;
    var WeakMap$12 = global_1.WeakMap;
    var nativeWeakMap = typeof WeakMap$12 === "function" && /native code/.test(inspectSource(WeakMap$12));
    var shared = createCommonjsModule(function(module2) {
      (module2.exports = function(key, value2) {
        return sharedStore[key] || (sharedStore[key] = value2 !== void 0 ? value2 : {});
      })("versions", []).push({
        version: "3.14.0",
        mode: "global",
        copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
      });
    });
    var id2 = 0;
    var postfix = Math.random();
    var uid2 = function(key) {
      return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id2 + postfix).toString(36);
    };
    var keys2 = shared("keys");
    var sharedKey = function(key) {
      return keys2[key] || (keys2[key] = uid2(key));
    };
    var hiddenKeys$1 = {};
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var WeakMap2 = global_1.WeakMap;
    var set2, get, has2;
    var enforce = function(it) {
      return has2(it) ? get(it) : set2(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject2(it) || (state = get(it)).type !== TYPE) {
          throw TypeError("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (nativeWeakMap || sharedStore.state) {
      var store = sharedStore.state || (sharedStore.state = new WeakMap2());
      var wmget = store.get;
      var wmhas = store.has;
      var wmset = store.set;
      set2 = function(it, metadata) {
        if (wmhas.call(store, it))
          throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        wmset.call(store, it, metadata);
        return metadata;
      };
      get = function(it) {
        return wmget.call(store, it) || {};
      };
      has2 = function(it) {
        return wmhas.call(store, it);
      };
    } else {
      var STATE = sharedKey("state");
      hiddenKeys$1[STATE] = true;
      set2 = function(it, metadata) {
        if (has$12(it, STATE))
          throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return has$12(it, STATE) ? it[STATE] : {};
      };
      has2 = function(it) {
        return has$12(it, STATE);
      };
    }
    var internalState = {
      set: set2,
      get,
      has: has2,
      enforce,
      getterFor
    };
    var redefine = createCommonjsModule(function(module2) {
      var getInternalState = internalState.get;
      var enforceInternalState = internalState.enforce;
      var TEMPLATE2 = String(String).split("String");
      (module2.exports = function(O, key, value2, options2) {
        var unsafe = options2 ? !!options2.unsafe : false;
        var simple = options2 ? !!options2.enumerable : false;
        var noTargetGet = options2 ? !!options2.noTargetGet : false;
        var state;
        if (typeof value2 == "function") {
          if (typeof key == "string" && !has$12(value2, "name")) {
            createNonEnumerableProperty(value2, "name", key);
          }
          state = enforceInternalState(value2);
          if (!state.source) {
            state.source = TEMPLATE2.join(typeof key == "string" ? key : "");
          }
        }
        if (O === global_1) {
          if (simple)
            O[key] = value2;
          else
            setGlobal(key, value2);
          return;
        } else if (!unsafe) {
          delete O[key];
        } else if (!noTargetGet && O[key]) {
          simple = true;
        }
        if (simple)
          O[key] = value2;
        else
          createNonEnumerableProperty(O, key, value2);
      })(Function.prototype, "toString", function toString4() {
        return typeof this == "function" && getInternalState(this).source || inspectSource(this);
      });
    });
    var path = global_1;
    var aFunction$1 = function(variable) {
      return typeof variable == "function" ? variable : void 0;
    };
    var getBuiltIn = function(namespace, method3) {
      return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace]) : path[namespace] && path[namespace][method3] || global_1[namespace] && global_1[namespace][method3];
    };
    var ceil = Math.ceil;
    var floor$2 = Math.floor;
    var toInteger = function(argument) {
      return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor$2 : ceil)(argument);
    };
    var min$4 = Math.min;
    var toLength = function(argument) {
      return argument > 0 ? min$4(toInteger(argument), 9007199254740991) : 0;
    };
    var max$3 = Math.max;
    var min$3 = Math.min;
    var toAbsoluteIndex = function(index2, length) {
      var integer3 = toInteger(index2);
      return integer3 < 0 ? max$3(integer3 + length, 0) : min$3(integer3, length);
    };
    var createMethod$2 = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = toLength(O.length);
        var index2 = toAbsoluteIndex(fromIndex, length);
        var value2;
        if (IS_INCLUDES && el != el)
          while (length > index2) {
            value2 = O[index2++];
            if (value2 != value2)
              return true;
          }
        else
          for (; length > index2; index2++) {
            if ((IS_INCLUDES || index2 in O) && O[index2] === el)
              return IS_INCLUDES || index2 || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    var arrayIncludes2 = {
      includes: createMethod$2(true),
      indexOf: createMethod$2(false)
    };
    var indexOf2 = arrayIncludes2.indexOf;
    var objectKeysInternal = function(object3, names) {
      var O = toIndexedObject(object3);
      var i2 = 0;
      var result = [];
      var key;
      for (key in O)
        !has$12(hiddenKeys$1, key) && has$12(O, key) && result.push(key);
      while (names.length > i2)
        if (has$12(O, key = names[i2++])) {
          ~indexOf2(result, key) || result.push(key);
        }
      return result;
    };
    var enumBugKeys = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    var f$1 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return objectKeysInternal(O, hiddenKeys);
    };
    var objectGetOwnPropertyNames = {
      f: f$1
    };
    var f = Object.getOwnPropertySymbols;
    var objectGetOwnPropertySymbols = {
      f
    };
    var ownKeys2 = getBuiltIn("Reflect", "ownKeys") || function ownKeys3(it) {
      var keys3 = objectGetOwnPropertyNames.f(anObject(it));
      var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
      return getOwnPropertySymbols ? keys3.concat(getOwnPropertySymbols(it)) : keys3;
    };
    var copyConstructorProperties = function(target, source2) {
      var keys3 = ownKeys2(source2);
      var defineProperty3 = objectDefineProperty.f;
      var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
      for (var i2 = 0; i2 < keys3.length; i2++) {
        var key = keys3[i2];
        if (!has$12(target, key))
          defineProperty3(target, key, getOwnPropertyDescriptor2(source2, key));
      }
    };
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value2 = data[normalize(feature)];
      return value2 == POLYFILL ? true : value2 == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string2) {
      return String(string2).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    var isForced_1 = isForced;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var _export = function(options2, source2) {
      var TARGET = options2.target;
      var GLOBAL = options2.global;
      var STATIC = options2.stat;
      var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global_1;
      } else if (STATIC) {
        target = global_1[TARGET] || setGlobal(TARGET, {});
      } else {
        target = (global_1[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source2) {
          sourceProperty = source2[key];
          if (options2.noTargetGet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED2 = isForced_1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options2.forced);
          if (!FORCED2 && targetProperty !== void 0) {
            if (typeof sourceProperty === typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options2.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          redefine(target, key, sourceProperty, options2);
        }
    };
    var regexpFlags = function() {
      var that = anObject(this);
      var result = "";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.sticky)
        result += "y";
      return result;
    };
    function RE(s, f2) {
      return RegExp(s, f2);
    }
    var UNSUPPORTED_Y$2 = fails(function() {
      var re = RE("a", "y");
      re.lastIndex = 2;
      return re.exec("abcd") != null;
    });
    var BROKEN_CARET = fails(function() {
      var re = RE("^r", "gy");
      re.lastIndex = 2;
      return re.exec("str") != null;
    });
    var regexpStickyHelpers = {
      UNSUPPORTED_Y: UNSUPPORTED_Y$2,
      BROKEN_CARET
    };
    var nativeExec = RegExp.prototype.exec;
    var nativeReplace = shared("native-string-replace", String.prototype.replace);
    var patchedExec = nativeExec;
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      nativeExec.call(re1, "a");
      nativeExec.call(re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;
    if (PATCH) {
      patchedExec = function exec(str) {
        var re = this;
        var lastIndex, reCopy, match2, i2;
        var sticky = UNSUPPORTED_Y$1 && re.sticky;
        var flags = regexpFlags.call(re);
        var source2 = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = flags.replace("y", "");
          if (flags.indexOf("g") === -1) {
            flags += "g";
          }
          strCopy = String(str).slice(re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== "\n")) {
            source2 = "(?: " + source2 + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source2 + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source2 + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG)
          lastIndex = re.lastIndex;
        match2 = nativeExec.call(sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match2) {
            match2.input = match2.input.slice(charsAdded);
            match2[0] = match2[0].slice(charsAdded);
            match2.index = re.lastIndex;
            re.lastIndex += match2[0].length;
          } else
            re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match2) {
          re.lastIndex = re.global ? match2.index + match2[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match2 && match2.length > 1) {
          nativeReplace.call(match2[0], reCopy, function() {
            for (i2 = 1; i2 < arguments.length - 2; i2++) {
              if (arguments[i2] === void 0)
                match2[i2] = void 0;
            }
          });
        }
        return match2;
      };
    }
    var regexpExec = patchedExec;
    _export({ target: "RegExp", proto: true, forced: /./.exec !== regexpExec }, {
      exec: regexpExec
    });
    var engineUserAgent = getBuiltIn("navigator", "userAgent") || "";
    var process2 = global_1.process;
    var versions = process2 && process2.versions;
    var v8 = versions && versions.v8;
    var match, version$12;
    if (v8) {
      match = v8.split(".");
      version$12 = match[0] < 4 ? 1 : match[0] + match[1];
    } else if (engineUserAgent) {
      match = engineUserAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = engineUserAgent.match(/Chrome\/(\d+)/);
        if (match)
          version$12 = match[1];
      }
    }
    var engineV8Version = version$12 && +version$12;
    var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol();
      return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && engineV8Version && engineV8Version < 41;
    });
    var useSymbolAsUid = nativeSymbol && !Symbol.sham && typeof Symbol.iterator == "symbol";
    var WellKnownSymbolsStore = shared("wks");
    var Symbol$12 = global_1.Symbol;
    var createWellKnownSymbol = useSymbolAsUid ? Symbol$12 : Symbol$12 && Symbol$12.withoutSetter || uid2;
    var wellKnownSymbol = function(name2) {
      if (!has$12(WellKnownSymbolsStore, name2) || !(nativeSymbol || typeof WellKnownSymbolsStore[name2] == "string")) {
        if (nativeSymbol && has$12(Symbol$12, name2)) {
          WellKnownSymbolsStore[name2] = Symbol$12[name2];
        } else {
          WellKnownSymbolsStore[name2] = createWellKnownSymbol("Symbol." + name2);
        }
      }
      return WellKnownSymbolsStore[name2];
    };
    var SPECIES$4 = wellKnownSymbol("species");
    var RegExpPrototype$1 = RegExp.prototype;
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    var REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    var REPLACE = wellKnownSymbol("replace");
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    var fixRegexpWellKnownSymbolLogic = function(KEY, length, exec, sham) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re = /a/;
        if (KEY === "split") {
          re = {};
          re.constructor = {};
          re.constructor[SPECIES$4] = function() {
            return re;
          };
          re.flags = "";
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
          execCalled = true;
          return null;
        };
        re[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp3, str, arg2, forceStringMethod) {
          var $exec = regexp3.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype$1.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: nativeRegExpMethod.call(regexp3, str, arg2) };
            }
            return { done: true, value: nativeMethod.call(str, regexp3, arg2) };
          }
          return { done: false };
        }, {
          REPLACE_KEEPS_$0,
          REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
        });
        var stringMethod = methods[0];
        var regexMethod = methods[1];
        redefine(String.prototype, KEY, stringMethod);
        redefine(RegExpPrototype$1, SYMBOL, length == 2 ? function(string2, arg) {
          return regexMethod.call(string2, this, arg);
        } : function(string2) {
          return regexMethod.call(string2, this);
        });
      }
      if (sham)
        createNonEnumerableProperty(RegExpPrototype$1[SYMBOL], "sham", true);
    };
    var createMethod$1 = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = String(requireObjectCoercible($this));
        var position = toInteger(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = S.charCodeAt(position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    var stringMultibyte = {
      codeAt: createMethod$1(false),
      charAt: createMethod$1(true)
    };
    var charAt = stringMultibyte.charAt;
    var advanceStringIndex = function(S, index2, unicode) {
      return index2 + (unicode ? charAt(S, index2).length : 1);
    };
    var regexpExecAbstract = function(R, S) {
      var exec = R.exec;
      if (typeof exec === "function") {
        var result = exec.call(R, S);
        if (typeof result !== "object") {
          throw TypeError("RegExp exec method returned something other than an Object or null");
        }
        return result;
      }
      if (classofRaw(R) !== "RegExp") {
        throw TypeError("RegExp#exec called on incompatible receiver");
      }
      return regexpExec.call(R, S);
    };
    fixRegexpWellKnownSymbolLogic("match", 1, function(MATCH2, nativeMatch, maybeCallNative) {
      return [
        function match2(regexp3) {
          var O = requireObjectCoercible(this);
          var matcher = regexp3 == void 0 ? void 0 : regexp3[MATCH2];
          return matcher !== void 0 ? matcher.call(regexp3, O) : new RegExp(regexp3)[MATCH2](String(O));
        },
        function(regexp3) {
          var res = maybeCallNative(nativeMatch, regexp3, this);
          if (res.done)
            return res.value;
          var rx = anObject(regexp3);
          var S = String(this);
          if (!rx.global)
            return regexpExecAbstract(rx, S);
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
          var A = [];
          var n = 0;
          var result;
          while ((result = regexpExecAbstract(rx, S)) !== null) {
            var matchStr = String(result[0]);
            A[n] = matchStr;
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            n++;
          }
          return n === 0 ? null : A;
        }
      ];
    });
    var isArray2 = Array.isArray || function isArray3(arg) {
      return classofRaw(arg) == "Array";
    };
    var createProperty = function(object3, key, value2) {
      var propertyKey = toPrimitive(key);
      if (propertyKey in object3)
        objectDefineProperty.f(object3, propertyKey, createPropertyDescriptor(0, value2));
      else
        object3[propertyKey] = value2;
    };
    var SPECIES$3 = wellKnownSymbol("species");
    var arraySpeciesCreate = function(originalArray, length) {
      var C;
      if (isArray2(originalArray)) {
        C = originalArray.constructor;
        if (typeof C == "function" && (C === Array || isArray2(C.prototype)))
          C = void 0;
        else if (isObject2(C)) {
          C = C[SPECIES$3];
          if (C === null)
            C = void 0;
        }
      }
      return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
    };
    var SPECIES$2 = wellKnownSymbol("species");
    var arrayMethodHasSpeciesSupport = function(METHOD_NAME) {
      return engineV8Version >= 51 || !fails(function() {
        var array3 = [];
        var constructor = array3.constructor = {};
        constructor[SPECIES$2] = function() {
          return { foo: 1 };
        };
        return array3[METHOD_NAME](Boolean).foo !== 1;
      });
    };
    var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
    var MAX_SAFE_INTEGER$12 = 9007199254740991;
    var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
    var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function() {
      var array3 = [];
      array3[IS_CONCAT_SPREADABLE] = false;
      return array3.concat()[0] !== array3;
    });
    var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
    var isConcatSpreadable = function(O) {
      if (!isObject2(O))
        return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== void 0 ? !!spreadable : isArray2(O);
    };
    var FORCED$1 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
    _export({ target: "Array", proto: true, forced: FORCED$1 }, {
      concat: function concat(arg) {
        var O = toObject2(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i2, k, length, len, E;
        for (i2 = -1, length = arguments.length; i2 < length; i2++) {
          E = i2 === -1 ? O : arguments[i2];
          if (isConcatSpreadable(E)) {
            len = toLength(E.length);
            if (n + len > MAX_SAFE_INTEGER$12)
              throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            for (k = 0; k < len; k++, n++)
              if (k in E)
                createProperty(A, n, E[k]);
          } else {
            if (n >= MAX_SAFE_INTEGER$12)
              throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            createProperty(A, n++, E);
          }
        }
        A.length = n;
        return A;
      }
    });
    var TO_STRING_TAG$1 = wellKnownSymbol("toStringTag");
    var test$1 = {};
    test$1[TO_STRING_TAG$1] = "z";
    var toStringTagSupport = String(test$1) === "[object z]";
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    var classof = toStringTagSupport ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
    };
    var objectToString2 = toStringTagSupport ? {}.toString : function toString4() {
      return "[object " + classof(this) + "]";
    };
    if (!toStringTagSupport) {
      redefine(Object.prototype, "toString", objectToString2, { unsafe: true });
    }
    var TO_STRING = "toString";
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function() {
      return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
    });
    var INCORRECT_NAME = nativeToString.name != TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      redefine(RegExp.prototype, TO_STRING, function toString4() {
        var R = anObject(this);
        var p = String(R.source);
        var rf = R.flags;
        var f2 = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype) ? regexpFlags.call(R) : rf);
        return "/" + p + "/" + f2;
      }, { unsafe: true });
    }
    var MATCH$1 = wellKnownSymbol("match");
    var isRegexp = function(it) {
      var isRegExp3;
      return isObject2(it) && ((isRegExp3 = it[MATCH$1]) !== void 0 ? !!isRegExp3 : classofRaw(it) == "RegExp");
    };
    var aFunction = function(it) {
      if (typeof it != "function") {
        throw TypeError(String(it) + " is not a function");
      }
      return it;
    };
    var SPECIES$1 = wellKnownSymbol("species");
    var speciesConstructor = function(O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === void 0 || (S = anObject(C)[SPECIES$1]) == void 0 ? defaultConstructor : aFunction(S);
    };
    var UNSUPPORTED_Y = regexpStickyHelpers.UNSUPPORTED_Y;
    var arrayPush2 = [].push;
    var min$2 = Math.min;
    var MAX_UINT32 = 4294967295;
    fixRegexpWellKnownSymbolLogic("split", 2, function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit;
      if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
        internalSplit = function(separator, limit) {
          var string2 = String(requireObjectCoercible(this));
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (separator === void 0)
            return [string2];
          if (!isRegexp(separator)) {
            return nativeSplit.call(string2, separator, lim);
          }
          var output = [];
          var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
          var lastLastIndex = 0;
          var separatorCopy = new RegExp(separator.source, flags + "g");
          var match2, lastIndex, lastLength;
          while (match2 = regexpExec.call(separatorCopy, string2)) {
            lastIndex = separatorCopy.lastIndex;
            if (lastIndex > lastLastIndex) {
              output.push(string2.slice(lastLastIndex, match2.index));
              if (match2.length > 1 && match2.index < string2.length)
                arrayPush2.apply(output, match2.slice(1));
              lastLength = match2[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= lim)
                break;
            }
            if (separatorCopy.lastIndex === match2.index)
              separatorCopy.lastIndex++;
          }
          if (lastLastIndex === string2.length) {
            if (lastLength || !separatorCopy.test(""))
              output.push("");
          } else
            output.push(string2.slice(lastLastIndex));
          return output.length > lim ? output.slice(0, lim) : output;
        };
      } else if ("0".split(void 0, 0).length) {
        internalSplit = function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
        };
      } else
        internalSplit = nativeSplit;
      return [
        function split2(separator, limit) {
          var O = requireObjectCoercible(this);
          var splitter = separator == void 0 ? void 0 : separator[SPLIT];
          return splitter !== void 0 ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
        },
        function(regexp3, limit) {
          var res = maybeCallNative(internalSplit, regexp3, this, limit, internalSplit !== nativeSplit);
          if (res.done)
            return res.value;
          var rx = anObject(regexp3);
          var S = String(this);
          var C = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (S.length === 0)
            return regexpExecAbstract(splitter, S) === null ? [S] : [];
          var p = 0;
          var q = 0;
          var A = [];
          while (q < S.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
            var z = regexpExecAbstract(splitter, UNSUPPORTED_Y ? S.slice(q) : S);
            var e;
            if (z === null || (e = min$2(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
              q = advanceStringIndex(S, q, unicodeMatching);
            } else {
              A.push(S.slice(p, q));
              if (A.length === lim)
                return A;
              for (var i2 = 1; i2 <= z.length - 1; i2++) {
                A.push(z[i2]);
                if (A.length === lim)
                  return A;
              }
              q = p = e;
            }
          }
          A.push(S.slice(p));
          return A;
        }
      ];
    }, UNSUPPORTED_Y);
    function addClass2(element, className) {
      if (element instanceof SVGElement) {
        var pre = element.getAttribute("class") || "";
        if (!pre.match(className)) {
          element.setAttribute("class", "".concat(pre, " ").concat(className));
        }
      } else {
        if (element.classList !== void 0) {
          var classes = className.split(" ");
          forEach3(classes, function(cls) {
            element.classList.add(cls);
          });
        } else if (!element.className.match(className)) {
          element.className += " ".concat(className);
        }
      }
    }
    function getPropValue(element, propName) {
      var propValue = "";
      if (element.currentStyle) {
        propValue = element.currentStyle[propName];
      } else if (document.defaultView && document.defaultView.getComputedStyle) {
        propValue = document.defaultView.getComputedStyle(element, null).getPropertyValue(propName);
      }
      if (propValue && propValue.toLowerCase) {
        return propValue.toLowerCase();
      } else {
        return propValue;
      }
    }
    function setShowElement(_ref) {
      var element = _ref.element;
      addClass2(element, "introjs-showElement");
      var currentElementPosition = getPropValue(element, "position");
      if (currentElementPosition !== "absolute" && currentElementPosition !== "relative" && currentElementPosition !== "sticky" && currentElementPosition !== "fixed") {
        addClass2(element, "introjs-relativePosition");
      }
    }
    function getScrollParent2(element) {
      var style = window.getComputedStyle(element);
      var excludeStaticParent = style.position === "absolute";
      var overflowRegex = /(auto|scroll)/;
      if (style.position === "fixed")
        return document.body;
      for (var parent2 = element; parent2 = parent2.parentElement; ) {
        style = window.getComputedStyle(parent2);
        if (excludeStaticParent && style.position === "static") {
          continue;
        }
        if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX))
          return parent2;
      }
      return document.body;
    }
    function scrollParentToElement(targetElement) {
      var element = targetElement.element;
      if (!this._options.scrollToElement)
        return;
      var parent2 = getScrollParent2(element);
      if (parent2 === document.body)
        return;
      parent2.scrollTop = element.offsetTop - parent2.offsetTop;
    }
    function getWinSize() {
      if (window.innerWidth !== void 0) {
        return {
          width: window.innerWidth,
          height: window.innerHeight
        };
      } else {
        var D = document.documentElement;
        return {
          width: D.clientWidth,
          height: D.clientHeight
        };
      }
    }
    function elementInViewport(el) {
      var rect = el.getBoundingClientRect();
      return rect.top >= 0 && rect.left >= 0 && rect.bottom + 80 <= window.innerHeight && rect.right <= window.innerWidth;
    }
    function scrollTo(scrollTo2, _ref, tooltipLayer) {
      var element = _ref.element;
      if (scrollTo2 === "off")
        return;
      var rect;
      if (!this._options.scrollToElement)
        return;
      if (scrollTo2 === "tooltip") {
        rect = tooltipLayer.getBoundingClientRect();
      } else {
        rect = element.getBoundingClientRect();
      }
      if (!elementInViewport(element)) {
        var winHeight = getWinSize().height;
        var top2 = rect.bottom - (rect.bottom - rect.top);
        if (top2 < 0 || element.clientHeight > winHeight) {
          window.scrollBy(0, rect.top - (winHeight / 2 - rect.height / 2) - this._options.scrollPadding);
        } else {
          window.scrollBy(0, rect.top - (winHeight / 2 - rect.height / 2) + this._options.scrollPadding);
        }
      }
    }
    function setAnchorAsButton(anchor) {
      anchor.setAttribute("role", "button");
      anchor.tabIndex = 0;
    }
    var objectKeys = Object.keys || function keys3(O) {
      return objectKeysInternal(O, enumBugKeys);
    };
    var $assign = Object.assign;
    var defineProperty2 = Object.defineProperty;
    var objectAssign = !$assign || fails(function() {
      if (descriptors && $assign({ b: 1 }, $assign(defineProperty2({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty2(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), { b: 2 })).b !== 1)
        return true;
      var A = {};
      var B = {};
      var symbol = Symbol();
      var alphabet = "abcdefghijklmnopqrst";
      A[symbol] = 7;
      alphabet.split("").forEach(function(chr) {
        B[chr] = chr;
      });
      return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join("") != alphabet;
    }) ? function assign2(target, source2) {
      var T = toObject2(target);
      var argumentsLength = arguments.length;
      var index2 = 1;
      var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
      var propertyIsEnumerable2 = objectPropertyIsEnumerable.f;
      while (argumentsLength > index2) {
        var S = indexedObject(arguments[index2++]);
        var keys3 = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
        var length = keys3.length;
        var j = 0;
        var key;
        while (length > j) {
          key = keys3[j++];
          if (!descriptors || propertyIsEnumerable2.call(S, key))
            T[key] = S[key];
        }
      }
      return T;
    } : $assign;
    _export({ target: "Object", stat: true, forced: Object.assign !== objectAssign }, {
      assign: objectAssign
    });
    function getOffset2(element, relativeEl) {
      var body = document.body;
      var docEl = document.documentElement;
      var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
      var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
      relativeEl = relativeEl || body;
      var x = element.getBoundingClientRect();
      var xr = relativeEl.getBoundingClientRect();
      var relativeElPosition = getPropValue(relativeEl, "position");
      var obj = {
        width: x.width,
        height: x.height
      };
      if (relativeEl.tagName.toLowerCase() !== "body" && relativeElPosition === "relative" || relativeElPosition === "sticky") {
        return Object.assign(obj, {
          top: x.top - xr.top,
          left: x.left - xr.left
        });
      } else {
        return Object.assign(obj, {
          top: x.top + scrollTop,
          left: x.left + scrollLeft
        });
      }
    }
    function isFixed(element) {
      var p = element.parentNode;
      if (!p || p.nodeName === "HTML") {
        return false;
      }
      if (getPropValue(element, "position") === "fixed") {
        return true;
      }
      return isFixed(p);
    }
    var floor$1 = Math.floor;
    var replace2 = "".replace;
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    var getSubstitution = function(matched, str, position, captures, namedCaptures, replacement2) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject2(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace2.call(replacement2, symbols, function(match2, ch) {
        var capture;
        switch (ch.charAt(0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return str.slice(0, position);
          case "'":
            return str.slice(tailPos);
          case "<":
            capture = namedCaptures[ch.slice(1, -1)];
            break;
          default:
            var n = +ch;
            if (n === 0)
              return match2;
            if (n > m) {
              var f2 = floor$1(n / 10);
              if (f2 === 0)
                return match2;
              if (f2 <= m)
                return captures[f2 - 1] === void 0 ? ch.charAt(1) : captures[f2 - 1] + ch.charAt(1);
              return match2;
            }
            capture = captures[n - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
    var max$2 = Math.max;
    var min$12 = Math.min;
    var maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    fixRegexpWellKnownSymbolLogic("replace", 2, function(REPLACE2, nativeReplace2, maybeCallNative, reason) {
      var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE2 = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
      var REPLACE_KEEPS_$02 = reason.REPLACE_KEEPS_$0;
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE2 ? "$" : "$0";
      return [
        function replace3(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var replacer = searchValue == void 0 ? void 0 : searchValue[REPLACE2];
          return replacer !== void 0 ? replacer.call(searchValue, O, replaceValue) : nativeReplace2.call(String(O), searchValue, replaceValue);
        },
        function(regexp3, replaceValue) {
          if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE2 && REPLACE_KEEPS_$02 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
            var res = maybeCallNative(nativeReplace2, regexp3, this, replaceValue);
            if (res.done)
              return res.value;
          }
          var rx = anObject(regexp3);
          var S = String(this);
          var functionalReplace = typeof replaceValue === "function";
          if (!functionalReplace)
            replaceValue = String(replaceValue);
          var global2 = rx.global;
          if (global2) {
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
          }
          var results = [];
          while (true) {
            var result = regexpExecAbstract(rx, S);
            if (result === null)
              break;
            results.push(result);
            if (!global2)
              break;
            var matchStr = String(result[0]);
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i2 = 0; i2 < results.length; i2++) {
            result = results[i2];
            var matched = String(result[0]);
            var position = max$2(min$12(toInteger(result.index), S.length), 0);
            var captures = [];
            for (var j = 1; j < result.length; j++)
              captures.push(maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = [matched].concat(captures, position, S);
              if (namedCaptures !== void 0)
                replacerArgs.push(namedCaptures);
              var replacement2 = String(replaceValue.apply(void 0, replacerArgs));
            } else {
              replacement2 = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += S.slice(nextSourcePosition, position) + replacement2;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + S.slice(nextSourcePosition);
        }
      ];
    });
    function removeClass2(element, classNameRegex) {
      if (element instanceof SVGElement) {
        var pre = element.getAttribute("class") || "";
        element.setAttribute("class", pre.replace(classNameRegex, "").replace(/^\s+|\s+$/g, ""));
      } else {
        element.className = element.className.replace(classNameRegex, "").replace(/^\s+|\s+$/g, "");
      }
    }
    function setStyle(element, style) {
      var cssText = "";
      if (element.style.cssText) {
        cssText += element.style.cssText;
      }
      if (typeof style === "string") {
        cssText += style;
      } else {
        for (var rule in style) {
          cssText += "".concat(rule, ":").concat(style[rule], ";");
        }
      }
      element.style.cssText = cssText;
    }
    function setHelperLayerPosition(helperLayer) {
      if (helperLayer) {
        if (!this._introItems[this._currentStep])
          return;
        var currentElement = this._introItems[this._currentStep];
        var elementPosition = getOffset2(currentElement.element, this._targetElement);
        var widthHeightPadding = this._options.helperElementPadding;
        if (isFixed(currentElement.element)) {
          addClass2(helperLayer, "introjs-fixedTooltip");
        } else {
          removeClass2(helperLayer, "introjs-fixedTooltip");
        }
        if (currentElement.position === "floating") {
          widthHeightPadding = 0;
        }
        setStyle(helperLayer, {
          width: "".concat(elementPosition.width + widthHeightPadding, "px"),
          height: "".concat(elementPosition.height + widthHeightPadding, "px"),
          top: "".concat(elementPosition.top - widthHeightPadding / 2, "px"),
          left: "".concat(elementPosition.left - widthHeightPadding / 2, "px")
        });
      }
    }
    var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var keys3 = objectKeys(Properties);
      var length = keys3.length;
      var index2 = 0;
      var key;
      while (length > index2)
        objectDefineProperty.f(O, key = keys3[index2++], Properties[key]);
      return O;
    };
    var html = getBuiltIn("document", "documentElement");
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe2 = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe2.style.display = "none";
      html.appendChild(iframe2);
      iframe2.src = String(JS);
      iframeDocument = iframe2.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = document.domain && new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
      var length = enumBugKeys.length;
      while (length--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys$1[IE_PROTO] = true;
    var objectCreate2 = Object.create || function create2(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : objectDefineProperties(result, Properties);
    };
    var UNSCOPABLES = wellKnownSymbol("unscopables");
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] == void 0) {
      objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: objectCreate2(null)
      });
    }
    var addToUnscopables = function(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
    var $includes = arrayIncludes2.includes;
    _export({ target: "Array", proto: true }, {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables("includes");
    var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport("slice");
    var SPECIES = wellKnownSymbol("species");
    var nativeSlice = [].slice;
    var max$12 = Math.max;
    _export({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
      slice: function slice(start2, end2) {
        var O = toIndexedObject(this);
        var length = toLength(O.length);
        var k = toAbsoluteIndex(start2, length);
        var fin = toAbsoluteIndex(end2 === void 0 ? length : end2, length);
        var Constructor, result, n;
        if (isArray2(O)) {
          Constructor = O.constructor;
          if (typeof Constructor == "function" && (Constructor === Array || isArray2(Constructor.prototype))) {
            Constructor = void 0;
          } else if (isObject2(Constructor)) {
            Constructor = Constructor[SPECIES];
            if (Constructor === null)
              Constructor = void 0;
          }
          if (Constructor === Array || Constructor === void 0) {
            return nativeSlice.call(O, k, fin);
          }
        }
        result = new (Constructor === void 0 ? Array : Constructor)(max$12(fin - k, 0));
        for (n = 0; k < fin; k++, n++)
          if (k in O)
            createProperty(result, n, O[k]);
        result.length = n;
        return result;
      }
    });
    var notARegexp = function(it) {
      if (isRegexp(it)) {
        throw TypeError("The method doesn't accept regular expressions");
      }
      return it;
    };
    var MATCH = wellKnownSymbol("match");
    var correctIsRegexpLogic = function(METHOD_NAME) {
      var regexp3 = /./;
      try {
        "/./"[METHOD_NAME](regexp3);
      } catch (error1) {
        try {
          regexp3[MATCH] = false;
          return "/./"[METHOD_NAME](regexp3);
        } catch (error2) {
        }
      }
      return false;
    };
    _export({ target: "String", proto: true, forced: !correctIsRegexpLogic("includes") }, {
      includes: function includes(searchString) {
        return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    var arrayMethodIsStrict = function(METHOD_NAME, argument) {
      var method3 = [][METHOD_NAME];
      return !!method3 && fails(function() {
        method3.call(null, argument || function() {
          throw 1;
        }, 1);
      });
    };
    var nativeJoin = [].join;
    var ES3_STRINGS = indexedObject != Object;
    var STRICT_METHOD$1 = arrayMethodIsStrict("join", ",");
    _export({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD$1 }, {
      join: function join(separator) {
        return nativeJoin.call(toIndexedObject(this), separator === void 0 ? "," : separator);
      }
    });
    var functionBindContext = function(fn2, that, length) {
      aFunction(fn2);
      if (that === void 0)
        return fn2;
      switch (length) {
        case 0:
          return function() {
            return fn2.call(that);
          };
        case 1:
          return function(a) {
            return fn2.call(that, a);
          };
        case 2:
          return function(a, b) {
            return fn2.call(that, a, b);
          };
        case 3:
          return function(a, b, c) {
            return fn2.call(that, a, b, c);
          };
      }
      return function() {
        return fn2.apply(that, arguments);
      };
    };
    var push2 = [].push;
    var createMethod = function(TYPE) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var IS_FILTER_OUT = TYPE == 7;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that, specificCreate) {
        var O = toObject2($this);
        var self2 = indexedObject(O);
        var boundFunction = functionBindContext(callbackfn, that, 3);
        var length = toLength(self2.length);
        var index2 = 0;
        var create2 = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create2($this, length) : IS_FILTER || IS_FILTER_OUT ? create2($this, 0) : void 0;
        var value2, result;
        for (; length > index2; index2++)
          if (NO_HOLES || index2 in self2) {
            value2 = self2[index2];
            result = boundFunction(value2, index2, O);
            if (TYPE) {
              if (IS_MAP)
                target[index2] = result;
              else if (result)
                switch (TYPE) {
                  case 3:
                    return true;
                  case 5:
                    return value2;
                  case 6:
                    return index2;
                  case 2:
                    push2.call(target, value2);
                }
              else
                switch (TYPE) {
                  case 4:
                    return false;
                  case 7:
                    push2.call(target, value2);
                }
            }
          }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    var arrayIteration = {
      forEach: createMethod(0),
      map: createMethod(1),
      filter: createMethod(2),
      some: createMethod(3),
      every: createMethod(4),
      find: createMethod(5),
      findIndex: createMethod(6),
      filterOut: createMethod(7)
    };
    var $filter = arrayIteration.filter;
    var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport("filter");
    _export({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
      filter: function filter(callbackfn) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    function checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer) {
      if (targetOffset.left + tooltipLayerStyleLeft + tooltipOffset.width > windowSize.width) {
        tooltipLayer.style.left = "".concat(windowSize.width - tooltipOffset.width - targetOffset.left, "px");
        return false;
      }
      tooltipLayer.style.left = "".concat(tooltipLayerStyleLeft, "px");
      return true;
    }
    function checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer) {
      if (targetOffset.left + targetOffset.width - tooltipLayerStyleRight - tooltipOffset.width < 0) {
        tooltipLayer.style.left = "".concat(-targetOffset.left, "px");
        return false;
      }
      tooltipLayer.style.right = "".concat(tooltipLayerStyleRight, "px");
      return true;
    }
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
    var max2 = Math.max;
    var min2 = Math.min;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
    _export({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      splice: function splice2(start2, deleteCount) {
        var O = toObject2(this);
        var len = toLength(O.length);
        var actualStart = toAbsoluteIndex(start2, len);
        var argumentsLength = arguments.length;
        var insertCount, actualDeleteCount, A, k, from, to;
        if (argumentsLength === 0) {
          insertCount = actualDeleteCount = 0;
        } else if (argumentsLength === 1) {
          insertCount = 0;
          actualDeleteCount = len - actualStart;
        } else {
          insertCount = argumentsLength - 2;
          actualDeleteCount = min2(max2(toInteger(deleteCount), 0), len - actualStart);
        }
        if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER2) {
          throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
        }
        A = arraySpeciesCreate(O, actualDeleteCount);
        for (k = 0; k < actualDeleteCount; k++) {
          from = actualStart + k;
          if (from in O)
            createProperty(A, k, O[from]);
        }
        A.length = actualDeleteCount;
        if (insertCount < actualDeleteCount) {
          for (k = actualStart; k < len - actualDeleteCount; k++) {
            from = k + actualDeleteCount;
            to = k + insertCount;
            if (from in O)
              O[to] = O[from];
            else
              delete O[to];
          }
          for (k = len; k > len - actualDeleteCount + insertCount; k--)
            delete O[k - 1];
        } else if (insertCount > actualDeleteCount) {
          for (k = len - actualDeleteCount; k > actualStart; k--) {
            from = k + actualDeleteCount - 1;
            to = k + insertCount - 1;
            if (from in O)
              O[to] = O[from];
            else
              delete O[to];
          }
        }
        for (k = 0; k < insertCount; k++) {
          O[k + actualStart] = arguments[k + 2];
        }
        O.length = len - actualDeleteCount + insertCount;
        return A;
      }
    });
    function removeEntry(stringArray, stringToRemove) {
      if (stringArray.includes(stringToRemove)) {
        stringArray.splice(stringArray.indexOf(stringToRemove), 1);
      }
    }
    function _determineAutoAlignment(offsetLeft, tooltipWidth, _ref, desiredAlignment) {
      var width2 = _ref.width;
      var halfTooltipWidth = tooltipWidth / 2;
      var winWidth = Math.min(width2, window.screen.width);
      var possibleAlignments = ["-left-aligned", "-middle-aligned", "-right-aligned"];
      var calculatedAlignment = "";
      if (winWidth - offsetLeft < tooltipWidth) {
        removeEntry(possibleAlignments, "-left-aligned");
      }
      if (offsetLeft < halfTooltipWidth || winWidth - offsetLeft < halfTooltipWidth) {
        removeEntry(possibleAlignments, "-middle-aligned");
      }
      if (offsetLeft < tooltipWidth) {
        removeEntry(possibleAlignments, "-right-aligned");
      }
      if (possibleAlignments.length) {
        if (possibleAlignments.includes(desiredAlignment)) {
          calculatedAlignment = desiredAlignment;
        } else {
          calculatedAlignment = possibleAlignments[0];
        }
      } else {
        calculatedAlignment = "-middle-aligned";
      }
      return calculatedAlignment;
    }
    function _determineAutoPosition(targetElement, tooltipLayer, desiredTooltipPosition) {
      var possiblePositions = this._options.positionPrecedence.slice();
      var windowSize = getWinSize();
      var tooltipHeight = getOffset2(tooltipLayer).height + 10;
      var tooltipWidth = getOffset2(tooltipLayer).width + 20;
      var targetElementRect = targetElement.getBoundingClientRect();
      var calculatedPosition = "floating";
      if (targetElementRect.bottom + tooltipHeight > windowSize.height) {
        removeEntry(possiblePositions, "bottom");
      }
      if (targetElementRect.top - tooltipHeight < 0) {
        removeEntry(possiblePositions, "top");
      }
      if (targetElementRect.right + tooltipWidth > windowSize.width) {
        removeEntry(possiblePositions, "right");
      }
      if (targetElementRect.left - tooltipWidth < 0) {
        removeEntry(possiblePositions, "left");
      }
      var desiredAlignment = function(pos) {
        var hyphenIndex = pos.indexOf("-");
        if (hyphenIndex !== -1) {
          return pos.substr(hyphenIndex);
        }
        return "";
      }(desiredTooltipPosition || "");
      if (desiredTooltipPosition) {
        desiredTooltipPosition = desiredTooltipPosition.split("-")[0];
      }
      if (possiblePositions.length) {
        if (possiblePositions.includes(desiredTooltipPosition)) {
          calculatedPosition = desiredTooltipPosition;
        } else {
          calculatedPosition = possiblePositions[0];
        }
      }
      if (["top", "bottom"].includes(calculatedPosition)) {
        calculatedPosition += _determineAutoAlignment(targetElementRect.left, tooltipWidth, windowSize, desiredAlignment);
      }
      return calculatedPosition;
    }
    function placeTooltip(targetElement, tooltipLayer, arrowLayer, hintMode) {
      var tooltipCssClass = "";
      var currentStepObj;
      var tooltipOffset;
      var targetOffset;
      var windowSize;
      var currentTooltipPosition;
      hintMode = hintMode || false;
      tooltipLayer.style.top = null;
      tooltipLayer.style.right = null;
      tooltipLayer.style.bottom = null;
      tooltipLayer.style.left = null;
      tooltipLayer.style.marginLeft = null;
      tooltipLayer.style.marginTop = null;
      arrowLayer.style.display = "inherit";
      if (!this._introItems[this._currentStep])
        return;
      currentStepObj = this._introItems[this._currentStep];
      if (typeof currentStepObj.tooltipClass === "string") {
        tooltipCssClass = currentStepObj.tooltipClass;
      } else {
        tooltipCssClass = this._options.tooltipClass;
      }
      tooltipLayer.className = ["introjs-tooltip", tooltipCssClass].filter(Boolean).join(" ");
      tooltipLayer.setAttribute("role", "dialog");
      currentTooltipPosition = this._introItems[this._currentStep].position;
      if (currentTooltipPosition !== "floating" && this._options.autoPosition) {
        currentTooltipPosition = _determineAutoPosition.call(this, targetElement, tooltipLayer, currentTooltipPosition);
      }
      var tooltipLayerStyleLeft;
      targetOffset = getOffset2(targetElement);
      tooltipOffset = getOffset2(tooltipLayer);
      windowSize = getWinSize();
      addClass2(tooltipLayer, "introjs-".concat(currentTooltipPosition));
      switch (currentTooltipPosition) {
        case "top-right-aligned":
          arrowLayer.className = "introjs-arrow bottom-right";
          var tooltipLayerStyleRight = 0;
          checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer);
          tooltipLayer.style.bottom = "".concat(targetOffset.height + 20, "px");
          break;
        case "top-middle-aligned":
          arrowLayer.className = "introjs-arrow bottom-middle";
          var tooltipLayerStyleLeftRight = targetOffset.width / 2 - tooltipOffset.width / 2;
          if (hintMode) {
            tooltipLayerStyleLeftRight += 5;
          }
          if (checkLeft(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, tooltipLayer)) {
            tooltipLayer.style.right = null;
            checkRight(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, windowSize, tooltipLayer);
          }
          tooltipLayer.style.bottom = "".concat(targetOffset.height + 20, "px");
          break;
        case "top-left-aligned":
        case "top":
          arrowLayer.className = "introjs-arrow bottom";
          tooltipLayerStyleLeft = hintMode ? 0 : 15;
          checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
          tooltipLayer.style.bottom = "".concat(targetOffset.height + 20, "px");
          break;
        case "right":
          tooltipLayer.style.left = "".concat(targetOffset.width + 20, "px");
          if (targetOffset.top + tooltipOffset.height > windowSize.height) {
            arrowLayer.className = "introjs-arrow left-bottom";
            tooltipLayer.style.top = "-".concat(tooltipOffset.height - targetOffset.height - 20, "px");
          } else {
            arrowLayer.className = "introjs-arrow left";
          }
          break;
        case "left":
          if (!hintMode && this._options.showStepNumbers === true) {
            tooltipLayer.style.top = "15px";
          }
          if (targetOffset.top + tooltipOffset.height > windowSize.height) {
            tooltipLayer.style.top = "-".concat(tooltipOffset.height - targetOffset.height - 20, "px");
            arrowLayer.className = "introjs-arrow right-bottom";
          } else {
            arrowLayer.className = "introjs-arrow right";
          }
          tooltipLayer.style.right = "".concat(targetOffset.width + 20, "px");
          break;
        case "floating":
          arrowLayer.style.display = "none";
          tooltipLayer.style.left = "50%";
          tooltipLayer.style.top = "50%";
          tooltipLayer.style.marginLeft = "-".concat(tooltipOffset.width / 2, "px");
          tooltipLayer.style.marginTop = "-".concat(tooltipOffset.height / 2, "px");
          break;
        case "bottom-right-aligned":
          arrowLayer.className = "introjs-arrow top-right";
          tooltipLayerStyleRight = 0;
          checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer);
          tooltipLayer.style.top = "".concat(targetOffset.height + 20, "px");
          break;
        case "bottom-middle-aligned":
          arrowLayer.className = "introjs-arrow top-middle";
          tooltipLayerStyleLeftRight = targetOffset.width / 2 - tooltipOffset.width / 2;
          if (hintMode) {
            tooltipLayerStyleLeftRight += 5;
          }
          if (checkLeft(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, tooltipLayer)) {
            tooltipLayer.style.right = null;
            checkRight(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, windowSize, tooltipLayer);
          }
          tooltipLayer.style.top = "".concat(targetOffset.height + 20, "px");
          break;
        default:
          arrowLayer.className = "introjs-arrow top";
          tooltipLayerStyleLeft = 0;
          checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
          tooltipLayer.style.top = "".concat(targetOffset.height + 20, "px");
      }
    }
    function removeShowElement() {
      var elms = document.querySelectorAll(".introjs-showElement");
      forEach3(elms, function(elm) {
        removeClass2(elm, /introjs-[a-zA-Z]+/g);
      });
    }
    function _createElement(tagname, attrs) {
      var element = document.createElement(tagname);
      attrs = attrs || {};
      var setAttRegex = /^(?:role|data-|aria-)/;
      for (var k in attrs) {
        var v = attrs[k];
        if (k === "style") {
          setStyle(element, v);
        } else if (k.match(setAttRegex)) {
          element.setAttribute(k, v);
        } else {
          element[k] = v;
        }
      }
      return element;
    }
    function appendChild(parentElement, element, animate) {
      if (animate) {
        var existingOpacity = element.style.opacity || "1";
        setStyle(element, {
          opacity: "0"
        });
        window.setTimeout(function() {
          setStyle(element, {
            opacity: existingOpacity
          });
        }, 10);
      }
      parentElement.appendChild(element);
    }
    function _getProgress() {
      var currentStep2 = parseInt(this._currentStep + 1, 10);
      return currentStep2 / this._introItems.length * 100;
    }
    function _disableInteraction() {
      var disableInteractionLayer = document.querySelector(".introjs-disableInteraction");
      if (disableInteractionLayer === null) {
        disableInteractionLayer = _createElement("div", {
          className: "introjs-disableInteraction"
        });
        this._targetElement.appendChild(disableInteractionLayer);
      }
      setHelperLayerPosition.call(this, disableInteractionLayer);
    }
    function _createBullets(targetElement) {
      var self2 = this;
      var bulletsLayer = _createElement("div", {
        className: "introjs-bullets"
      });
      if (this._options.showBullets === false) {
        bulletsLayer.style.display = "none";
      }
      var ulContainer = _createElement("ul");
      ulContainer.setAttribute("role", "tablist");
      var anchorClick = function anchorClick2() {
        self2.goToStep(this.getAttribute("data-stepnumber"));
      };
      forEach3(this._introItems, function(_ref, i2) {
        var step = _ref.step;
        var innerLi = _createElement("li");
        var anchorLink = _createElement("a");
        innerLi.setAttribute("role", "presentation");
        anchorLink.setAttribute("role", "tab");
        anchorLink.onclick = anchorClick;
        if (i2 === targetElement.step - 1) {
          anchorLink.className = "active";
        }
        setAnchorAsButton(anchorLink);
        anchorLink.innerHTML = "&nbsp;";
        anchorLink.setAttribute("data-stepnumber", step);
        innerLi.appendChild(anchorLink);
        ulContainer.appendChild(innerLi);
      });
      bulletsLayer.appendChild(ulContainer);
      return bulletsLayer;
    }
    function _recreateBullets(oldReferenceLayer, targetElement) {
      if (this._options.showBullets) {
        var existing = document.querySelector(".introjs-bullets");
        existing.parentNode.replaceChild(_createBullets.call(this, targetElement), existing);
      }
    }
    function _updateBullets(oldReferenceLayer, targetElement) {
      if (this._options.showBullets) {
        oldReferenceLayer.querySelector(".introjs-bullets li > a.active").className = "";
        oldReferenceLayer.querySelector('.introjs-bullets li > a[data-stepnumber="'.concat(targetElement.step, '"]')).className = "active";
      }
    }
    function _createProgressBar() {
      var progressLayer = _createElement("div");
      progressLayer.className = "introjs-progress";
      if (this._options.showProgress === false) {
        progressLayer.style.display = "none";
      }
      var progressBar = _createElement("div", {
        className: "introjs-progressbar"
      });
      if (this._options.progressBarAdditionalClass) {
        progressBar.className += " " + this._options.progressBarAdditionalClass;
      }
      progressBar.setAttribute("role", "progress");
      progressBar.setAttribute("aria-valuemin", 0);
      progressBar.setAttribute("aria-valuemax", 100);
      progressBar.setAttribute("aria-valuenow", _getProgress.call(this));
      progressBar.style.cssText = "width:".concat(_getProgress.call(this), "%;");
      progressLayer.appendChild(progressBar);
      return progressLayer;
    }
    function _updateProgressBar(oldReferenceLayer) {
      oldReferenceLayer.querySelector(".introjs-progress .introjs-progressbar").style.cssText = "width:".concat(_getProgress.call(this), "%;");
      oldReferenceLayer.querySelector(".introjs-progress .introjs-progressbar").setAttribute("aria-valuenow", _getProgress.call(this));
    }
    function _showElement(targetElement) {
      var _this = this;
      if (typeof this._introChangeCallback !== "undefined") {
        this._introChangeCallback.call(this, targetElement.element);
      }
      var self2 = this;
      var oldHelperLayer = document.querySelector(".introjs-helperLayer");
      var oldReferenceLayer = document.querySelector(".introjs-tooltipReferenceLayer");
      var highlightClass = "introjs-helperLayer";
      var nextTooltipButton;
      var prevTooltipButton;
      var skipTooltipButton;
      if (typeof targetElement.highlightClass === "string") {
        highlightClass += " ".concat(targetElement.highlightClass);
      }
      if (typeof this._options.highlightClass === "string") {
        highlightClass += " ".concat(this._options.highlightClass);
      }
      if (oldHelperLayer !== null && oldReferenceLayer !== null) {
        var oldHelperNumberLayer = oldReferenceLayer.querySelector(".introjs-helperNumberLayer");
        var oldtooltipLayer = oldReferenceLayer.querySelector(".introjs-tooltiptext");
        var oldTooltipTitleLayer = oldReferenceLayer.querySelector(".introjs-tooltip-title");
        var oldArrowLayer = oldReferenceLayer.querySelector(".introjs-arrow");
        var oldtooltipContainer = oldReferenceLayer.querySelector(".introjs-tooltip");
        skipTooltipButton = oldReferenceLayer.querySelector(".introjs-skipbutton");
        prevTooltipButton = oldReferenceLayer.querySelector(".introjs-prevbutton");
        nextTooltipButton = oldReferenceLayer.querySelector(".introjs-nextbutton");
        oldHelperLayer.className = highlightClass;
        oldtooltipContainer.style.opacity = 0;
        oldtooltipContainer.style.display = "none";
        scrollParentToElement.call(self2, targetElement);
        setHelperLayerPosition.call(self2, oldHelperLayer);
        setHelperLayerPosition.call(self2, oldReferenceLayer);
        removeShowElement();
        if (self2._lastShowElementTimer) {
          window.clearTimeout(self2._lastShowElementTimer);
        }
        self2._lastShowElementTimer = window.setTimeout(function() {
          if (oldHelperNumberLayer !== null) {
            oldHelperNumberLayer.innerHTML = "".concat(targetElement.step, " of ").concat(_this._introItems.length);
          }
          oldtooltipLayer.innerHTML = targetElement.intro;
          oldTooltipTitleLayer.innerHTML = targetElement.title;
          oldtooltipContainer.style.display = "block";
          placeTooltip.call(self2, targetElement.element, oldtooltipContainer, oldArrowLayer);
          _updateBullets.call(self2, oldReferenceLayer, targetElement);
          _updateProgressBar.call(self2, oldReferenceLayer);
          oldtooltipContainer.style.opacity = 1;
          if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null && /introjs-donebutton/gi.test(nextTooltipButton.className)) {
            nextTooltipButton.focus();
          } else if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
            nextTooltipButton.focus();
          }
          scrollTo.call(self2, targetElement.scrollTo, targetElement, oldtooltipLayer);
        }, 350);
      } else {
        var helperLayer = _createElement("div", {
          className: highlightClass
        });
        var referenceLayer = _createElement("div", {
          className: "introjs-tooltipReferenceLayer"
        });
        var arrowLayer = _createElement("div", {
          className: "introjs-arrow"
        });
        var tooltipLayer = _createElement("div", {
          className: "introjs-tooltip"
        });
        var tooltipTextLayer = _createElement("div", {
          className: "introjs-tooltiptext"
        });
        var tooltipHeaderLayer = _createElement("div", {
          className: "introjs-tooltip-header"
        });
        var tooltipTitleLayer = _createElement("h1", {
          className: "introjs-tooltip-title"
        });
        var buttonsLayer = _createElement("div");
        setStyle(helperLayer, {
          "box-shadow": "0 0 1px 2px rgba(33, 33, 33, 0.8), rgba(33, 33, 33, ".concat(self2._options.overlayOpacity.toString(), ") 0 0 0 5000px")
        });
        scrollParentToElement.call(self2, targetElement);
        setHelperLayerPosition.call(self2, helperLayer);
        setHelperLayerPosition.call(self2, referenceLayer);
        appendChild(this._targetElement, helperLayer, true);
        appendChild(this._targetElement, referenceLayer);
        tooltipTextLayer.innerHTML = targetElement.intro;
        tooltipTitleLayer.innerHTML = targetElement.title;
        buttonsLayer.className = "introjs-tooltipbuttons";
        if (this._options.showButtons === false) {
          buttonsLayer.style.display = "none";
        }
        tooltipHeaderLayer.appendChild(tooltipTitleLayer);
        tooltipLayer.appendChild(tooltipHeaderLayer);
        tooltipLayer.appendChild(tooltipTextLayer);
        tooltipLayer.appendChild(_createBullets.call(this, targetElement));
        tooltipLayer.appendChild(_createProgressBar.call(this));
        var helperNumberLayer = _createElement("div");
        if (this._options.showStepNumbers === true) {
          helperNumberLayer.className = "introjs-helperNumberLayer";
          helperNumberLayer.innerHTML = "".concat(targetElement.step, " of ").concat(this._introItems.length);
          tooltipLayer.appendChild(helperNumberLayer);
        }
        tooltipLayer.appendChild(arrowLayer);
        referenceLayer.appendChild(tooltipLayer);
        nextTooltipButton = _createElement("a");
        nextTooltipButton.onclick = function() {
          if (self2._introItems.length - 1 !== self2._currentStep) {
            nextStep.call(self2);
          } else if (/introjs-donebutton/gi.test(nextTooltipButton.className)) {
            if (typeof self2._introCompleteCallback === "function") {
              self2._introCompleteCallback.call(self2);
            }
            exitIntro.call(self2, self2._targetElement);
          }
        };
        setAnchorAsButton(nextTooltipButton);
        nextTooltipButton.innerHTML = this._options.nextLabel;
        prevTooltipButton = _createElement("a");
        prevTooltipButton.onclick = function() {
          if (self2._currentStep !== 0) {
            previousStep.call(self2);
          }
        };
        setAnchorAsButton(prevTooltipButton);
        prevTooltipButton.innerHTML = this._options.prevLabel;
        skipTooltipButton = _createElement("a", {
          className: "introjs-skipbutton"
        });
        setAnchorAsButton(skipTooltipButton);
        skipTooltipButton.innerHTML = this._options.skipLabel;
        skipTooltipButton.onclick = function() {
          if (self2._introItems.length - 1 === self2._currentStep && typeof self2._introCompleteCallback === "function") {
            self2._introCompleteCallback.call(self2);
          }
          if (typeof self2._introSkipCallback === "function") {
            self2._introSkipCallback.call(self2);
          }
          exitIntro.call(self2, self2._targetElement);
        };
        tooltipHeaderLayer.appendChild(skipTooltipButton);
        if (this._introItems.length > 1) {
          buttonsLayer.appendChild(prevTooltipButton);
        }
        buttonsLayer.appendChild(nextTooltipButton);
        tooltipLayer.appendChild(buttonsLayer);
        placeTooltip.call(self2, targetElement.element, tooltipLayer, arrowLayer);
        scrollTo.call(this, targetElement.scrollTo, targetElement, tooltipLayer);
      }
      var disableInteractionLayer = self2._targetElement.querySelector(".introjs-disableInteraction");
      if (disableInteractionLayer) {
        disableInteractionLayer.parentNode.removeChild(disableInteractionLayer);
      }
      if (targetElement.disableInteraction) {
        _disableInteraction.call(self2);
      }
      if (this._currentStep === 0 && this._introItems.length > 1) {
        if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
          nextTooltipButton.className = "".concat(this._options.buttonClass, " introjs-nextbutton");
          nextTooltipButton.innerHTML = this._options.nextLabel;
        }
        if (this._options.hidePrev === true) {
          if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
            prevTooltipButton.className = "".concat(this._options.buttonClass, " introjs-prevbutton introjs-hidden");
          }
          if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
            addClass2(nextTooltipButton, "introjs-fullbutton");
          }
        } else {
          if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
            prevTooltipButton.className = "".concat(this._options.buttonClass, " introjs-prevbutton introjs-disabled");
          }
        }
      } else if (this._introItems.length - 1 === this._currentStep || this._introItems.length === 1) {
        if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
          prevTooltipButton.className = "".concat(this._options.buttonClass, " introjs-prevbutton");
        }
        if (this._options.hideNext === true) {
          if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
            nextTooltipButton.className = "".concat(this._options.buttonClass, " introjs-nextbutton introjs-hidden");
          }
          if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
            addClass2(prevTooltipButton, "introjs-fullbutton");
          }
        } else {
          if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
            if (this._options.nextToDone === true) {
              nextTooltipButton.innerHTML = this._options.doneLabel;
              addClass2(nextTooltipButton, "".concat(this._options.buttonClass, " introjs-nextbutton introjs-donebutton"));
            } else {
              nextTooltipButton.className = "".concat(this._options.buttonClass, " introjs-nextbutton introjs-disabled");
            }
          }
        }
      } else {
        if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
          prevTooltipButton.className = "".concat(this._options.buttonClass, " introjs-prevbutton");
        }
        if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
          nextTooltipButton.className = "".concat(this._options.buttonClass, " introjs-nextbutton");
          nextTooltipButton.innerHTML = this._options.nextLabel;
        }
      }
      if (typeof prevTooltipButton !== "undefined" && prevTooltipButton !== null) {
        prevTooltipButton.setAttribute("role", "button");
      }
      if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
        nextTooltipButton.setAttribute("role", "button");
      }
      if (typeof skipTooltipButton !== "undefined" && skipTooltipButton !== null) {
        skipTooltipButton.setAttribute("role", "button");
      }
      if (typeof nextTooltipButton !== "undefined" && nextTooltipButton !== null) {
        nextTooltipButton.focus();
      }
      setShowElement(targetElement);
      if (typeof this._introAfterChangeCallback !== "undefined") {
        this._introAfterChangeCallback.call(this, targetElement.element);
      }
    }
    function goToStep(step) {
      this._currentStep = step - 2;
      if (typeof this._introItems !== "undefined") {
        nextStep.call(this);
      }
    }
    function goToStepNumber(step) {
      this._currentStepNumber = step;
      if (typeof this._introItems !== "undefined") {
        nextStep.call(this);
      }
    }
    function nextStep() {
      var _this = this;
      this._direction = "forward";
      if (typeof this._currentStepNumber !== "undefined") {
        forEach3(this._introItems, function(_ref, i2) {
          var step = _ref.step;
          if (step === _this._currentStepNumber) {
            _this._currentStep = i2 - 1;
            _this._currentStepNumber = void 0;
          }
        });
      }
      if (typeof this._currentStep === "undefined") {
        this._currentStep = 0;
      } else {
        ++this._currentStep;
      }
      var nextStep2 = this._introItems[this._currentStep];
      var continueStep = true;
      if (typeof this._introBeforeChangeCallback !== "undefined") {
        continueStep = this._introBeforeChangeCallback.call(this, nextStep2 && nextStep2.element);
      }
      if (continueStep === false) {
        --this._currentStep;
        return false;
      }
      if (this._introItems.length <= this._currentStep) {
        if (typeof this._introCompleteCallback === "function") {
          this._introCompleteCallback.call(this);
        }
        exitIntro.call(this, this._targetElement);
        return;
      }
      _showElement.call(this, nextStep2);
    }
    function previousStep() {
      this._direction = "backward";
      if (this._currentStep === 0) {
        return false;
      }
      --this._currentStep;
      var nextStep2 = this._introItems[this._currentStep];
      var continueStep = true;
      if (typeof this._introBeforeChangeCallback !== "undefined") {
        continueStep = this._introBeforeChangeCallback.call(this, nextStep2 && nextStep2.element);
      }
      if (continueStep === false) {
        ++this._currentStep;
        return false;
      }
      _showElement.call(this, nextStep2);
    }
    function currentStep() {
      return this._currentStep;
    }
    function onKeyDown2(e) {
      var code = e.code === void 0 ? e.which : e.code;
      if (code === null) {
        code = e.charCode === null ? e.keyCode : e.charCode;
      }
      if ((code === "Escape" || code === 27) && this._options.exitOnEsc === true) {
        exitIntro.call(this, this._targetElement);
      } else if (code === "ArrowLeft" || code === 37) {
        previousStep.call(this);
      } else if (code === "ArrowRight" || code === 39) {
        nextStep.call(this);
      } else if (code === "Enter" || code === "NumpadEnter" || code === 13) {
        var target = e.target || e.srcElement;
        if (target && target.className.match("introjs-prevbutton")) {
          previousStep.call(this);
        } else if (target && target.className.match("introjs-skipbutton")) {
          if (this._introItems.length - 1 === this._currentStep && typeof this._introCompleteCallback === "function") {
            this._introCompleteCallback.call(this);
          }
          exitIntro.call(this, this._targetElement);
        } else if (target && target.getAttribute("data-stepnumber")) {
          target.click();
        } else {
          nextStep.call(this);
        }
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
      }
    }
    function cloneObject(object3) {
      if (object3 === null || _typeof2(object3) !== "object" || typeof object3.nodeType !== "undefined") {
        return object3;
      }
      var temp = {};
      for (var key in object3) {
        if (typeof window.jQuery !== "undefined" && object3[key] instanceof window.jQuery) {
          temp[key] = object3[key];
        } else {
          temp[key] = cloneObject(object3[key]);
        }
      }
      return temp;
    }
    function hintQuerySelectorAll(selector) {
      var hintsWrapper = document.querySelector(".introjs-hints");
      return hintsWrapper ? hintsWrapper.querySelectorAll(selector) : [];
    }
    function hideHint(stepId) {
      var hint = hintQuerySelectorAll('.introjs-hint[data-step="'.concat(stepId, '"]'))[0];
      removeHintTooltip.call(this);
      if (hint) {
        addClass2(hint, "introjs-hidehint");
      }
      if (typeof this._hintCloseCallback !== "undefined") {
        this._hintCloseCallback.call(this, stepId);
      }
    }
    function hideHints() {
      var _this = this;
      var hints = hintQuerySelectorAll(".introjs-hint");
      forEach3(hints, function(hint) {
        hideHint.call(_this, hint.getAttribute("data-step"));
      });
    }
    function showHints() {
      var _this2 = this;
      var hints = hintQuerySelectorAll(".introjs-hint");
      if (hints && hints.length) {
        forEach3(hints, function(hint) {
          showHint.call(_this2, hint.getAttribute("data-step"));
        });
      } else {
        populateHints.call(this, this._targetElement);
      }
    }
    function showHint(stepId) {
      var hint = hintQuerySelectorAll('.introjs-hint[data-step="'.concat(stepId, '"]'))[0];
      if (hint) {
        removeClass2(hint, /introjs-hidehint/g);
      }
    }
    function removeHints() {
      var _this3 = this;
      var hints = hintQuerySelectorAll(".introjs-hint");
      forEach3(hints, function(hint) {
        removeHint.call(_this3, hint.getAttribute("data-step"));
      });
    }
    function removeHint(stepId) {
      var hint = hintQuerySelectorAll('.introjs-hint[data-step="'.concat(stepId, '"]'))[0];
      if (hint) {
        hint.parentNode.removeChild(hint);
      }
    }
    function addHints() {
      var _this4 = this;
      var self2 = this;
      var hintsWrapper = document.querySelector(".introjs-hints");
      if (hintsWrapper === null) {
        hintsWrapper = _createElement("div", {
          className: "introjs-hints"
        });
      }
      var getHintClick = function getHintClick2(i2) {
        return function(e) {
          var evt = e ? e : window.event;
          if (evt.stopPropagation) {
            evt.stopPropagation();
          }
          if (evt.cancelBubble !== null) {
            evt.cancelBubble = true;
          }
          showHintDialog.call(self2, i2);
        };
      };
      forEach3(this._introItems, function(item, i2) {
        if (document.querySelector('.introjs-hint[data-step="'.concat(i2, '"]'))) {
          return;
        }
        var hint = _createElement("a", {
          className: "introjs-hint"
        });
        setAnchorAsButton(hint);
        hint.onclick = getHintClick(i2);
        if (!item.hintAnimation) {
          addClass2(hint, "introjs-hint-no-anim");
        }
        if (isFixed(item.element)) {
          addClass2(hint, "introjs-fixedhint");
        }
        var hintDot = _createElement("div", {
          className: "introjs-hint-dot"
        });
        var hintPulse = _createElement("div", {
          className: "introjs-hint-pulse"
        });
        hint.appendChild(hintDot);
        hint.appendChild(hintPulse);
        hint.setAttribute("data-step", i2);
        item.targetElement = item.element;
        item.element = hint;
        alignHintPosition.call(_this4, item.hintPosition, hint, item.targetElement);
        hintsWrapper.appendChild(hint);
      });
      document.body.appendChild(hintsWrapper);
      if (typeof this._hintsAddedCallback !== "undefined") {
        this._hintsAddedCallback.call(this);
      }
    }
    function alignHintPosition(position, _ref, element) {
      var style = _ref.style;
      var offset2 = getOffset2.call(this, element);
      var iconWidth = 20;
      var iconHeight = 20;
      switch (position) {
        default:
        case "top-left":
          style.left = "".concat(offset2.left, "px");
          style.top = "".concat(offset2.top, "px");
          break;
        case "top-right":
          style.left = "".concat(offset2.left + offset2.width - iconWidth, "px");
          style.top = "".concat(offset2.top, "px");
          break;
        case "bottom-left":
          style.left = "".concat(offset2.left, "px");
          style.top = "".concat(offset2.top + offset2.height - iconHeight, "px");
          break;
        case "bottom-right":
          style.left = "".concat(offset2.left + offset2.width - iconWidth, "px");
          style.top = "".concat(offset2.top + offset2.height - iconHeight, "px");
          break;
        case "middle-left":
          style.left = "".concat(offset2.left, "px");
          style.top = "".concat(offset2.top + (offset2.height - iconHeight) / 2, "px");
          break;
        case "middle-right":
          style.left = "".concat(offset2.left + offset2.width - iconWidth, "px");
          style.top = "".concat(offset2.top + (offset2.height - iconHeight) / 2, "px");
          break;
        case "middle-middle":
          style.left = "".concat(offset2.left + (offset2.width - iconWidth) / 2, "px");
          style.top = "".concat(offset2.top + (offset2.height - iconHeight) / 2, "px");
          break;
        case "bottom-middle":
          style.left = "".concat(offset2.left + (offset2.width - iconWidth) / 2, "px");
          style.top = "".concat(offset2.top + offset2.height - iconHeight, "px");
          break;
        case "top-middle":
          style.left = "".concat(offset2.left + (offset2.width - iconWidth) / 2, "px");
          style.top = "".concat(offset2.top, "px");
          break;
      }
    }
    function showHintDialog(stepId) {
      var hintElement = document.querySelector('.introjs-hint[data-step="'.concat(stepId, '"]'));
      var item = this._introItems[stepId];
      if (typeof this._hintClickCallback !== "undefined") {
        this._hintClickCallback.call(this, hintElement, item, stepId);
      }
      var removedStep = removeHintTooltip.call(this);
      if (parseInt(removedStep, 10) === stepId) {
        return;
      }
      var tooltipLayer = _createElement("div", {
        className: "introjs-tooltip"
      });
      var tooltipTextLayer = _createElement("div");
      var arrowLayer = _createElement("div");
      var referenceLayer = _createElement("div");
      tooltipLayer.onclick = function(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else {
          e.cancelBubble = true;
        }
      };
      tooltipTextLayer.className = "introjs-tooltiptext";
      var tooltipWrapper = _createElement("p");
      tooltipWrapper.innerHTML = item.hint;
      var closeButton = _createElement("a");
      closeButton.className = this._options.buttonClass;
      closeButton.setAttribute("role", "button");
      closeButton.innerHTML = this._options.hintButtonLabel;
      closeButton.onclick = hideHint.bind(this, stepId);
      tooltipTextLayer.appendChild(tooltipWrapper);
      tooltipTextLayer.appendChild(closeButton);
      arrowLayer.className = "introjs-arrow";
      tooltipLayer.appendChild(arrowLayer);
      tooltipLayer.appendChild(tooltipTextLayer);
      this._currentStep = hintElement.getAttribute("data-step");
      referenceLayer.className = "introjs-tooltipReferenceLayer introjs-hintReference";
      referenceLayer.setAttribute("data-step", hintElement.getAttribute("data-step"));
      setHelperLayerPosition.call(this, referenceLayer);
      referenceLayer.appendChild(tooltipLayer);
      document.body.appendChild(referenceLayer);
      placeTooltip.call(this, hintElement, tooltipLayer, arrowLayer, true);
    }
    function removeHintTooltip() {
      var tooltip = document.querySelector(".introjs-hintReference");
      if (tooltip) {
        var step = tooltip.getAttribute("data-step");
        tooltip.parentNode.removeChild(tooltip);
        return step;
      }
    }
    function populateHints(targetElm) {
      var _this5 = this;
      this._introItems = [];
      if (this._options.hints) {
        forEach3(this._options.hints, function(hint) {
          var currentItem = cloneObject(hint);
          if (typeof currentItem.element === "string") {
            currentItem.element = document.querySelector(currentItem.element);
          }
          currentItem.hintPosition = currentItem.hintPosition || _this5._options.hintPosition;
          currentItem.hintAnimation = currentItem.hintAnimation || _this5._options.hintAnimation;
          if (currentItem.element !== null) {
            _this5._introItems.push(currentItem);
          }
        });
      } else {
        var hints = targetElm.querySelectorAll("*[data-hint]");
        if (!hints || !hints.length) {
          return false;
        }
        forEach3(hints, function(currentElement) {
          var hintAnimation = currentElement.getAttribute("data-hintanimation");
          if (hintAnimation) {
            hintAnimation = hintAnimation === "true";
          } else {
            hintAnimation = _this5._options.hintAnimation;
          }
          _this5._introItems.push({
            element: currentElement,
            hint: currentElement.getAttribute("data-hint"),
            hintPosition: currentElement.getAttribute("data-hintposition") || _this5._options.hintPosition,
            hintAnimation,
            tooltipClass: currentElement.getAttribute("data-tooltipclass"),
            position: currentElement.getAttribute("data-position") || _this5._options.tooltipPosition
          });
        });
      }
      addHints.call(this);
      DOMEvent.on(document, "click", removeHintTooltip, this, false);
      DOMEvent.on(window, "resize", reAlignHints, this, true);
    }
    function reAlignHints() {
      var _this6 = this;
      forEach3(this._introItems, function(_ref2) {
        var targetElement = _ref2.targetElement, hintPosition = _ref2.hintPosition, element = _ref2.element;
        if (typeof targetElement === "undefined") {
          return;
        }
        alignHintPosition.call(_this6, hintPosition, element, targetElement);
      });
    }
    var floor2 = Math.floor;
    var mergeSort = function(array3, comparefn) {
      var length = array3.length;
      var middle = floor2(length / 2);
      return length < 8 ? insertionSort(array3, comparefn) : merge3(mergeSort(array3.slice(0, middle), comparefn), mergeSort(array3.slice(middle), comparefn), comparefn);
    };
    var insertionSort = function(array3, comparefn) {
      var length = array3.length;
      var i2 = 1;
      var element, j;
      while (i2 < length) {
        j = i2;
        element = array3[i2];
        while (j && comparefn(array3[j - 1], element) > 0) {
          array3[j] = array3[--j];
        }
        if (j !== i2++)
          array3[j] = element;
      }
      return array3;
    };
    var merge3 = function(left2, right2, comparefn) {
      var llength = left2.length;
      var rlength = right2.length;
      var lindex = 0;
      var rindex = 0;
      var result = [];
      while (lindex < llength || rindex < rlength) {
        if (lindex < llength && rindex < rlength) {
          result.push(comparefn(left2[lindex], right2[rindex]) <= 0 ? left2[lindex++] : right2[rindex++]);
        } else {
          result.push(lindex < llength ? left2[lindex++] : right2[rindex++]);
        }
      }
      return result;
    };
    var arraySort = mergeSort;
    var firefox = engineUserAgent.match(/firefox\/(\d+)/i);
    var engineFfVersion = !!firefox && +firefox[1];
    var engineIsIeOrEdge = /MSIE|Trident/.test(engineUserAgent);
    var webkit2 = engineUserAgent.match(/AppleWebKit\/(\d+)\./);
    var engineWebkitVersion = !!webkit2 && +webkit2[1];
    var test = [];
    var nativeSort = test.sort;
    var FAILS_ON_UNDEFINED = fails(function() {
      test.sort(void 0);
    });
    var FAILS_ON_NULL = fails(function() {
      test.sort(null);
    });
    var STRICT_METHOD = arrayMethodIsStrict("sort");
    var STABLE_SORT = !fails(function() {
      if (engineV8Version)
        return engineV8Version < 70;
      if (engineFfVersion && engineFfVersion > 3)
        return;
      if (engineIsIeOrEdge)
        return true;
      if (engineWebkitVersion)
        return engineWebkitVersion < 603;
      var result = "";
      var code, chr, value2, index2;
      for (code = 65; code < 76; code++) {
        chr = String.fromCharCode(code);
        switch (code) {
          case 66:
          case 69:
          case 70:
          case 72:
            value2 = 3;
            break;
          case 68:
          case 71:
            value2 = 4;
            break;
          default:
            value2 = 2;
        }
        for (index2 = 0; index2 < 47; index2++) {
          test.push({ k: chr + index2, v: value2 });
        }
      }
      test.sort(function(a, b) {
        return b.v - a.v;
      });
      for (index2 = 0; index2 < test.length; index2++) {
        chr = test[index2].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr)
          result += chr;
      }
      return result !== "DGBEFHACIJK";
    });
    var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
    var getSortCompare = function(comparefn) {
      return function(x, y) {
        if (y === void 0)
          return -1;
        if (x === void 0)
          return 1;
        if (comparefn !== void 0)
          return +comparefn(x, y) || 0;
        return String(x) > String(y) ? 1 : -1;
      };
    };
    _export({ target: "Array", proto: true, forced: FORCED }, {
      sort: function sort2(comparefn) {
        if (comparefn !== void 0)
          aFunction(comparefn);
        var array3 = toObject2(this);
        if (STABLE_SORT)
          return comparefn === void 0 ? nativeSort.call(array3) : nativeSort.call(array3, comparefn);
        var items = [];
        var arrayLength = toLength(array3.length);
        var itemsLength, index2;
        for (index2 = 0; index2 < arrayLength; index2++) {
          if (index2 in array3)
            items.push(array3[index2]);
        }
        items = arraySort(items, getSortCompare(comparefn));
        itemsLength = items.length;
        index2 = 0;
        while (index2 < itemsLength)
          array3[index2] = items[index2++];
        while (index2 < arrayLength)
          delete array3[index2++];
        return array3;
      }
    });
    function fetchIntroSteps(targetElm) {
      var _this = this;
      var allIntroSteps = targetElm.querySelectorAll("*[data-intro]");
      var introItems = [];
      if (this._options.steps) {
        forEach3(this._options.steps, function(step) {
          var currentItem = cloneObject(step);
          currentItem.step = introItems.length + 1;
          currentItem.title = currentItem.title || "";
          if (typeof currentItem.element === "string") {
            currentItem.element = document.querySelector(currentItem.element);
          }
          if (typeof currentItem.element === "undefined" || currentItem.element === null) {
            var floatingElementQuery = document.querySelector(".introjsFloatingElement");
            if (floatingElementQuery === null) {
              floatingElementQuery = _createElement("div", {
                className: "introjsFloatingElement"
              });
              document.body.appendChild(floatingElementQuery);
            }
            currentItem.element = floatingElementQuery;
            currentItem.position = "floating";
          }
          currentItem.position = currentItem.position || _this._options.tooltipPosition;
          currentItem.scrollTo = currentItem.scrollTo || _this._options.scrollTo;
          if (typeof currentItem.disableInteraction === "undefined") {
            currentItem.disableInteraction = _this._options.disableInteraction;
          }
          if (currentItem.element !== null) {
            introItems.push(currentItem);
          }
        });
      } else {
        var elmsLength = allIntroSteps.length;
        var disableInteraction;
        if (elmsLength < 1) {
          return [];
        }
        forEach3(allIntroSteps, function(currentElement) {
          if (_this._options.group && currentElement.getAttribute("data-intro-group") !== _this._options.group) {
            return;
          }
          if (currentElement.style.display === "none") {
            return;
          }
          var step = parseInt(currentElement.getAttribute("data-step"), 10);
          if (currentElement.hasAttribute("data-disable-interaction")) {
            disableInteraction = !!currentElement.getAttribute("data-disable-interaction");
          } else {
            disableInteraction = _this._options.disableInteraction;
          }
          if (step > 0) {
            introItems[step - 1] = {
              element: currentElement,
              title: currentElement.getAttribute("data-title") || "",
              intro: currentElement.getAttribute("data-intro"),
              step: parseInt(currentElement.getAttribute("data-step"), 10),
              tooltipClass: currentElement.getAttribute("data-tooltipclass"),
              highlightClass: currentElement.getAttribute("data-highlightclass"),
              position: currentElement.getAttribute("data-position") || _this._options.tooltipPosition,
              scrollTo: currentElement.getAttribute("data-scrollto") || _this._options.scrollTo,
              disableInteraction
            };
          }
        });
        var nextStep2 = 0;
        forEach3(allIntroSteps, function(currentElement) {
          if (_this._options.group && currentElement.getAttribute("data-intro-group") !== _this._options.group) {
            return;
          }
          if (currentElement.getAttribute("data-step") === null) {
            while (true) {
              if (typeof introItems[nextStep2] === "undefined") {
                break;
              } else {
                nextStep2++;
              }
            }
            if (currentElement.hasAttribute("data-disable-interaction")) {
              disableInteraction = !!currentElement.getAttribute("data-disable-interaction");
            } else {
              disableInteraction = _this._options.disableInteraction;
            }
            introItems[nextStep2] = {
              element: currentElement,
              title: currentElement.getAttribute("data-title") || "",
              intro: currentElement.getAttribute("data-intro"),
              step: nextStep2 + 1,
              tooltipClass: currentElement.getAttribute("data-tooltipclass"),
              highlightClass: currentElement.getAttribute("data-highlightclass"),
              position: currentElement.getAttribute("data-position") || _this._options.tooltipPosition,
              scrollTo: currentElement.getAttribute("data-scrollto") || _this._options.scrollTo,
              disableInteraction
            };
          }
        });
      }
      var tempIntroItems = [];
      for (var z = 0; z < introItems.length; z++) {
        if (introItems[z]) {
          tempIntroItems.push(introItems[z]);
        }
      }
      introItems = tempIntroItems;
      introItems.sort(function(a, b) {
        return a.step - b.step;
      });
      return introItems;
    }
    function refresh2(refreshSteps) {
      var referenceLayer = document.querySelector(".introjs-tooltipReferenceLayer");
      var helperLayer = document.querySelector(".introjs-helperLayer");
      var disableInteractionLayer = document.querySelector(".introjs-disableInteraction");
      setHelperLayerPosition.call(this, helperLayer);
      setHelperLayerPosition.call(this, referenceLayer);
      setHelperLayerPosition.call(this, disableInteractionLayer);
      if (refreshSteps) {
        this._introItems = fetchIntroSteps.call(this, this._targetElement);
        _recreateBullets.call(this, referenceLayer, this._introItems[this._currentStep]);
        _updateProgressBar.call(this, referenceLayer);
      }
      if (this._currentStep !== void 0 && this._currentStep !== null) {
        var oldArrowLayer = document.querySelector(".introjs-arrow");
        var oldtooltipContainer = document.querySelector(".introjs-tooltip");
        placeTooltip.call(this, this._introItems[this._currentStep].element, oldtooltipContainer, oldArrowLayer);
      }
      reAlignHints.call(this);
      return this;
    }
    function onResize2() {
      refresh2.call(this);
    }
    function removeChild(element, animate) {
      if (!element || !element.parentElement)
        return;
      var parentElement = element.parentElement;
      if (animate) {
        setStyle(element, {
          opacity: "0"
        });
        window.setTimeout(function() {
          try {
            parentElement.removeChild(element);
          } catch (e) {
          }
        }, 500);
      } else {
        parentElement.removeChild(element);
      }
    }
    function exitIntro(targetElement, force) {
      var continueExit = true;
      if (this._introBeforeExitCallback !== void 0) {
        continueExit = this._introBeforeExitCallback.call(this);
      }
      if (!force && continueExit === false)
        return;
      var overlayLayers = targetElement.querySelectorAll(".introjs-overlay");
      if (overlayLayers && overlayLayers.length) {
        forEach3(overlayLayers, function(overlayLayer) {
          return removeChild(overlayLayer);
        });
      }
      var helperLayer = targetElement.querySelector(".introjs-helperLayer");
      removeChild(helperLayer, true);
      var referenceLayer = targetElement.querySelector(".introjs-tooltipReferenceLayer");
      removeChild(referenceLayer);
      var disableInteractionLayer = targetElement.querySelector(".introjs-disableInteraction");
      removeChild(disableInteractionLayer);
      var floatingElement = document.querySelector(".introjsFloatingElement");
      removeChild(floatingElement);
      removeShowElement();
      DOMEvent.off(window, "keydown", onKeyDown2, this, true);
      DOMEvent.off(window, "resize", onResize2, this, true);
      if (this._introExitCallback !== void 0) {
        this._introExitCallback.call(this);
      }
      this._currentStep = void 0;
    }
    function addOverlayLayer(targetElm) {
      var _this = this;
      var overlayLayer = _createElement("div", {
        className: "introjs-overlay"
      });
      setStyle(overlayLayer, {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        position: "fixed"
      });
      targetElm.appendChild(overlayLayer);
      if (this._options.exitOnOverlayClick === true) {
        setStyle(overlayLayer, {
          cursor: "pointer"
        });
        overlayLayer.onclick = function() {
          exitIntro.call(_this, targetElm);
        };
      }
      return true;
    }
    function introForElement(targetElm) {
      var steps = fetchIntroSteps.call(this, targetElm);
      if (steps.length === 0) {
        return false;
      }
      this._introItems = steps;
      if (addOverlayLayer.call(this, targetElm)) {
        nextStep.call(this);
        if (this._options.keyboardNavigation) {
          DOMEvent.on(window, "keydown", onKeyDown2, this, true);
        }
        DOMEvent.on(window, "resize", onResize2, this, true);
      }
      return false;
    }
    var version2 = "4.1.0";
    function IntroJs(obj) {
      this._targetElement = obj;
      this._introItems = [];
      this._options = {
        nextLabel: "Next",
        prevLabel: "Back",
        skipLabel: "\xD7",
        doneLabel: "Done",
        hidePrev: false,
        hideNext: false,
        nextToDone: true,
        tooltipPosition: "bottom",
        tooltipClass: "",
        group: "",
        highlightClass: "",
        exitOnEsc: true,
        exitOnOverlayClick: true,
        showStepNumbers: false,
        keyboardNavigation: true,
        showButtons: true,
        showBullets: true,
        showProgress: false,
        scrollToElement: true,
        scrollTo: "element",
        scrollPadding: 30,
        overlayOpacity: 0.5,
        autoPosition: true,
        positionPrecedence: ["bottom", "top", "right", "left"],
        disableInteraction: false,
        helperElementPadding: 10,
        hintPosition: "top-middle",
        hintButtonLabel: "Got it",
        hintAnimation: true,
        buttonClass: "introjs-button",
        progressBarAdditionalClass: false
      };
    }
    var introJs2 = function introJs3(targetElm) {
      var instance;
      if (_typeof2(targetElm) === "object") {
        instance = new IntroJs(targetElm);
      } else if (typeof targetElm === "string") {
        var targetElement = document.querySelector(targetElm);
        if (targetElement) {
          instance = new IntroJs(targetElement);
        } else {
          throw new Error("There is no element with given selector.");
        }
      } else {
        instance = new IntroJs(document.body);
      }
      introJs3.instances[stamp(instance, "introjs-instance")] = instance;
      return instance;
    };
    introJs2.version = version2;
    introJs2.instances = {};
    introJs2.fn = IntroJs.prototype = {
      clone: function clone2() {
        return new IntroJs(this);
      },
      setOption: function setOption(option2, value2) {
        this._options[option2] = value2;
        return this;
      },
      setOptions: function setOptions(options2) {
        this._options = mergeOptions2(this._options, options2);
        return this;
      },
      start: function start2() {
        introForElement.call(this, this._targetElement);
        return this;
      },
      goToStep: function goToStep$1(step) {
        goToStep.call(this, step);
        return this;
      },
      addStep: function addStep(options2) {
        if (!this._options.steps) {
          this._options.steps = [];
        }
        this._options.steps.push(options2);
        return this;
      },
      addSteps: function addSteps(steps) {
        if (!steps.length)
          return;
        for (var index2 = 0; index2 < steps.length; index2++) {
          this.addStep(steps[index2]);
        }
        return this;
      },
      goToStepNumber: function goToStepNumber$1(step) {
        goToStepNumber.call(this, step);
        return this;
      },
      nextStep: function nextStep$1() {
        nextStep.call(this);
        return this;
      },
      previousStep: function previousStep$1() {
        previousStep.call(this);
        return this;
      },
      currentStep: function currentStep$1() {
        return currentStep.call(this);
      },
      exit: function exit(force) {
        exitIntro.call(this, this._targetElement, force);
        return this;
      },
      refresh: function refresh$1(refreshSteps) {
        refresh2.call(this, refreshSteps);
        return this;
      },
      onbeforechange: function onbeforechange(providedCallback) {
        if (typeof providedCallback === "function") {
          this._introBeforeChangeCallback = providedCallback;
        } else {
          throw new Error("Provided callback for onbeforechange was not a function");
        }
        return this;
      },
      onchange: function onchange(providedCallback) {
        if (typeof providedCallback === "function") {
          this._introChangeCallback = providedCallback;
        } else {
          throw new Error("Provided callback for onchange was not a function.");
        }
        return this;
      },
      onafterchange: function onafterchange(providedCallback) {
        if (typeof providedCallback === "function") {
          this._introAfterChangeCallback = providedCallback;
        } else {
          throw new Error("Provided callback for onafterchange was not a function");
        }
        return this;
      },
      oncomplete: function oncomplete(providedCallback) {
        if (typeof providedCallback === "function") {
          this._introCompleteCallback = providedCallback;
        } else {
          throw new Error("Provided callback for oncomplete was not a function.");
        }
        return this;
      },
      onhintsadded: function onhintsadded(providedCallback) {
        if (typeof providedCallback === "function") {
          this._hintsAddedCallback = providedCallback;
        } else {
          throw new Error("Provided callback for onhintsadded was not a function.");
        }
        return this;
      },
      onhintclick: function onhintclick(providedCallback) {
        if (typeof providedCallback === "function") {
          this._hintClickCallback = providedCallback;
        } else {
          throw new Error("Provided callback for onhintclick was not a function.");
        }
        return this;
      },
      onhintclose: function onhintclose(providedCallback) {
        if (typeof providedCallback === "function") {
          this._hintCloseCallback = providedCallback;
        } else {
          throw new Error("Provided callback for onhintclose was not a function.");
        }
        return this;
      },
      onexit: function onexit(providedCallback) {
        if (typeof providedCallback === "function") {
          this._introExitCallback = providedCallback;
        } else {
          throw new Error("Provided callback for onexit was not a function.");
        }
        return this;
      },
      onskip: function onskip(providedCallback) {
        if (typeof providedCallback === "function") {
          this._introSkipCallback = providedCallback;
        } else {
          throw new Error("Provided callback for onskip was not a function.");
        }
        return this;
      },
      onbeforeexit: function onbeforeexit(providedCallback) {
        if (typeof providedCallback === "function") {
          this._introBeforeExitCallback = providedCallback;
        } else {
          throw new Error("Provided callback for onbeforeexit was not a function.");
        }
        return this;
      },
      addHints: function addHints2() {
        populateHints.call(this, this._targetElement);
        return this;
      },
      hideHint: function hideHint$1(stepId) {
        hideHint.call(this, stepId);
        return this;
      },
      hideHints: function hideHints$1() {
        hideHints.call(this);
        return this;
      },
      showHint: function showHint$1(stepId) {
        showHint.call(this, stepId);
        return this;
      },
      showHints: function showHints$1() {
        showHints.call(this);
        return this;
      },
      removeHints: function removeHints$1() {
        removeHints.call(this);
        return this;
      },
      removeHint: function removeHint$1(stepId) {
        removeHint().call(this, stepId);
        return this;
      },
      showHintDialog: function showHintDialog$1(stepId) {
        showHintDialog.call(this, stepId);
        return this;
      }
    };
    return introJs2;
  });
})(intro);
var introJs = intro.exports;
const _sfc_main$3 = defineComponent({
  name: "AwsuiDeploy",
  data() {
    return {
      disableBtn: false,
      showLoading: false,
      type: "deploy",
      oldFrame: null,
      visible: false,
      guideDialogClose: false,
      passElement: {}
    };
  },
  props: {
    modelValue: Boolean,
    guide: Boolean,
    params: {
      type: Object,
      default: () => {
        return {};
      }
    }
  },
  methods: {
    getUrlParam(url2, name2) {
      let reg = new RegExp("(^|&)" + name2 + "=([^&]*)(&|$)", "i");
      let r = url2.substr(1).match(reg);
      if (r != null)
        return unescape(r[2]);
      return null;
    },
    deployFunction() {
      let url2 = this.params.url, isParentOpen = this.params.isParentOpen, appId = this.params.appId, categoryName = this.params.categoryName;
      let processDefId = this.params.processDefId;
      let processGroupId = this.params.processGroupId;
      let deployUrl = this.getUrlParam(url2, "url");
      url2 = decodeURIComponent(url2);
      let functionName = this.getUrlParam(url2, "functionName");
      let sidvalue = this.$store.state.sessionId || this.AWSPageContext.settingParam.sessionId;
      let params = {
        url: encodeURIComponent(deployUrl),
        functionName: encodeURIComponent(functionName)
      };
      let that = this;
      let urlReq = "./jd?sid=" + sidvalue + "&cmd=CONSOLE_COMMON_NAVIGATION_CHARGE_DEPLOY_TYPE";
      this.awsuiaxios.post({
        url: urlReq,
        data: params
      }).then(function(responseObject) {
        if (responseObject["result"] == "ok") {
          if (responseObject.data.type == "custom") {
            let customUrl = "./w?sid=" + sidvalue + "&cmd=CONSOLE_COMMON_NAVIGATION_DESIGN_DEPLOY_OPEN&url=" + encodeURIComponent(deployUrl) + "&functionName=" + encodeURIComponent(functionName) + "&isParentOpen=" + isParentOpen;
            that.openDeploy(customUrl, "deploy", isParentOpen);
          } else {
            let url3 = "./w?sid=" + sidvalue + "&cmd=CONSOLE_COMMON_NAVIGATION_PREV_DEPLOY&url=" + encodeURIComponent(deployUrl) + "&functionName=" + encodeURIComponent(functionName) + "&isParentOpen=" + isParentOpen;
            if (appId != void 0 && appId != null && appId != "") {
              url3 += "&appId=" + appId;
            }
            if (categoryName != void 0 && categoryName != null && categoryName != "") {
              url3 += "&categoryName=" + encodeURIComponent(categoryName);
            }
            if (processDefId != void 0 && processDefId != null && processDefId != "") {
              url3 += "&processDefId=" + processDefId;
            }
            if (processGroupId != void 0 && processGroupId != null && processGroupId != "") {
              url3 += "&processGroupId=" + processGroupId;
            }
            that.openDeploy(url3, "oneKey", isParentOpen);
          }
        }
      });
    },
    removeSecurity(id2, type2) {
      this.awsuiaxios.post({
        url: "./jd",
        data: {
          sid: this.$store.state.sessionId,
          cmd: "CLIENT_M_NAV_SECURITYGROUP_REMOVE",
          id: id2,
          permissionType: type2
        }
      }).then((r) => {
        console.log(r);
      });
    },
    applyDeploy() {
      try {
        this.$refs.openDeploy9521.contentWindow.deployFunction();
      } catch (e) {
        this.$refs.openDeploy9521.deployFunction();
      }
      introJs().exit();
    },
    toClose() {
      if (this.type == "deploy") {
        let funcId;
        try {
          funcId = this.$refs.openDeploy9521.contentWindow.$("#functionId").val();
        } catch (e) {
          funcId = this.$refs.openDeploy9521.$("#functionId").val();
        }
        try {
          this.removeSecurity(funcId, "nav");
        } catch (e) {
          try {
            this.$refs.openDeploy9521.contentWindow.removeSecurity(funcId, "nav");
          } catch (e2) {
            this.$refs.openDeploy9521.removeSecurity(funcId, "nav");
          }
        }
      }
      this.visible = false;
      if (window.openDeploy9521) {
        this.$emit("getDeployGuide", window.openDeploy9521.guide);
      }
    },
    openDeploy(url2, type2, isParentOpen) {
      let that = this;
      if (isParentOpen) {
        this.oldFrame = parent.FrmDialog;
        let frmd = parent.FrmDialog;
        let button = [];
        if (type2 == "deploy") {
          button.push({
            text: "\u90E8\u7F72",
            cls: "blue",
            handler: function() {
              introJs().exit();
              frmd.get("deploy").win().deployFunction();
            }
          });
        }
        button.push({
          text: "\u5173\u95ED",
          handler: function() {
            if (type2 == "deploy") {
              let funcId = frmd.get("deploy").$("#functionId").val();
              try {
                that.removeSecurity(funcId, "nav");
              } catch (e) {
                frmd.get("deploy").win().removeSecurity(funcId, "nav");
              }
            }
            that.$emit("update:modelValue", false);
            that.$emit("getDeploGuide", false);
            frmd.get("deploy").close();
          }
        });
        frmd.open({
          title: "\u5FEB\u901F\u90E8\u7F72",
          width: 800,
          height: 390,
          id: "deploy",
          closable: false,
          buttons: button
        }, url2, {}, "deploy");
      } else {
        this.visible = true;
        this.type = type2;
        this.$nextTick(() => {
          this.replaceUrl(url2);
        });
      }
      window.openDeploy9521 = {
        exec: this.execThis,
        guide: this.guide,
        onRenderIntroStep: this.onRenderIntroStep,
        closeIntro: this.closeIntro
      };
    },
    execThis(method3, ...args) {
      this[method3](...args);
    },
    closeIntro(go, close2) {
      this.guideDialogClose = true;
      this.passElement = {
        go,
        close: close2
      };
    },
    loading(isshow) {
      this.showLoading = isshow;
    },
    toDisableBtn(disable) {
      this.disableBtn = disable;
    },
    toShowDeploy() {
      this.type = "deploy";
    },
    replaceUrl(url2) {
      try {
        this.$refs.openDeploy9521.contentWindow.location.replace(url2.replace(/\.\//, this.getPath));
      } finally {
        this.$refs.openDeploy9521.location.replace(url2.replace(/\.\//, this.getPath));
      }
    },
    showMessage(type2, msg) {
      this.$message({
        type: type2,
        message: msg
      });
    },
    onRenderIntroStep() {
      if (this.guide) {
        debugger;
        setTimeout(() => {
          introJs().exit();
          introJs().refresh().setOptions({
            prevLabel: "\u4E0A\u4E00\u6B65",
            nextLabel: "\u4E0B\u4E00\u6B65",
            doneLabel: "\u4E0B\u4E00\u6B65",
            hidePrev: true,
            exitOnEsc: false,
            exitOnOverlayClick: false,
            showStepNumbers: false,
            keyboardNavigation: false,
            showBullets: false,
            showProgress: false,
            steps: [
              {
                title: "\u70B9\u51FB\u90E8\u7F72",
                element: "#applyDeployBtn",
                intro: '<div class="introjs-stepnumber" style="margin-top:-10px;">\u7B2C33\u6B65\uFF08\u517137\u6B65\uFF09</div>',
                tooltipClass: "intro-default-tooltip intro-no-tooltext",
                highlightClass: "intro-dialog-default-highlight",
                position: "top-right-aligned"
              }
            ]
          }).onbeforechange((targetElement) => {
            let content = document.querySelector(".deployDialog9547 .content");
            if (content) {
              content.classList.remove("pointer-events-auto");
            }
            targetElement.childNodes.item(0).style.display = "block";
            targetElement.setAttribute("class", "animate-pulse pointer-events-auto");
          }).onbeforeexit(() => {
            this.guideDialogClose = true;
            let animatePulse = document.querySelector(".animate-pulse"), toolTip = document.querySelector(".introjs-tooltip");
            if (animatePulse) {
              animatePulse.style.animationName = "none";
            }
            if (toolTip) {
              toolTip.style.display = "none";
            }
            return false;
          }).start();
        }, 100);
      }
    },
    closeGuide() {
      introJs().exit();
      this.awsuiaxios.post({
        url: "jd",
        data: {
          sid: this.AWSPageContext.settingParam.sessionId,
          cmd: "com.actionsoft.apps.dingding.yijing_save_user_tour"
        }
      }).then((res) => {
        if (res.result == "ok") {
          let dialog = document.querySelector(".deployDialog9547");
          if (dialog) {
            dialog.classList.remove("pointer-events-none");
          }
          let content = document.querySelector(".deployDialog9547 .content");
          if (content) {
            content.classList.remove("pointer-events-none");
          }
          this.guideDialogClose = false;
          this.$emit("getDeploGuide", false);
          window.openDeploy9521.guide = false;
          if (this.passElement.close !== void 0) {
            this.passElement.close();
          }
        }
      });
    },
    goGuide() {
      let dialog = document.querySelector(".deployDialog9547");
      if (dialog) {
        dialog.classList.add("pointer-events-none");
      }
      this.guideDialogClose = false;
      this.$emit("getDeploGuide", true);
      window.openDeploy9521.guide = true;
      let animatePulse = document.querySelector(".animate-pulse");
      if (animatePulse) {
        animatePulse.style.animationName = "pulse";
      }
      let toolTip = document.querySelector(".introjs-tooltip");
      if (toolTip) {
        toolTip.style.display = "block";
      }
      if (this.passElement.go !== void 0) {
        this.passElement.go();
      }
    },
    handleIntroClick() {
      if (this.guide) {
        let intro2 = document.querySelector(".animate-pulse");
        if (intro2 !== null) {
          intro2.classList.add("animate-shake-horizontal");
          setTimeout(() => {
            intro2.classList.remove("animate-shake-horizontal");
          }, 1e3);
        }
      }
    }
  },
  watch: {
    modelValue(val) {
      this.disableBtn = false;
      if (val) {
        this.deployFunction();
      } else {
        this.visible = false;
        if (this.oldFrame) {
          this.oldFrame.close();
        }
      }
    },
    visible(val) {
      if (!val) {
        this.$emit("update:modelValue", val);
      }
    }
  },
  computed: {
    getHeight() {
      return {
        height: this.guide ? "420px" : window.innerHeight * 0.6 + "px"
      };
    },
    getNoRPath() {
      return this.getPath.replace("r/", "").replace("./", "../");
    },
    getPath() {
      return this.AWSPageContext.axiosBaseUrl;
    }
  }
});
const _withScopeId$2 = (n) => (pushScopeId("data-v-23e3e5f4"), n = n(), popScopeId(), n);
const _hoisted_1$3 = ["src"];
const _hoisted_2$3 = { class: "dialog-footer" };
const _hoisted_3$3 = { id: "applyDeployBtn" };
const _hoisted_4$2 = /* @__PURE__ */ createTextVNode("\u90E8\u7F72 ");
const _hoisted_5$2 = /* @__PURE__ */ createTextVNode("\u5173\u95ED");
const _hoisted_6$2 = { class: "intro" };
const _hoisted_7$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("div", { class: "guide-con" }, [
  /* @__PURE__ */ createElementVNode("span", { class: "title" }, "\u786E\u8BA4\u9000\u51FA\u6559\u7A0B\u5417"),
  /* @__PURE__ */ createElementVNode("span", { class: "content" }, "\u9000\u51FA\u540E\u4ECD\u7136\u53EF\u4EE5\u5728\u5E2E\u52A9\u4E2D\u627E\u5230\u65B0\u624B\u6559\u7A0B \u518D\u6B21\u5B66\u4E60")
], -1));
const _hoisted_8$2 = { class: "button-warp" };
const _hoisted_9$2 = /* @__PURE__ */ createTextVNode(" \u9000\u51FA ");
const _hoisted_10$1 = /* @__PURE__ */ createTextVNode(" \u7EE7\u7EED\u5B66\u4E60 ");
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_button = resolveComponent("awsui-button");
  const _component_awsui_dialog = resolveComponent("awsui-dialog");
  const _directive_loading = resolveDirective("loading");
  return openBlock(), createElementBlock(Fragment, null, [
    createElementVNode("div", {
      class: "box",
      onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.handleIntroClick && _ctx.handleIntroClick(...args), ["stop"]))
    }, [
      withDirectives(createVNode(_component_awsui_dialog, {
        title: "\u53D1\u5E03",
        name: "openDeployDialog",
        customClass: _ctx.guide ? "deployDialog9547 pointer-events-none" : "deployDialog9547",
        width: "816px",
        modelValue: _ctx.visible,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.visible = $event),
        "destroy-on-close": "",
        "close-on-click-modal": _ctx.guide ? false : true,
        "before-close": _ctx.toClose
      }, {
        footer: withCtx(() => [
          createElementVNode("div", _hoisted_2$3, [
            createElementVNode("span", _hoisted_3$3, [
              withDirectives(createVNode(_component_awsui_button, {
                type: "primary",
                onClick: withModifiers(_ctx.applyDeploy, ["stop"]),
                disabled: _ctx.disableBtn
              }, {
                default: withCtx(() => [
                  _hoisted_4$2
                ]),
                _: 1
              }, 8, ["onClick", "disabled"]), [
                [vShow, _ctx.type == "deploy"]
              ])
            ]),
            createVNode(_component_awsui_button, {
              onClick: withModifiers(_ctx.toClose, ["stop"])
            }, {
              default: withCtx(() => [
                _hoisted_5$2
              ]),
              _: 1
            }, 8, ["onClick"])
          ])
        ]),
        default: withCtx(() => [
          createElementVNode("div", {
            class: normalizeClass(_ctx.guide ? "content pointer-events-auto" : "frameDiv"),
            style: normalizeStyle(_ctx.getHeight)
          }, [
            createElementVNode("iframe", {
              ref: "openDeploy9521",
              class: "awsui-layout-iframe",
              src: _ctx.getNoRPath + "commons/wait.htm"
            }, null, 8, _hoisted_1$3)
          ], 6)
        ]),
        _: 1
      }, 8, ["customClass", "modelValue", "close-on-click-modal", "before-close"]), [
        [_directive_loading, _ctx.showLoading]
      ])
    ]),
    createElementVNode("div", _hoisted_6$2, [
      createVNode(_component_awsui_dialog, {
        modelValue: _ctx.guideDialogClose,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.guideDialogClose = $event),
        width: "500px",
        "close-on-click-modal": false,
        "show-close": false,
        "destroy-on-close": ""
      }, {
        footer: withCtx(() => [
          createElementVNode("div", _hoisted_8$2, [
            createVNode(_component_awsui_button, {
              type: "primary",
              onClick: withModifiers(_ctx.closeGuide, ["stop"])
            }, {
              default: withCtx(() => [
                _hoisted_9$2
              ]),
              _: 1
            }, 8, ["onClick"]),
            createVNode(_component_awsui_button, {
              class: "quit",
              onClick: withModifiers(_ctx.goGuide, ["stop"])
            }, {
              default: withCtx(() => [
                _hoisted_10$1
              ]),
              _: 1
            }, 8, ["onClick"])
          ])
        ]),
        default: withCtx(() => [
          _hoisted_7$2
        ]),
        _: 1
      }, 8, ["modelValue"])
    ])
  ], 64);
}
var deploy = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-23e3e5f4"]]);
deploy.install = (app) => {
  app.component(deploy.name, deploy);
};
const _sfc_main$2 = defineComponent({
  name: "AwsuiCodeHelper",
  components: { codemirror: AwsuiCodemirror },
  props: {
    cmoptions: {
      type: Object,
      default: function() {
        return {
          tabSize: 4,
          mode: "text/javascript",
          theme: "dracula",
          lineNumbers: true,
          line: true
        };
      }
    },
    headerStyle: {
      type: Object,
      default: function() {
        return {
          height: "30px"
        };
      }
    },
    footerStyle: {
      type: Object,
      default: function() {
        return {
          height: "auto"
        };
      }
    },
    placeholder: {
      type: String
    },
    codeHelpInfo: {
      type: Array
    },
    height: {
      type: Number
    },
    modelValue: {
      type: String,
      default: ""
    },
    isRequiredShow: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {};
  },
  setup(props2, context) {
    const instance = getCurrentInstance();
    let show = ref(false);
    let activeName = ref("1");
    let activeTitle = ref("");
    let mirrorPlaceholder = ref("");
    let lineCh = reactive({
      line: 0,
      ch: 0
    });
    let codemirr = ref(null);
    let svalue = computed({
      set: (value2) => {
        context.emit("update:modelValue", value2);
        context.emit("change", value2);
      },
      get: () => {
        return props2.modelValue;
      }
    });
    const methods = {
      setHeaderStyle() {
        return props2.headerStyle;
      },
      setFooterStyle() {
        return props2.footerStyle;
      },
      fullSreen() {
        var winHeight = window.screen.availHeight - 400;
        var winWidth = window.screen.availWidth - 400;
        if (window.top.FrmDialog) {
          let dlg = window.top.FrmDialog.open({
            width: winWidth,
            height: winHeight,
            id: "aws_sql_fullscreen_dlg",
            closable: false,
            url: "./w",
            data: {
              sid: this.$store.state.sessionId,
              cmd: "CONSOLE_COMMON_SQL_FULLSCREEN",
              sqlVal: svalue.value,
              appId: ""
            },
            onClose: () => {
              svalue.value = window.top.FrmDialog.win().$("#full_sql_dlg").val();
            }
          });
          this.dlgx = dlg;
        }
      },
      getTextAreaPostion() {
        lineCh = codemirr.value.getCodeMirrorInstance().getCursor();
      },
      replaceHTML(val) {
        return val.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/\\n/g, "\n");
      },
      insert(val, item) {
        let str = this.replaceHTML(val);
        codemirr.value.getCodeMirrorInstance().replaceRange(str, lineCh, lineCh);
        codemirr.value.getCodeMirrorInstance().focus();
        codemirr.value.getCodeMirrorInstance().setCursor({
          line: lineCh.line,
          ch: lineCh.ch + str.length
        });
        svalue.value = codemirr.value.getCodeMirrorInstance().getValue();
        activeTitle.value = item.title;
      },
      collapseShow() {
        show.value = !show.value;
      },
      helpMsg(val) {
        instance == null ? void 0 : instance.appContext.config.globalProperties.$alert(val, "\u5E2E\u52A9\u4FE1\u606F", {
          customClass: "el-message-box_custom",
          dangerouslyUseHTMLString: true,
          closeOnClickModal: true
        });
      },
      setCodeMirrorSize() {
        codemirr.value.getCodeMirrorInstance().setSize(null, props2.height);
        codemirr.value.getCodeMirrorInstance().focus();
      },
      setHeight(h2) {
        codemirr.value.getCodeMirrorInstance().setSize(null, h2);
      },
      getCodeMirror() {
        return codemirr.value.getCodeMirrorInstance();
      }
    };
    onMounted(() => {
      methods.setCodeMirrorSize();
    });
    watch(() => props2.modelValue, () => {
      mirrorPlaceholder.value = props2.modelValue ? "" : props2.placeholder;
    });
    return __spreadValues2({
      codemirr,
      lineCh,
      show,
      activeName,
      activeTitle,
      mirrorPlaceholder,
      svalue
    }, methods);
  }
});
const _hoisted_1$2 = {
  key: 0,
  class: "code-helper-required"
};
const _hoisted_2$2 = ["onClick"];
const _hoisted_3$2 = ["onClick"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_header = resolveComponent("awsui-header");
  const _component_codemirror = resolveComponent("codemirror");
  const _component_el_collapse_item = resolveComponent("el-collapse-item");
  const _component_el_collapse = resolveComponent("el-collapse");
  const _component_awsui_footer = resolveComponent("awsui-footer");
  const _component_awsui_main = resolveComponent("awsui-main");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  const _component_awsui_aside = resolveComponent("awsui-aside");
  const _component_awsui_layout = resolveComponent("awsui-layout");
  return openBlock(), createBlock(_component_awsui_layout, null, {
    default: withCtx(() => [
      _ctx.$slots.header != null ? (openBlock(), createBlock(_component_awsui_header, {
        key: 0,
        style: normalizeStyle(_ctx.setHeaderStyle())
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "header", {}, void 0, true)
        ]),
        _: 3
      }, 8, ["style"])) : createCommentVNode("v-if", true),
      createVNode(_component_awsui_layout, null, {
        default: withCtx(() => [
          createVNode(_component_awsui_main, { style: { "position": "relative" } }, {
            default: withCtx(() => [
              _ctx.isRequiredShow ? (openBlock(), createElementBlock("div", _hoisted_1$2, "* ")) : createCommentVNode("v-if", true),
              createVNode(_component_codemirror, {
                ref: "codemirr",
                options: _ctx.cmoptions,
                onBlur: _ctx.getTextAreaPostion,
                modelValue: _ctx.svalue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.svalue = $event),
                placeholder: _ctx.mirrorPlaceholder,
                class: "customCode"
              }, null, 8, ["options", "onBlur", "modelValue", "placeholder"]),
              withDirectives(createVNode(_component_el_collapse, {
                modelValue: _ctx.activeName,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.activeName = $event),
                accordion: ""
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.codeHelpInfo, (categoryitem) => {
                    return openBlock(), createBlock(_component_el_collapse_item, {
                      title: categoryitem.category,
                      name: categoryitem.id,
                      key: categoryitem.index
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(categoryitem.content, (item) => {
                          return openBlock(), createElementBlock("div", {
                            key: item.index,
                            class: normalizeClass(["collapse-item", { "active": item.title === _ctx.activeTitle }]),
                            onClick: ($event) => _ctx.insert(item.insertCode, item)
                          }, [
                            createElementVNode("span", {
                              class: normalizeClass(["spot", { "activespot": item.title === _ctx.activeTitle }])
                            }, null, 2),
                            createTextVNode(toDisplayString(item.title) + " ", 1),
                            item.desc ? (openBlock(), createElementBlock("i", {
                              key: 0,
                              class: "awsui-iconfont help",
                              onClick: withModifiers(($event) => _ctx.helpMsg(item.desc), ["stop"])
                            }, "\uE609", 8, _hoisted_3$2)) : createCommentVNode("v-if", true)
                          ], 10, _hoisted_2$2);
                        }), 128))
                      ]),
                      _: 2
                    }, 1032, ["title", "name"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue"]), [
                [vShow, _ctx.show]
              ]),
              _ctx.$slots.errorMsg != null ? (openBlock(), createBlock(_component_awsui_footer, {
                key: 1,
                style: normalizeStyle(_ctx.setFooterStyle())
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "errorMsg", {}, void 0, true)
                ]),
                _: 3
              }, 8, ["style"])) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }),
          createVNode(_component_awsui_aside, {
            width: "26px",
            style: { "position": "relative" }
          }, {
            default: withCtx(() => [
              withDirectives(createElementVNode("div", null, [
                _ctx.show ? (openBlock(), createElementBlock("i", {
                  key: 0,
                  class: "awsui-iconfont topDiv",
                  onClick: _cache[2] || (_cache[2] = (...args) => _ctx.collapseShow && _ctx.collapseShow(...args))
                }, "\uE837")) : (openBlock(), createElementBlock("i", {
                  key: 1,
                  class: "awsui-iconfont topDiv",
                  onClick: _cache[3] || (_cache[3] = (...args) => _ctx.collapseShow && _ctx.collapseShow(...args))
                }, "\uE838"))
              ], 512), [
                [vShow, _ctx.codeHelpInfo]
              ]),
              createVNode(_component_el_tooltip, {
                content: "\u5168\u5C4F",
                placement: "bottom"
              }, {
                default: withCtx(() => [
                  createElementVNode("i", {
                    class: "awsui-iconfont enlarge",
                    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.fullSreen && _ctx.fullSreen(...args))
                  }, "\uE800")
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 3
      })
    ]),
    _: 3
  });
}
var AwsuiCodeHelper = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-8c9a24ea"]]);
var codemirror = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var userAgent2 = navigator.userAgent;
    var platform2 = navigator.platform;
    var gecko2 = /gecko\/\d/i.test(userAgent2);
    var ie_upto102 = /MSIE \d/.test(userAgent2);
    var ie_11up2 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent2);
    var edge2 = /Edge\/(\d+)/.exec(userAgent2);
    var ie2 = ie_upto102 || ie_11up2 || edge2;
    var ie_version2 = ie2 && (ie_upto102 ? document.documentMode || 6 : +(edge2 || ie_11up2)[1]);
    var webkit2 = !edge2 && /WebKit\//.test(userAgent2);
    var qtwebkit2 = webkit2 && /Qt\/\d+\.\d+/.test(userAgent2);
    var chrome2 = !edge2 && /Chrome\//.test(userAgent2);
    var presto2 = /Opera\//.test(userAgent2);
    var safari2 = /Apple Computer/.test(navigator.vendor);
    var mac_geMountainLion2 = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent2);
    var phantom2 = /PhantomJS/.test(userAgent2);
    var ios2 = safari2 && (/Mobile\/\w+/.test(userAgent2) || navigator.maxTouchPoints > 2);
    var android2 = /Android/.test(userAgent2);
    var mobile2 = ios2 || android2 || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent2);
    var mac2 = ios2 || /Mac/.test(platform2);
    var chromeOS2 = /\bCrOS\b/.test(userAgent2);
    var windows2 = /win/i.test(platform2);
    var presto_version2 = presto2 && userAgent2.match(/Version\/(\d*\.\d*)/);
    if (presto_version2) {
      presto_version2 = Number(presto_version2[1]);
    }
    if (presto_version2 && presto_version2 >= 15) {
      presto2 = false;
      webkit2 = true;
    }
    var flipCtrlCmd2 = mac2 && (qtwebkit2 || presto2 && (presto_version2 == null || presto_version2 < 12.11));
    var captureRightClick2 = gecko2 || ie2 && ie_version2 >= 9;
    function classTest2(cls) {
      return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
    }
    var rmClass2 = function(node, cls) {
      var current = node.className;
      var match = classTest2(cls).exec(current);
      if (match) {
        var after = current.slice(match.index + match[0].length);
        node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
      }
    };
    function removeChildren2(e) {
      for (var count = e.childNodes.length; count > 0; --count) {
        e.removeChild(e.firstChild);
      }
      return e;
    }
    function removeChildrenAndAdd2(parent2, e) {
      return removeChildren2(parent2).appendChild(e);
    }
    function elt2(tag, content, className, style) {
      var e = document.createElement(tag);
      if (className) {
        e.className = className;
      }
      if (style) {
        e.style.cssText = style;
      }
      if (typeof content == "string") {
        e.appendChild(document.createTextNode(content));
      } else if (content) {
        for (var i3 = 0; i3 < content.length; ++i3) {
          e.appendChild(content[i3]);
        }
      }
      return e;
    }
    function eltP2(tag, content, className, style) {
      var e = elt2(tag, content, className, style);
      e.setAttribute("role", "presentation");
      return e;
    }
    var range2;
    if (document.createRange) {
      range2 = function(node, start2, end2, endNode) {
        var r = document.createRange();
        r.setEnd(endNode || node, end2);
        r.setStart(node, start2);
        return r;
      };
    } else {
      range2 = function(node, start2, end2) {
        var r = document.body.createTextRange();
        try {
          r.moveToElementText(node.parentNode);
        } catch (e) {
          return r;
        }
        r.collapse(true);
        r.moveEnd("character", end2);
        r.moveStart("character", start2);
        return r;
      };
    }
    function contains2(parent2, child) {
      if (child.nodeType == 3) {
        child = child.parentNode;
      }
      if (parent2.contains) {
        return parent2.contains(child);
      }
      do {
        if (child.nodeType == 11) {
          child = child.host;
        }
        if (child == parent2) {
          return true;
        }
      } while (child = child.parentNode);
    }
    function activeElt2() {
      var activeElement;
      try {
        activeElement = document.activeElement;
      } catch (e) {
        activeElement = document.body || null;
      }
      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      return activeElement;
    }
    function addClass2(node, cls) {
      var current = node.className;
      if (!classTest2(cls).test(current)) {
        node.className += (current ? " " : "") + cls;
      }
    }
    function joinClasses2(a, b) {
      var as = a.split(" ");
      for (var i3 = 0; i3 < as.length; i3++) {
        if (as[i3] && !classTest2(as[i3]).test(b)) {
          b += " " + as[i3];
        }
      }
      return b;
    }
    var selectInput2 = function(node) {
      node.select();
    };
    if (ios2) {
      selectInput2 = function(node) {
        node.selectionStart = 0;
        node.selectionEnd = node.value.length;
      };
    } else if (ie2) {
      selectInput2 = function(node) {
        try {
          node.select();
        } catch (_e) {
        }
      };
    }
    function bind3(f) {
      var args = Array.prototype.slice.call(arguments, 1);
      return function() {
        return f.apply(null, args);
      };
    }
    function copyObj2(obj, target, overwrite) {
      if (!target) {
        target = {};
      }
      for (var prop2 in obj) {
        if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
          target[prop2] = obj[prop2];
        }
      }
      return target;
    }
    function countColumn2(string2, end2, tabSize, startIndex, startValue) {
      if (end2 == null) {
        end2 = string2.search(/[^\s\u00a0]/);
        if (end2 == -1) {
          end2 = string2.length;
        }
      }
      for (var i3 = startIndex || 0, n = startValue || 0; ; ) {
        var nextTab = string2.indexOf("	", i3);
        if (nextTab < 0 || nextTab >= end2) {
          return n + (end2 - i3);
        }
        n += nextTab - i3;
        n += tabSize - n % tabSize;
        i3 = nextTab + 1;
      }
    }
    var Delayed2 = function() {
      this.id = null;
      this.f = null;
      this.time = 0;
      this.handler = bind3(this.onTimeout, this);
    };
    Delayed2.prototype.onTimeout = function(self2) {
      self2.id = 0;
      if (self2.time <= +new Date()) {
        self2.f();
      } else {
        setTimeout(self2.handler, self2.time - +new Date());
      }
    };
    Delayed2.prototype.set = function(ms, f) {
      this.f = f;
      var time = +new Date() + ms;
      if (!this.id || time < this.time) {
        clearTimeout(this.id);
        this.id = setTimeout(this.handler, ms);
        this.time = time;
      }
    };
    function indexOf2(array3, elt3) {
      for (var i3 = 0; i3 < array3.length; ++i3) {
        if (array3[i3] == elt3) {
          return i3;
        }
      }
      return -1;
    }
    var scrollerGap2 = 50;
    var Pass2 = { toString: function() {
      return "CodeMirror.Pass";
    } };
    var sel_dontScroll2 = { scroll: false }, sel_mouse2 = { origin: "*mouse" }, sel_move2 = { origin: "+move" };
    function findColumn2(string2, goal, tabSize) {
      for (var pos = 0, col = 0; ; ) {
        var nextTab = string2.indexOf("	", pos);
        if (nextTab == -1) {
          nextTab = string2.length;
        }
        var skipped = nextTab - pos;
        if (nextTab == string2.length || col + skipped >= goal) {
          return pos + Math.min(skipped, goal - col);
        }
        col += nextTab - pos;
        col += tabSize - col % tabSize;
        pos = nextTab + 1;
        if (col >= goal) {
          return pos;
        }
      }
    }
    var spaceStrs2 = [""];
    function spaceStr2(n) {
      while (spaceStrs2.length <= n) {
        spaceStrs2.push(lst2(spaceStrs2) + " ");
      }
      return spaceStrs2[n];
    }
    function lst2(arr) {
      return arr[arr.length - 1];
    }
    function map2(array3, f) {
      var out = [];
      for (var i3 = 0; i3 < array3.length; i3++) {
        out[i3] = f(array3[i3], i3);
      }
      return out;
    }
    function insertSorted2(array3, value2, score) {
      var pos = 0, priority = score(value2);
      while (pos < array3.length && score(array3[pos]) <= priority) {
        pos++;
      }
      array3.splice(pos, 0, value2);
    }
    function nothing2() {
    }
    function createObj2(base, props2) {
      var inst;
      if (Object.create) {
        inst = Object.create(base);
      } else {
        nothing2.prototype = base;
        inst = new nothing2();
      }
      if (props2) {
        copyObj2(props2, inst);
      }
      return inst;
    }
    var nonASCIISingleCaseWordChar2 = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic2(ch) {
      return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar2.test(ch));
    }
    function isWordChar2(ch, helper) {
      if (!helper) {
        return isWordCharBasic2(ch);
      }
      if (helper.source.indexOf("\\w") > -1 && isWordCharBasic2(ch)) {
        return true;
      }
      return helper.test(ch);
    }
    function isEmpty2(obj) {
      for (var n in obj) {
        if (obj.hasOwnProperty(n) && obj[n]) {
          return false;
        }
      }
      return true;
    }
    var extendingChars2 = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar2(ch) {
      return ch.charCodeAt(0) >= 768 && extendingChars2.test(ch);
    }
    function skipExtendingChars2(str, pos, dir) {
      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar2(str.charAt(pos))) {
        pos += dir;
      }
      return pos;
    }
    function findFirst2(pred, from, to) {
      var dir = from > to ? -1 : 1;
      for (; ; ) {
        if (from == to) {
          return from;
        }
        var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
        if (mid == from) {
          return pred(mid) ? from : to;
        }
        if (pred(mid)) {
          to = mid;
        } else {
          from = mid + dir;
        }
      }
    }
    function iterateBidiSections2(order2, from, to, f) {
      if (!order2) {
        return f(from, to, "ltr", 0);
      }
      var found = false;
      for (var i3 = 0; i3 < order2.length; ++i3) {
        var part = order2[i3];
        if (part.from < to && part.to > from || from == to && part.to == from) {
          f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i3);
          found = true;
        }
      }
      if (!found) {
        f(from, to, "ltr");
      }
    }
    var bidiOther2 = null;
    function getBidiPartAt2(order2, ch, sticky) {
      var found;
      bidiOther2 = null;
      for (var i3 = 0; i3 < order2.length; ++i3) {
        var cur = order2[i3];
        if (cur.from < ch && cur.to > ch) {
          return i3;
        }
        if (cur.to == ch) {
          if (cur.from != cur.to && sticky == "before") {
            found = i3;
          } else {
            bidiOther2 = i3;
          }
        }
        if (cur.from == ch) {
          if (cur.from != cur.to && sticky != "before") {
            found = i3;
          } else {
            bidiOther2 = i3;
          }
        }
      }
      return found != null ? found : bidiOther2;
    }
    var bidiOrdering2 = function() {
      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
      var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
      function charType(code) {
        if (code <= 247) {
          return lowTypes.charAt(code);
        } else if (1424 <= code && code <= 1524) {
          return "R";
        } else if (1536 <= code && code <= 1785) {
          return arabicTypes.charAt(code - 1536);
        } else if (1774 <= code && code <= 2220) {
          return "r";
        } else if (8192 <= code && code <= 8203) {
          return "w";
        } else if (code == 8204) {
          return "b";
        } else {
          return "L";
        }
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      function BidiSpan(level, from, to) {
        this.level = level;
        this.from = from;
        this.to = to;
      }
      return function(str, direction) {
        var outerType = direction == "ltr" ? "L" : "R";
        if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
          return false;
        }
        var len = str.length, types2 = [];
        for (var i3 = 0; i3 < len; ++i3) {
          types2.push(charType(str.charCodeAt(i3)));
        }
        for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
          var type2 = types2[i$12];
          if (type2 == "m") {
            types2[i$12] = prev;
          } else {
            prev = type2;
          }
        }
        for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
          var type$12 = types2[i$22];
          if (type$12 == "1" && cur == "r") {
            types2[i$22] = "n";
          } else if (isStrong.test(type$12)) {
            cur = type$12;
            if (type$12 == "r") {
              types2[i$22] = "R";
            }
          }
        }
        for (var i$3 = 1, prev$1 = types2[0]; i$3 < len - 1; ++i$3) {
          var type$2 = types2[i$3];
          if (type$2 == "+" && prev$1 == "1" && types2[i$3 + 1] == "1") {
            types2[i$3] = "1";
          } else if (type$2 == "," && prev$1 == types2[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
            types2[i$3] = prev$1;
          }
          prev$1 = type$2;
        }
        for (var i$4 = 0; i$4 < len; ++i$4) {
          var type$3 = types2[i$4];
          if (type$3 == ",") {
            types2[i$4] = "N";
          } else if (type$3 == "%") {
            var end2 = void 0;
            for (end2 = i$4 + 1; end2 < len && types2[end2] == "%"; ++end2) {
            }
            var replace2 = i$4 && types2[i$4 - 1] == "!" || end2 < len && types2[end2] == "1" ? "1" : "N";
            for (var j = i$4; j < end2; ++j) {
              types2[j] = replace2;
            }
            i$4 = end2 - 1;
          }
        }
        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
          var type$4 = types2[i$5];
          if (cur$1 == "L" && type$4 == "1") {
            types2[i$5] = "L";
          } else if (isStrong.test(type$4)) {
            cur$1 = type$4;
          }
        }
        for (var i$6 = 0; i$6 < len; ++i$6) {
          if (isNeutral.test(types2[i$6])) {
            var end$1 = void 0;
            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types2[end$1]); ++end$1) {
            }
            var before = (i$6 ? types2[i$6 - 1] : outerType) == "L";
            var after = (end$1 < len ? types2[end$1] : outerType) == "L";
            var replace$1 = before == after ? before ? "L" : "R" : outerType;
            for (var j$1 = i$6; j$1 < end$1; ++j$1) {
              types2[j$1] = replace$1;
            }
            i$6 = end$1 - 1;
          }
        }
        var order2 = [], m;
        for (var i$7 = 0; i$7 < len; ) {
          if (countsAsLeft.test(types2[i$7])) {
            var start2 = i$7;
            for (++i$7; i$7 < len && countsAsLeft.test(types2[i$7]); ++i$7) {
            }
            order2.push(new BidiSpan(0, start2, i$7));
          } else {
            var pos = i$7, at = order2.length, isRTL2 = direction == "rtl" ? 1 : 0;
            for (++i$7; i$7 < len && types2[i$7] != "L"; ++i$7) {
            }
            for (var j$2 = pos; j$2 < i$7; ) {
              if (countsAsNum.test(types2[j$2])) {
                if (pos < j$2) {
                  order2.splice(at, 0, new BidiSpan(1, pos, j$2));
                  at += isRTL2;
                }
                var nstart = j$2;
                for (++j$2; j$2 < i$7 && countsAsNum.test(types2[j$2]); ++j$2) {
                }
                order2.splice(at, 0, new BidiSpan(2, nstart, j$2));
                at += isRTL2;
                pos = j$2;
              } else {
                ++j$2;
              }
            }
            if (pos < i$7) {
              order2.splice(at, 0, new BidiSpan(1, pos, i$7));
            }
          }
        }
        if (direction == "ltr") {
          if (order2[0].level == 1 && (m = str.match(/^\s+/))) {
            order2[0].from = m[0].length;
            order2.unshift(new BidiSpan(0, 0, m[0].length));
          }
          if (lst2(order2).level == 1 && (m = str.match(/\s+$/))) {
            lst2(order2).to -= m[0].length;
            order2.push(new BidiSpan(0, len - m[0].length, len));
          }
        }
        return direction == "rtl" ? order2.reverse() : order2;
      };
    }();
    function getOrder2(line, direction) {
      var order2 = line.order;
      if (order2 == null) {
        order2 = line.order = bidiOrdering2(line.text, direction);
      }
      return order2;
    }
    var noHandlers2 = [];
    var on2 = function(emitter, type2, f) {
      if (emitter.addEventListener) {
        emitter.addEventListener(type2, f, false);
      } else if (emitter.attachEvent) {
        emitter.attachEvent("on" + type2, f);
      } else {
        var map3 = emitter._handlers || (emitter._handlers = {});
        map3[type2] = (map3[type2] || noHandlers2).concat(f);
      }
    };
    function getHandlers2(emitter, type2) {
      return emitter._handlers && emitter._handlers[type2] || noHandlers2;
    }
    function off2(emitter, type2, f) {
      if (emitter.removeEventListener) {
        emitter.removeEventListener(type2, f, false);
      } else if (emitter.detachEvent) {
        emitter.detachEvent("on" + type2, f);
      } else {
        var map3 = emitter._handlers, arr = map3 && map3[type2];
        if (arr) {
          var index2 = indexOf2(arr, f);
          if (index2 > -1) {
            map3[type2] = arr.slice(0, index2).concat(arr.slice(index2 + 1));
          }
        }
      }
    }
    function signal2(emitter, type2) {
      var handlers = getHandlers2(emitter, type2);
      if (!handlers.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2);
      for (var i3 = 0; i3 < handlers.length; ++i3) {
        handlers[i3].apply(null, args);
      }
    }
    function signalDOMEvent2(cm, e, override) {
      if (typeof e == "string") {
        e = { type: e, preventDefault: function() {
          this.defaultPrevented = true;
        } };
      }
      signal2(cm, override || e.type, cm, e);
      return e_defaultPrevented2(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity2(cm) {
      var arr = cm._handlers && cm._handlers.cursorActivity;
      if (!arr) {
        return;
      }
      var set2 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
      for (var i3 = 0; i3 < arr.length; ++i3) {
        if (indexOf2(set2, arr[i3]) == -1) {
          set2.push(arr[i3]);
        }
      }
    }
    function hasHandler2(emitter, type2) {
      return getHandlers2(emitter, type2).length > 0;
    }
    function eventMixin2(ctor) {
      ctor.prototype.on = function(type2, f) {
        on2(this, type2, f);
      };
      ctor.prototype.off = function(type2, f) {
        off2(this, type2, f);
      };
    }
    function e_preventDefault2(e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
    }
    function e_stopPropagation2(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    }
    function e_defaultPrevented2(e) {
      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
    }
    function e_stop2(e) {
      e_preventDefault2(e);
      e_stopPropagation2(e);
    }
    function e_target2(e) {
      return e.target || e.srcElement;
    }
    function e_button2(e) {
      var b = e.which;
      if (b == null) {
        if (e.button & 1) {
          b = 1;
        } else if (e.button & 2) {
          b = 3;
        } else if (e.button & 4) {
          b = 2;
        }
      }
      if (mac2 && e.ctrlKey && b == 1) {
        b = 3;
      }
      return b;
    }
    var dragAndDrop2 = function() {
      if (ie2 && ie_version2 < 9) {
        return false;
      }
      var div = elt2("div");
      return "draggable" in div || "dragDrop" in div;
    }();
    var zwspSupported2;
    function zeroWidthElement2(measure) {
      if (zwspSupported2 == null) {
        var test = elt2("span", "\u200B");
        removeChildrenAndAdd2(measure, elt2("span", [test, document.createTextNode("x")]));
        if (measure.firstChild.offsetHeight != 0) {
          zwspSupported2 = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie2 && ie_version2 < 8);
        }
      }
      var node = zwspSupported2 ? elt2("span", "\u200B") : elt2("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
      node.setAttribute("cm-text", "");
      return node;
    }
    var badBidiRects2;
    function hasBadBidiRects2(measure) {
      if (badBidiRects2 != null) {
        return badBidiRects2;
      }
      var txt = removeChildrenAndAdd2(measure, document.createTextNode("A\u062EA"));
      var r0 = range2(txt, 0, 1).getBoundingClientRect();
      var r1 = range2(txt, 1, 2).getBoundingClientRect();
      removeChildren2(measure);
      if (!r0 || r0.left == r0.right) {
        return false;
      }
      return badBidiRects2 = r1.right - r0.right < 3;
    }
    var splitLinesAuto2 = "\n\nb".split(/\n/).length != 3 ? function(string2) {
      var pos = 0, result = [], l = string2.length;
      while (pos <= l) {
        var nl = string2.indexOf("\n", pos);
        if (nl == -1) {
          nl = string2.length;
        }
        var line = string2.slice(pos, string2.charAt(nl - 1) == "\r" ? nl - 1 : nl);
        var rt = line.indexOf("\r");
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function(string2) {
      return string2.split(/\r\n?|\n/);
    };
    var hasSelection2 = window.getSelection ? function(te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function(te) {
      var range3;
      try {
        range3 = te.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range3 || range3.parentElement() != te) {
        return false;
      }
      return range3.compareEndPoints("StartToEnd", range3) != 0;
    };
    var hasCopyEvent2 = function() {
      var e = elt2("div");
      if ("oncopy" in e) {
        return true;
      }
      e.setAttribute("oncopy", "return;");
      return typeof e.oncopy == "function";
    }();
    var badZoomedRects2 = null;
    function hasBadZoomedRects2(measure) {
      if (badZoomedRects2 != null) {
        return badZoomedRects2;
      }
      var node = removeChildrenAndAdd2(measure, elt2("span", "x"));
      var normal = node.getBoundingClientRect();
      var fromRange = range2(node, 0, 1).getBoundingClientRect();
      return badZoomedRects2 = Math.abs(normal.left - fromRange.left) > 1;
    }
    var modes2 = {}, mimeModes2 = {};
    function defineMode2(name2, mode) {
      if (arguments.length > 2) {
        mode.dependencies = Array.prototype.slice.call(arguments, 2);
      }
      modes2[name2] = mode;
    }
    function defineMIME2(mime, spec) {
      mimeModes2[mime] = spec;
    }
    function resolveMode2(spec) {
      if (typeof spec == "string" && mimeModes2.hasOwnProperty(spec)) {
        spec = mimeModes2[spec];
      } else if (spec && typeof spec.name == "string" && mimeModes2.hasOwnProperty(spec.name)) {
        var found = mimeModes2[spec.name];
        if (typeof found == "string") {
          found = { name: found };
        }
        spec = createObj2(found, spec);
        spec.name = found.name;
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
        return resolveMode2("application/xml");
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
        return resolveMode2("application/json");
      }
      if (typeof spec == "string") {
        return { name: spec };
      } else {
        return spec || { name: "null" };
      }
    }
    function getMode2(options2, spec) {
      spec = resolveMode2(spec);
      var mfactory = modes2[spec.name];
      if (!mfactory) {
        return getMode2(options2, "text/plain");
      }
      var modeObj = mfactory(options2, spec);
      if (modeExtensions2.hasOwnProperty(spec.name)) {
        var exts = modeExtensions2[spec.name];
        for (var prop2 in exts) {
          if (!exts.hasOwnProperty(prop2)) {
            continue;
          }
          if (modeObj.hasOwnProperty(prop2)) {
            modeObj["_" + prop2] = modeObj[prop2];
          }
          modeObj[prop2] = exts[prop2];
        }
      }
      modeObj.name = spec.name;
      if (spec.helperType) {
        modeObj.helperType = spec.helperType;
      }
      if (spec.modeProps) {
        for (var prop$1 in spec.modeProps) {
          modeObj[prop$1] = spec.modeProps[prop$1];
        }
      }
      return modeObj;
    }
    var modeExtensions2 = {};
    function extendMode2(mode, properties) {
      var exts = modeExtensions2.hasOwnProperty(mode) ? modeExtensions2[mode] : modeExtensions2[mode] = {};
      copyObj2(properties, exts);
    }
    function copyState2(mode, state) {
      if (state === true) {
        return state;
      }
      if (mode.copyState) {
        return mode.copyState(state);
      }
      var nstate = {};
      for (var n in state) {
        var val = state[n];
        if (val instanceof Array) {
          val = val.concat([]);
        }
        nstate[n] = val;
      }
      return nstate;
    }
    function innerMode2(mode, state) {
      var info;
      while (mode.innerMode) {
        info = mode.innerMode(state);
        if (!info || info.mode == mode) {
          break;
        }
        state = info.state;
        mode = info.mode;
      }
      return info || { mode, state };
    }
    function startState2(mode, a1, a2) {
      return mode.startState ? mode.startState(a1, a2) : true;
    }
    var StringStream2 = function(string2, tabSize, lineOracle) {
      this.pos = this.start = 0;
      this.string = string2;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
      this.lineOracle = lineOracle;
    };
    StringStream2.prototype.eol = function() {
      return this.pos >= this.string.length;
    };
    StringStream2.prototype.sol = function() {
      return this.pos == this.lineStart;
    };
    StringStream2.prototype.peek = function() {
      return this.string.charAt(this.pos) || void 0;
    };
    StringStream2.prototype.next = function() {
      if (this.pos < this.string.length) {
        return this.string.charAt(this.pos++);
      }
    };
    StringStream2.prototype.eat = function(match) {
      var ch = this.string.charAt(this.pos);
      var ok;
      if (typeof match == "string") {
        ok = ch == match;
      } else {
        ok = ch && (match.test ? match.test(ch) : match(ch));
      }
      if (ok) {
        ++this.pos;
        return ch;
      }
    };
    StringStream2.prototype.eatWhile = function(match) {
      var start2 = this.pos;
      while (this.eat(match)) {
      }
      return this.pos > start2;
    };
    StringStream2.prototype.eatSpace = function() {
      var start2 = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
        ++this.pos;
      }
      return this.pos > start2;
    };
    StringStream2.prototype.skipToEnd = function() {
      this.pos = this.string.length;
    };
    StringStream2.prototype.skipTo = function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    };
    StringStream2.prototype.backUp = function(n) {
      this.pos -= n;
    };
    StringStream2.prototype.column = function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn2(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn2(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream2.prototype.indentation = function() {
      return countColumn2(this.string, null, this.tabSize) - (this.lineStart ? countColumn2(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream2.prototype.match = function(pattern2, consume, caseInsensitive) {
      if (typeof pattern2 == "string") {
        var cased = function(str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern2.length);
        if (cased(substr) == cased(pattern2)) {
          if (consume !== false) {
            this.pos += pattern2.length;
          }
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern2);
        if (match && match.index > 0) {
          return null;
        }
        if (match && consume !== false) {
          this.pos += match[0].length;
        }
        return match;
      }
    };
    StringStream2.prototype.current = function() {
      return this.string.slice(this.start, this.pos);
    };
    StringStream2.prototype.hideFirstChars = function(n, inner) {
      this.lineStart += n;
      try {
        return inner();
      } finally {
        this.lineStart -= n;
      }
    };
    StringStream2.prototype.lookAhead = function(n) {
      var oracle = this.lineOracle;
      return oracle && oracle.lookAhead(n);
    };
    StringStream2.prototype.baseToken = function() {
      var oracle = this.lineOracle;
      return oracle && oracle.baseToken(this.pos);
    };
    function getLine2(doc, n) {
      n -= doc.first;
      if (n < 0 || n >= doc.size) {
        throw new Error("There is no line " + (n + doc.first) + " in the document.");
      }
      var chunk = doc;
      while (!chunk.lines) {
        for (var i3 = 0; ; ++i3) {
          var child = chunk.children[i3], sz = child.chunkSize();
          if (n < sz) {
            chunk = child;
            break;
          }
          n -= sz;
        }
      }
      return chunk.lines[n];
    }
    function getBetween2(doc, start2, end2) {
      var out = [], n = start2.line;
      doc.iter(start2.line, end2.line + 1, function(line) {
        var text = line.text;
        if (n == end2.line) {
          text = text.slice(0, end2.ch);
        }
        if (n == start2.line) {
          text = text.slice(start2.ch);
        }
        out.push(text);
        ++n;
      });
      return out;
    }
    function getLines2(doc, from, to) {
      var out = [];
      doc.iter(from, to, function(line) {
        out.push(line.text);
      });
      return out;
    }
    function updateLineHeight2(line, height) {
      var diff = height - line.height;
      if (diff) {
        for (var n = line; n; n = n.parent) {
          n.height += diff;
        }
      }
    }
    function lineNo2(line) {
      if (line.parent == null) {
        return null;
      }
      var cur = line.parent, no = indexOf2(cur.lines, line);
      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
        for (var i3 = 0; ; ++i3) {
          if (chunk.children[i3] == cur) {
            break;
          }
          no += chunk.children[i3].chunkSize();
        }
      }
      return no + cur.first;
    }
    function lineAtHeight2(chunk, h2) {
      var n = chunk.first;
      outer:
        do {
          for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
            var child = chunk.children[i$12], ch = child.height;
            if (h2 < ch) {
              chunk = child;
              continue outer;
            }
            h2 -= ch;
            n += child.chunkSize();
          }
          return n;
        } while (!chunk.lines);
      var i3 = 0;
      for (; i3 < chunk.lines.length; ++i3) {
        var line = chunk.lines[i3], lh = line.height;
        if (h2 < lh) {
          break;
        }
        h2 -= lh;
      }
      return n + i3;
    }
    function isLine2(doc, l) {
      return l >= doc.first && l < doc.first + doc.size;
    }
    function lineNumberFor2(options2, i3) {
      return String(options2.lineNumberFormatter(i3 + options2.firstLineNumber));
    }
    function Pos2(line, ch, sticky) {
      if (sticky === void 0)
        sticky = null;
      if (!(this instanceof Pos2)) {
        return new Pos2(line, ch, sticky);
      }
      this.line = line;
      this.ch = ch;
      this.sticky = sticky;
    }
    function cmp2(a, b) {
      return a.line - b.line || a.ch - b.ch;
    }
    function equalCursorPos2(a, b) {
      return a.sticky == b.sticky && cmp2(a, b) == 0;
    }
    function copyPos2(x) {
      return Pos2(x.line, x.ch);
    }
    function maxPos2(a, b) {
      return cmp2(a, b) < 0 ? b : a;
    }
    function minPos2(a, b) {
      return cmp2(a, b) < 0 ? a : b;
    }
    function clipLine2(doc, n) {
      return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
    }
    function clipPos2(doc, pos) {
      if (pos.line < doc.first) {
        return Pos2(doc.first, 0);
      }
      var last = doc.first + doc.size - 1;
      if (pos.line > last) {
        return Pos2(last, getLine2(doc, last).text.length);
      }
      return clipToLen2(pos, getLine2(doc, pos.line).text.length);
    }
    function clipToLen2(pos, linelen) {
      var ch = pos.ch;
      if (ch == null || ch > linelen) {
        return Pos2(pos.line, linelen);
      } else if (ch < 0) {
        return Pos2(pos.line, 0);
      } else {
        return pos;
      }
    }
    function clipPosArray2(doc, array3) {
      var out = [];
      for (var i3 = 0; i3 < array3.length; i3++) {
        out[i3] = clipPos2(doc, array3[i3]);
      }
      return out;
    }
    var SavedContext2 = function(state, lookAhead) {
      this.state = state;
      this.lookAhead = lookAhead;
    };
    var Context2 = function(doc, state, line, lookAhead) {
      this.state = state;
      this.doc = doc;
      this.line = line;
      this.maxLookAhead = lookAhead || 0;
      this.baseTokens = null;
      this.baseTokenPos = 1;
    };
    Context2.prototype.lookAhead = function(n) {
      var line = this.doc.getLine(this.line + n);
      if (line != null && n > this.maxLookAhead) {
        this.maxLookAhead = n;
      }
      return line;
    };
    Context2.prototype.baseToken = function(n) {
      if (!this.baseTokens) {
        return null;
      }
      while (this.baseTokens[this.baseTokenPos] <= n) {
        this.baseTokenPos += 2;
      }
      var type2 = this.baseTokens[this.baseTokenPos + 1];
      return {
        type: type2 && type2.replace(/( |^)overlay .*/, ""),
        size: this.baseTokens[this.baseTokenPos] - n
      };
    };
    Context2.prototype.nextLine = function() {
      this.line++;
      if (this.maxLookAhead > 0) {
        this.maxLookAhead--;
      }
    };
    Context2.fromSaved = function(doc, saved, line) {
      if (saved instanceof SavedContext2) {
        return new Context2(doc, copyState2(doc.mode, saved.state), line, saved.lookAhead);
      } else {
        return new Context2(doc, copyState2(doc.mode, saved), line);
      }
    };
    Context2.prototype.save = function(copy) {
      var state = copy !== false ? copyState2(this.doc.mode, this.state) : this.state;
      return this.maxLookAhead > 0 ? new SavedContext2(state, this.maxLookAhead) : state;
    };
    function highlightLine2(cm, line, context, forceToEnd) {
      var st = [cm.state.modeGen], lineClasses = {};
      runMode2(cm, line.text, cm.doc.mode, context, function(end2, style) {
        return st.push(end2, style);
      }, lineClasses, forceToEnd);
      var state = context.state;
      var loop = function(o2) {
        context.baseTokens = st;
        var overlay = cm.state.overlays[o2], i3 = 1, at = 0;
        context.state = true;
        runMode2(cm, line.text, overlay.mode, context, function(end2, style) {
          var start2 = i3;
          while (at < end2) {
            var i_end = st[i3];
            if (i_end > end2) {
              st.splice(i3, 1, end2, st[i3 + 1], i_end);
            }
            i3 += 2;
            at = Math.min(end2, i_end);
          }
          if (!style) {
            return;
          }
          if (overlay.opaque) {
            st.splice(start2, i3 - start2, end2, "overlay " + style);
            i3 = start2 + 2;
          } else {
            for (; start2 < i3; start2 += 2) {
              var cur = st[start2 + 1];
              st[start2 + 1] = (cur ? cur + " " : "") + "overlay " + style;
            }
          }
        }, lineClasses);
        context.state = state;
        context.baseTokens = null;
        context.baseTokenPos = 1;
      };
      for (var o = 0; o < cm.state.overlays.length; ++o)
        loop(o);
      return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
    }
    function getLineStyles2(cm, line, updateFrontier) {
      if (!line.styles || line.styles[0] != cm.state.modeGen) {
        var context = getContextBefore2(cm, lineNo2(line));
        var resetState = line.text.length > cm.options.maxHighlightLength && copyState2(cm.doc.mode, context.state);
        var result = highlightLine2(cm, line, context);
        if (resetState) {
          context.state = resetState;
        }
        line.stateAfter = context.save(!resetState);
        line.styles = result.styles;
        if (result.classes) {
          line.styleClasses = result.classes;
        } else if (line.styleClasses) {
          line.styleClasses = null;
        }
        if (updateFrontier === cm.doc.highlightFrontier) {
          cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
        }
      }
      return line.styles;
    }
    function getContextBefore2(cm, n, precise) {
      var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) {
        return new Context2(doc, true, n);
      }
      var start2 = findStartLine2(cm, n, precise);
      var saved = start2 > doc.first && getLine2(doc, start2 - 1).stateAfter;
      var context = saved ? Context2.fromSaved(doc, saved, start2) : new Context2(doc, startState2(doc.mode), start2);
      doc.iter(start2, n, function(line) {
        processLine2(cm, line.text, context);
        var pos = context.line;
        line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
        context.nextLine();
      });
      if (precise) {
        doc.modeFrontier = context.line;
      }
      return context;
    }
    function processLine2(cm, text, context, startAt) {
      var mode = cm.doc.mode;
      var stream = new StringStream2(text, cm.options.tabSize, context);
      stream.start = stream.pos = startAt || 0;
      if (text == "") {
        callBlankLine2(mode, context.state);
      }
      while (!stream.eol()) {
        readToken2(mode, stream, context.state);
        stream.start = stream.pos;
      }
    }
    function callBlankLine2(mode, state) {
      if (mode.blankLine) {
        return mode.blankLine(state);
      }
      if (!mode.innerMode) {
        return;
      }
      var inner = innerMode2(mode, state);
      if (inner.mode.blankLine) {
        return inner.mode.blankLine(inner.state);
      }
    }
    function readToken2(mode, stream, state, inner) {
      for (var i3 = 0; i3 < 10; i3++) {
        if (inner) {
          inner[0] = innerMode2(mode, state).mode;
        }
        var style = mode.token(stream, state);
        if (stream.pos > stream.start) {
          return style;
        }
      }
      throw new Error("Mode " + mode.name + " failed to advance stream.");
    }
    var Token2 = function(stream, type2, state) {
      this.start = stream.start;
      this.end = stream.pos;
      this.string = stream.current();
      this.type = type2 || null;
      this.state = state;
    };
    function takeToken2(cm, pos, precise, asArray) {
      var doc = cm.doc, mode = doc.mode, style;
      pos = clipPos2(doc, pos);
      var line = getLine2(doc, pos.line), context = getContextBefore2(cm, pos.line, precise);
      var stream = new StringStream2(line.text, cm.options.tabSize, context), tokens;
      if (asArray) {
        tokens = [];
      }
      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
        stream.start = stream.pos;
        style = readToken2(mode, stream, context.state);
        if (asArray) {
          tokens.push(new Token2(stream, style, copyState2(doc.mode, context.state)));
        }
      }
      return asArray ? tokens : new Token2(stream, style, context.state);
    }
    function extractLineClasses2(type2, output) {
      if (type2) {
        for (; ; ) {
          var lineClass = type2.match(/(?:^|\s+)line-(background-)?(\S+)/);
          if (!lineClass) {
            break;
          }
          type2 = type2.slice(0, lineClass.index) + type2.slice(lineClass.index + lineClass[0].length);
          var prop2 = lineClass[1] ? "bgClass" : "textClass";
          if (output[prop2] == null) {
            output[prop2] = lineClass[2];
          } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
            output[prop2] += " " + lineClass[2];
          }
        }
      }
      return type2;
    }
    function runMode2(cm, text, mode, context, f, lineClasses, forceToEnd) {
      var flattenSpans = mode.flattenSpans;
      if (flattenSpans == null) {
        flattenSpans = cm.options.flattenSpans;
      }
      var curStart = 0, curStyle = null;
      var stream = new StringStream2(text, cm.options.tabSize, context), style;
      var inner = cm.options.addModeClass && [null];
      if (text == "") {
        extractLineClasses2(callBlankLine2(mode, context.state), lineClasses);
      }
      while (!stream.eol()) {
        if (stream.pos > cm.options.maxHighlightLength) {
          flattenSpans = false;
          if (forceToEnd) {
            processLine2(cm, text, context, stream.pos);
          }
          stream.pos = text.length;
          style = null;
        } else {
          style = extractLineClasses2(readToken2(mode, stream, context.state, inner), lineClasses);
        }
        if (inner) {
          var mName = inner[0].name;
          if (mName) {
            style = "m-" + (style ? mName + " " + style : mName);
          }
        }
        if (!flattenSpans || curStyle != style) {
          while (curStart < stream.start) {
            curStart = Math.min(stream.start, curStart + 5e3);
            f(curStart, curStyle);
          }
          curStyle = style;
        }
        stream.start = stream.pos;
      }
      while (curStart < stream.pos) {
        var pos = Math.min(stream.pos, curStart + 5e3);
        f(pos, curStyle);
        curStart = pos;
      }
    }
    function findStartLine2(cm, n, precise) {
      var minindent, minline, doc = cm.doc;
      var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
      for (var search = n; search > lim; --search) {
        if (search <= doc.first) {
          return doc.first;
        }
        var line = getLine2(doc, search - 1), after = line.stateAfter;
        if (after && (!precise || search + (after instanceof SavedContext2 ? after.lookAhead : 0) <= doc.modeFrontier)) {
          return search;
        }
        var indented = countColumn2(line.text, null, cm.options.tabSize);
        if (minline == null || minindent > indented) {
          minline = search - 1;
          minindent = indented;
        }
      }
      return minline;
    }
    function retreatFrontier2(doc, n) {
      doc.modeFrontier = Math.min(doc.modeFrontier, n);
      if (doc.highlightFrontier < n - 10) {
        return;
      }
      var start2 = doc.first;
      for (var line = n - 1; line > start2; line--) {
        var saved = getLine2(doc, line).stateAfter;
        if (saved && (!(saved instanceof SavedContext2) || line + saved.lookAhead < n)) {
          start2 = line + 1;
          break;
        }
      }
      doc.highlightFrontier = Math.min(doc.highlightFrontier, start2);
    }
    var sawReadOnlySpans2 = false, sawCollapsedSpans2 = false;
    function seeReadOnlySpans2() {
      sawReadOnlySpans2 = true;
    }
    function seeCollapsedSpans2() {
      sawCollapsedSpans2 = true;
    }
    function MarkedSpan2(marker, from, to) {
      this.marker = marker;
      this.from = from;
      this.to = to;
    }
    function getMarkedSpanFor2(spans, marker) {
      if (spans) {
        for (var i3 = 0; i3 < spans.length; ++i3) {
          var span = spans[i3];
          if (span.marker == marker) {
            return span;
          }
        }
      }
    }
    function removeMarkedSpan2(spans, span) {
      var r;
      for (var i3 = 0; i3 < spans.length; ++i3) {
        if (spans[i3] != span) {
          (r || (r = [])).push(spans[i3]);
        }
      }
      return r;
    }
    function addMarkedSpan2(line, span, op) {
      var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));
      if (inThisOp && inThisOp.has(line.markedSpans)) {
        line.markedSpans.push(span);
      } else {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        if (inThisOp) {
          inThisOp.add(line.markedSpans);
        }
      }
      span.marker.attachLine(line);
    }
    function markedSpansBefore2(old, startCh, isInsert) {
      var nw;
      if (old) {
        for (var i3 = 0; i3 < old.length; ++i3) {
          var span = old[i3], marker = span.marker;
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
          if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
            (nw || (nw = [])).push(new MarkedSpan2(marker, span.from, endsAfter ? null : span.to));
          }
        }
      }
      return nw;
    }
    function markedSpansAfter2(old, endCh, isInsert) {
      var nw;
      if (old) {
        for (var i3 = 0; i3 < old.length; ++i3) {
          var span = old[i3], marker = span.marker;
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
          if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
            (nw || (nw = [])).push(new MarkedSpan2(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
          }
        }
      }
      return nw;
    }
    function stretchSpansOverChange2(doc, change) {
      if (change.full) {
        return null;
      }
      var oldFirst = isLine2(doc, change.from.line) && getLine2(doc, change.from.line).markedSpans;
      var oldLast = isLine2(doc, change.to.line) && getLine2(doc, change.to.line).markedSpans;
      if (!oldFirst && !oldLast) {
        return null;
      }
      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp2(change.from, change.to) == 0;
      var first = markedSpansBefore2(oldFirst, startCh, isInsert);
      var last = markedSpansAfter2(oldLast, endCh, isInsert);
      var sameLine = change.text.length == 1, offset2 = lst2(change.text).length + (sameLine ? startCh : 0);
      if (first) {
        for (var i3 = 0; i3 < first.length; ++i3) {
          var span = first[i3];
          if (span.to == null) {
            var found = getMarkedSpanFor2(last, span.marker);
            if (!found) {
              span.to = startCh;
            } else if (sameLine) {
              span.to = found.to == null ? null : found.to + offset2;
            }
          }
        }
      }
      if (last) {
        for (var i$12 = 0; i$12 < last.length; ++i$12) {
          var span$1 = last[i$12];
          if (span$1.to != null) {
            span$1.to += offset2;
          }
          if (span$1.from == null) {
            var found$1 = getMarkedSpanFor2(first, span$1.marker);
            if (!found$1) {
              span$1.from = offset2;
              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          } else {
            span$1.from += offset2;
            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        }
      }
      if (first) {
        first = clearEmptySpans2(first);
      }
      if (last && last != first) {
        last = clearEmptySpans2(last);
      }
      var newMarkers = [first];
      if (!sameLine) {
        var gap = change.text.length - 2, gapMarkers;
        if (gap > 0 && first) {
          for (var i$22 = 0; i$22 < first.length; ++i$22) {
            if (first[i$22].to == null) {
              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan2(first[i$22].marker, null, null));
            }
          }
        }
        for (var i$3 = 0; i$3 < gap; ++i$3) {
          newMarkers.push(gapMarkers);
        }
        newMarkers.push(last);
      }
      return newMarkers;
    }
    function clearEmptySpans2(spans) {
      for (var i3 = 0; i3 < spans.length; ++i3) {
        var span = spans[i3];
        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
          spans.splice(i3--, 1);
        }
      }
      if (!spans.length) {
        return null;
      }
      return spans;
    }
    function removeReadOnlyRanges2(doc, from, to) {
      var markers = null;
      doc.iter(from.line, to.line + 1, function(line) {
        if (line.markedSpans) {
          for (var i4 = 0; i4 < line.markedSpans.length; ++i4) {
            var mark = line.markedSpans[i4].marker;
            if (mark.readOnly && (!markers || indexOf2(markers, mark) == -1)) {
              (markers || (markers = [])).push(mark);
            }
          }
        }
      });
      if (!markers) {
        return null;
      }
      var parts = [{ from, to }];
      for (var i3 = 0; i3 < markers.length; ++i3) {
        var mk = markers[i3], m = mk.find(0);
        for (var j = 0; j < parts.length; ++j) {
          var p = parts[j];
          if (cmp2(p.to, m.from) < 0 || cmp2(p.from, m.to) > 0) {
            continue;
          }
          var newParts = [j, 1], dfrom = cmp2(p.from, m.from), dto = cmp2(p.to, m.to);
          if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
            newParts.push({ from: p.from, to: m.from });
          }
          if (dto > 0 || !mk.inclusiveRight && !dto) {
            newParts.push({ from: m.to, to: p.to });
          }
          parts.splice.apply(parts, newParts);
          j += newParts.length - 3;
        }
      }
      return parts;
    }
    function detachMarkedSpans2(line) {
      var spans = line.markedSpans;
      if (!spans) {
        return;
      }
      for (var i3 = 0; i3 < spans.length; ++i3) {
        spans[i3].marker.detachLine(line);
      }
      line.markedSpans = null;
    }
    function attachMarkedSpans2(line, spans) {
      if (!spans) {
        return;
      }
      for (var i3 = 0; i3 < spans.length; ++i3) {
        spans[i3].marker.attachLine(line);
      }
      line.markedSpans = spans;
    }
    function extraLeft2(marker) {
      return marker.inclusiveLeft ? -1 : 0;
    }
    function extraRight2(marker) {
      return marker.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers2(a, b) {
      var lenDiff = a.lines.length - b.lines.length;
      if (lenDiff != 0) {
        return lenDiff;
      }
      var aPos = a.find(), bPos = b.find();
      var fromCmp = cmp2(aPos.from, bPos.from) || extraLeft2(a) - extraLeft2(b);
      if (fromCmp) {
        return -fromCmp;
      }
      var toCmp = cmp2(aPos.to, bPos.to) || extraRight2(a) - extraRight2(b);
      if (toCmp) {
        return toCmp;
      }
      return b.id - a.id;
    }
    function collapsedSpanAtSide2(line, start2) {
      var sps = sawCollapsedSpans2 && line.markedSpans, found;
      if (sps) {
        for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
          sp = sps[i3];
          if (sp.marker.collapsed && (start2 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers2(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function collapsedSpanAtStart2(line) {
      return collapsedSpanAtSide2(line, true);
    }
    function collapsedSpanAtEnd2(line) {
      return collapsedSpanAtSide2(line, false);
    }
    function collapsedSpanAround2(line, ch) {
      var sps = sawCollapsedSpans2 && line.markedSpans, found;
      if (sps) {
        for (var i3 = 0; i3 < sps.length; ++i3) {
          var sp = sps[i3];
          if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers2(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function conflictingCollapsedRange2(doc, lineNo3, from, to, marker) {
      var line = getLine2(doc, lineNo3);
      var sps = sawCollapsedSpans2 && line.markedSpans;
      if (sps) {
        for (var i3 = 0; i3 < sps.length; ++i3) {
          var sp = sps[i3];
          if (!sp.marker.collapsed) {
            continue;
          }
          var found = sp.marker.find(0);
          var fromCmp = cmp2(found.from, from) || extraLeft2(sp.marker) - extraLeft2(marker);
          var toCmp = cmp2(found.to, to) || extraRight2(sp.marker) - extraRight2(marker);
          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
            continue;
          }
          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp2(found.to, from) >= 0 : cmp2(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp2(found.from, to) <= 0 : cmp2(found.from, to) < 0)) {
            return true;
          }
        }
      }
    }
    function visualLine2(line) {
      var merged;
      while (merged = collapsedSpanAtStart2(line)) {
        line = merged.find(-1, true).line;
      }
      return line;
    }
    function visualLineEnd2(line) {
      var merged;
      while (merged = collapsedSpanAtEnd2(line)) {
        line = merged.find(1, true).line;
      }
      return line;
    }
    function visualLineContinued2(line) {
      var merged, lines;
      while (merged = collapsedSpanAtEnd2(line)) {
        line = merged.find(1, true).line;
        (lines || (lines = [])).push(line);
      }
      return lines;
    }
    function visualLineNo2(doc, lineN) {
      var line = getLine2(doc, lineN), vis = visualLine2(line);
      if (line == vis) {
        return lineN;
      }
      return lineNo2(vis);
    }
    function visualLineEndNo2(doc, lineN) {
      if (lineN > doc.lastLine()) {
        return lineN;
      }
      var line = getLine2(doc, lineN), merged;
      if (!lineIsHidden2(doc, line)) {
        return lineN;
      }
      while (merged = collapsedSpanAtEnd2(line)) {
        line = merged.find(1, true).line;
      }
      return lineNo2(line) + 1;
    }
    function lineIsHidden2(doc, line) {
      var sps = sawCollapsedSpans2 && line.markedSpans;
      if (sps) {
        for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
          sp = sps[i3];
          if (!sp.marker.collapsed) {
            continue;
          }
          if (sp.from == null) {
            return true;
          }
          if (sp.marker.widgetNode) {
            continue;
          }
          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner2(doc, line, sp)) {
            return true;
          }
        }
      }
    }
    function lineIsHiddenInner2(doc, line, span) {
      if (span.to == null) {
        var end2 = span.marker.find(1, true);
        return lineIsHiddenInner2(doc, end2.line, getMarkedSpanFor2(end2.line.markedSpans, span.marker));
      }
      if (span.marker.inclusiveRight && span.to == line.text.length) {
        return true;
      }
      for (var sp = void 0, i3 = 0; i3 < line.markedSpans.length; ++i3) {
        sp = line.markedSpans[i3];
        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner2(doc, line, sp)) {
          return true;
        }
      }
    }
    function heightAtLine2(lineObj) {
      lineObj = visualLine2(lineObj);
      var h2 = 0, chunk = lineObj.parent;
      for (var i3 = 0; i3 < chunk.lines.length; ++i3) {
        var line = chunk.lines[i3];
        if (line == lineObj) {
          break;
        } else {
          h2 += line.height;
        }
      }
      for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
        for (var i$12 = 0; i$12 < p.children.length; ++i$12) {
          var cur = p.children[i$12];
          if (cur == chunk) {
            break;
          } else {
            h2 += cur.height;
          }
        }
      }
      return h2;
    }
    function lineLength2(line) {
      if (line.height == 0) {
        return 0;
      }
      var len = line.text.length, merged, cur = line;
      while (merged = collapsedSpanAtStart2(cur)) {
        var found = merged.find(0, true);
        cur = found.from.line;
        len += found.from.ch - found.to.ch;
      }
      cur = line;
      while (merged = collapsedSpanAtEnd2(cur)) {
        var found$1 = merged.find(0, true);
        len -= cur.text.length - found$1.from.ch;
        cur = found$1.to.line;
        len += cur.text.length - found$1.to.ch;
      }
      return len;
    }
    function findMaxLine2(cm) {
      var d = cm.display, doc = cm.doc;
      d.maxLine = getLine2(doc, doc.first);
      d.maxLineLength = lineLength2(d.maxLine);
      d.maxLineChanged = true;
      doc.iter(function(line) {
        var len = lineLength2(line);
        if (len > d.maxLineLength) {
          d.maxLineLength = len;
          d.maxLine = line;
        }
      });
    }
    var Line2 = function(text, markedSpans, estimateHeight3) {
      this.text = text;
      attachMarkedSpans2(this, markedSpans);
      this.height = estimateHeight3 ? estimateHeight3(this) : 1;
    };
    Line2.prototype.lineNo = function() {
      return lineNo2(this);
    };
    eventMixin2(Line2);
    function updateLine2(line, text, markedSpans, estimateHeight3) {
      line.text = text;
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
      if (line.order != null) {
        line.order = null;
      }
      detachMarkedSpans2(line);
      attachMarkedSpans2(line, markedSpans);
      var estHeight = estimateHeight3 ? estimateHeight3(line) : 1;
      if (estHeight != line.height) {
        updateLineHeight2(line, estHeight);
      }
    }
    function cleanUpLine2(line) {
      line.parent = null;
      detachMarkedSpans2(line);
    }
    var styleToClassCache2 = {}, styleToClassCacheWithMode2 = {};
    function interpretTokenStyle2(style, options2) {
      if (!style || /^\s*$/.test(style)) {
        return null;
      }
      var cache = options2.addModeClass ? styleToClassCacheWithMode2 : styleToClassCache2;
      return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
    }
    function buildLineContent2(cm, lineView) {
      var content = eltP2("span", null, null, webkit2 ? "padding-right: .1px" : null);
      var builder = {
        pre: eltP2("pre", [content], "CodeMirror-line"),
        content,
        col: 0,
        pos: 0,
        cm,
        trailingSpace: false,
        splitSpaces: cm.getOption("lineWrapping")
      };
      lineView.measure = {};
      for (var i3 = 0; i3 <= (lineView.rest ? lineView.rest.length : 0); i3++) {
        var line = i3 ? lineView.rest[i3 - 1] : lineView.line, order2 = void 0;
        builder.pos = 0;
        builder.addToken = buildToken2;
        if (hasBadBidiRects2(cm.display.measure) && (order2 = getOrder2(line, cm.doc.direction))) {
          builder.addToken = buildTokenBadBidi2(builder.addToken, order2);
        }
        builder.map = [];
        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo2(line);
        insertLineContent2(line, builder, getLineStyles2(cm, line, allowFrontierUpdate));
        if (line.styleClasses) {
          if (line.styleClasses.bgClass) {
            builder.bgClass = joinClasses2(line.styleClasses.bgClass, builder.bgClass || "");
          }
          if (line.styleClasses.textClass) {
            builder.textClass = joinClasses2(line.styleClasses.textClass, builder.textClass || "");
          }
        }
        if (builder.map.length == 0) {
          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement2(cm.display.measure)));
        }
        if (i3 == 0) {
          lineView.measure.map = builder.map;
          lineView.measure.cache = {};
        } else {
          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
          (lineView.measure.caches || (lineView.measure.caches = [])).push({});
        }
      }
      if (webkit2) {
        var last = builder.content.lastChild;
        if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
          builder.content.className = "cm-tab-wrap-hack";
        }
      }
      signal2(cm, "renderLine", cm, lineView.line, builder.pre);
      if (builder.pre.className) {
        builder.textClass = joinClasses2(builder.pre.className, builder.textClass || "");
      }
      return builder;
    }
    function defaultSpecialCharPlaceholder2(ch) {
      var token = elt2("span", "\u2022", "cm-invalidchar");
      token.title = "\\u" + ch.charCodeAt(0).toString(16);
      token.setAttribute("aria-label", token.title);
      return token;
    }
    function buildToken2(builder, text, style, startStyle, endStyle, css, attributes2) {
      if (!text) {
        return;
      }
      var displayText = builder.splitSpaces ? splitSpaces2(text, builder.trailingSpace) : text;
      var special = builder.cm.state.specialChars, mustWrap = false;
      var content;
      if (!special.test(text)) {
        builder.col += text.length;
        content = document.createTextNode(displayText);
        builder.map.push(builder.pos, builder.pos + text.length, content);
        if (ie2 && ie_version2 < 9) {
          mustWrap = true;
        }
        builder.pos += text.length;
      } else {
        content = document.createDocumentFragment();
        var pos = 0;
        while (true) {
          special.lastIndex = pos;
          var m = special.exec(text);
          var skipped = m ? m.index - pos : text.length - pos;
          if (skipped) {
            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
            if (ie2 && ie_version2 < 9) {
              content.appendChild(elt2("span", [txt]));
            } else {
              content.appendChild(txt);
            }
            builder.map.push(builder.pos, builder.pos + skipped, txt);
            builder.col += skipped;
            builder.pos += skipped;
          }
          if (!m) {
            break;
          }
          pos += skipped + 1;
          var txt$1 = void 0;
          if (m[0] == "	") {
            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
            txt$1 = content.appendChild(elt2("span", spaceStr2(tabWidth), "cm-tab"));
            txt$1.setAttribute("role", "presentation");
            txt$1.setAttribute("cm-text", "	");
            builder.col += tabWidth;
          } else if (m[0] == "\r" || m[0] == "\n") {
            txt$1 = content.appendChild(elt2("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
            txt$1.setAttribute("cm-text", m[0]);
            builder.col += 1;
          } else {
            txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
            txt$1.setAttribute("cm-text", m[0]);
            if (ie2 && ie_version2 < 9) {
              content.appendChild(elt2("span", [txt$1]));
            } else {
              content.appendChild(txt$1);
            }
            builder.col += 1;
          }
          builder.map.push(builder.pos, builder.pos + 1, txt$1);
          builder.pos++;
        }
      }
      builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
      if (style || startStyle || endStyle || mustWrap || css || attributes2) {
        var fullStyle = style || "";
        if (startStyle) {
          fullStyle += startStyle;
        }
        if (endStyle) {
          fullStyle += endStyle;
        }
        var token = elt2("span", [content], fullStyle, css);
        if (attributes2) {
          for (var attr in attributes2) {
            if (attributes2.hasOwnProperty(attr) && attr != "style" && attr != "class") {
              token.setAttribute(attr, attributes2[attr]);
            }
          }
        }
        return builder.content.appendChild(token);
      }
      builder.content.appendChild(content);
    }
    function splitSpaces2(text, trailingBefore) {
      if (text.length > 1 && !/  /.test(text)) {
        return text;
      }
      var spaceBefore = trailingBefore, result = "";
      for (var i3 = 0; i3 < text.length; i3++) {
        var ch = text.charAt(i3);
        if (ch == " " && spaceBefore && (i3 == text.length - 1 || text.charCodeAt(i3 + 1) == 32)) {
          ch = "\xA0";
        }
        result += ch;
        spaceBefore = ch == " ";
      }
      return result;
    }
    function buildTokenBadBidi2(inner, order2) {
      return function(builder, text, style, startStyle, endStyle, css, attributes2) {
        style = style ? style + " cm-force-border" : "cm-force-border";
        var start2 = builder.pos, end2 = start2 + text.length;
        for (; ; ) {
          var part = void 0;
          for (var i3 = 0; i3 < order2.length; i3++) {
            part = order2[i3];
            if (part.to > start2 && part.from <= start2) {
              break;
            }
          }
          if (part.to >= end2) {
            return inner(builder, text, style, startStyle, endStyle, css, attributes2);
          }
          inner(builder, text.slice(0, part.to - start2), style, startStyle, null, css, attributes2);
          startStyle = null;
          text = text.slice(part.to - start2);
          start2 = part.to;
        }
      };
    }
    function buildCollapsedSpan2(builder, size, marker, ignoreWidget) {
      var widget = !ignoreWidget && marker.widgetNode;
      if (widget) {
        builder.map.push(builder.pos, builder.pos + size, widget);
      }
      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
        if (!widget) {
          widget = builder.content.appendChild(document.createElement("span"));
        }
        widget.setAttribute("cm-marker", marker.id);
      }
      if (widget) {
        builder.cm.display.input.setUneditable(widget);
        builder.content.appendChild(widget);
      }
      builder.pos += size;
      builder.trailingSpace = false;
    }
    function insertLineContent2(line, builder, styles) {
      var spans = line.markedSpans, allText = line.text, at = 0;
      if (!spans) {
        for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
          builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle2(styles[i$12 + 1], builder.cm.options));
        }
        return;
      }
      var len = allText.length, pos = 0, i3 = 1, text = "", style, css;
      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes2;
      for (; ; ) {
        if (nextChange == pos) {
          spanStyle = spanEndStyle = spanStartStyle = css = "";
          attributes2 = null;
          collapsed = null;
          nextChange = Infinity;
          var foundBookmarks = [], endStyles = void 0;
          for (var j = 0; j < spans.length; ++j) {
            var sp = spans[j], m = sp.marker;
            if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
              foundBookmarks.push(m);
            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
              if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                nextChange = sp.to;
                spanEndStyle = "";
              }
              if (m.className) {
                spanStyle += " " + m.className;
              }
              if (m.css) {
                css = (css ? css + ";" : "") + m.css;
              }
              if (m.startStyle && sp.from == pos) {
                spanStartStyle += " " + m.startStyle;
              }
              if (m.endStyle && sp.to == nextChange) {
                (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
              }
              if (m.title) {
                (attributes2 || (attributes2 = {})).title = m.title;
              }
              if (m.attributes) {
                for (var attr in m.attributes) {
                  (attributes2 || (attributes2 = {}))[attr] = m.attributes[attr];
                }
              }
              if (m.collapsed && (!collapsed || compareCollapsedMarkers2(collapsed.marker, m) < 0)) {
                collapsed = sp;
              }
            } else if (sp.from > pos && nextChange > sp.from) {
              nextChange = sp.from;
            }
          }
          if (endStyles) {
            for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
              if (endStyles[j$1 + 1] == nextChange) {
                spanEndStyle += " " + endStyles[j$1];
              }
            }
          }
          if (!collapsed || collapsed.from == pos) {
            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
              buildCollapsedSpan2(builder, 0, foundBookmarks[j$2]);
            }
          }
          if (collapsed && (collapsed.from || 0) == pos) {
            buildCollapsedSpan2(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
            if (collapsed.to == null) {
              return;
            }
            if (collapsed.to == pos) {
              collapsed = false;
            }
          }
        }
        if (pos >= len) {
          break;
        }
        var upto = Math.min(len, nextChange);
        while (true) {
          if (text) {
            var end2 = pos + text.length;
            if (!collapsed) {
              var tokenText = end2 > upto ? text.slice(0, upto - pos) : text;
              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes2);
            }
            if (end2 >= upto) {
              text = text.slice(upto - pos);
              pos = upto;
              break;
            }
            pos = end2;
            spanStartStyle = "";
          }
          text = allText.slice(at, at = styles[i3++]);
          style = interpretTokenStyle2(styles[i3++], builder.cm.options);
        }
      }
    }
    function LineView2(doc, line, lineN) {
      this.line = line;
      this.rest = visualLineContinued2(line);
      this.size = this.rest ? lineNo2(lst2(this.rest)) - lineN + 1 : 1;
      this.node = this.text = null;
      this.hidden = lineIsHidden2(doc, line);
    }
    function buildViewArray2(cm, from, to) {
      var array3 = [], nextPos;
      for (var pos = from; pos < to; pos = nextPos) {
        var view = new LineView2(cm.doc, getLine2(cm.doc, pos), pos);
        nextPos = pos + view.size;
        array3.push(view);
      }
      return array3;
    }
    var operationGroup2 = null;
    function pushOperation2(op) {
      if (operationGroup2) {
        operationGroup2.ops.push(op);
      } else {
        op.ownsGroup = operationGroup2 = {
          ops: [op],
          delayedCallbacks: []
        };
      }
    }
    function fireCallbacksForOps2(group) {
      var callbacks = group.delayedCallbacks, i3 = 0;
      do {
        for (; i3 < callbacks.length; i3++) {
          callbacks[i3].call(null);
        }
        for (var j = 0; j < group.ops.length; j++) {
          var op = group.ops[j];
          if (op.cursorActivityHandlers) {
            while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
              op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
            }
          }
        }
      } while (i3 < callbacks.length);
    }
    function finishOperation2(op, endCb) {
      var group = op.ownsGroup;
      if (!group) {
        return;
      }
      try {
        fireCallbacksForOps2(group);
      } finally {
        operationGroup2 = null;
        endCb(group);
      }
    }
    var orphanDelayedCallbacks2 = null;
    function signalLater2(emitter, type2) {
      var arr = getHandlers2(emitter, type2);
      if (!arr.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2), list;
      if (operationGroup2) {
        list = operationGroup2.delayedCallbacks;
      } else if (orphanDelayedCallbacks2) {
        list = orphanDelayedCallbacks2;
      } else {
        list = orphanDelayedCallbacks2 = [];
        setTimeout(fireOrphanDelayed2, 0);
      }
      var loop = function(i4) {
        list.push(function() {
          return arr[i4].apply(null, args);
        });
      };
      for (var i3 = 0; i3 < arr.length; ++i3)
        loop(i3);
    }
    function fireOrphanDelayed2() {
      var delayed = orphanDelayedCallbacks2;
      orphanDelayedCallbacks2 = null;
      for (var i3 = 0; i3 < delayed.length; ++i3) {
        delayed[i3]();
      }
    }
    function updateLineForChanges2(cm, lineView, lineN, dims) {
      for (var j = 0; j < lineView.changes.length; j++) {
        var type2 = lineView.changes[j];
        if (type2 == "text") {
          updateLineText2(cm, lineView);
        } else if (type2 == "gutter") {
          updateLineGutter2(cm, lineView, lineN, dims);
        } else if (type2 == "class") {
          updateLineClasses2(cm, lineView);
        } else if (type2 == "widget") {
          updateLineWidgets2(cm, lineView, dims);
        }
      }
      lineView.changes = null;
    }
    function ensureLineWrapped2(lineView) {
      if (lineView.node == lineView.text) {
        lineView.node = elt2("div", null, null, "position: relative");
        if (lineView.text.parentNode) {
          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
        }
        lineView.node.appendChild(lineView.text);
        if (ie2 && ie_version2 < 8) {
          lineView.node.style.zIndex = 2;
        }
      }
      return lineView.node;
    }
    function updateLineBackground2(cm, lineView) {
      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
      if (cls) {
        cls += " CodeMirror-linebackground";
      }
      if (lineView.background) {
        if (cls) {
          lineView.background.className = cls;
        } else {
          lineView.background.parentNode.removeChild(lineView.background);
          lineView.background = null;
        }
      } else if (cls) {
        var wrap = ensureLineWrapped2(lineView);
        lineView.background = wrap.insertBefore(elt2("div", null, cls), wrap.firstChild);
        cm.display.input.setUneditable(lineView.background);
      }
    }
    function getLineContent2(cm, lineView) {
      var ext = cm.display.externalMeasured;
      if (ext && ext.line == lineView.line) {
        cm.display.externalMeasured = null;
        lineView.measure = ext.measure;
        return ext.built;
      }
      return buildLineContent2(cm, lineView);
    }
    function updateLineText2(cm, lineView) {
      var cls = lineView.text.className;
      var built = getLineContent2(cm, lineView);
      if (lineView.text == lineView.node) {
        lineView.node = built.pre;
      }
      lineView.text.parentNode.replaceChild(built.pre, lineView.text);
      lineView.text = built.pre;
      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
        lineView.bgClass = built.bgClass;
        lineView.textClass = built.textClass;
        updateLineClasses2(cm, lineView);
      } else if (cls) {
        lineView.text.className = cls;
      }
    }
    function updateLineClasses2(cm, lineView) {
      updateLineBackground2(cm, lineView);
      if (lineView.line.wrapClass) {
        ensureLineWrapped2(lineView).className = lineView.line.wrapClass;
      } else if (lineView.node != lineView.text) {
        lineView.node.className = "";
      }
      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
      lineView.text.className = textClass || "";
    }
    function updateLineGutter2(cm, lineView, lineN, dims) {
      if (lineView.gutter) {
        lineView.node.removeChild(lineView.gutter);
        lineView.gutter = null;
      }
      if (lineView.gutterBackground) {
        lineView.node.removeChild(lineView.gutterBackground);
        lineView.gutterBackground = null;
      }
      if (lineView.line.gutterClass) {
        var wrap = ensureLineWrapped2(lineView);
        lineView.gutterBackground = elt2("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
        cm.display.input.setUneditable(lineView.gutterBackground);
        wrap.insertBefore(lineView.gutterBackground, lineView.text);
      }
      var markers = lineView.line.gutterMarkers;
      if (cm.options.lineNumbers || markers) {
        var wrap$1 = ensureLineWrapped2(lineView);
        var gutterWrap = lineView.gutter = elt2("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
        gutterWrap.setAttribute("aria-hidden", "true");
        cm.display.input.setUneditable(gutterWrap);
        wrap$1.insertBefore(gutterWrap, lineView.text);
        if (lineView.line.gutterClass) {
          gutterWrap.className += " " + lineView.line.gutterClass;
        }
        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
          lineView.lineNumber = gutterWrap.appendChild(elt2("div", lineNumberFor2(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
        }
        if (markers) {
          for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
            var id2 = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id2) && markers[id2];
            if (found) {
              gutterWrap.appendChild(elt2("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id2] + "px; width: " + dims.gutterWidth[id2] + "px"));
            }
          }
        }
      }
    }
    function updateLineWidgets2(cm, lineView, dims) {
      if (lineView.alignable) {
        lineView.alignable = null;
      }
      var isWidget = classTest2("CodeMirror-linewidget");
      for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
        next = node.nextSibling;
        if (isWidget.test(node.className)) {
          lineView.node.removeChild(node);
        }
      }
      insertLineWidgets2(cm, lineView, dims);
    }
    function buildLineElement2(cm, lineView, lineN, dims) {
      var built = getLineContent2(cm, lineView);
      lineView.text = lineView.node = built.pre;
      if (built.bgClass) {
        lineView.bgClass = built.bgClass;
      }
      if (built.textClass) {
        lineView.textClass = built.textClass;
      }
      updateLineClasses2(cm, lineView);
      updateLineGutter2(cm, lineView, lineN, dims);
      insertLineWidgets2(cm, lineView, dims);
      return lineView.node;
    }
    function insertLineWidgets2(cm, lineView, dims) {
      insertLineWidgetsFor2(cm, lineView.line, lineView, dims, true);
      if (lineView.rest) {
        for (var i3 = 0; i3 < lineView.rest.length; i3++) {
          insertLineWidgetsFor2(cm, lineView.rest[i3], lineView, dims, false);
        }
      }
    }
    function insertLineWidgetsFor2(cm, line, lineView, dims, allowAbove) {
      if (!line.widgets) {
        return;
      }
      var wrap = ensureLineWrapped2(lineView);
      for (var i3 = 0, ws = line.widgets; i3 < ws.length; ++i3) {
        var widget = ws[i3], node = elt2("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
        if (!widget.handleMouseEvents) {
          node.setAttribute("cm-ignore-events", "true");
        }
        positionLineWidget2(widget, node, lineView, dims);
        cm.display.input.setUneditable(node);
        if (allowAbove && widget.above) {
          wrap.insertBefore(node, lineView.gutter || lineView.text);
        } else {
          wrap.appendChild(node);
        }
        signalLater2(widget, "redraw");
      }
    }
    function positionLineWidget2(widget, node, lineView, dims) {
      if (widget.noHScroll) {
        (lineView.alignable || (lineView.alignable = [])).push(node);
        var width2 = dims.wrapperWidth;
        node.style.left = dims.fixedPos + "px";
        if (!widget.coverGutter) {
          width2 -= dims.gutterTotalWidth;
          node.style.paddingLeft = dims.gutterTotalWidth + "px";
        }
        node.style.width = width2 + "px";
      }
      if (widget.coverGutter) {
        node.style.zIndex = 5;
        node.style.position = "relative";
        if (!widget.noHScroll) {
          node.style.marginLeft = -dims.gutterTotalWidth + "px";
        }
      }
    }
    function widgetHeight2(widget) {
      if (widget.height != null) {
        return widget.height;
      }
      var cm = widget.doc.cm;
      if (!cm) {
        return 0;
      }
      if (!contains2(document.body, widget.node)) {
        var parentStyle = "position: relative;";
        if (widget.coverGutter) {
          parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
        }
        if (widget.noHScroll) {
          parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
        }
        removeChildrenAndAdd2(cm.display.measure, elt2("div", [widget.node], null, parentStyle));
      }
      return widget.height = widget.node.parentNode.offsetHeight;
    }
    function eventInWidget2(display, e) {
      for (var n = e_target2(e); n != display.wrapper; n = n.parentNode) {
        if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
          return true;
        }
      }
    }
    function paddingTop2(display) {
      return display.lineSpace.offsetTop;
    }
    function paddingVert2(display) {
      return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH2(display) {
      if (display.cachedPaddingH) {
        return display.cachedPaddingH;
      }
      var e = removeChildrenAndAdd2(display.measure, elt2("pre", "x", "CodeMirror-line-like"));
      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
      var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
      if (!isNaN(data.left) && !isNaN(data.right)) {
        display.cachedPaddingH = data;
      }
      return data;
    }
    function scrollGap2(cm) {
      return scrollerGap2 - cm.display.nativeBarWidth;
    }
    function displayWidth2(cm) {
      return cm.display.scroller.clientWidth - scrollGap2(cm) - cm.display.barWidth;
    }
    function displayHeight2(cm) {
      return cm.display.scroller.clientHeight - scrollGap2(cm) - cm.display.barHeight;
    }
    function ensureLineHeights2(cm, lineView, rect) {
      var wrapping = cm.options.lineWrapping;
      var curWidth = wrapping && displayWidth2(cm);
      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
        var heights = lineView.measure.heights = [];
        if (wrapping) {
          lineView.measure.width = curWidth;
          var rects = lineView.text.firstChild.getClientRects();
          for (var i3 = 0; i3 < rects.length - 1; i3++) {
            var cur = rects[i3], next = rects[i3 + 1];
            if (Math.abs(cur.bottom - next.bottom) > 2) {
              heights.push((cur.bottom + next.top) / 2 - rect.top);
            }
          }
        }
        heights.push(rect.bottom - rect.top);
      }
    }
    function mapFromLineView2(lineView, line, lineN) {
      if (lineView.line == line) {
        return { map: lineView.measure.map, cache: lineView.measure.cache };
      }
      for (var i3 = 0; i3 < lineView.rest.length; i3++) {
        if (lineView.rest[i3] == line) {
          return { map: lineView.measure.maps[i3], cache: lineView.measure.caches[i3] };
        }
      }
      for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
        if (lineNo2(lineView.rest[i$12]) > lineN) {
          return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
        }
      }
    }
    function updateExternalMeasurement2(cm, line) {
      line = visualLine2(line);
      var lineN = lineNo2(line);
      var view = cm.display.externalMeasured = new LineView2(cm.doc, line, lineN);
      view.lineN = lineN;
      var built = view.built = buildLineContent2(cm, view);
      view.text = built.pre;
      removeChildrenAndAdd2(cm.display.lineMeasure, built.pre);
      return view;
    }
    function measureChar2(cm, line, ch, bias) {
      return measureCharPrepared2(cm, prepareMeasureForLine2(cm, line), ch, bias);
    }
    function findViewForLine2(cm, lineN) {
      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
        return cm.display.view[findViewIndex2(cm, lineN)];
      }
      var ext = cm.display.externalMeasured;
      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
        return ext;
      }
    }
    function prepareMeasureForLine2(cm, line) {
      var lineN = lineNo2(line);
      var view = findViewForLine2(cm, lineN);
      if (view && !view.text) {
        view = null;
      } else if (view && view.changes) {
        updateLineForChanges2(cm, view, lineN, getDimensions2(cm));
        cm.curOp.forceUpdate = true;
      }
      if (!view) {
        view = updateExternalMeasurement2(cm, line);
      }
      var info = mapFromLineView2(view, line, lineN);
      return {
        line,
        view,
        rect: null,
        map: info.map,
        cache: info.cache,
        before: info.before,
        hasHeights: false
      };
    }
    function measureCharPrepared2(cm, prepared, ch, bias, varHeight) {
      if (prepared.before) {
        ch = -1;
      }
      var key = ch + (bias || ""), found;
      if (prepared.cache.hasOwnProperty(key)) {
        found = prepared.cache[key];
      } else {
        if (!prepared.rect) {
          prepared.rect = prepared.view.text.getBoundingClientRect();
        }
        if (!prepared.hasHeights) {
          ensureLineHeights2(cm, prepared.view, prepared.rect);
          prepared.hasHeights = true;
        }
        found = measureCharInner2(cm, prepared, ch, bias);
        if (!found.bogus) {
          prepared.cache[key] = found;
        }
      }
      return {
        left: found.left,
        right: found.right,
        top: varHeight ? found.rtop : found.top,
        bottom: varHeight ? found.rbottom : found.bottom
      };
    }
    var nullRect2 = { left: 0, right: 0, top: 0, bottom: 0 };
    function nodeAndOffsetInLineMap2(map3, ch, bias) {
      var node, start2, end2, collapse, mStart, mEnd;
      for (var i3 = 0; i3 < map3.length; i3 += 3) {
        mStart = map3[i3];
        mEnd = map3[i3 + 1];
        if (ch < mStart) {
          start2 = 0;
          end2 = 1;
          collapse = "left";
        } else if (ch < mEnd) {
          start2 = ch - mStart;
          end2 = start2 + 1;
        } else if (i3 == map3.length - 3 || ch == mEnd && map3[i3 + 3] > ch) {
          end2 = mEnd - mStart;
          start2 = end2 - 1;
          if (ch >= mEnd) {
            collapse = "right";
          }
        }
        if (start2 != null) {
          node = map3[i3 + 2];
          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
            collapse = bias;
          }
          if (bias == "left" && start2 == 0) {
            while (i3 && map3[i3 - 2] == map3[i3 - 3] && map3[i3 - 1].insertLeft) {
              node = map3[(i3 -= 3) + 2];
              collapse = "left";
            }
          }
          if (bias == "right" && start2 == mEnd - mStart) {
            while (i3 < map3.length - 3 && map3[i3 + 3] == map3[i3 + 4] && !map3[i3 + 5].insertLeft) {
              node = map3[(i3 += 3) + 2];
              collapse = "right";
            }
          }
          break;
        }
      }
      return { node, start: start2, end: end2, collapse, coverStart: mStart, coverEnd: mEnd };
    }
    function getUsefulRect2(rects, bias) {
      var rect = nullRect2;
      if (bias == "left") {
        for (var i3 = 0; i3 < rects.length; i3++) {
          if ((rect = rects[i3]).left != rect.right) {
            break;
          }
        }
      } else {
        for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
          if ((rect = rects[i$12]).left != rect.right) {
            break;
          }
        }
      }
      return rect;
    }
    function measureCharInner2(cm, prepared, ch, bias) {
      var place = nodeAndOffsetInLineMap2(prepared.map, ch, bias);
      var node = place.node, start2 = place.start, end2 = place.end, collapse = place.collapse;
      var rect;
      if (node.nodeType == 3) {
        for (var i$12 = 0; i$12 < 4; i$12++) {
          while (start2 && isExtendingChar2(prepared.line.text.charAt(place.coverStart + start2))) {
            --start2;
          }
          while (place.coverStart + end2 < place.coverEnd && isExtendingChar2(prepared.line.text.charAt(place.coverStart + end2))) {
            ++end2;
          }
          if (ie2 && ie_version2 < 9 && start2 == 0 && end2 == place.coverEnd - place.coverStart) {
            rect = node.parentNode.getBoundingClientRect();
          } else {
            rect = getUsefulRect2(range2(node, start2, end2).getClientRects(), bias);
          }
          if (rect.left || rect.right || start2 == 0) {
            break;
          }
          end2 = start2;
          start2 = start2 - 1;
          collapse = "right";
        }
        if (ie2 && ie_version2 < 11) {
          rect = maybeUpdateRectForZooming2(cm.display.measure, rect);
        }
      } else {
        if (start2 > 0) {
          collapse = bias = "right";
        }
        var rects;
        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
          rect = rects[bias == "right" ? rects.length - 1 : 0];
        } else {
          rect = node.getBoundingClientRect();
        }
      }
      if (ie2 && ie_version2 < 9 && !start2 && (!rect || !rect.left && !rect.right)) {
        var rSpan = node.parentNode.getClientRects()[0];
        if (rSpan) {
          rect = { left: rSpan.left, right: rSpan.left + charWidth2(cm.display), top: rSpan.top, bottom: rSpan.bottom };
        } else {
          rect = nullRect2;
        }
      }
      var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
      var mid = (rtop + rbot) / 2;
      var heights = prepared.view.measure.heights;
      var i3 = 0;
      for (; i3 < heights.length - 1; i3++) {
        if (mid < heights[i3]) {
          break;
        }
      }
      var top2 = i3 ? heights[i3 - 1] : 0, bot = heights[i3];
      var result = {
        left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
        right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
        top: top2,
        bottom: bot
      };
      if (!rect.left && !rect.right) {
        result.bogus = true;
      }
      if (!cm.options.singleCursorHeightPerLine) {
        result.rtop = rtop;
        result.rbottom = rbot;
      }
      return result;
    }
    function maybeUpdateRectForZooming2(measure, rect) {
      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects2(measure)) {
        return rect;
      }
      var scaleX = screen.logicalXDPI / screen.deviceXDPI;
      var scaleY = screen.logicalYDPI / screen.deviceYDPI;
      return {
        left: rect.left * scaleX,
        right: rect.right * scaleX,
        top: rect.top * scaleY,
        bottom: rect.bottom * scaleY
      };
    }
    function clearLineMeasurementCacheFor2(lineView) {
      if (lineView.measure) {
        lineView.measure.cache = {};
        lineView.measure.heights = null;
        if (lineView.rest) {
          for (var i3 = 0; i3 < lineView.rest.length; i3++) {
            lineView.measure.caches[i3] = {};
          }
        }
      }
    }
    function clearLineMeasurementCache2(cm) {
      cm.display.externalMeasure = null;
      removeChildren2(cm.display.lineMeasure);
      for (var i3 = 0; i3 < cm.display.view.length; i3++) {
        clearLineMeasurementCacheFor2(cm.display.view[i3]);
      }
    }
    function clearCaches2(cm) {
      clearLineMeasurementCache2(cm);
      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
      if (!cm.options.lineWrapping) {
        cm.display.maxLineChanged = true;
      }
      cm.display.lineNumChars = null;
    }
    function pageScrollX2() {
      if (chrome2 && android2) {
        return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
      }
      return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY2() {
      if (chrome2 && android2) {
        return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
      }
      return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function widgetTopHeight2(lineObj) {
      var height = 0;
      if (lineObj.widgets) {
        for (var i3 = 0; i3 < lineObj.widgets.length; ++i3) {
          if (lineObj.widgets[i3].above) {
            height += widgetHeight2(lineObj.widgets[i3]);
          }
        }
      }
      return height;
    }
    function intoCoordSystem2(cm, lineObj, rect, context, includeWidgets) {
      if (!includeWidgets) {
        var height = widgetTopHeight2(lineObj);
        rect.top += height;
        rect.bottom += height;
      }
      if (context == "line") {
        return rect;
      }
      if (!context) {
        context = "local";
      }
      var yOff = heightAtLine2(lineObj);
      if (context == "local") {
        yOff += paddingTop2(cm.display);
      } else {
        yOff -= cm.display.viewOffset;
      }
      if (context == "page" || context == "window") {
        var lOff = cm.display.lineSpace.getBoundingClientRect();
        yOff += lOff.top + (context == "window" ? 0 : pageScrollY2());
        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX2());
        rect.left += xOff;
        rect.right += xOff;
      }
      rect.top += yOff;
      rect.bottom += yOff;
      return rect;
    }
    function fromCoordSystem2(cm, coords, context) {
      if (context == "div") {
        return coords;
      }
      var left2 = coords.left, top2 = coords.top;
      if (context == "page") {
        left2 -= pageScrollX2();
        top2 -= pageScrollY2();
      } else if (context == "local" || !context) {
        var localBox = cm.display.sizer.getBoundingClientRect();
        left2 += localBox.left;
        top2 += localBox.top;
      }
      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
      return { left: left2 - lineSpaceBox.left, top: top2 - lineSpaceBox.top };
    }
    function charCoords2(cm, pos, context, lineObj, bias) {
      if (!lineObj) {
        lineObj = getLine2(cm.doc, pos.line);
      }
      return intoCoordSystem2(cm, lineObj, measureChar2(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords2(cm, pos, context, lineObj, preparedMeasure, varHeight) {
      lineObj = lineObj || getLine2(cm.doc, pos.line);
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine2(cm, lineObj);
      }
      function get(ch2, right2) {
        var m = measureCharPrepared2(cm, preparedMeasure, ch2, right2 ? "right" : "left", varHeight);
        if (right2) {
          m.left = m.right;
        } else {
          m.right = m.left;
        }
        return intoCoordSystem2(cm, lineObj, m, context);
      }
      var order2 = getOrder2(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
      if (ch >= lineObj.text.length) {
        ch = lineObj.text.length;
        sticky = "before";
      } else if (ch <= 0) {
        ch = 0;
        sticky = "after";
      }
      if (!order2) {
        return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
      }
      function getBidi(ch2, partPos2, invert) {
        var part = order2[partPos2], right2 = part.level == 1;
        return get(invert ? ch2 - 1 : ch2, right2 != invert);
      }
      var partPos = getBidiPartAt2(order2, ch, sticky);
      var other = bidiOther2;
      var val = getBidi(ch, partPos, sticky == "before");
      if (other != null) {
        val.other = getBidi(ch, other, sticky != "before");
      }
      return val;
    }
    function estimateCoords2(cm, pos) {
      var left2 = 0;
      pos = clipPos2(cm.doc, pos);
      if (!cm.options.lineWrapping) {
        left2 = charWidth2(cm.display) * pos.ch;
      }
      var lineObj = getLine2(cm.doc, pos.line);
      var top2 = heightAtLine2(lineObj) + paddingTop2(cm.display);
      return { left: left2, right: left2, top: top2, bottom: top2 + lineObj.height };
    }
    function PosWithInfo2(line, ch, sticky, outside, xRel) {
      var pos = Pos2(line, ch, sticky);
      pos.xRel = xRel;
      if (outside) {
        pos.outside = outside;
      }
      return pos;
    }
    function coordsChar2(cm, x, y) {
      var doc = cm.doc;
      y += cm.display.viewOffset;
      if (y < 0) {
        return PosWithInfo2(doc.first, 0, null, -1, -1);
      }
      var lineN = lineAtHeight2(doc, y), last = doc.first + doc.size - 1;
      if (lineN > last) {
        return PosWithInfo2(doc.first + doc.size - 1, getLine2(doc, last).text.length, null, 1, 1);
      }
      if (x < 0) {
        x = 0;
      }
      var lineObj = getLine2(doc, lineN);
      for (; ; ) {
        var found = coordsCharInner2(cm, lineObj, lineN, x, y);
        var collapsed = collapsedSpanAround2(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
        if (!collapsed) {
          return found;
        }
        var rangeEnd = collapsed.find(1);
        if (rangeEnd.line == lineN) {
          return rangeEnd;
        }
        lineObj = getLine2(doc, lineN = rangeEnd.line);
      }
    }
    function wrappedLineExtent2(cm, lineObj, preparedMeasure, y) {
      y -= widgetTopHeight2(lineObj);
      var end2 = lineObj.text.length;
      var begin = findFirst2(function(ch) {
        return measureCharPrepared2(cm, preparedMeasure, ch - 1).bottom <= y;
      }, end2, 0);
      end2 = findFirst2(function(ch) {
        return measureCharPrepared2(cm, preparedMeasure, ch).top > y;
      }, begin, end2);
      return { begin, end: end2 };
    }
    function wrappedLineExtentChar2(cm, lineObj, preparedMeasure, target) {
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine2(cm, lineObj);
      }
      var targetTop = intoCoordSystem2(cm, lineObj, measureCharPrepared2(cm, preparedMeasure, target), "line").top;
      return wrappedLineExtent2(cm, lineObj, preparedMeasure, targetTop);
    }
    function boxIsAfter2(box, x, y, left2) {
      return box.bottom <= y ? false : box.top > y ? true : (left2 ? box.left : box.right) > x;
    }
    function coordsCharInner2(cm, lineObj, lineNo3, x, y) {
      y -= heightAtLine2(lineObj);
      var preparedMeasure = prepareMeasureForLine2(cm, lineObj);
      var widgetHeight3 = widgetTopHeight2(lineObj);
      var begin = 0, end2 = lineObj.text.length, ltr = true;
      var order2 = getOrder2(lineObj, cm.doc.direction);
      if (order2) {
        var part = (cm.options.lineWrapping ? coordsBidiPartWrapped2 : coordsBidiPart2)(cm, lineObj, lineNo3, preparedMeasure, order2, x, y);
        ltr = part.level != 1;
        begin = ltr ? part.from : part.to - 1;
        end2 = ltr ? part.to : part.from - 1;
      }
      var chAround = null, boxAround = null;
      var ch = findFirst2(function(ch2) {
        var box = measureCharPrepared2(cm, preparedMeasure, ch2);
        box.top += widgetHeight3;
        box.bottom += widgetHeight3;
        if (!boxIsAfter2(box, x, y, false)) {
          return false;
        }
        if (box.top <= y && box.left <= x) {
          chAround = ch2;
          boxAround = box;
        }
        return true;
      }, begin, end2);
      var baseX, sticky, outside = false;
      if (boxAround) {
        var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
        ch = chAround + (atStart ? 0 : 1);
        sticky = atStart ? "after" : "before";
        baseX = atLeft ? boxAround.left : boxAround.right;
      } else {
        if (!ltr && (ch == end2 || ch == begin)) {
          ch++;
        }
        sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared2(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight3 <= y == ltr ? "after" : "before";
        var coords = cursorCoords2(cm, Pos2(lineNo3, ch, sticky), "line", lineObj, preparedMeasure);
        baseX = coords.left;
        outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
      }
      ch = skipExtendingChars2(lineObj.text, ch, 1);
      return PosWithInfo2(lineNo3, ch, sticky, outside, x - baseX);
    }
    function coordsBidiPart2(cm, lineObj, lineNo3, preparedMeasure, order2, x, y) {
      var index2 = findFirst2(function(i3) {
        var part2 = order2[i3], ltr2 = part2.level != 1;
        return boxIsAfter2(cursorCoords2(cm, Pos2(lineNo3, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
      }, 0, order2.length - 1);
      var part = order2[index2];
      if (index2 > 0) {
        var ltr = part.level != 1;
        var start2 = cursorCoords2(cm, Pos2(lineNo3, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
        if (boxIsAfter2(start2, x, y, true) && start2.top > y) {
          part = order2[index2 - 1];
        }
      }
      return part;
    }
    function coordsBidiPartWrapped2(cm, lineObj, _lineNo, preparedMeasure, order2, x, y) {
      var ref2 = wrappedLineExtent2(cm, lineObj, preparedMeasure, y);
      var begin = ref2.begin;
      var end2 = ref2.end;
      if (/\s/.test(lineObj.text.charAt(end2 - 1))) {
        end2--;
      }
      var part = null, closestDist = null;
      for (var i3 = 0; i3 < order2.length; i3++) {
        var p = order2[i3];
        if (p.from >= end2 || p.to <= begin) {
          continue;
        }
        var ltr = p.level != 1;
        var endX = measureCharPrepared2(cm, preparedMeasure, ltr ? Math.min(end2, p.to) - 1 : Math.max(begin, p.from)).right;
        var dist = endX < x ? x - endX + 1e9 : endX - x;
        if (!part || closestDist > dist) {
          part = p;
          closestDist = dist;
        }
      }
      if (!part) {
        part = order2[order2.length - 1];
      }
      if (part.from < begin) {
        part = { from: begin, to: part.to, level: part.level };
      }
      if (part.to > end2) {
        part = { from: part.from, to: end2, level: part.level };
      }
      return part;
    }
    var measureText2;
    function textHeight2(display) {
      if (display.cachedTextHeight != null) {
        return display.cachedTextHeight;
      }
      if (measureText2 == null) {
        measureText2 = elt2("pre", null, "CodeMirror-line-like");
        for (var i3 = 0; i3 < 49; ++i3) {
          measureText2.appendChild(document.createTextNode("x"));
          measureText2.appendChild(elt2("br"));
        }
        measureText2.appendChild(document.createTextNode("x"));
      }
      removeChildrenAndAdd2(display.measure, measureText2);
      var height = measureText2.offsetHeight / 50;
      if (height > 3) {
        display.cachedTextHeight = height;
      }
      removeChildren2(display.measure);
      return height || 1;
    }
    function charWidth2(display) {
      if (display.cachedCharWidth != null) {
        return display.cachedCharWidth;
      }
      var anchor = elt2("span", "xxxxxxxxxx");
      var pre = elt2("pre", [anchor], "CodeMirror-line-like");
      removeChildrenAndAdd2(display.measure, pre);
      var rect = anchor.getBoundingClientRect(), width2 = (rect.right - rect.left) / 10;
      if (width2 > 2) {
        display.cachedCharWidth = width2;
      }
      return width2 || 10;
    }
    function getDimensions2(cm) {
      var d = cm.display, left2 = {}, width2 = {};
      var gutterLeft = d.gutters.clientLeft;
      for (var n = d.gutters.firstChild, i3 = 0; n; n = n.nextSibling, ++i3) {
        var id2 = cm.display.gutterSpecs[i3].className;
        left2[id2] = n.offsetLeft + n.clientLeft + gutterLeft;
        width2[id2] = n.clientWidth;
      }
      return {
        fixedPos: compensateForHScroll2(d),
        gutterTotalWidth: d.gutters.offsetWidth,
        gutterLeft: left2,
        gutterWidth: width2,
        wrapperWidth: d.wrapper.clientWidth
      };
    }
    function compensateForHScroll2(display) {
      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function estimateHeight2(cm) {
      var th = textHeight2(cm.display), wrapping = cm.options.lineWrapping;
      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth2(cm.display) - 3);
      return function(line) {
        if (lineIsHidden2(cm.doc, line)) {
          return 0;
        }
        var widgetsHeight = 0;
        if (line.widgets) {
          for (var i3 = 0; i3 < line.widgets.length; i3++) {
            if (line.widgets[i3].height) {
              widgetsHeight += line.widgets[i3].height;
            }
          }
        }
        if (wrapping) {
          return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
        } else {
          return widgetsHeight + th;
        }
      };
    }
    function estimateLineHeights2(cm) {
      var doc = cm.doc, est = estimateHeight2(cm);
      doc.iter(function(line) {
        var estHeight = est(line);
        if (estHeight != line.height) {
          updateLineHeight2(line, estHeight);
        }
      });
    }
    function posFromMouse2(cm, e, liberal, forRect) {
      var display = cm.display;
      if (!liberal && e_target2(e).getAttribute("cm-not-content") == "true") {
        return null;
      }
      var x, y, space = display.lineSpace.getBoundingClientRect();
      try {
        x = e.clientX - space.left;
        y = e.clientY - space.top;
      } catch (e$1) {
        return null;
      }
      var coords = coordsChar2(cm, x, y), line;
      if (forRect && coords.xRel > 0 && (line = getLine2(cm.doc, coords.line).text).length == coords.ch) {
        var colDiff = countColumn2(line, line.length, cm.options.tabSize) - line.length;
        coords = Pos2(coords.line, Math.max(0, Math.round((x - paddingH2(cm.display).left) / charWidth2(cm.display)) - colDiff));
      }
      return coords;
    }
    function findViewIndex2(cm, n) {
      if (n >= cm.display.viewTo) {
        return null;
      }
      n -= cm.display.viewFrom;
      if (n < 0) {
        return null;
      }
      var view = cm.display.view;
      for (var i3 = 0; i3 < view.length; i3++) {
        n -= view[i3].size;
        if (n < 0) {
          return i3;
        }
      }
    }
    function regChange2(cm, from, to, lendiff) {
      if (from == null) {
        from = cm.doc.first;
      }
      if (to == null) {
        to = cm.doc.first + cm.doc.size;
      }
      if (!lendiff) {
        lendiff = 0;
      }
      var display = cm.display;
      if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
        display.updateLineNumbers = from;
      }
      cm.curOp.viewChanged = true;
      if (from >= display.viewTo) {
        if (sawCollapsedSpans2 && visualLineNo2(cm.doc, from) < display.viewTo) {
          resetView2(cm);
        }
      } else if (to <= display.viewFrom) {
        if (sawCollapsedSpans2 && visualLineEndNo2(cm.doc, to + lendiff) > display.viewFrom) {
          resetView2(cm);
        } else {
          display.viewFrom += lendiff;
          display.viewTo += lendiff;
        }
      } else if (from <= display.viewFrom && to >= display.viewTo) {
        resetView2(cm);
      } else if (from <= display.viewFrom) {
        var cut = viewCuttingPoint2(cm, to, to + lendiff, 1);
        if (cut) {
          display.view = display.view.slice(cut.index);
          display.viewFrom = cut.lineN;
          display.viewTo += lendiff;
        } else {
          resetView2(cm);
        }
      } else if (to >= display.viewTo) {
        var cut$1 = viewCuttingPoint2(cm, from, from, -1);
        if (cut$1) {
          display.view = display.view.slice(0, cut$1.index);
          display.viewTo = cut$1.lineN;
        } else {
          resetView2(cm);
        }
      } else {
        var cutTop = viewCuttingPoint2(cm, from, from, -1);
        var cutBot = viewCuttingPoint2(cm, to, to + lendiff, 1);
        if (cutTop && cutBot) {
          display.view = display.view.slice(0, cutTop.index).concat(buildViewArray2(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
          display.viewTo += lendiff;
        } else {
          resetView2(cm);
        }
      }
      var ext = display.externalMeasured;
      if (ext) {
        if (to < ext.lineN) {
          ext.lineN += lendiff;
        } else if (from < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }
      }
    }
    function regLineChange2(cm, line, type2) {
      cm.curOp.viewChanged = true;
      var display = cm.display, ext = cm.display.externalMeasured;
      if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
      if (line < display.viewFrom || line >= display.viewTo) {
        return;
      }
      var lineView = display.view[findViewIndex2(cm, line)];
      if (lineView.node == null) {
        return;
      }
      var arr = lineView.changes || (lineView.changes = []);
      if (indexOf2(arr, type2) == -1) {
        arr.push(type2);
      }
    }
    function resetView2(cm) {
      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
      cm.display.view = [];
      cm.display.viewOffset = 0;
    }
    function viewCuttingPoint2(cm, oldN, newN, dir) {
      var index2 = findViewIndex2(cm, oldN), diff, view = cm.display.view;
      if (!sawCollapsedSpans2 || newN == cm.doc.first + cm.doc.size) {
        return { index: index2, lineN: newN };
      }
      var n = cm.display.viewFrom;
      for (var i3 = 0; i3 < index2; i3++) {
        n += view[i3].size;
      }
      if (n != oldN) {
        if (dir > 0) {
          if (index2 == view.length - 1) {
            return null;
          }
          diff = n + view[index2].size - oldN;
          index2++;
        } else {
          diff = n - oldN;
        }
        oldN += diff;
        newN += diff;
      }
      while (visualLineNo2(cm.doc, newN) != newN) {
        if (index2 == (dir < 0 ? 0 : view.length - 1)) {
          return null;
        }
        newN += dir * view[index2 - (dir < 0 ? 1 : 0)].size;
        index2 += dir;
      }
      return { index: index2, lineN: newN };
    }
    function adjustView2(cm, from, to) {
      var display = cm.display, view = display.view;
      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
        display.view = buildViewArray2(cm, from, to);
        display.viewFrom = from;
      } else {
        if (display.viewFrom > from) {
          display.view = buildViewArray2(cm, from, display.viewFrom).concat(display.view);
        } else if (display.viewFrom < from) {
          display.view = display.view.slice(findViewIndex2(cm, from));
        }
        display.viewFrom = from;
        if (display.viewTo < to) {
          display.view = display.view.concat(buildViewArray2(cm, display.viewTo, to));
        } else if (display.viewTo > to) {
          display.view = display.view.slice(0, findViewIndex2(cm, to));
        }
      }
      display.viewTo = to;
    }
    function countDirtyView2(cm) {
      var view = cm.display.view, dirty = 0;
      for (var i3 = 0; i3 < view.length; i3++) {
        var lineView = view[i3];
        if (!lineView.hidden && (!lineView.node || lineView.changes)) {
          ++dirty;
        }
      }
      return dirty;
    }
    function updateSelection2(cm) {
      cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection2(cm, primary) {
      if (primary === void 0)
        primary = true;
      var doc = cm.doc, result = {};
      var curFragment = result.cursors = document.createDocumentFragment();
      var selFragment = result.selection = document.createDocumentFragment();
      for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
        if (!primary && i3 == doc.sel.primIndex) {
          continue;
        }
        var range3 = doc.sel.ranges[i3];
        if (range3.from().line >= cm.display.viewTo || range3.to().line < cm.display.viewFrom) {
          continue;
        }
        var collapsed = range3.empty();
        if (collapsed || cm.options.showCursorWhenSelecting) {
          drawSelectionCursor2(cm, range3.head, curFragment);
        }
        if (!collapsed) {
          drawSelectionRange2(cm, range3, selFragment);
        }
      }
      return result;
    }
    function drawSelectionCursor2(cm, head, output) {
      var pos = cursorCoords2(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
      var cursor = output.appendChild(elt2("div", "\xA0", "CodeMirror-cursor"));
      cursor.style.left = pos.left + "px";
      cursor.style.top = pos.top + "px";
      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
      if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
        var charPos = charCoords2(cm, head, "div", null, null);
        if (charPos.right - charPos.left > 0) {
          cursor.style.width = charPos.right - charPos.left + "px";
        }
      }
      if (pos.other) {
        var otherCursor = output.appendChild(elt2("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
        otherCursor.style.display = "";
        otherCursor.style.left = pos.other.left + "px";
        otherCursor.style.top = pos.other.top + "px";
        otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
      }
    }
    function cmpCoords2(a, b) {
      return a.top - b.top || a.left - b.left;
    }
    function drawSelectionRange2(cm, range3, output) {
      var display = cm.display, doc = cm.doc;
      var fragment = document.createDocumentFragment();
      var padding = paddingH2(cm.display), leftSide = padding.left;
      var rightSide = Math.max(display.sizerWidth, displayWidth2(cm) - display.sizer.offsetLeft) - padding.right;
      var docLTR = doc.direction == "ltr";
      function add(left2, top2, width2, bottom2) {
        if (top2 < 0) {
          top2 = 0;
        }
        top2 = Math.round(top2);
        bottom2 = Math.round(bottom2);
        fragment.appendChild(elt2("div", null, "CodeMirror-selected", "position: absolute; left: " + left2 + "px;\n                             top: " + top2 + "px; width: " + (width2 == null ? rightSide - left2 : width2) + "px;\n                             height: " + (bottom2 - top2) + "px"));
      }
      function drawForLine(line, fromArg, toArg) {
        var lineObj = getLine2(doc, line);
        var lineLen = lineObj.text.length;
        var start2, end2;
        function coords(ch, bias) {
          return charCoords2(cm, Pos2(line, ch), "div", lineObj, bias);
        }
        function wrapX(pos, dir, side) {
          var extent = wrappedLineExtentChar2(cm, lineObj, null, pos);
          var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
          var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
          return coords(ch, prop2)[prop2];
        }
        var order2 = getOrder2(lineObj, doc.direction);
        iterateBidiSections2(order2, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i3) {
          var ltr = dir == "ltr";
          var fromPos = coords(from, ltr ? "left" : "right");
          var toPos = coords(to - 1, ltr ? "right" : "left");
          var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
          var first = i3 == 0, last = !order2 || i3 == order2.length - 1;
          if (toPos.top - fromPos.top <= 3) {
            var openLeft = (docLTR ? openStart : openEnd) && first;
            var openRight = (docLTR ? openEnd : openStart) && last;
            var left2 = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
            var right2 = openRight ? rightSide : (ltr ? toPos : fromPos).right;
            add(left2, fromPos.top, right2 - left2, fromPos.bottom);
          } else {
            var topLeft, topRight, botLeft, botRight;
            if (ltr) {
              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
              topRight = docLTR ? rightSide : wrapX(from, dir, "before");
              botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
              botRight = docLTR && openEnd && last ? rightSide : toPos.right;
            } else {
              topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
              botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
            }
            add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
            if (fromPos.bottom < toPos.top) {
              add(leftSide, fromPos.bottom, null, toPos.top);
            }
            add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
          }
          if (!start2 || cmpCoords2(fromPos, start2) < 0) {
            start2 = fromPos;
          }
          if (cmpCoords2(toPos, start2) < 0) {
            start2 = toPos;
          }
          if (!end2 || cmpCoords2(fromPos, end2) < 0) {
            end2 = fromPos;
          }
          if (cmpCoords2(toPos, end2) < 0) {
            end2 = toPos;
          }
        });
        return { start: start2, end: end2 };
      }
      var sFrom = range3.from(), sTo = range3.to();
      if (sFrom.line == sTo.line) {
        drawForLine(sFrom.line, sFrom.ch, sTo.ch);
      } else {
        var fromLine = getLine2(doc, sFrom.line), toLine = getLine2(doc, sTo.line);
        var singleVLine = visualLine2(fromLine) == visualLine2(toLine);
        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
        if (singleVLine) {
          if (leftEnd.top < rightStart.top - 2) {
            add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
            add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
          } else {
            add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
          }
        }
        if (leftEnd.bottom < rightStart.top) {
          add(leftSide, leftEnd.bottom, null, rightStart.top);
        }
      }
      output.appendChild(fragment);
    }
    function restartBlink2(cm) {
      if (!cm.state.focused) {
        return;
      }
      var display = cm.display;
      clearInterval(display.blinker);
      var on3 = true;
      display.cursorDiv.style.visibility = "";
      if (cm.options.cursorBlinkRate > 0) {
        display.blinker = setInterval(function() {
          if (!cm.hasFocus()) {
            onBlur2(cm);
          }
          display.cursorDiv.style.visibility = (on3 = !on3) ? "" : "hidden";
        }, cm.options.cursorBlinkRate);
      } else if (cm.options.cursorBlinkRate < 0) {
        display.cursorDiv.style.visibility = "hidden";
      }
    }
    function ensureFocus2(cm) {
      if (!cm.hasFocus()) {
        cm.display.input.focus();
        if (!cm.state.focused) {
          onFocus2(cm);
        }
      }
    }
    function delayBlurEvent2(cm) {
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        if (cm.state.delayingBlurEvent) {
          cm.state.delayingBlurEvent = false;
          if (cm.state.focused) {
            onBlur2(cm);
          }
        }
      }, 100);
    }
    function onFocus2(cm, e) {
      if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
        cm.state.delayingBlurEvent = false;
      }
      if (cm.options.readOnly == "nocursor") {
        return;
      }
      if (!cm.state.focused) {
        signal2(cm, "focus", cm, e);
        cm.state.focused = true;
        addClass2(cm.display.wrapper, "CodeMirror-focused");
        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
          cm.display.input.reset();
          if (webkit2) {
            setTimeout(function() {
              return cm.display.input.reset(true);
            }, 20);
          }
        }
        cm.display.input.receivedFocus();
      }
      restartBlink2(cm);
    }
    function onBlur2(cm, e) {
      if (cm.state.delayingBlurEvent) {
        return;
      }
      if (cm.state.focused) {
        signal2(cm, "blur", cm, e);
        cm.state.focused = false;
        rmClass2(cm.display.wrapper, "CodeMirror-focused");
      }
      clearInterval(cm.display.blinker);
      setTimeout(function() {
        if (!cm.state.focused) {
          cm.display.shift = false;
        }
      }, 150);
    }
    function updateHeightsInViewport2(cm) {
      var display = cm.display;
      var prevBottom = display.lineDiv.offsetTop;
      var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
      var oldHeight = display.lineDiv.getBoundingClientRect().top;
      var mustScroll = 0;
      for (var i3 = 0; i3 < display.view.length; i3++) {
        var cur = display.view[i3], wrapping = cm.options.lineWrapping;
        var height = void 0, width2 = 0;
        if (cur.hidden) {
          continue;
        }
        oldHeight += cur.line.height;
        if (ie2 && ie_version2 < 8) {
          var bot = cur.node.offsetTop + cur.node.offsetHeight;
          height = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = cur.node.getBoundingClientRect();
          height = box.bottom - box.top;
          if (!wrapping && cur.text.firstChild) {
            width2 = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
          }
        }
        var diff = cur.line.height - height;
        if (diff > 5e-3 || diff < -5e-3) {
          if (oldHeight < viewTop) {
            mustScroll -= diff;
          }
          updateLineHeight2(cur.line, height);
          updateWidgetHeight2(cur.line);
          if (cur.rest) {
            for (var j = 0; j < cur.rest.length; j++) {
              updateWidgetHeight2(cur.rest[j]);
            }
          }
        }
        if (width2 > cm.display.sizerWidth) {
          var chWidth = Math.ceil(width2 / charWidth2(cm.display));
          if (chWidth > cm.display.maxLineLength) {
            cm.display.maxLineLength = chWidth;
            cm.display.maxLine = cur.line;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (Math.abs(mustScroll) > 2) {
        display.scroller.scrollTop += mustScroll;
      }
    }
    function updateWidgetHeight2(line) {
      if (line.widgets) {
        for (var i3 = 0; i3 < line.widgets.length; ++i3) {
          var w = line.widgets[i3], parent2 = w.node.parentNode;
          if (parent2) {
            w.height = parent2.offsetHeight;
          }
        }
      }
    }
    function visibleLines2(display, doc, viewport2) {
      var top2 = viewport2 && viewport2.top != null ? Math.max(0, viewport2.top) : display.scroller.scrollTop;
      top2 = Math.floor(top2 - paddingTop2(display));
      var bottom2 = viewport2 && viewport2.bottom != null ? viewport2.bottom : top2 + display.wrapper.clientHeight;
      var from = lineAtHeight2(doc, top2), to = lineAtHeight2(doc, bottom2);
      if (viewport2 && viewport2.ensure) {
        var ensureFrom = viewport2.ensure.from.line, ensureTo = viewport2.ensure.to.line;
        if (ensureFrom < from) {
          from = ensureFrom;
          to = lineAtHeight2(doc, heightAtLine2(getLine2(doc, ensureFrom)) + display.wrapper.clientHeight);
        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
          from = lineAtHeight2(doc, heightAtLine2(getLine2(doc, ensureTo)) - display.wrapper.clientHeight);
          to = ensureTo;
        }
      }
      return { from, to: Math.max(to, from + 1) };
    }
    function maybeScrollWindow2(cm, rect) {
      if (signalDOMEvent2(cm, "scrollCursorIntoView")) {
        return;
      }
      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
      if (rect.top + box.top < 0) {
        doScroll = true;
      } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
        doScroll = false;
      }
      if (doScroll != null && !phantom2) {
        var scrollNode = elt2("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop2(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap2(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
        cm.display.lineSpace.appendChild(scrollNode);
        scrollNode.scrollIntoView(doScroll);
        cm.display.lineSpace.removeChild(scrollNode);
      }
    }
    function scrollPosIntoView2(cm, pos, end2, margin) {
      if (margin == null) {
        margin = 0;
      }
      var rect;
      if (!cm.options.lineWrapping && pos == end2) {
        end2 = pos.sticky == "before" ? Pos2(pos.line, pos.ch + 1, "before") : pos;
        pos = pos.ch ? Pos2(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      }
      for (var limit = 0; limit < 5; limit++) {
        var changed = false;
        var coords = cursorCoords2(cm, pos);
        var endCoords = !end2 || end2 == pos ? coords : cursorCoords2(cm, end2);
        rect = {
          left: Math.min(coords.left, endCoords.left),
          top: Math.min(coords.top, endCoords.top) - margin,
          right: Math.max(coords.left, endCoords.left),
          bottom: Math.max(coords.bottom, endCoords.bottom) + margin
        };
        var scrollPos = calculateScrollPos2(cm, rect);
        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
        if (scrollPos.scrollTop != null) {
          updateScrollTop2(cm, scrollPos.scrollTop);
          if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
            changed = true;
          }
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft2(cm, scrollPos.scrollLeft);
          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
            changed = true;
          }
        }
        if (!changed) {
          break;
        }
      }
      return rect;
    }
    function scrollIntoView2(cm, rect) {
      var scrollPos = calculateScrollPos2(cm, rect);
      if (scrollPos.scrollTop != null) {
        updateScrollTop2(cm, scrollPos.scrollTop);
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft2(cm, scrollPos.scrollLeft);
      }
    }
    function calculateScrollPos2(cm, rect) {
      var display = cm.display, snapMargin = textHeight2(cm.display);
      if (rect.top < 0) {
        rect.top = 0;
      }
      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
      var screen2 = displayHeight2(cm), result = {};
      if (rect.bottom - rect.top > screen2) {
        rect.bottom = rect.top + screen2;
      }
      var docBottom = cm.doc.height + paddingVert2(display);
      var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
      if (rect.top < screentop) {
        result.scrollTop = atTop ? 0 : rect.top;
      } else if (rect.bottom > screentop + screen2) {
        var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
        if (newTop != screentop) {
          result.scrollTop = newTop;
        }
      }
      var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
      var screenw = displayWidth2(cm) - display.gutters.offsetWidth;
      var tooWide = rect.right - rect.left > screenw;
      if (tooWide) {
        rect.right = rect.left + screenw;
      }
      if (rect.left < 10) {
        result.scrollLeft = 0;
      } else if (rect.left < screenleft) {
        result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
      } else if (rect.right > screenw + screenleft - 3) {
        result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
      }
      return result;
    }
    function addToScrollTop2(cm, top2) {
      if (top2 == null) {
        return;
      }
      resolveScrollToPos2(cm);
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top2;
    }
    function ensureCursorVisible2(cm) {
      resolveScrollToPos2(cm);
      var cur = cm.getCursor();
      cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
    }
    function scrollToCoords2(cm, x, y) {
      if (x != null || y != null) {
        resolveScrollToPos2(cm);
      }
      if (x != null) {
        cm.curOp.scrollLeft = x;
      }
      if (y != null) {
        cm.curOp.scrollTop = y;
      }
    }
    function scrollToRange2(cm, range3) {
      resolveScrollToPos2(cm);
      cm.curOp.scrollToPos = range3;
    }
    function resolveScrollToPos2(cm) {
      var range3 = cm.curOp.scrollToPos;
      if (range3) {
        cm.curOp.scrollToPos = null;
        var from = estimateCoords2(cm, range3.from), to = estimateCoords2(cm, range3.to);
        scrollToCoordsRange2(cm, from, to, range3.margin);
      }
    }
    function scrollToCoordsRange2(cm, from, to, margin) {
      var sPos = calculateScrollPos2(cm, {
        left: Math.min(from.left, to.left),
        top: Math.min(from.top, to.top) - margin,
        right: Math.max(from.right, to.right),
        bottom: Math.max(from.bottom, to.bottom) + margin
      });
      scrollToCoords2(cm, sPos.scrollLeft, sPos.scrollTop);
    }
    function updateScrollTop2(cm, val) {
      if (Math.abs(cm.doc.scrollTop - val) < 2) {
        return;
      }
      if (!gecko2) {
        updateDisplaySimple2(cm, { top: val });
      }
      setScrollTop2(cm, val, true);
      if (gecko2) {
        updateDisplaySimple2(cm);
      }
      startWorker2(cm, 100);
    }
    function setScrollTop2(cm, val, forceScroll) {
      val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
      if (cm.display.scroller.scrollTop == val && !forceScroll) {
        return;
      }
      cm.doc.scrollTop = val;
      cm.display.scrollbars.setScrollTop(val);
      if (cm.display.scroller.scrollTop != val) {
        cm.display.scroller.scrollTop = val;
      }
    }
    function setScrollLeft2(cm, val, isScroller, forceScroll) {
      val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
        return;
      }
      cm.doc.scrollLeft = val;
      alignHorizontally2(cm);
      if (cm.display.scroller.scrollLeft != val) {
        cm.display.scroller.scrollLeft = val;
      }
      cm.display.scrollbars.setScrollLeft(val);
    }
    function measureForScrollbars2(cm) {
      var d = cm.display, gutterW = d.gutters.offsetWidth;
      var docH = Math.round(cm.doc.height + paddingVert2(cm.display));
      return {
        clientHeight: d.scroller.clientHeight,
        viewHeight: d.wrapper.clientHeight,
        scrollWidth: d.scroller.scrollWidth,
        clientWidth: d.scroller.clientWidth,
        viewWidth: d.wrapper.clientWidth,
        barLeft: cm.options.fixedGutter ? gutterW : 0,
        docHeight: docH,
        scrollHeight: docH + scrollGap2(cm) + d.barHeight,
        nativeBarWidth: d.nativeBarWidth,
        gutterWidth: gutterW
      };
    }
    var NativeScrollbars2 = function(place, scroll, cm) {
      this.cm = cm;
      var vert = this.vert = elt2("div", [elt2("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
      var horiz = this.horiz = elt2("div", [elt2("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
      vert.tabIndex = horiz.tabIndex = -1;
      place(vert);
      place(horiz);
      on2(vert, "scroll", function() {
        if (vert.clientHeight) {
          scroll(vert.scrollTop, "vertical");
        }
      });
      on2(horiz, "scroll", function() {
        if (horiz.clientWidth) {
          scroll(horiz.scrollLeft, "horizontal");
        }
      });
      this.checkedZeroWidth = false;
      if (ie2 && ie_version2 < 8) {
        this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
      }
    };
    NativeScrollbars2.prototype.update = function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;
      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }
      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }
      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) {
          this.zeroWidthHack();
        }
        this.checkedZeroWidth = true;
      }
      return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
    };
    NativeScrollbars2.prototype.setScrollLeft = function(pos) {
      if (this.horiz.scrollLeft != pos) {
        this.horiz.scrollLeft = pos;
      }
      if (this.disableHoriz) {
        this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
      }
    };
    NativeScrollbars2.prototype.setScrollTop = function(pos) {
      if (this.vert.scrollTop != pos) {
        this.vert.scrollTop = pos;
      }
      if (this.disableVert) {
        this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
      }
    };
    NativeScrollbars2.prototype.zeroWidthHack = function() {
      var w = mac2 && !mac_geMountainLion2 ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed2();
      this.disableVert = new Delayed2();
    };
    NativeScrollbars2.prototype.enableZeroWidthBar = function(bar, delay, type2) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        var box = bar.getBoundingClientRect();
        var elt3 = type2 == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
        if (elt3 != bar) {
          bar.style.pointerEvents = "none";
        } else {
          delay.set(1e3, maybeDisable);
        }
      }
      delay.set(1e3, maybeDisable);
    };
    NativeScrollbars2.prototype.clear = function() {
      var parent2 = this.horiz.parentNode;
      parent2.removeChild(this.horiz);
      parent2.removeChild(this.vert);
    };
    var NullScrollbars2 = function() {
    };
    NullScrollbars2.prototype.update = function() {
      return { bottom: 0, right: 0 };
    };
    NullScrollbars2.prototype.setScrollLeft = function() {
    };
    NullScrollbars2.prototype.setScrollTop = function() {
    };
    NullScrollbars2.prototype.clear = function() {
    };
    function updateScrollbars2(cm, measure) {
      if (!measure) {
        measure = measureForScrollbars2(cm);
      }
      var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
      updateScrollbarsInner2(cm, measure);
      for (var i3 = 0; i3 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i3++) {
        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
          updateHeightsInViewport2(cm);
        }
        updateScrollbarsInner2(cm, measureForScrollbars2(cm));
        startWidth = cm.display.barWidth;
        startHeight = cm.display.barHeight;
      }
    }
    function updateScrollbarsInner2(cm, measure) {
      var d = cm.display;
      var sizes = d.scrollbars.update(measure);
      d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
      d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
      d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
      if (sizes.right && sizes.bottom) {
        d.scrollbarFiller.style.display = "block";
        d.scrollbarFiller.style.height = sizes.bottom + "px";
        d.scrollbarFiller.style.width = sizes.right + "px";
      } else {
        d.scrollbarFiller.style.display = "";
      }
      if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
        d.gutterFiller.style.display = "block";
        d.gutterFiller.style.height = sizes.bottom + "px";
        d.gutterFiller.style.width = measure.gutterWidth + "px";
      } else {
        d.gutterFiller.style.display = "";
      }
    }
    var scrollbarModel2 = { "native": NativeScrollbars2, "null": NullScrollbars2 };
    function initScrollbars2(cm) {
      if (cm.display.scrollbars) {
        cm.display.scrollbars.clear();
        if (cm.display.scrollbars.addClass) {
          rmClass2(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      }
      cm.display.scrollbars = new scrollbarModel2[cm.options.scrollbarStyle](function(node) {
        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
        on2(node, "mousedown", function() {
          if (cm.state.focused) {
            setTimeout(function() {
              return cm.display.input.focus();
            }, 0);
          }
        });
        node.setAttribute("cm-not-content", "true");
      }, function(pos, axis) {
        if (axis == "horizontal") {
          setScrollLeft2(cm, pos);
        } else {
          updateScrollTop2(cm, pos);
        }
      }, cm);
      if (cm.display.scrollbars.addClass) {
        addClass2(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }
    var nextOpId2 = 0;
    function startOperation2(cm) {
      cm.curOp = {
        cm,
        viewChanged: false,
        startHeight: cm.doc.height,
        forceUpdate: false,
        updateInput: 0,
        typing: false,
        changeObjs: null,
        cursorActivityHandlers: null,
        cursorActivityCalled: 0,
        selectionChanged: false,
        updateMaxLine: false,
        scrollLeft: null,
        scrollTop: null,
        scrollToPos: null,
        focus: false,
        id: ++nextOpId2,
        markArrays: null
      };
      pushOperation2(cm.curOp);
    }
    function endOperation2(cm) {
      var op = cm.curOp;
      if (op) {
        finishOperation2(op, function(group) {
          for (var i3 = 0; i3 < group.ops.length; i3++) {
            group.ops[i3].cm.curOp = null;
          }
          endOperations2(group);
        });
      }
    }
    function endOperations2(group) {
      var ops = group.ops;
      for (var i3 = 0; i3 < ops.length; i3++) {
        endOperation_R12(ops[i3]);
      }
      for (var i$12 = 0; i$12 < ops.length; i$12++) {
        endOperation_W12(ops[i$12]);
      }
      for (var i$22 = 0; i$22 < ops.length; i$22++) {
        endOperation_R22(ops[i$22]);
      }
      for (var i$3 = 0; i$3 < ops.length; i$3++) {
        endOperation_W22(ops[i$3]);
      }
      for (var i$4 = 0; i$4 < ops.length; i$4++) {
        endOperation_finish2(ops[i$4]);
      }
    }
    function endOperation_R12(op) {
      var cm = op.cm, display = cm.display;
      maybeClipScrollbars2(cm);
      if (op.updateMaxLine) {
        findMaxLine2(cm);
      }
      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
      op.update = op.mustUpdate && new DisplayUpdate2(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
    }
    function endOperation_W12(op) {
      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded2(op.cm, op.update);
    }
    function endOperation_R22(op) {
      var cm = op.cm, display = cm.display;
      if (op.updatedDisplay) {
        updateHeightsInViewport2(cm);
      }
      op.barMeasure = measureForScrollbars2(cm);
      if (display.maxLineChanged && !cm.options.lineWrapping) {
        op.adjustWidthTo = measureChar2(cm, display.maxLine, display.maxLine.text.length).left + 3;
        cm.display.sizerWidth = op.adjustWidthTo;
        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap2(cm) + cm.display.barWidth);
        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth2(cm));
      }
      if (op.updatedDisplay || op.selectionChanged) {
        op.preparedSelection = display.input.prepareSelection();
      }
    }
    function endOperation_W22(op) {
      var cm = op.cm;
      if (op.adjustWidthTo != null) {
        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
        if (op.maxScrollLeft < cm.doc.scrollLeft) {
          setScrollLeft2(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
        }
        cm.display.maxLineChanged = false;
      }
      var takeFocus = op.focus && op.focus == activeElt2();
      if (op.preparedSelection) {
        cm.display.input.showSelection(op.preparedSelection, takeFocus);
      }
      if (op.updatedDisplay || op.startHeight != cm.doc.height) {
        updateScrollbars2(cm, op.barMeasure);
      }
      if (op.updatedDisplay) {
        setDocumentHeight2(cm, op.barMeasure);
      }
      if (op.selectionChanged) {
        restartBlink2(cm);
      }
      if (cm.state.focused && op.updateInput) {
        cm.display.input.reset(op.typing);
      }
      if (takeFocus) {
        ensureFocus2(op.cm);
      }
    }
    function endOperation_finish2(op) {
      var cm = op.cm, display = cm.display, doc = cm.doc;
      if (op.updatedDisplay) {
        postUpdateDisplay2(cm, op.update);
      }
      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
        display.wheelStartX = display.wheelStartY = null;
      }
      if (op.scrollTop != null) {
        setScrollTop2(cm, op.scrollTop, op.forceScroll);
      }
      if (op.scrollLeft != null) {
        setScrollLeft2(cm, op.scrollLeft, true, true);
      }
      if (op.scrollToPos) {
        var rect = scrollPosIntoView2(cm, clipPos2(doc, op.scrollToPos.from), clipPos2(doc, op.scrollToPos.to), op.scrollToPos.margin);
        maybeScrollWindow2(cm, rect);
      }
      var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
      if (hidden) {
        for (var i3 = 0; i3 < hidden.length; ++i3) {
          if (!hidden[i3].lines.length) {
            signal2(hidden[i3], "hide");
          }
        }
      }
      if (unhidden) {
        for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
          if (unhidden[i$12].lines.length) {
            signal2(unhidden[i$12], "unhide");
          }
        }
      }
      if (display.wrapper.offsetHeight) {
        doc.scrollTop = cm.display.scroller.scrollTop;
      }
      if (op.changeObjs) {
        signal2(cm, "changes", cm, op.changeObjs);
      }
      if (op.update) {
        op.update.finish();
      }
    }
    function runInOp2(cm, f) {
      if (cm.curOp) {
        return f();
      }
      startOperation2(cm);
      try {
        return f();
      } finally {
        endOperation2(cm);
      }
    }
    function operation2(cm, f) {
      return function() {
        if (cm.curOp) {
          return f.apply(cm, arguments);
        }
        startOperation2(cm);
        try {
          return f.apply(cm, arguments);
        } finally {
          endOperation2(cm);
        }
      };
    }
    function methodOp2(f) {
      return function() {
        if (this.curOp) {
          return f.apply(this, arguments);
        }
        startOperation2(this);
        try {
          return f.apply(this, arguments);
        } finally {
          endOperation2(this);
        }
      };
    }
    function docMethodOp2(f) {
      return function() {
        var cm = this.cm;
        if (!cm || cm.curOp) {
          return f.apply(this, arguments);
        }
        startOperation2(cm);
        try {
          return f.apply(this, arguments);
        } finally {
          endOperation2(cm);
        }
      };
    }
    function startWorker2(cm, time) {
      if (cm.doc.highlightFrontier < cm.display.viewTo) {
        cm.state.highlight.set(time, bind3(highlightWorker2, cm));
      }
    }
    function highlightWorker2(cm) {
      var doc = cm.doc;
      if (doc.highlightFrontier >= cm.display.viewTo) {
        return;
      }
      var end2 = +new Date() + cm.options.workTime;
      var context = getContextBefore2(cm, doc.highlightFrontier);
      var changedLines = [];
      doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
        if (context.line >= cm.display.viewFrom) {
          var oldStyles = line.styles;
          var resetState = line.text.length > cm.options.maxHighlightLength ? copyState2(doc.mode, context.state) : null;
          var highlighted = highlightLine2(cm, line, context, true);
          if (resetState) {
            context.state = resetState;
          }
          line.styles = highlighted.styles;
          var oldCls = line.styleClasses, newCls = highlighted.classes;
          if (newCls) {
            line.styleClasses = newCls;
          } else if (oldCls) {
            line.styleClasses = null;
          }
          var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
          for (var i3 = 0; !ischange && i3 < oldStyles.length; ++i3) {
            ischange = oldStyles[i3] != line.styles[i3];
          }
          if (ischange) {
            changedLines.push(context.line);
          }
          line.stateAfter = context.save();
          context.nextLine();
        } else {
          if (line.text.length <= cm.options.maxHighlightLength) {
            processLine2(cm, line.text, context);
          }
          line.stateAfter = context.line % 5 == 0 ? context.save() : null;
          context.nextLine();
        }
        if (+new Date() > end2) {
          startWorker2(cm, cm.options.workDelay);
          return true;
        }
      });
      doc.highlightFrontier = context.line;
      doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
      if (changedLines.length) {
        runInOp2(cm, function() {
          for (var i3 = 0; i3 < changedLines.length; i3++) {
            regLineChange2(cm, changedLines[i3], "text");
          }
        });
      }
    }
    var DisplayUpdate2 = function(cm, viewport2, force) {
      var display = cm.display;
      this.viewport = viewport2;
      this.visible = visibleLines2(display, cm.doc, viewport2);
      this.editorIsHidden = !display.wrapper.offsetWidth;
      this.wrapperHeight = display.wrapper.clientHeight;
      this.wrapperWidth = display.wrapper.clientWidth;
      this.oldDisplayWidth = displayWidth2(cm);
      this.force = force;
      this.dims = getDimensions2(cm);
      this.events = [];
    };
    DisplayUpdate2.prototype.signal = function(emitter, type2) {
      if (hasHandler2(emitter, type2)) {
        this.events.push(arguments);
      }
    };
    DisplayUpdate2.prototype.finish = function() {
      for (var i3 = 0; i3 < this.events.length; i3++) {
        signal2.apply(null, this.events[i3]);
      }
    };
    function maybeClipScrollbars2(cm) {
      var display = cm.display;
      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
        display.heightForcer.style.height = scrollGap2(cm) + "px";
        display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
        display.sizer.style.borderRightWidth = scrollGap2(cm) + "px";
        display.scrollbarsClipped = true;
      }
    }
    function selectionSnapshot2(cm) {
      if (cm.hasFocus()) {
        return null;
      }
      var active = activeElt2();
      if (!active || !contains2(cm.display.lineDiv, active)) {
        return null;
      }
      var result = { activeElt: active };
      if (window.getSelection) {
        var sel = window.getSelection();
        if (sel.anchorNode && sel.extend && contains2(cm.display.lineDiv, sel.anchorNode)) {
          result.anchorNode = sel.anchorNode;
          result.anchorOffset = sel.anchorOffset;
          result.focusNode = sel.focusNode;
          result.focusOffset = sel.focusOffset;
        }
      }
      return result;
    }
    function restoreSelection2(snapshot) {
      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt2()) {
        return;
      }
      snapshot.activeElt.focus();
      if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains2(document.body, snapshot.anchorNode) && contains2(document.body, snapshot.focusNode)) {
        var sel = window.getSelection(), range3 = document.createRange();
        range3.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
        range3.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range3);
        sel.extend(snapshot.focusNode, snapshot.focusOffset);
      }
    }
    function updateDisplayIfNeeded2(cm, update) {
      var display = cm.display, doc = cm.doc;
      if (update.editorIsHidden) {
        resetView2(cm);
        return false;
      }
      if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView2(cm) == 0) {
        return false;
      }
      if (maybeUpdateLineNumberWidth2(cm)) {
        resetView2(cm);
        update.dims = getDimensions2(cm);
      }
      var end2 = doc.first + doc.size;
      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
      var to = Math.min(end2, update.visible.to + cm.options.viewportMargin);
      if (display.viewFrom < from && from - display.viewFrom < 20) {
        from = Math.max(doc.first, display.viewFrom);
      }
      if (display.viewTo > to && display.viewTo - to < 20) {
        to = Math.min(end2, display.viewTo);
      }
      if (sawCollapsedSpans2) {
        from = visualLineNo2(cm.doc, from);
        to = visualLineEndNo2(cm.doc, to);
      }
      var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
      adjustView2(cm, from, to);
      display.viewOffset = heightAtLine2(getLine2(cm.doc, display.viewFrom));
      cm.display.mover.style.top = display.viewOffset + "px";
      var toUpdate = countDirtyView2(cm);
      if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
        return false;
      }
      var selSnapshot = selectionSnapshot2(cm);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "none";
      }
      patchDisplay2(cm, display.updateLineNumbers, update.dims);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "";
      }
      display.renderedView = display.view;
      restoreSelection2(selSnapshot);
      removeChildren2(display.cursorDiv);
      removeChildren2(display.selectionDiv);
      display.gutters.style.height = display.sizer.style.minHeight = 0;
      if (different) {
        display.lastWrapHeight = update.wrapperHeight;
        display.lastWrapWidth = update.wrapperWidth;
        startWorker2(cm, 400);
      }
      display.updateLineNumbers = null;
      return true;
    }
    function postUpdateDisplay2(cm, update) {
      var viewport2 = update.viewport;
      for (var first = true; ; first = false) {
        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth2(cm)) {
          if (viewport2 && viewport2.top != null) {
            viewport2 = { top: Math.min(cm.doc.height + paddingVert2(cm.display) - displayHeight2(cm), viewport2.top) };
          }
          update.visible = visibleLines2(cm.display, cm.doc, viewport2);
          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
            break;
          }
        } else if (first) {
          update.visible = visibleLines2(cm.display, cm.doc, viewport2);
        }
        if (!updateDisplayIfNeeded2(cm, update)) {
          break;
        }
        updateHeightsInViewport2(cm);
        var barMeasure = measureForScrollbars2(cm);
        updateSelection2(cm);
        updateScrollbars2(cm, barMeasure);
        setDocumentHeight2(cm, barMeasure);
        update.force = false;
      }
      update.signal(cm, "update", cm);
      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
        update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
        cm.display.reportedViewFrom = cm.display.viewFrom;
        cm.display.reportedViewTo = cm.display.viewTo;
      }
    }
    function updateDisplaySimple2(cm, viewport2) {
      var update = new DisplayUpdate2(cm, viewport2);
      if (updateDisplayIfNeeded2(cm, update)) {
        updateHeightsInViewport2(cm);
        postUpdateDisplay2(cm, update);
        var barMeasure = measureForScrollbars2(cm);
        updateSelection2(cm);
        updateScrollbars2(cm, barMeasure);
        setDocumentHeight2(cm, barMeasure);
        update.finish();
      }
    }
    function patchDisplay2(cm, updateNumbersFrom, dims) {
      var display = cm.display, lineNumbers = cm.options.lineNumbers;
      var container = display.lineDiv, cur = container.firstChild;
      function rm(node2) {
        var next = node2.nextSibling;
        if (webkit2 && mac2 && cm.display.currentWheelTarget == node2) {
          node2.style.display = "none";
        } else {
          node2.parentNode.removeChild(node2);
        }
        return next;
      }
      var view = display.view, lineN = display.viewFrom;
      for (var i3 = 0; i3 < view.length; i3++) {
        var lineView = view[i3];
        if (lineView.hidden)
          ;
        else if (!lineView.node || lineView.node.parentNode != container) {
          var node = buildLineElement2(cm, lineView, lineN, dims);
          container.insertBefore(node, cur);
        } else {
          while (cur != lineView.node) {
            cur = rm(cur);
          }
          var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
          if (lineView.changes) {
            if (indexOf2(lineView.changes, "gutter") > -1) {
              updateNumber = false;
            }
            updateLineForChanges2(cm, lineView, lineN, dims);
          }
          if (updateNumber) {
            removeChildren2(lineView.lineNumber);
            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor2(cm.options, lineN)));
          }
          cur = lineView.node.nextSibling;
        }
        lineN += lineView.size;
      }
      while (cur) {
        cur = rm(cur);
      }
    }
    function updateGutterSpace2(display) {
      var width2 = display.gutters.offsetWidth;
      display.sizer.style.marginLeft = width2 + "px";
      signalLater2(display, "gutterChanged", display);
    }
    function setDocumentHeight2(cm, measure) {
      cm.display.sizer.style.minHeight = measure.docHeight + "px";
      cm.display.heightForcer.style.top = measure.docHeight + "px";
      cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap2(cm) + "px";
    }
    function alignHorizontally2(cm) {
      var display = cm.display, view = display.view;
      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
        return;
      }
      var comp = compensateForHScroll2(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
      var gutterW = display.gutters.offsetWidth, left2 = comp + "px";
      for (var i3 = 0; i3 < view.length; i3++) {
        if (!view[i3].hidden) {
          if (cm.options.fixedGutter) {
            if (view[i3].gutter) {
              view[i3].gutter.style.left = left2;
            }
            if (view[i3].gutterBackground) {
              view[i3].gutterBackground.style.left = left2;
            }
          }
          var align = view[i3].alignable;
          if (align) {
            for (var j = 0; j < align.length; j++) {
              align[j].style.left = left2;
            }
          }
        }
      }
      if (cm.options.fixedGutter) {
        display.gutters.style.left = comp + gutterW + "px";
      }
    }
    function maybeUpdateLineNumberWidth2(cm) {
      if (!cm.options.lineNumbers) {
        return false;
      }
      var doc = cm.doc, last = lineNumberFor2(cm.options, doc.first + doc.size - 1), display = cm.display;
      if (last.length != display.lineNumChars) {
        var test = display.measure.appendChild(elt2("div", [elt2("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
        var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
        display.lineGutter.style.width = "";
        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
        display.lineNumWidth = display.lineNumInnerWidth + padding;
        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
        display.lineGutter.style.width = display.lineNumWidth + "px";
        updateGutterSpace2(cm.display);
        return true;
      }
      return false;
    }
    function getGutters2(gutters, lineNumbers) {
      var result = [], sawLineNumbers = false;
      for (var i3 = 0; i3 < gutters.length; i3++) {
        var name2 = gutters[i3], style = null;
        if (typeof name2 != "string") {
          style = name2.style;
          name2 = name2.className;
        }
        if (name2 == "CodeMirror-linenumbers") {
          if (!lineNumbers) {
            continue;
          } else {
            sawLineNumbers = true;
          }
        }
        result.push({ className: name2, style });
      }
      if (lineNumbers && !sawLineNumbers) {
        result.push({ className: "CodeMirror-linenumbers", style: null });
      }
      return result;
    }
    function renderGutters2(display) {
      var gutters = display.gutters, specs = display.gutterSpecs;
      removeChildren2(gutters);
      display.lineGutter = null;
      for (var i3 = 0; i3 < specs.length; ++i3) {
        var ref2 = specs[i3];
        var className = ref2.className;
        var style = ref2.style;
        var gElt = gutters.appendChild(elt2("div", null, "CodeMirror-gutter " + className));
        if (style) {
          gElt.style.cssText = style;
        }
        if (className == "CodeMirror-linenumbers") {
          display.lineGutter = gElt;
          gElt.style.width = (display.lineNumWidth || 1) + "px";
        }
      }
      gutters.style.display = specs.length ? "" : "none";
      updateGutterSpace2(display);
    }
    function updateGutters2(cm) {
      renderGutters2(cm.display);
      regChange2(cm);
      alignHorizontally2(cm);
    }
    function Display2(place, doc, input2, options2) {
      var d = this;
      this.input = input2;
      d.scrollbarFiller = elt2("div", null, "CodeMirror-scrollbar-filler");
      d.scrollbarFiller.setAttribute("cm-not-content", "true");
      d.gutterFiller = elt2("div", null, "CodeMirror-gutter-filler");
      d.gutterFiller.setAttribute("cm-not-content", "true");
      d.lineDiv = eltP2("div", null, "CodeMirror-code");
      d.selectionDiv = elt2("div", null, null, "position: relative; z-index: 1");
      d.cursorDiv = elt2("div", null, "CodeMirror-cursors");
      d.measure = elt2("div", null, "CodeMirror-measure");
      d.lineMeasure = elt2("div", null, "CodeMirror-measure");
      d.lineSpace = eltP2("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
      var lines = eltP2("div", [d.lineSpace], "CodeMirror-lines");
      d.mover = elt2("div", [lines], null, "position: relative");
      d.sizer = elt2("div", [d.mover], "CodeMirror-sizer");
      d.sizerWidth = null;
      d.heightForcer = elt2("div", null, null, "position: absolute; height: " + scrollerGap2 + "px; width: 1px;");
      d.gutters = elt2("div", null, "CodeMirror-gutters");
      d.lineGutter = null;
      d.scroller = elt2("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
      d.scroller.setAttribute("tabIndex", "-1");
      d.wrapper = elt2("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
      d.wrapper.setAttribute("translate", "no");
      if (ie2 && ie_version2 < 8) {
        d.gutters.style.zIndex = -1;
        d.scroller.style.paddingRight = 0;
      }
      if (!webkit2 && !(gecko2 && mobile2)) {
        d.scroller.draggable = true;
      }
      if (place) {
        if (place.appendChild) {
          place.appendChild(d.wrapper);
        } else {
          place(d.wrapper);
        }
      }
      d.viewFrom = d.viewTo = doc.first;
      d.reportedViewFrom = d.reportedViewTo = doc.first;
      d.view = [];
      d.renderedView = null;
      d.externalMeasured = null;
      d.viewOffset = 0;
      d.lastWrapHeight = d.lastWrapWidth = 0;
      d.updateLineNumbers = null;
      d.nativeBarWidth = d.barHeight = d.barWidth = 0;
      d.scrollbarsClipped = false;
      d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
      d.alignWidgets = false;
      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
      d.maxLine = null;
      d.maxLineLength = 0;
      d.maxLineChanged = false;
      d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
      d.shift = false;
      d.selForContextMenu = null;
      d.activeTouch = null;
      d.gutterSpecs = getGutters2(options2.gutters, options2.lineNumbers);
      renderGutters2(d);
      input2.init(d);
    }
    var wheelSamples2 = 0, wheelPixelsPerUnit2 = null;
    if (ie2) {
      wheelPixelsPerUnit2 = -0.53;
    } else if (gecko2) {
      wheelPixelsPerUnit2 = 15;
    } else if (chrome2) {
      wheelPixelsPerUnit2 = -0.7;
    } else if (safari2) {
      wheelPixelsPerUnit2 = -1 / 3;
    }
    function wheelEventDelta2(e) {
      var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
        dx = e.detail;
      }
      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
        dy = e.detail;
      } else if (dy == null) {
        dy = e.wheelDelta;
      }
      return { x: dx, y: dy };
    }
    function wheelEventPixels2(e) {
      var delta = wheelEventDelta2(e);
      delta.x *= wheelPixelsPerUnit2;
      delta.y *= wheelPixelsPerUnit2;
      return delta;
    }
    function onScrollWheel2(cm, e) {
      var delta = wheelEventDelta2(e), dx = delta.x, dy = delta.y;
      var pixelsPerUnit = wheelPixelsPerUnit2;
      if (event.deltaMode === 0) {
        dx = e.deltaX;
        dy = e.deltaY;
        pixelsPerUnit = 1;
      }
      var display = cm.display, scroll = display.scroller;
      var canScrollX = scroll.scrollWidth > scroll.clientWidth;
      var canScrollY = scroll.scrollHeight > scroll.clientHeight;
      if (!(dx && canScrollX || dy && canScrollY)) {
        return;
      }
      if (dy && mac2 && webkit2) {
        outer:
          for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i3 = 0; i3 < view.length; i3++) {
              if (view[i3].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
      }
      if (dx && !gecko2 && !presto2 && pixelsPerUnit != null) {
        if (dy && canScrollY) {
          updateScrollTop2(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
        }
        setScrollLeft2(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
        if (!dy || dy && canScrollY) {
          e_preventDefault2(e);
        }
        display.wheelStartX = null;
        return;
      }
      if (dy && pixelsPerUnit != null) {
        var pixels = dy * pixelsPerUnit;
        var top2 = cm.doc.scrollTop, bot = top2 + display.wrapper.clientHeight;
        if (pixels < 0) {
          top2 = Math.max(0, top2 + pixels - 50);
        } else {
          bot = Math.min(cm.doc.height, bot + pixels + 50);
        }
        updateDisplaySimple2(cm, { top: top2, bottom: bot });
      }
      if (wheelSamples2 < 20 && e.deltaMode !== 0) {
        if (display.wheelStartX == null) {
          display.wheelStartX = scroll.scrollLeft;
          display.wheelStartY = scroll.scrollTop;
          display.wheelDX = dx;
          display.wheelDY = dy;
          setTimeout(function() {
            if (display.wheelStartX == null) {
              return;
            }
            var movedX = scroll.scrollLeft - display.wheelStartX;
            var movedY = scroll.scrollTop - display.wheelStartY;
            var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
            display.wheelStartX = display.wheelStartY = null;
            if (!sample) {
              return;
            }
            wheelPixelsPerUnit2 = (wheelPixelsPerUnit2 * wheelSamples2 + sample) / (wheelSamples2 + 1);
            ++wheelSamples2;
          }, 200);
        } else {
          display.wheelDX += dx;
          display.wheelDY += dy;
        }
      }
    }
    var Selection2 = function(ranges, primIndex) {
      this.ranges = ranges;
      this.primIndex = primIndex;
    };
    Selection2.prototype.primary = function() {
      return this.ranges[this.primIndex];
    };
    Selection2.prototype.equals = function(other) {
      if (other == this) {
        return true;
      }
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
        return false;
      }
      for (var i3 = 0; i3 < this.ranges.length; i3++) {
        var here = this.ranges[i3], there = other.ranges[i3];
        if (!equalCursorPos2(here.anchor, there.anchor) || !equalCursorPos2(here.head, there.head)) {
          return false;
        }
      }
      return true;
    };
    Selection2.prototype.deepCopy = function() {
      var out = [];
      for (var i3 = 0; i3 < this.ranges.length; i3++) {
        out[i3] = new Range2(copyPos2(this.ranges[i3].anchor), copyPos2(this.ranges[i3].head));
      }
      return new Selection2(out, this.primIndex);
    };
    Selection2.prototype.somethingSelected = function() {
      for (var i3 = 0; i3 < this.ranges.length; i3++) {
        if (!this.ranges[i3].empty()) {
          return true;
        }
      }
      return false;
    };
    Selection2.prototype.contains = function(pos, end2) {
      if (!end2) {
        end2 = pos;
      }
      for (var i3 = 0; i3 < this.ranges.length; i3++) {
        var range3 = this.ranges[i3];
        if (cmp2(end2, range3.from()) >= 0 && cmp2(pos, range3.to()) <= 0) {
          return i3;
        }
      }
      return -1;
    };
    var Range2 = function(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    };
    Range2.prototype.from = function() {
      return minPos2(this.anchor, this.head);
    };
    Range2.prototype.to = function() {
      return maxPos2(this.anchor, this.head);
    };
    Range2.prototype.empty = function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    };
    function normalizeSelection2(cm, ranges, primIndex) {
      var mayTouch = cm && cm.options.selectionsMayTouch;
      var prim = ranges[primIndex];
      ranges.sort(function(a, b) {
        return cmp2(a.from(), b.from());
      });
      primIndex = indexOf2(ranges, prim);
      for (var i3 = 1; i3 < ranges.length; i3++) {
        var cur = ranges[i3], prev = ranges[i3 - 1];
        var diff = cmp2(prev.to(), cur.from());
        if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
          var from = minPos2(prev.from(), cur.from()), to = maxPos2(prev.to(), cur.to());
          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
          if (i3 <= primIndex) {
            --primIndex;
          }
          ranges.splice(--i3, 2, new Range2(inv ? to : from, inv ? from : to));
        }
      }
      return new Selection2(ranges, primIndex);
    }
    function simpleSelection2(anchor, head) {
      return new Selection2([new Range2(anchor, head || anchor)], 0);
    }
    function changeEnd2(change) {
      if (!change.text) {
        return change.to;
      }
      return Pos2(change.from.line + change.text.length - 1, lst2(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    }
    function adjustForChange2(pos, change) {
      if (cmp2(pos, change.from) < 0) {
        return pos;
      }
      if (cmp2(pos, change.to) <= 0) {
        return changeEnd2(change);
      }
      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line) {
        ch += changeEnd2(change).ch - change.to.ch;
      }
      return Pos2(line, ch);
    }
    function computeSelAfterChange2(doc, change) {
      var out = [];
      for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
        var range3 = doc.sel.ranges[i3];
        out.push(new Range2(adjustForChange2(range3.anchor, change), adjustForChange2(range3.head, change)));
      }
      return normalizeSelection2(doc.cm, out, doc.sel.primIndex);
    }
    function offsetPos2(pos, old, nw) {
      if (pos.line == old.line) {
        return Pos2(nw.line, pos.ch - old.ch + nw.ch);
      } else {
        return Pos2(nw.line + (pos.line - old.line), pos.ch);
      }
    }
    function computeReplacedSel2(doc, changes, hint) {
      var out = [];
      var oldPrev = Pos2(doc.first, 0), newPrev = oldPrev;
      for (var i3 = 0; i3 < changes.length; i3++) {
        var change = changes[i3];
        var from = offsetPos2(change.from, oldPrev, newPrev);
        var to = offsetPos2(changeEnd2(change), oldPrev, newPrev);
        oldPrev = change.to;
        newPrev = to;
        if (hint == "around") {
          var range3 = doc.sel.ranges[i3], inv = cmp2(range3.head, range3.anchor) < 0;
          out[i3] = new Range2(inv ? to : from, inv ? from : to);
        } else {
          out[i3] = new Range2(from, from);
        }
      }
      return new Selection2(out, doc.sel.primIndex);
    }
    function loadMode2(cm) {
      cm.doc.mode = getMode2(cm.options, cm.doc.modeOption);
      resetModeState2(cm);
    }
    function resetModeState2(cm) {
      cm.doc.iter(function(line) {
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        if (line.styles) {
          line.styles = null;
        }
      });
      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
      startWorker2(cm, 100);
      cm.state.modeGen++;
      if (cm.curOp) {
        regChange2(cm);
      }
    }
    function isWholeLineUpdate2(doc, change) {
      return change.from.ch == 0 && change.to.ch == 0 && lst2(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc2(doc, change, markedSpans, estimateHeight3) {
      function spansFor(n) {
        return markedSpans ? markedSpans[n] : null;
      }
      function update(line, text2, spans) {
        updateLine2(line, text2, spans, estimateHeight3);
        signalLater2(line, "change", line, change);
      }
      function linesFor(start2, end2) {
        var result = [];
        for (var i3 = start2; i3 < end2; ++i3) {
          result.push(new Line2(text[i3], spansFor(i3), estimateHeight3));
        }
        return result;
      }
      var from = change.from, to = change.to, text = change.text;
      var firstLine = getLine2(doc, from.line), lastLine = getLine2(doc, to.line);
      var lastText = lst2(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
      if (change.full) {
        doc.insert(0, linesFor(0, text.length));
        doc.remove(text.length, doc.size - text.length);
      } else if (isWholeLineUpdate2(doc, change)) {
        var added = linesFor(0, text.length - 1);
        update(lastLine, lastLine.text, lastSpans);
        if (nlines) {
          doc.remove(from.line, nlines);
        }
        if (added.length) {
          doc.insert(from.line, added);
        }
      } else if (firstLine == lastLine) {
        if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
        } else {
          var added$1 = linesFor(1, text.length - 1);
          added$1.push(new Line2(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight3));
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          doc.insert(from.line + 1, added$1);
        }
      } else if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
        doc.remove(from.line + 1, nlines);
      } else {
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
        var added$2 = linesFor(1, text.length - 1);
        if (nlines > 1) {
          doc.remove(from.line + 1, nlines - 1);
        }
        doc.insert(from.line + 1, added$2);
      }
      signalLater2(doc, "change", doc, change);
    }
    function linkedDocs2(doc, f, sharedHistOnly) {
      function propagate(doc2, skip, sharedHist) {
        if (doc2.linked) {
          for (var i3 = 0; i3 < doc2.linked.length; ++i3) {
            var rel = doc2.linked[i3];
            if (rel.doc == skip) {
              continue;
            }
            var shared = sharedHist && rel.sharedHist;
            if (sharedHistOnly && !shared) {
              continue;
            }
            f(rel.doc, shared);
            propagate(rel.doc, doc2, shared);
          }
        }
      }
      propagate(doc, null, true);
    }
    function attachDoc2(cm, doc) {
      if (doc.cm) {
        throw new Error("This document is already in use.");
      }
      cm.doc = doc;
      doc.cm = cm;
      estimateLineHeights2(cm);
      loadMode2(cm);
      setDirectionClass2(cm);
      cm.options.direction = doc.direction;
      if (!cm.options.lineWrapping) {
        findMaxLine2(cm);
      }
      cm.options.mode = doc.modeOption;
      regChange2(cm);
    }
    function setDirectionClass2(cm) {
      (cm.doc.direction == "rtl" ? addClass2 : rmClass2)(cm.display.lineDiv, "CodeMirror-rtl");
    }
    function directionChanged2(cm) {
      runInOp2(cm, function() {
        setDirectionClass2(cm);
        regChange2(cm);
      });
    }
    function History2(prev) {
      this.done = [];
      this.undone = [];
      this.undoDepth = prev ? prev.undoDepth : Infinity;
      this.lastModTime = this.lastSelTime = 0;
      this.lastOp = this.lastSelOp = null;
      this.lastOrigin = this.lastSelOrigin = null;
      this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
    }
    function historyChangeFromChange2(doc, change) {
      var histChange = { from: copyPos2(change.from), to: changeEnd2(change), text: getBetween2(doc, change.from, change.to) };
      attachLocalSpans2(doc, histChange, change.from.line, change.to.line + 1);
      linkedDocs2(doc, function(doc2) {
        return attachLocalSpans2(doc2, histChange, change.from.line, change.to.line + 1);
      }, true);
      return histChange;
    }
    function clearSelectionEvents2(array3) {
      while (array3.length) {
        var last = lst2(array3);
        if (last.ranges) {
          array3.pop();
        } else {
          break;
        }
      }
    }
    function lastChangeEvent2(hist, force) {
      if (force) {
        clearSelectionEvents2(hist.done);
        return lst2(hist.done);
      } else if (hist.done.length && !lst2(hist.done).ranges) {
        return lst2(hist.done);
      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
        hist.done.pop();
        return lst2(hist.done);
      }
    }
    function addChangeToHistory2(doc, change, selAfter, opId) {
      var hist = doc.history;
      hist.undone.length = 0;
      var time = +new Date(), cur;
      var last;
      if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent2(hist, hist.lastOp == opId))) {
        last = lst2(cur.changes);
        if (cmp2(change.from, change.to) == 0 && cmp2(change.from, last.to) == 0) {
          last.to = changeEnd2(change);
        } else {
          cur.changes.push(historyChangeFromChange2(doc, change));
        }
      } else {
        var before = lst2(hist.done);
        if (!before || !before.ranges) {
          pushSelectionToHistory2(doc.sel, hist.done);
        }
        cur = {
          changes: [historyChangeFromChange2(doc, change)],
          generation: hist.generation
        };
        hist.done.push(cur);
        while (hist.done.length > hist.undoDepth) {
          hist.done.shift();
          if (!hist.done[0].ranges) {
            hist.done.shift();
          }
        }
      }
      hist.done.push(selAfter);
      hist.generation = ++hist.maxGeneration;
      hist.lastModTime = hist.lastSelTime = time;
      hist.lastOp = hist.lastSelOp = opId;
      hist.lastOrigin = hist.lastSelOrigin = change.origin;
      if (!last) {
        signal2(doc, "historyAdded");
      }
    }
    function selectionEventCanBeMerged2(doc, origin, prev, sel) {
      var ch = origin.charAt(0);
      return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory2(doc, sel, opId, options2) {
      var hist = doc.history, origin = options2 && options2.origin;
      if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged2(doc, origin, lst2(hist.done), sel))) {
        hist.done[hist.done.length - 1] = sel;
      } else {
        pushSelectionToHistory2(sel, hist.done);
      }
      hist.lastSelTime = +new Date();
      hist.lastSelOrigin = origin;
      hist.lastSelOp = opId;
      if (options2 && options2.clearRedo !== false) {
        clearSelectionEvents2(hist.undone);
      }
    }
    function pushSelectionToHistory2(sel, dest) {
      var top2 = lst2(dest);
      if (!(top2 && top2.ranges && top2.equals(sel))) {
        dest.push(sel);
      }
    }
    function attachLocalSpans2(doc, change, from, to) {
      var existing = change["spans_" + doc.id], n = 0;
      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
        if (line.markedSpans) {
          (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
        }
        ++n;
      });
    }
    function removeClearedSpans2(spans) {
      if (!spans) {
        return null;
      }
      var out;
      for (var i3 = 0; i3 < spans.length; ++i3) {
        if (spans[i3].marker.explicitlyCleared) {
          if (!out) {
            out = spans.slice(0, i3);
          }
        } else if (out) {
          out.push(spans[i3]);
        }
      }
      return !out ? spans : out.length ? out : null;
    }
    function getOldSpans2(doc, change) {
      var found = change["spans_" + doc.id];
      if (!found) {
        return null;
      }
      var nw = [];
      for (var i3 = 0; i3 < change.text.length; ++i3) {
        nw.push(removeClearedSpans2(found[i3]));
      }
      return nw;
    }
    function mergeOldSpans2(doc, change) {
      var old = getOldSpans2(doc, change);
      var stretched = stretchSpansOverChange2(doc, change);
      if (!old) {
        return stretched;
      }
      if (!stretched) {
        return old;
      }
      for (var i3 = 0; i3 < old.length; ++i3) {
        var oldCur = old[i3], stretchCur = stretched[i3];
        if (oldCur && stretchCur) {
          spans:
            for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k) {
                if (oldCur[k].marker == span.marker) {
                  continue spans;
                }
              }
              oldCur.push(span);
            }
        } else if (stretchCur) {
          old[i3] = stretchCur;
        }
      }
      return old;
    }
    function copyHistoryArray2(events2, newGroup, instantiateSel) {
      var copy = [];
      for (var i3 = 0; i3 < events2.length; ++i3) {
        var event2 = events2[i3];
        if (event2.ranges) {
          copy.push(instantiateSel ? Selection2.prototype.deepCopy.call(event2) : event2);
          continue;
        }
        var changes = event2.changes, newChanges = [];
        copy.push({ changes: newChanges });
        for (var j = 0; j < changes.length; ++j) {
          var change = changes[j], m = void 0;
          newChanges.push({ from: change.from, to: change.to, text: change.text });
          if (newGroup) {
            for (var prop2 in change) {
              if (m = prop2.match(/^spans_(\d+)$/)) {
                if (indexOf2(newGroup, Number(m[1])) > -1) {
                  lst2(newChanges)[prop2] = change[prop2];
                  delete change[prop2];
                }
              }
            }
          }
        }
      }
      return copy;
    }
    function extendRange2(range3, head, other, extend2) {
      if (extend2) {
        var anchor = range3.anchor;
        if (other) {
          var posBefore = cmp2(head, anchor) < 0;
          if (posBefore != cmp2(other, anchor) < 0) {
            anchor = head;
            head = other;
          } else if (posBefore != cmp2(head, other) < 0) {
            head = other;
          }
        }
        return new Range2(anchor, head);
      } else {
        return new Range2(other || head, head);
      }
    }
    function extendSelection2(doc, head, other, options2, extend2) {
      if (extend2 == null) {
        extend2 = doc.cm && (doc.cm.display.shift || doc.extend);
      }
      setSelection2(doc, new Selection2([extendRange2(doc.sel.primary(), head, other, extend2)], 0), options2);
    }
    function extendSelections2(doc, heads, options2) {
      var out = [];
      var extend2 = doc.cm && (doc.cm.display.shift || doc.extend);
      for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
        out[i3] = extendRange2(doc.sel.ranges[i3], heads[i3], null, extend2);
      }
      var newSel = normalizeSelection2(doc.cm, out, doc.sel.primIndex);
      setSelection2(doc, newSel, options2);
    }
    function replaceOneSelection2(doc, i3, range3, options2) {
      var ranges = doc.sel.ranges.slice(0);
      ranges[i3] = range3;
      setSelection2(doc, normalizeSelection2(doc.cm, ranges, doc.sel.primIndex), options2);
    }
    function setSimpleSelection2(doc, anchor, head, options2) {
      setSelection2(doc, simpleSelection2(anchor, head), options2);
    }
    function filterSelectionChange2(doc, sel, options2) {
      var obj = {
        ranges: sel.ranges,
        update: function(ranges) {
          this.ranges = [];
          for (var i3 = 0; i3 < ranges.length; i3++) {
            this.ranges[i3] = new Range2(clipPos2(doc, ranges[i3].anchor), clipPos2(doc, ranges[i3].head));
          }
        },
        origin: options2 && options2.origin
      };
      signal2(doc, "beforeSelectionChange", doc, obj);
      if (doc.cm) {
        signal2(doc.cm, "beforeSelectionChange", doc.cm, obj);
      }
      if (obj.ranges != sel.ranges) {
        return normalizeSelection2(doc.cm, obj.ranges, obj.ranges.length - 1);
      } else {
        return sel;
      }
    }
    function setSelectionReplaceHistory2(doc, sel, options2) {
      var done = doc.history.done, last = lst2(done);
      if (last && last.ranges) {
        done[done.length - 1] = sel;
        setSelectionNoUndo2(doc, sel, options2);
      } else {
        setSelection2(doc, sel, options2);
      }
    }
    function setSelection2(doc, sel, options2) {
      setSelectionNoUndo2(doc, sel, options2);
      addSelectionToHistory2(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options2);
    }
    function setSelectionNoUndo2(doc, sel, options2) {
      if (hasHandler2(doc, "beforeSelectionChange") || doc.cm && hasHandler2(doc.cm, "beforeSelectionChange")) {
        sel = filterSelectionChange2(doc, sel, options2);
      }
      var bias = options2 && options2.bias || (cmp2(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
      setSelectionInner2(doc, skipAtomicInSelection2(doc, sel, bias, true));
      if (!(options2 && options2.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
        ensureCursorVisible2(doc.cm);
      }
    }
    function setSelectionInner2(doc, sel) {
      if (sel.equals(doc.sel)) {
        return;
      }
      doc.sel = sel;
      if (doc.cm) {
        doc.cm.curOp.updateInput = 1;
        doc.cm.curOp.selectionChanged = true;
        signalCursorActivity2(doc.cm);
      }
      signalLater2(doc, "cursorActivity", doc);
    }
    function reCheckSelection2(doc) {
      setSelectionInner2(doc, skipAtomicInSelection2(doc, doc.sel, null, false));
    }
    function skipAtomicInSelection2(doc, sel, bias, mayClear) {
      var out;
      for (var i3 = 0; i3 < sel.ranges.length; i3++) {
        var range3 = sel.ranges[i3];
        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i3];
        var newAnchor = skipAtomic2(doc, range3.anchor, old && old.anchor, bias, mayClear);
        var newHead = skipAtomic2(doc, range3.head, old && old.head, bias, mayClear);
        if (out || newAnchor != range3.anchor || newHead != range3.head) {
          if (!out) {
            out = sel.ranges.slice(0, i3);
          }
          out[i3] = new Range2(newAnchor, newHead);
        }
      }
      return out ? normalizeSelection2(doc.cm, out, sel.primIndex) : sel;
    }
    function skipAtomicInner2(doc, pos, oldPos, dir, mayClear) {
      var line = getLine2(doc, pos.line);
      if (line.markedSpans) {
        for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
          var sp = line.markedSpans[i3], m = sp.marker;
          var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
          var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
          if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
            if (mayClear) {
              signal2(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) {
                  break;
                } else {
                  --i3;
                  continue;
                }
              }
            }
            if (!m.atomic) {
              continue;
            }
            if (oldPos) {
              var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
              if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                near = movePos2(doc, near, -dir, near && near.line == pos.line ? line : null);
              }
              if (near && near.line == pos.line && (diff = cmp2(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                return skipAtomicInner2(doc, near, pos, dir, mayClear);
              }
            }
            var far = m.find(dir < 0 ? -1 : 1);
            if (dir < 0 ? preventCursorLeft : preventCursorRight) {
              far = movePos2(doc, far, dir, far.line == pos.line ? line : null);
            }
            return far ? skipAtomicInner2(doc, far, pos, dir, mayClear) : null;
          }
        }
      }
      return pos;
    }
    function skipAtomic2(doc, pos, oldPos, bias, mayClear) {
      var dir = bias || 1;
      var found = skipAtomicInner2(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner2(doc, pos, oldPos, dir, true) || skipAtomicInner2(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner2(doc, pos, oldPos, -dir, true);
      if (!found) {
        doc.cantEdit = true;
        return Pos2(doc.first, 0);
      }
      return found;
    }
    function movePos2(doc, pos, dir, line) {
      if (dir < 0 && pos.ch == 0) {
        if (pos.line > doc.first) {
          return clipPos2(doc, Pos2(pos.line - 1));
        } else {
          return null;
        }
      } else if (dir > 0 && pos.ch == (line || getLine2(doc, pos.line)).text.length) {
        if (pos.line < doc.first + doc.size - 1) {
          return Pos2(pos.line + 1, 0);
        } else {
          return null;
        }
      } else {
        return new Pos2(pos.line, pos.ch + dir);
      }
    }
    function selectAll2(cm) {
      cm.setSelection(Pos2(cm.firstLine(), 0), Pos2(cm.lastLine()), sel_dontScroll2);
    }
    function filterChange2(doc, change, update) {
      var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        cancel: function() {
          return obj.canceled = true;
        }
      };
      if (update) {
        obj.update = function(from, to, text, origin) {
          if (from) {
            obj.from = clipPos2(doc, from);
          }
          if (to) {
            obj.to = clipPos2(doc, to);
          }
          if (text) {
            obj.text = text;
          }
          if (origin !== void 0) {
            obj.origin = origin;
          }
        };
      }
      signal2(doc, "beforeChange", doc, obj);
      if (doc.cm) {
        signal2(doc.cm, "beforeChange", doc.cm, obj);
      }
      if (obj.canceled) {
        if (doc.cm) {
          doc.cm.curOp.updateInput = 2;
        }
        return null;
      }
      return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
    }
    function makeChange2(doc, change, ignoreReadOnly) {
      if (doc.cm) {
        if (!doc.cm.curOp) {
          return operation2(doc.cm, makeChange2)(doc, change, ignoreReadOnly);
        }
        if (doc.cm.state.suppressEdits) {
          return;
        }
      }
      if (hasHandler2(doc, "beforeChange") || doc.cm && hasHandler2(doc.cm, "beforeChange")) {
        change = filterChange2(doc, change, true);
        if (!change) {
          return;
        }
      }
      var split = sawReadOnlySpans2 && !ignoreReadOnly && removeReadOnlyRanges2(doc, change.from, change.to);
      if (split) {
        for (var i3 = split.length - 1; i3 >= 0; --i3) {
          makeChangeInner2(doc, { from: split[i3].from, to: split[i3].to, text: i3 ? [""] : change.text, origin: change.origin });
        }
      } else {
        makeChangeInner2(doc, change);
      }
    }
    function makeChangeInner2(doc, change) {
      if (change.text.length == 1 && change.text[0] == "" && cmp2(change.from, change.to) == 0) {
        return;
      }
      var selAfter = computeSelAfterChange2(doc, change);
      addChangeToHistory2(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
      makeChangeSingleDoc2(doc, change, selAfter, stretchSpansOverChange2(doc, change));
      var rebased = [];
      linkedDocs2(doc, function(doc2, sharedHist) {
        if (!sharedHist && indexOf2(rebased, doc2.history) == -1) {
          rebaseHist2(doc2.history, change);
          rebased.push(doc2.history);
        }
        makeChangeSingleDoc2(doc2, change, null, stretchSpansOverChange2(doc2, change));
      });
    }
    function makeChangeFromHistory2(doc, type2, allowSelectionOnly) {
      var suppress = doc.cm && doc.cm.state.suppressEdits;
      if (suppress && !allowSelectionOnly) {
        return;
      }
      var hist = doc.history, event2, selAfter = doc.sel;
      var source2 = type2 == "undo" ? hist.done : hist.undone, dest = type2 == "undo" ? hist.undone : hist.done;
      var i3 = 0;
      for (; i3 < source2.length; i3++) {
        event2 = source2[i3];
        if (allowSelectionOnly ? event2.ranges && !event2.equals(doc.sel) : !event2.ranges) {
          break;
        }
      }
      if (i3 == source2.length) {
        return;
      }
      hist.lastOrigin = hist.lastSelOrigin = null;
      for (; ; ) {
        event2 = source2.pop();
        if (event2.ranges) {
          pushSelectionToHistory2(event2, dest);
          if (allowSelectionOnly && !event2.equals(doc.sel)) {
            setSelection2(doc, event2, { clearRedo: false });
            return;
          }
          selAfter = event2;
        } else if (suppress) {
          source2.push(event2);
          return;
        } else {
          break;
        }
      }
      var antiChanges = [];
      pushSelectionToHistory2(selAfter, dest);
      dest.push({ changes: antiChanges, generation: hist.generation });
      hist.generation = event2.generation || ++hist.maxGeneration;
      var filter = hasHandler2(doc, "beforeChange") || doc.cm && hasHandler2(doc.cm, "beforeChange");
      var loop = function(i4) {
        var change = event2.changes[i4];
        change.origin = type2;
        if (filter && !filterChange2(doc, change, false)) {
          source2.length = 0;
          return {};
        }
        antiChanges.push(historyChangeFromChange2(doc, change));
        var after = i4 ? computeSelAfterChange2(doc, change) : lst2(source2);
        makeChangeSingleDoc2(doc, change, after, mergeOldSpans2(doc, change));
        if (!i4 && doc.cm) {
          doc.cm.scrollIntoView({ from: change.from, to: changeEnd2(change) });
        }
        var rebased = [];
        linkedDocs2(doc, function(doc2, sharedHist) {
          if (!sharedHist && indexOf2(rebased, doc2.history) == -1) {
            rebaseHist2(doc2.history, change);
            rebased.push(doc2.history);
          }
          makeChangeSingleDoc2(doc2, change, null, mergeOldSpans2(doc2, change));
        });
      };
      for (var i$12 = event2.changes.length - 1; i$12 >= 0; --i$12) {
        var returned = loop(i$12);
        if (returned)
          return returned.v;
      }
    }
    function shiftDoc2(doc, distance) {
      if (distance == 0) {
        return;
      }
      doc.first += distance;
      doc.sel = new Selection2(map2(doc.sel.ranges, function(range3) {
        return new Range2(Pos2(range3.anchor.line + distance, range3.anchor.ch), Pos2(range3.head.line + distance, range3.head.ch));
      }), doc.sel.primIndex);
      if (doc.cm) {
        regChange2(doc.cm, doc.first, doc.first - distance, distance);
        for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
          regLineChange2(doc.cm, l, "gutter");
        }
      }
    }
    function makeChangeSingleDoc2(doc, change, selAfter, spans) {
      if (doc.cm && !doc.cm.curOp) {
        return operation2(doc.cm, makeChangeSingleDoc2)(doc, change, selAfter, spans);
      }
      if (change.to.line < doc.first) {
        shiftDoc2(doc, change.text.length - 1 - (change.to.line - change.from.line));
        return;
      }
      if (change.from.line > doc.lastLine()) {
        return;
      }
      if (change.from.line < doc.first) {
        var shift = change.text.length - 1 - (doc.first - change.from.line);
        shiftDoc2(doc, shift);
        change = {
          from: Pos2(doc.first, 0),
          to: Pos2(change.to.line + shift, change.to.ch),
          text: [lst2(change.text)],
          origin: change.origin
        };
      }
      var last = doc.lastLine();
      if (change.to.line > last) {
        change = {
          from: change.from,
          to: Pos2(last, getLine2(doc, last).text.length),
          text: [change.text[0]],
          origin: change.origin
        };
      }
      change.removed = getBetween2(doc, change.from, change.to);
      if (!selAfter) {
        selAfter = computeSelAfterChange2(doc, change);
      }
      if (doc.cm) {
        makeChangeSingleDocInEditor2(doc.cm, change, spans);
      } else {
        updateDoc2(doc, change, spans);
      }
      setSelectionNoUndo2(doc, selAfter, sel_dontScroll2);
      if (doc.cantEdit && skipAtomic2(doc, Pos2(doc.firstLine(), 0))) {
        doc.cantEdit = false;
      }
    }
    function makeChangeSingleDocInEditor2(cm, change, spans) {
      var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
      var recomputeMaxLength = false, checkWidthStart = from.line;
      if (!cm.options.lineWrapping) {
        checkWidthStart = lineNo2(visualLine2(getLine2(doc, from.line)));
        doc.iter(checkWidthStart, to.line + 1, function(line) {
          if (line == display.maxLine) {
            recomputeMaxLength = true;
            return true;
          }
        });
      }
      if (doc.sel.contains(change.from, change.to) > -1) {
        signalCursorActivity2(cm);
      }
      updateDoc2(doc, change, spans, estimateHeight2(cm));
      if (!cm.options.lineWrapping) {
        doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
          var len = lineLength2(line);
          if (len > display.maxLineLength) {
            display.maxLine = line;
            display.maxLineLength = len;
            display.maxLineChanged = true;
            recomputeMaxLength = false;
          }
        });
        if (recomputeMaxLength) {
          cm.curOp.updateMaxLine = true;
        }
      }
      retreatFrontier2(doc, from.line);
      startWorker2(cm, 400);
      var lendiff = change.text.length - (to.line - from.line) - 1;
      if (change.full) {
        regChange2(cm);
      } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate2(cm.doc, change)) {
        regLineChange2(cm, from.line, "text");
      } else {
        regChange2(cm, from.line, to.line + 1, lendiff);
      }
      var changesHandler = hasHandler2(cm, "changes"), changeHandler = hasHandler2(cm, "change");
      if (changeHandler || changesHandler) {
        var obj = {
          from,
          to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
        if (changeHandler) {
          signalLater2(cm, "change", cm, obj);
        }
        if (changesHandler) {
          (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
      }
      cm.display.selForContextMenu = null;
    }
    function replaceRange2(doc, code, from, to, origin) {
      var assign2;
      if (!to) {
        to = from;
      }
      if (cmp2(to, from) < 0) {
        assign2 = [to, from], from = assign2[0], to = assign2[1];
      }
      if (typeof code == "string") {
        code = doc.splitLines(code);
      }
      makeChange2(doc, { from, to, text: code, origin });
    }
    function rebaseHistSelSingle2(pos, from, to, diff) {
      if (to < pos.line) {
        pos.line += diff;
      } else if (from < pos.line) {
        pos.line = from;
        pos.ch = 0;
      }
    }
    function rebaseHistArray2(array3, from, to, diff) {
      for (var i3 = 0; i3 < array3.length; ++i3) {
        var sub = array3[i3], ok = true;
        if (sub.ranges) {
          if (!sub.copied) {
            sub = array3[i3] = sub.deepCopy();
            sub.copied = true;
          }
          for (var j = 0; j < sub.ranges.length; j++) {
            rebaseHistSelSingle2(sub.ranges[j].anchor, from, to, diff);
            rebaseHistSelSingle2(sub.ranges[j].head, from, to, diff);
          }
          continue;
        }
        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
          var cur = sub.changes[j$1];
          if (to < cur.from.line) {
            cur.from = Pos2(cur.from.line + diff, cur.from.ch);
            cur.to = Pos2(cur.to.line + diff, cur.to.ch);
          } else if (from <= cur.to.line) {
            ok = false;
            break;
          }
        }
        if (!ok) {
          array3.splice(0, i3 + 1);
          i3 = 0;
        }
      }
    }
    function rebaseHist2(hist, change) {
      var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
      rebaseHistArray2(hist.done, from, to, diff);
      rebaseHistArray2(hist.undone, from, to, diff);
    }
    function changeLine2(doc, handle, changeType, op) {
      var no = handle, line = handle;
      if (typeof handle == "number") {
        line = getLine2(doc, clipLine2(doc, handle));
      } else {
        no = lineNo2(handle);
      }
      if (no == null) {
        return null;
      }
      if (op(line, no) && doc.cm) {
        regLineChange2(doc.cm, no, changeType);
      }
      return line;
    }
    function LeafChunk2(lines) {
      this.lines = lines;
      this.parent = null;
      var height = 0;
      for (var i3 = 0; i3 < lines.length; ++i3) {
        lines[i3].parent = this;
        height += lines[i3].height;
      }
      this.height = height;
    }
    LeafChunk2.prototype = {
      chunkSize: function() {
        return this.lines.length;
      },
      removeInner: function(at, n) {
        for (var i3 = at, e = at + n; i3 < e; ++i3) {
          var line = this.lines[i3];
          this.height -= line.height;
          cleanUpLine2(line);
          signalLater2(line, "delete");
        }
        this.lines.splice(at, n);
      },
      collapse: function(lines) {
        lines.push.apply(lines, this.lines);
      },
      insertInner: function(at, lines, height) {
        this.height += height;
        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
        for (var i3 = 0; i3 < lines.length; ++i3) {
          lines[i3].parent = this;
        }
      },
      iterN: function(at, n, op) {
        for (var e = at + n; at < e; ++at) {
          if (op(this.lines[at])) {
            return true;
          }
        }
      }
    };
    function BranchChunk2(children) {
      this.children = children;
      var size = 0, height = 0;
      for (var i3 = 0; i3 < children.length; ++i3) {
        var ch = children[i3];
        size += ch.chunkSize();
        height += ch.height;
        ch.parent = this;
      }
      this.size = size;
      this.height = height;
      this.parent = null;
    }
    BranchChunk2.prototype = {
      chunkSize: function() {
        return this.size;
      },
      removeInner: function(at, n) {
        this.size -= n;
        for (var i3 = 0; i3 < this.children.length; ++i3) {
          var child = this.children[i3], sz = child.chunkSize();
          if (at < sz) {
            var rm = Math.min(n, sz - at), oldHeight = child.height;
            child.removeInner(at, rm);
            this.height -= oldHeight - child.height;
            if (sz == rm) {
              this.children.splice(i3--, 1);
              child.parent = null;
            }
            if ((n -= rm) == 0) {
              break;
            }
            at = 0;
          } else {
            at -= sz;
          }
        }
        if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk2))) {
          var lines = [];
          this.collapse(lines);
          this.children = [new LeafChunk2(lines)];
          this.children[0].parent = this;
        }
      },
      collapse: function(lines) {
        for (var i3 = 0; i3 < this.children.length; ++i3) {
          this.children[i3].collapse(lines);
        }
      },
      insertInner: function(at, lines, height) {
        this.size += lines.length;
        this.height += height;
        for (var i3 = 0; i3 < this.children.length; ++i3) {
          var child = this.children[i3], sz = child.chunkSize();
          if (at <= sz) {
            child.insertInner(at, lines, height);
            if (child.lines && child.lines.length > 50) {
              var remaining = child.lines.length % 25 + 25;
              for (var pos = remaining; pos < child.lines.length; ) {
                var leaf = new LeafChunk2(child.lines.slice(pos, pos += 25));
                child.height -= leaf.height;
                this.children.splice(++i3, 0, leaf);
                leaf.parent = this;
              }
              child.lines = child.lines.slice(0, remaining);
              this.maybeSpill();
            }
            break;
          }
          at -= sz;
        }
      },
      maybeSpill: function() {
        if (this.children.length <= 10) {
          return;
        }
        var me = this;
        do {
          var spilled = me.children.splice(me.children.length - 5, 5);
          var sibling = new BranchChunk2(spilled);
          if (!me.parent) {
            var copy = new BranchChunk2(me.children);
            copy.parent = me;
            me.children = [copy, sibling];
            me = copy;
          } else {
            me.size -= sibling.size;
            me.height -= sibling.height;
            var myIndex = indexOf2(me.parent.children, me);
            me.parent.children.splice(myIndex + 1, 0, sibling);
          }
          sibling.parent = me.parent;
        } while (me.children.length > 10);
        me.parent.maybeSpill();
      },
      iterN: function(at, n, op) {
        for (var i3 = 0; i3 < this.children.length; ++i3) {
          var child = this.children[i3], sz = child.chunkSize();
          if (at < sz) {
            var used = Math.min(n, sz - at);
            if (child.iterN(at, used, op)) {
              return true;
            }
            if ((n -= used) == 0) {
              break;
            }
            at = 0;
          } else {
            at -= sz;
          }
        }
      }
    };
    var LineWidget2 = function(doc, node, options2) {
      if (options2) {
        for (var opt in options2) {
          if (options2.hasOwnProperty(opt)) {
            this[opt] = options2[opt];
          }
        }
      }
      this.doc = doc;
      this.node = node;
    };
    LineWidget2.prototype.clear = function() {
      var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo2(line);
      if (no == null || !ws) {
        return;
      }
      for (var i3 = 0; i3 < ws.length; ++i3) {
        if (ws[i3] == this) {
          ws.splice(i3--, 1);
        }
      }
      if (!ws.length) {
        line.widgets = null;
      }
      var height = widgetHeight2(this);
      updateLineHeight2(line, Math.max(0, line.height - height));
      if (cm) {
        runInOp2(cm, function() {
          adjustScrollWhenAboveVisible2(cm, line, -height);
          regLineChange2(cm, no, "widget");
        });
        signalLater2(cm, "lineWidgetCleared", cm, this, no);
      }
    };
    LineWidget2.prototype.changed = function() {
      var this$1$1 = this;
      var oldH = this.height, cm = this.doc.cm, line = this.line;
      this.height = null;
      var diff = widgetHeight2(this) - oldH;
      if (!diff) {
        return;
      }
      if (!lineIsHidden2(this.doc, line)) {
        updateLineHeight2(line, line.height + diff);
      }
      if (cm) {
        runInOp2(cm, function() {
          cm.curOp.forceUpdate = true;
          adjustScrollWhenAboveVisible2(cm, line, diff);
          signalLater2(cm, "lineWidgetChanged", cm, this$1$1, lineNo2(line));
        });
      }
    };
    eventMixin2(LineWidget2);
    function adjustScrollWhenAboveVisible2(cm, line, diff) {
      if (heightAtLine2(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
        addToScrollTop2(cm, diff);
      }
    }
    function addLineWidget2(doc, handle, node, options2) {
      var widget = new LineWidget2(doc, node, options2);
      var cm = doc.cm;
      if (cm && widget.noHScroll) {
        cm.display.alignWidgets = true;
      }
      changeLine2(doc, handle, "widget", function(line) {
        var widgets = line.widgets || (line.widgets = []);
        if (widget.insertAt == null) {
          widgets.push(widget);
        } else {
          widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
        }
        widget.line = line;
        if (cm && !lineIsHidden2(doc, line)) {
          var aboveVisible = heightAtLine2(line) < doc.scrollTop;
          updateLineHeight2(line, line.height + widgetHeight2(widget));
          if (aboveVisible) {
            addToScrollTop2(cm, widget.height);
          }
          cm.curOp.forceUpdate = true;
        }
        return true;
      });
      if (cm) {
        signalLater2(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo2(handle));
      }
      return widget;
    }
    var nextMarkerId2 = 0;
    var TextMarker2 = function(doc, type2) {
      this.lines = [];
      this.type = type2;
      this.doc = doc;
      this.id = ++nextMarkerId2;
    };
    TextMarker2.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      var cm = this.doc.cm, withOp = cm && !cm.curOp;
      if (withOp) {
        startOperation2(cm);
      }
      if (hasHandler2(this, "clear")) {
        var found = this.find();
        if (found) {
          signalLater2(this, "clear", found.from, found.to);
        }
      }
      var min2 = null, max2 = null;
      for (var i3 = 0; i3 < this.lines.length; ++i3) {
        var line = this.lines[i3];
        var span = getMarkedSpanFor2(line.markedSpans, this);
        if (cm && !this.collapsed) {
          regLineChange2(cm, lineNo2(line), "text");
        } else if (cm) {
          if (span.to != null) {
            max2 = lineNo2(line);
          }
          if (span.from != null) {
            min2 = lineNo2(line);
          }
        }
        line.markedSpans = removeMarkedSpan2(line.markedSpans, span);
        if (span.from == null && this.collapsed && !lineIsHidden2(this.doc, line) && cm) {
          updateLineHeight2(line, textHeight2(cm.display));
        }
      }
      if (cm && this.collapsed && !cm.options.lineWrapping) {
        for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
          var visual = visualLine2(this.lines[i$12]), len = lineLength2(visual);
          if (len > cm.display.maxLineLength) {
            cm.display.maxLine = visual;
            cm.display.maxLineLength = len;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (min2 != null && cm && this.collapsed) {
        regChange2(cm, min2, max2 + 1);
      }
      this.lines.length = 0;
      this.explicitlyCleared = true;
      if (this.atomic && this.doc.cantEdit) {
        this.doc.cantEdit = false;
        if (cm) {
          reCheckSelection2(cm.doc);
        }
      }
      if (cm) {
        signalLater2(cm, "markerCleared", cm, this, min2, max2);
      }
      if (withOp) {
        endOperation2(cm);
      }
      if (this.parent) {
        this.parent.clear();
      }
    };
    TextMarker2.prototype.find = function(side, lineObj) {
      if (side == null && this.type == "bookmark") {
        side = 1;
      }
      var from, to;
      for (var i3 = 0; i3 < this.lines.length; ++i3) {
        var line = this.lines[i3];
        var span = getMarkedSpanFor2(line.markedSpans, this);
        if (span.from != null) {
          from = Pos2(lineObj ? line : lineNo2(line), span.from);
          if (side == -1) {
            return from;
          }
        }
        if (span.to != null) {
          to = Pos2(lineObj ? line : lineNo2(line), span.to);
          if (side == 1) {
            return to;
          }
        }
      }
      return from && { from, to };
    };
    TextMarker2.prototype.changed = function() {
      var this$1$1 = this;
      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
      if (!pos || !cm) {
        return;
      }
      runInOp2(cm, function() {
        var line = pos.line, lineN = lineNo2(pos.line);
        var view = findViewForLine2(cm, lineN);
        if (view) {
          clearLineMeasurementCacheFor2(view);
          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
        }
        cm.curOp.updateMaxLine = true;
        if (!lineIsHidden2(widget.doc, line) && widget.height != null) {
          var oldHeight = widget.height;
          widget.height = null;
          var dHeight = widgetHeight2(widget) - oldHeight;
          if (dHeight) {
            updateLineHeight2(line, line.height + dHeight);
          }
        }
        signalLater2(cm, "markerChanged", cm, this$1$1);
      });
    };
    TextMarker2.prototype.attachLine = function(line) {
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        if (!op.maybeHiddenMarkers || indexOf2(op.maybeHiddenMarkers, this) == -1) {
          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
      }
      this.lines.push(line);
    };
    TextMarker2.prototype.detachLine = function(line) {
      this.lines.splice(indexOf2(this.lines, line), 1);
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
      }
    };
    eventMixin2(TextMarker2);
    function markText2(doc, from, to, options2, type2) {
      if (options2 && options2.shared) {
        return markTextShared2(doc, from, to, options2, type2);
      }
      if (doc.cm && !doc.cm.curOp) {
        return operation2(doc.cm, markText2)(doc, from, to, options2, type2);
      }
      var marker = new TextMarker2(doc, type2), diff = cmp2(from, to);
      if (options2) {
        copyObj2(options2, marker, false);
      }
      if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
        return marker;
      }
      if (marker.replacedWith) {
        marker.collapsed = true;
        marker.widgetNode = eltP2("span", [marker.replacedWith], "CodeMirror-widget");
        if (!options2.handleMouseEvents) {
          marker.widgetNode.setAttribute("cm-ignore-events", "true");
        }
        if (options2.insertLeft) {
          marker.widgetNode.insertLeft = true;
        }
      }
      if (marker.collapsed) {
        if (conflictingCollapsedRange2(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange2(doc, to.line, from, to, marker)) {
          throw new Error("Inserting collapsed marker partially overlapping an existing one");
        }
        seeCollapsedSpans2();
      }
      if (marker.addToHistory) {
        addChangeToHistory2(doc, { from, to, origin: "markText" }, doc.sel, NaN);
      }
      var curLine = from.line, cm = doc.cm, updateMaxLine;
      doc.iter(curLine, to.line + 1, function(line) {
        if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine2(line) == cm.display.maxLine) {
          updateMaxLine = true;
        }
        if (marker.collapsed && curLine != from.line) {
          updateLineHeight2(line, 0);
        }
        addMarkedSpan2(line, new MarkedSpan2(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
        ++curLine;
      });
      if (marker.collapsed) {
        doc.iter(from.line, to.line + 1, function(line) {
          if (lineIsHidden2(doc, line)) {
            updateLineHeight2(line, 0);
          }
        });
      }
      if (marker.clearOnEnter) {
        on2(marker, "beforeCursorEnter", function() {
          return marker.clear();
        });
      }
      if (marker.readOnly) {
        seeReadOnlySpans2();
        if (doc.history.done.length || doc.history.undone.length) {
          doc.clearHistory();
        }
      }
      if (marker.collapsed) {
        marker.id = ++nextMarkerId2;
        marker.atomic = true;
      }
      if (cm) {
        if (updateMaxLine) {
          cm.curOp.updateMaxLine = true;
        }
        if (marker.collapsed) {
          regChange2(cm, from.line, to.line + 1);
        } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
          for (var i3 = from.line; i3 <= to.line; i3++) {
            regLineChange2(cm, i3, "text");
          }
        }
        if (marker.atomic) {
          reCheckSelection2(cm.doc);
        }
        signalLater2(cm, "markerAdded", cm, marker);
      }
      return marker;
    }
    var SharedTextMarker2 = function(markers, primary) {
      this.markers = markers;
      this.primary = primary;
      for (var i3 = 0; i3 < markers.length; ++i3) {
        markers[i3].parent = this;
      }
    };
    SharedTextMarker2.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      this.explicitlyCleared = true;
      for (var i3 = 0; i3 < this.markers.length; ++i3) {
        this.markers[i3].clear();
      }
      signalLater2(this, "clear");
    };
    SharedTextMarker2.prototype.find = function(side, lineObj) {
      return this.primary.find(side, lineObj);
    };
    eventMixin2(SharedTextMarker2);
    function markTextShared2(doc, from, to, options2, type2) {
      options2 = copyObj2(options2);
      options2.shared = false;
      var markers = [markText2(doc, from, to, options2, type2)], primary = markers[0];
      var widget = options2.widgetNode;
      linkedDocs2(doc, function(doc2) {
        if (widget) {
          options2.widgetNode = widget.cloneNode(true);
        }
        markers.push(markText2(doc2, clipPos2(doc2, from), clipPos2(doc2, to), options2, type2));
        for (var i3 = 0; i3 < doc2.linked.length; ++i3) {
          if (doc2.linked[i3].isParent) {
            return;
          }
        }
        primary = lst2(markers);
      });
      return new SharedTextMarker2(markers, primary);
    }
    function findSharedMarkers2(doc) {
      return doc.findMarks(Pos2(doc.first, 0), doc.clipPos(Pos2(doc.lastLine())), function(m) {
        return m.parent;
      });
    }
    function copySharedMarkers2(doc, markers) {
      for (var i3 = 0; i3 < markers.length; i3++) {
        var marker = markers[i3], pos = marker.find();
        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
        if (cmp2(mFrom, mTo)) {
          var subMark = markText2(doc, mFrom, mTo, marker.primary, marker.primary.type);
          marker.markers.push(subMark);
          subMark.parent = marker;
        }
      }
    }
    function detachSharedMarkers2(markers) {
      var loop = function(i4) {
        var marker = markers[i4], linked = [marker.primary.doc];
        linkedDocs2(marker.primary.doc, function(d) {
          return linked.push(d);
        });
        for (var j = 0; j < marker.markers.length; j++) {
          var subMarker = marker.markers[j];
          if (indexOf2(linked, subMarker.doc) == -1) {
            subMarker.parent = null;
            marker.markers.splice(j--, 1);
          }
        }
      };
      for (var i3 = 0; i3 < markers.length; i3++)
        loop(i3);
    }
    var nextDocId2 = 0;
    var Doc2 = function(text, mode, firstLine, lineSep, direction) {
      if (!(this instanceof Doc2)) {
        return new Doc2(text, mode, firstLine, lineSep, direction);
      }
      if (firstLine == null) {
        firstLine = 0;
      }
      BranchChunk2.call(this, [new LeafChunk2([new Line2("", null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.cleanGeneration = 1;
      this.modeFrontier = this.highlightFrontier = firstLine;
      var start2 = Pos2(firstLine, 0);
      this.sel = simpleSelection2(start2);
      this.history = new History2(null);
      this.id = ++nextDocId2;
      this.modeOption = mode;
      this.lineSep = lineSep;
      this.direction = direction == "rtl" ? "rtl" : "ltr";
      this.extend = false;
      if (typeof text == "string") {
        text = this.splitLines(text);
      }
      updateDoc2(this, { from: start2, to: start2, text });
      setSelection2(this, simpleSelection2(start2), sel_dontScroll2);
    };
    Doc2.prototype = createObj2(BranchChunk2.prototype, {
      constructor: Doc2,
      iter: function(from, to, op) {
        if (op) {
          this.iterN(from - this.first, to - from, op);
        } else {
          this.iterN(this.first, this.first + this.size, from);
        }
      },
      insert: function(at, lines) {
        var height = 0;
        for (var i3 = 0; i3 < lines.length; ++i3) {
          height += lines[i3].height;
        }
        this.insertInner(at - this.first, lines, height);
      },
      remove: function(at, n) {
        this.removeInner(at - this.first, n);
      },
      getValue: function(lineSep) {
        var lines = getLines2(this, this.first, this.first + this.size);
        if (lineSep === false) {
          return lines;
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      setValue: docMethodOp2(function(code) {
        var top2 = Pos2(this.first, 0), last = this.first + this.size - 1;
        makeChange2(this, {
          from: top2,
          to: Pos2(last, getLine2(this, last).text.length),
          text: this.splitLines(code),
          origin: "setValue",
          full: true
        }, true);
        if (this.cm) {
          scrollToCoords2(this.cm, 0, 0);
        }
        setSelection2(this, simpleSelection2(top2), sel_dontScroll2);
      }),
      replaceRange: function(code, from, to, origin) {
        from = clipPos2(this, from);
        to = to ? clipPos2(this, to) : from;
        replaceRange2(this, code, from, to, origin);
      },
      getRange: function(from, to, lineSep) {
        var lines = getBetween2(this, clipPos2(this, from), clipPos2(this, to));
        if (lineSep === false) {
          return lines;
        }
        if (lineSep === "") {
          return lines.join("");
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      getLine: function(line) {
        var l = this.getLineHandle(line);
        return l && l.text;
      },
      getLineHandle: function(line) {
        if (isLine2(this, line)) {
          return getLine2(this, line);
        }
      },
      getLineNumber: function(line) {
        return lineNo2(line);
      },
      getLineHandleVisualStart: function(line) {
        if (typeof line == "number") {
          line = getLine2(this, line);
        }
        return visualLine2(line);
      },
      lineCount: function() {
        return this.size;
      },
      firstLine: function() {
        return this.first;
      },
      lastLine: function() {
        return this.first + this.size - 1;
      },
      clipPos: function(pos) {
        return clipPos2(this, pos);
      },
      getCursor: function(start2) {
        var range3 = this.sel.primary(), pos;
        if (start2 == null || start2 == "head") {
          pos = range3.head;
        } else if (start2 == "anchor") {
          pos = range3.anchor;
        } else if (start2 == "end" || start2 == "to" || start2 === false) {
          pos = range3.to();
        } else {
          pos = range3.from();
        }
        return pos;
      },
      listSelections: function() {
        return this.sel.ranges;
      },
      somethingSelected: function() {
        return this.sel.somethingSelected();
      },
      setCursor: docMethodOp2(function(line, ch, options2) {
        setSimpleSelection2(this, clipPos2(this, typeof line == "number" ? Pos2(line, ch || 0) : line), null, options2);
      }),
      setSelection: docMethodOp2(function(anchor, head, options2) {
        setSimpleSelection2(this, clipPos2(this, anchor), clipPos2(this, head || anchor), options2);
      }),
      extendSelection: docMethodOp2(function(head, other, options2) {
        extendSelection2(this, clipPos2(this, head), other && clipPos2(this, other), options2);
      }),
      extendSelections: docMethodOp2(function(heads, options2) {
        extendSelections2(this, clipPosArray2(this, heads), options2);
      }),
      extendSelectionsBy: docMethodOp2(function(f, options2) {
        var heads = map2(this.sel.ranges, f);
        extendSelections2(this, clipPosArray2(this, heads), options2);
      }),
      setSelections: docMethodOp2(function(ranges, primary, options2) {
        if (!ranges.length) {
          return;
        }
        var out = [];
        for (var i3 = 0; i3 < ranges.length; i3++) {
          out[i3] = new Range2(clipPos2(this, ranges[i3].anchor), clipPos2(this, ranges[i3].head || ranges[i3].anchor));
        }
        if (primary == null) {
          primary = Math.min(ranges.length - 1, this.sel.primIndex);
        }
        setSelection2(this, normalizeSelection2(this.cm, out, primary), options2);
      }),
      addSelection: docMethodOp2(function(anchor, head, options2) {
        var ranges = this.sel.ranges.slice(0);
        ranges.push(new Range2(clipPos2(this, anchor), clipPos2(this, head || anchor)));
        setSelection2(this, normalizeSelection2(this.cm, ranges, ranges.length - 1), options2);
      }),
      getSelection: function(lineSep) {
        var ranges = this.sel.ranges, lines;
        for (var i3 = 0; i3 < ranges.length; i3++) {
          var sel = getBetween2(this, ranges[i3].from(), ranges[i3].to());
          lines = lines ? lines.concat(sel) : sel;
        }
        if (lineSep === false) {
          return lines;
        } else {
          return lines.join(lineSep || this.lineSeparator());
        }
      },
      getSelections: function(lineSep) {
        var parts = [], ranges = this.sel.ranges;
        for (var i3 = 0; i3 < ranges.length; i3++) {
          var sel = getBetween2(this, ranges[i3].from(), ranges[i3].to());
          if (lineSep !== false) {
            sel = sel.join(lineSep || this.lineSeparator());
          }
          parts[i3] = sel;
        }
        return parts;
      },
      replaceSelection: function(code, collapse, origin) {
        var dup = [];
        for (var i3 = 0; i3 < this.sel.ranges.length; i3++) {
          dup[i3] = code;
        }
        this.replaceSelections(dup, collapse, origin || "+input");
      },
      replaceSelections: docMethodOp2(function(code, collapse, origin) {
        var changes = [], sel = this.sel;
        for (var i3 = 0; i3 < sel.ranges.length; i3++) {
          var range3 = sel.ranges[i3];
          changes[i3] = { from: range3.from(), to: range3.to(), text: this.splitLines(code[i3]), origin };
        }
        var newSel = collapse && collapse != "end" && computeReplacedSel2(this, changes, collapse);
        for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
          makeChange2(this, changes[i$12]);
        }
        if (newSel) {
          setSelectionReplaceHistory2(this, newSel);
        } else if (this.cm) {
          ensureCursorVisible2(this.cm);
        }
      }),
      undo: docMethodOp2(function() {
        makeChangeFromHistory2(this, "undo");
      }),
      redo: docMethodOp2(function() {
        makeChangeFromHistory2(this, "redo");
      }),
      undoSelection: docMethodOp2(function() {
        makeChangeFromHistory2(this, "undo", true);
      }),
      redoSelection: docMethodOp2(function() {
        makeChangeFromHistory2(this, "redo", true);
      }),
      setExtending: function(val) {
        this.extend = val;
      },
      getExtending: function() {
        return this.extend;
      },
      historySize: function() {
        var hist = this.history, done = 0, undone = 0;
        for (var i3 = 0; i3 < hist.done.length; i3++) {
          if (!hist.done[i3].ranges) {
            ++done;
          }
        }
        for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
          if (!hist.undone[i$12].ranges) {
            ++undone;
          }
        }
        return { undo: done, redo: undone };
      },
      clearHistory: function() {
        var this$1$1 = this;
        this.history = new History2(this.history);
        linkedDocs2(this, function(doc) {
          return doc.history = this$1$1.history;
        }, true);
      },
      markClean: function() {
        this.cleanGeneration = this.changeGeneration(true);
      },
      changeGeneration: function(forceSplit) {
        if (forceSplit) {
          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
        }
        return this.history.generation;
      },
      isClean: function(gen) {
        return this.history.generation == (gen || this.cleanGeneration);
      },
      getHistory: function() {
        return {
          done: copyHistoryArray2(this.history.done),
          undone: copyHistoryArray2(this.history.undone)
        };
      },
      setHistory: function(histData) {
        var hist = this.history = new History2(this.history);
        hist.done = copyHistoryArray2(histData.done.slice(0), null, true);
        hist.undone = copyHistoryArray2(histData.undone.slice(0), null, true);
      },
      setGutterMarker: docMethodOp2(function(line, gutterID, value2) {
        return changeLine2(this, line, "gutter", function(line2) {
          var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
          markers[gutterID] = value2;
          if (!value2 && isEmpty2(markers)) {
            line2.gutterMarkers = null;
          }
          return true;
        });
      }),
      clearGutter: docMethodOp2(function(gutterID) {
        var this$1$1 = this;
        this.iter(function(line) {
          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
            changeLine2(this$1$1, line, "gutter", function() {
              line.gutterMarkers[gutterID] = null;
              if (isEmpty2(line.gutterMarkers)) {
                line.gutterMarkers = null;
              }
              return true;
            });
          }
        });
      }),
      lineInfo: function(line) {
        var n;
        if (typeof line == "number") {
          if (!isLine2(this, line)) {
            return null;
          }
          n = line;
          line = getLine2(this, line);
          if (!line) {
            return null;
          }
        } else {
          n = lineNo2(line);
          if (n == null) {
            return null;
          }
        }
        return {
          line: n,
          handle: line,
          text: line.text,
          gutterMarkers: line.gutterMarkers,
          textClass: line.textClass,
          bgClass: line.bgClass,
          wrapClass: line.wrapClass,
          widgets: line.widgets
        };
      },
      addLineClass: docMethodOp2(function(handle, where, cls) {
        return changeLine2(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          if (!line[prop2]) {
            line[prop2] = cls;
          } else if (classTest2(cls).test(line[prop2])) {
            return false;
          } else {
            line[prop2] += " " + cls;
          }
          return true;
        });
      }),
      removeLineClass: docMethodOp2(function(handle, where, cls) {
        return changeLine2(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
          var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          var cur = line[prop2];
          if (!cur) {
            return false;
          } else if (cls == null) {
            line[prop2] = null;
          } else {
            var found = cur.match(classTest2(cls));
            if (!found) {
              return false;
            }
            var end2 = found.index + found[0].length;
            line[prop2] = cur.slice(0, found.index) + (!found.index || end2 == cur.length ? "" : " ") + cur.slice(end2) || null;
          }
          return true;
        });
      }),
      addLineWidget: docMethodOp2(function(handle, node, options2) {
        return addLineWidget2(this, handle, node, options2);
      }),
      removeLineWidget: function(widget) {
        widget.clear();
      },
      markText: function(from, to, options2) {
        return markText2(this, clipPos2(this, from), clipPos2(this, to), options2, options2 && options2.type || "range");
      },
      setBookmark: function(pos, options2) {
        var realOpts = {
          replacedWith: options2 && (options2.nodeType == null ? options2.widget : options2),
          insertLeft: options2 && options2.insertLeft,
          clearWhenEmpty: false,
          shared: options2 && options2.shared,
          handleMouseEvents: options2 && options2.handleMouseEvents
        };
        pos = clipPos2(this, pos);
        return markText2(this, pos, pos, realOpts, "bookmark");
      },
      findMarksAt: function(pos) {
        pos = clipPos2(this, pos);
        var markers = [], spans = getLine2(this, pos.line).markedSpans;
        if (spans) {
          for (var i3 = 0; i3 < spans.length; ++i3) {
            var span = spans[i3];
            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
              markers.push(span.marker.parent || span.marker);
            }
          }
        }
        return markers;
      },
      findMarks: function(from, to, filter) {
        from = clipPos2(this, from);
        to = clipPos2(this, to);
        var found = [], lineNo3 = from.line;
        this.iter(from.line, to.line + 1, function(line) {
          var spans = line.markedSpans;
          if (spans) {
            for (var i3 = 0; i3 < spans.length; i3++) {
              var span = spans[i3];
              if (!(span.to != null && lineNo3 == from.line && from.ch >= span.to || span.from == null && lineNo3 != from.line || span.from != null && lineNo3 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                found.push(span.marker.parent || span.marker);
              }
            }
          }
          ++lineNo3;
        });
        return found;
      },
      getAllMarks: function() {
        var markers = [];
        this.iter(function(line) {
          var sps = line.markedSpans;
          if (sps) {
            for (var i3 = 0; i3 < sps.length; ++i3) {
              if (sps[i3].from != null) {
                markers.push(sps[i3].marker);
              }
            }
          }
        });
        return markers;
      },
      posFromIndex: function(off3) {
        var ch, lineNo3 = this.first, sepSize = this.lineSeparator().length;
        this.iter(function(line) {
          var sz = line.text.length + sepSize;
          if (sz > off3) {
            ch = off3;
            return true;
          }
          off3 -= sz;
          ++lineNo3;
        });
        return clipPos2(this, Pos2(lineNo3, ch));
      },
      indexFromPos: function(coords) {
        coords = clipPos2(this, coords);
        var index2 = coords.ch;
        if (coords.line < this.first || coords.ch < 0) {
          return 0;
        }
        var sepSize = this.lineSeparator().length;
        this.iter(this.first, coords.line, function(line) {
          index2 += line.text.length + sepSize;
        });
        return index2;
      },
      copy: function(copyHistory) {
        var doc = new Doc2(getLines2(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
        doc.scrollTop = this.scrollTop;
        doc.scrollLeft = this.scrollLeft;
        doc.sel = this.sel;
        doc.extend = false;
        if (copyHistory) {
          doc.history.undoDepth = this.history.undoDepth;
          doc.setHistory(this.getHistory());
        }
        return doc;
      },
      linkedDoc: function(options2) {
        if (!options2) {
          options2 = {};
        }
        var from = this.first, to = this.first + this.size;
        if (options2.from != null && options2.from > from) {
          from = options2.from;
        }
        if (options2.to != null && options2.to < to) {
          to = options2.to;
        }
        var copy = new Doc2(getLines2(this, from, to), options2.mode || this.modeOption, from, this.lineSep, this.direction);
        if (options2.sharedHist) {
          copy.history = this.history;
        }
        (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options2.sharedHist });
        copy.linked = [{ doc: this, isParent: true, sharedHist: options2.sharedHist }];
        copySharedMarkers2(copy, findSharedMarkers2(this));
        return copy;
      },
      unlinkDoc: function(other) {
        if (other instanceof CodeMirror2) {
          other = other.doc;
        }
        if (this.linked) {
          for (var i3 = 0; i3 < this.linked.length; ++i3) {
            var link = this.linked[i3];
            if (link.doc != other) {
              continue;
            }
            this.linked.splice(i3, 1);
            other.unlinkDoc(this);
            detachSharedMarkers2(findSharedMarkers2(this));
            break;
          }
        }
        if (other.history == this.history) {
          var splitIds = [other.id];
          linkedDocs2(other, function(doc) {
            return splitIds.push(doc.id);
          }, true);
          other.history = new History2(null);
          other.history.done = copyHistoryArray2(this.history.done, splitIds);
          other.history.undone = copyHistoryArray2(this.history.undone, splitIds);
        }
      },
      iterLinkedDocs: function(f) {
        linkedDocs2(this, f);
      },
      getMode: function() {
        return this.mode;
      },
      getEditor: function() {
        return this.cm;
      },
      splitLines: function(str) {
        if (this.lineSep) {
          return str.split(this.lineSep);
        }
        return splitLinesAuto2(str);
      },
      lineSeparator: function() {
        return this.lineSep || "\n";
      },
      setDirection: docMethodOp2(function(dir) {
        if (dir != "rtl") {
          dir = "ltr";
        }
        if (dir == this.direction) {
          return;
        }
        this.direction = dir;
        this.iter(function(line) {
          return line.order = null;
        });
        if (this.cm) {
          directionChanged2(this.cm);
        }
      })
    });
    Doc2.prototype.eachLine = Doc2.prototype.iter;
    var lastDrop2 = 0;
    function onDrop2(e) {
      var cm = this;
      clearDragCursor2(cm);
      if (signalDOMEvent2(cm, e) || eventInWidget2(cm.display, e)) {
        return;
      }
      e_preventDefault2(e);
      if (ie2) {
        lastDrop2 = +new Date();
      }
      var pos = posFromMouse2(cm, e, true), files = e.dataTransfer.files;
      if (!pos || cm.isReadOnly()) {
        return;
      }
      if (files && files.length && window.FileReader && window.File) {
        var n = files.length, text = Array(n), read2 = 0;
        var markAsReadAndPasteIfAllFilesAreRead = function() {
          if (++read2 == n) {
            operation2(cm, function() {
              pos = clipPos2(cm.doc, pos);
              var change = {
                from: pos,
                to: pos,
                text: cm.doc.splitLines(text.filter(function(t) {
                  return t != null;
                }).join(cm.doc.lineSeparator())),
                origin: "paste"
              };
              makeChange2(cm.doc, change);
              setSelectionReplaceHistory2(cm.doc, simpleSelection2(clipPos2(cm.doc, pos), clipPos2(cm.doc, changeEnd2(change))));
            })();
          }
        };
        var readTextFromFile = function(file, i4) {
          if (cm.options.allowDropFileTypes && indexOf2(cm.options.allowDropFileTypes, file.type) == -1) {
            markAsReadAndPasteIfAllFilesAreRead();
            return;
          }
          var reader = new FileReader();
          reader.onerror = function() {
            return markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.onload = function() {
            var content = reader.result;
            if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }
            text[i4] = content;
            markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.readAsText(file);
        };
        for (var i3 = 0; i3 < files.length; i3++) {
          readTextFromFile(files[i3], i3);
        }
      } else {
        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
          cm.state.draggingText(e);
          setTimeout(function() {
            return cm.display.input.focus();
          }, 20);
          return;
        }
        try {
          var text$1 = e.dataTransfer.getData("Text");
          if (text$1) {
            var selected;
            if (cm.state.draggingText && !cm.state.draggingText.copy) {
              selected = cm.listSelections();
            }
            setSelectionNoUndo2(cm.doc, simpleSelection2(pos, pos));
            if (selected) {
              for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                replaceRange2(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
              }
            }
            cm.replaceSelection(text$1, "around", "paste");
            cm.display.input.focus();
          }
        } catch (e$1) {
        }
      }
    }
    function onDragStart2(cm, e) {
      if (ie2 && (!cm.state.draggingText || +new Date() - lastDrop2 < 100)) {
        e_stop2(e);
        return;
      }
      if (signalDOMEvent2(cm, e) || eventInWidget2(cm.display, e)) {
        return;
      }
      e.dataTransfer.setData("Text", cm.getSelection());
      e.dataTransfer.effectAllowed = "copyMove";
      if (e.dataTransfer.setDragImage && !safari2) {
        var img = elt2("img", null, null, "position: fixed; left: 0; top: 0;");
        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (presto2) {
          img.width = img.height = 1;
          cm.display.wrapper.appendChild(img);
          img._top = img.offsetTop;
        }
        e.dataTransfer.setDragImage(img, 0, 0);
        if (presto2) {
          img.parentNode.removeChild(img);
        }
      }
    }
    function onDragOver2(cm, e) {
      var pos = posFromMouse2(cm, e);
      if (!pos) {
        return;
      }
      var frag = document.createDocumentFragment();
      drawSelectionCursor2(cm, pos, frag);
      if (!cm.display.dragCursor) {
        cm.display.dragCursor = elt2("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
      }
      removeChildrenAndAdd2(cm.display.dragCursor, frag);
    }
    function clearDragCursor2(cm) {
      if (cm.display.dragCursor) {
        cm.display.lineSpace.removeChild(cm.display.dragCursor);
        cm.display.dragCursor = null;
      }
    }
    function forEachCodeMirror2(f) {
      if (!document.getElementsByClassName) {
        return;
      }
      var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
      for (var i3 = 0; i3 < byClass.length; i3++) {
        var cm = byClass[i3].CodeMirror;
        if (cm) {
          editors.push(cm);
        }
      }
      if (editors.length) {
        editors[0].operation(function() {
          for (var i4 = 0; i4 < editors.length; i4++) {
            f(editors[i4]);
          }
        });
      }
    }
    var globalsRegistered2 = false;
    function ensureGlobalHandlers2() {
      if (globalsRegistered2) {
        return;
      }
      registerGlobalHandlers2();
      globalsRegistered2 = true;
    }
    function registerGlobalHandlers2() {
      var resizeTimer;
      on2(window, "resize", function() {
        if (resizeTimer == null) {
          resizeTimer = setTimeout(function() {
            resizeTimer = null;
            forEachCodeMirror2(onResize2);
          }, 100);
        }
      });
      on2(window, "blur", function() {
        return forEachCodeMirror2(onBlur2);
      });
    }
    function onResize2(cm) {
      var d = cm.display;
      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
      d.scrollbarsClipped = false;
      cm.setSize();
    }
    var keyNames2 = {
      3: "Pause",
      8: "Backspace",
      9: "Tab",
      13: "Enter",
      16: "Shift",
      17: "Ctrl",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Esc",
      32: "Space",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "Left",
      38: "Up",
      39: "Right",
      40: "Down",
      44: "PrintScrn",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Mod",
      92: "Mod",
      93: "Mod",
      106: "*",
      107: "=",
      109: "-",
      110: ".",
      111: "/",
      145: "ScrollLock",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      224: "Mod",
      63232: "Up",
      63233: "Down",
      63234: "Left",
      63235: "Right",
      63272: "Delete",
      63273: "Home",
      63275: "End",
      63276: "PageUp",
      63277: "PageDown",
      63302: "Insert"
    };
    for (var i2 = 0; i2 < 10; i2++) {
      keyNames2[i2 + 48] = keyNames2[i2 + 96] = String(i2);
    }
    for (var i$1 = 65; i$1 <= 90; i$1++) {
      keyNames2[i$1] = String.fromCharCode(i$1);
    }
    for (var i$2 = 1; i$2 <= 12; i$2++) {
      keyNames2[i$2 + 111] = keyNames2[i$2 + 63235] = "F" + i$2;
    }
    var keyMap2 = {};
    keyMap2.basic = {
      "Left": "goCharLeft",
      "Right": "goCharRight",
      "Up": "goLineUp",
      "Down": "goLineDown",
      "End": "goLineEnd",
      "Home": "goLineStartSmart",
      "PageUp": "goPageUp",
      "PageDown": "goPageDown",
      "Delete": "delCharAfter",
      "Backspace": "delCharBefore",
      "Shift-Backspace": "delCharBefore",
      "Tab": "defaultTab",
      "Shift-Tab": "indentAuto",
      "Enter": "newlineAndIndent",
      "Insert": "toggleOverwrite",
      "Esc": "singleSelection"
    };
    keyMap2.pcDefault = {
      "Ctrl-A": "selectAll",
      "Ctrl-D": "deleteLine",
      "Ctrl-Z": "undo",
      "Shift-Ctrl-Z": "redo",
      "Ctrl-Y": "redo",
      "Ctrl-Home": "goDocStart",
      "Ctrl-End": "goDocEnd",
      "Ctrl-Up": "goLineUp",
      "Ctrl-Down": "goLineDown",
      "Ctrl-Left": "goGroupLeft",
      "Ctrl-Right": "goGroupRight",
      "Alt-Left": "goLineStart",
      "Alt-Right": "goLineEnd",
      "Ctrl-Backspace": "delGroupBefore",
      "Ctrl-Delete": "delGroupAfter",
      "Ctrl-S": "save",
      "Ctrl-F": "find",
      "Ctrl-G": "findNext",
      "Shift-Ctrl-G": "findPrev",
      "Shift-Ctrl-F": "replace",
      "Shift-Ctrl-R": "replaceAll",
      "Ctrl-[": "indentLess",
      "Ctrl-]": "indentMore",
      "Ctrl-U": "undoSelection",
      "Shift-Ctrl-U": "redoSelection",
      "Alt-U": "redoSelection",
      "fallthrough": "basic"
    };
    keyMap2.emacsy = {
      "Ctrl-F": "goCharRight",
      "Ctrl-B": "goCharLeft",
      "Ctrl-P": "goLineUp",
      "Ctrl-N": "goLineDown",
      "Ctrl-A": "goLineStart",
      "Ctrl-E": "goLineEnd",
      "Ctrl-V": "goPageDown",
      "Shift-Ctrl-V": "goPageUp",
      "Ctrl-D": "delCharAfter",
      "Ctrl-H": "delCharBefore",
      "Alt-Backspace": "delWordBefore",
      "Ctrl-K": "killLine",
      "Ctrl-T": "transposeChars",
      "Ctrl-O": "openLine"
    };
    keyMap2.macDefault = {
      "Cmd-A": "selectAll",
      "Cmd-D": "deleteLine",
      "Cmd-Z": "undo",
      "Shift-Cmd-Z": "redo",
      "Cmd-Y": "redo",
      "Cmd-Home": "goDocStart",
      "Cmd-Up": "goDocStart",
      "Cmd-End": "goDocEnd",
      "Cmd-Down": "goDocEnd",
      "Alt-Left": "goGroupLeft",
      "Alt-Right": "goGroupRight",
      "Cmd-Left": "goLineLeft",
      "Cmd-Right": "goLineRight",
      "Alt-Backspace": "delGroupBefore",
      "Ctrl-Alt-Backspace": "delGroupAfter",
      "Alt-Delete": "delGroupAfter",
      "Cmd-S": "save",
      "Cmd-F": "find",
      "Cmd-G": "findNext",
      "Shift-Cmd-G": "findPrev",
      "Cmd-Alt-F": "replace",
      "Shift-Cmd-Alt-F": "replaceAll",
      "Cmd-[": "indentLess",
      "Cmd-]": "indentMore",
      "Cmd-Backspace": "delWrappedLineLeft",
      "Cmd-Delete": "delWrappedLineRight",
      "Cmd-U": "undoSelection",
      "Shift-Cmd-U": "redoSelection",
      "Ctrl-Up": "goDocStart",
      "Ctrl-Down": "goDocEnd",
      "fallthrough": ["basic", "emacsy"]
    };
    keyMap2["default"] = mac2 ? keyMap2.macDefault : keyMap2.pcDefault;
    function normalizeKeyName2(name2) {
      var parts = name2.split(/-(?!$)/);
      name2 = parts[parts.length - 1];
      var alt, ctrl, shift, cmd;
      for (var i3 = 0; i3 < parts.length - 1; i3++) {
        var mod = parts[i3];
        if (/^(cmd|meta|m)$/i.test(mod)) {
          cmd = true;
        } else if (/^a(lt)?$/i.test(mod)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod)) {
          shift = true;
        } else {
          throw new Error("Unrecognized modifier name: " + mod);
        }
      }
      if (alt) {
        name2 = "Alt-" + name2;
      }
      if (ctrl) {
        name2 = "Ctrl-" + name2;
      }
      if (cmd) {
        name2 = "Cmd-" + name2;
      }
      if (shift) {
        name2 = "Shift-" + name2;
      }
      return name2;
    }
    function normalizeKeyMap2(keymap) {
      var copy = {};
      for (var keyname in keymap) {
        if (keymap.hasOwnProperty(keyname)) {
          var value2 = keymap[keyname];
          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
            continue;
          }
          if (value2 == "...") {
            delete keymap[keyname];
            continue;
          }
          var keys2 = map2(keyname.split(" "), normalizeKeyName2);
          for (var i3 = 0; i3 < keys2.length; i3++) {
            var val = void 0, name2 = void 0;
            if (i3 == keys2.length - 1) {
              name2 = keys2.join(" ");
              val = value2;
            } else {
              name2 = keys2.slice(0, i3 + 1).join(" ");
              val = "...";
            }
            var prev = copy[name2];
            if (!prev) {
              copy[name2] = val;
            } else if (prev != val) {
              throw new Error("Inconsistent bindings for " + name2);
            }
          }
          delete keymap[keyname];
        }
      }
      for (var prop2 in copy) {
        keymap[prop2] = copy[prop2];
      }
      return keymap;
    }
    function lookupKey2(key, map3, handle, context) {
      map3 = getKeyMap2(map3);
      var found = map3.call ? map3.call(key, context) : map3[key];
      if (found === false) {
        return "nothing";
      }
      if (found === "...") {
        return "multi";
      }
      if (found != null && handle(found)) {
        return "handled";
      }
      if (map3.fallthrough) {
        if (Object.prototype.toString.call(map3.fallthrough) != "[object Array]") {
          return lookupKey2(key, map3.fallthrough, handle, context);
        }
        for (var i3 = 0; i3 < map3.fallthrough.length; i3++) {
          var result = lookupKey2(key, map3.fallthrough[i3], handle, context);
          if (result) {
            return result;
          }
        }
      }
    }
    function isModifierKey2(value2) {
      var name2 = typeof value2 == "string" ? value2 : keyNames2[value2.keyCode];
      return name2 == "Ctrl" || name2 == "Alt" || name2 == "Shift" || name2 == "Mod";
    }
    function addModifierNames2(name2, event2, noShift) {
      var base = name2;
      if (event2.altKey && base != "Alt") {
        name2 = "Alt-" + name2;
      }
      if ((flipCtrlCmd2 ? event2.metaKey : event2.ctrlKey) && base != "Ctrl") {
        name2 = "Ctrl-" + name2;
      }
      if ((flipCtrlCmd2 ? event2.ctrlKey : event2.metaKey) && base != "Mod") {
        name2 = "Cmd-" + name2;
      }
      if (!noShift && event2.shiftKey && base != "Shift") {
        name2 = "Shift-" + name2;
      }
      return name2;
    }
    function keyName2(event2, noShift) {
      if (presto2 && event2.keyCode == 34 && event2["char"]) {
        return false;
      }
      var name2 = keyNames2[event2.keyCode];
      if (name2 == null || event2.altGraphKey) {
        return false;
      }
      if (event2.keyCode == 3 && event2.code) {
        name2 = event2.code;
      }
      return addModifierNames2(name2, event2, noShift);
    }
    function getKeyMap2(val) {
      return typeof val == "string" ? keyMap2[val] : val;
    }
    function deleteNearSelection2(cm, compute) {
      var ranges = cm.doc.sel.ranges, kill = [];
      for (var i3 = 0; i3 < ranges.length; i3++) {
        var toKill = compute(ranges[i3]);
        while (kill.length && cmp2(toKill.from, lst2(kill).to) <= 0) {
          var replaced = kill.pop();
          if (cmp2(replaced.from, toKill.from) < 0) {
            toKill.from = replaced.from;
            break;
          }
        }
        kill.push(toKill);
      }
      runInOp2(cm, function() {
        for (var i4 = kill.length - 1; i4 >= 0; i4--) {
          replaceRange2(cm.doc, "", kill[i4].from, kill[i4].to, "+delete");
        }
        ensureCursorVisible2(cm);
      });
    }
    function moveCharLogically2(line, ch, dir) {
      var target = skipExtendingChars2(line.text, ch + dir, dir);
      return target < 0 || target > line.text.length ? null : target;
    }
    function moveLogically2(line, start2, dir) {
      var ch = moveCharLogically2(line, start2.ch, dir);
      return ch == null ? null : new Pos2(start2.line, ch, dir < 0 ? "after" : "before");
    }
    function endOfLine2(visually, cm, lineObj, lineNo3, dir) {
      if (visually) {
        if (cm.doc.direction == "rtl") {
          dir = -dir;
        }
        var order2 = getOrder2(lineObj, cm.doc.direction);
        if (order2) {
          var part = dir < 0 ? lst2(order2) : order2[0];
          var moveInStorageOrder = dir < 0 == (part.level == 1);
          var sticky = moveInStorageOrder ? "after" : "before";
          var ch;
          if (part.level > 0 || cm.doc.direction == "rtl") {
            var prep = prepareMeasureForLine2(cm, lineObj);
            ch = dir < 0 ? lineObj.text.length - 1 : 0;
            var targetTop = measureCharPrepared2(cm, prep, ch).top;
            ch = findFirst2(function(ch2) {
              return measureCharPrepared2(cm, prep, ch2).top == targetTop;
            }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
            if (sticky == "before") {
              ch = moveCharLogically2(lineObj, ch, 1);
            }
          } else {
            ch = dir < 0 ? part.to : part.from;
          }
          return new Pos2(lineNo3, ch, sticky);
        }
      }
      return new Pos2(lineNo3, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
    }
    function moveVisually2(cm, line, start2, dir) {
      var bidi = getOrder2(line, cm.doc.direction);
      if (!bidi) {
        return moveLogically2(line, start2, dir);
      }
      if (start2.ch >= line.text.length) {
        start2.ch = line.text.length;
        start2.sticky = "before";
      } else if (start2.ch <= 0) {
        start2.ch = 0;
        start2.sticky = "after";
      }
      var partPos = getBidiPartAt2(bidi, start2.ch, start2.sticky), part = bidi[partPos];
      if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start2.ch : part.from < start2.ch)) {
        return moveLogically2(line, start2, dir);
      }
      var mv = function(pos, dir2) {
        return moveCharLogically2(line, pos instanceof Pos2 ? pos.ch : pos, dir2);
      };
      var prep;
      var getWrappedLineExtent = function(ch2) {
        if (!cm.options.lineWrapping) {
          return { begin: 0, end: line.text.length };
        }
        prep = prep || prepareMeasureForLine2(cm, line);
        return wrappedLineExtentChar2(cm, line, prep, ch2);
      };
      var wrappedLineExtent3 = getWrappedLineExtent(start2.sticky == "before" ? mv(start2, -1) : start2.ch);
      if (cm.doc.direction == "rtl" || part.level == 1) {
        var moveInStorageOrder = part.level == 1 == dir < 0;
        var ch = mv(start2, moveInStorageOrder ? 1 : -1);
        if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent3.begin : ch <= part.to && ch <= wrappedLineExtent3.end)) {
          var sticky = moveInStorageOrder ? "before" : "after";
          return new Pos2(start2.line, ch, sticky);
        }
      }
      var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent4) {
        var getRes = function(ch3, moveInStorageOrder3) {
          return moveInStorageOrder3 ? new Pos2(start2.line, mv(ch3, 1), "before") : new Pos2(start2.line, ch3, "after");
        };
        for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
          var part2 = bidi[partPos2];
          var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
          var ch2 = moveInStorageOrder2 ? wrappedLineExtent4.begin : mv(wrappedLineExtent4.end, -1);
          if (part2.from <= ch2 && ch2 < part2.to) {
            return getRes(ch2, moveInStorageOrder2);
          }
          ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
          if (wrappedLineExtent4.begin <= ch2 && ch2 < wrappedLineExtent4.end) {
            return getRes(ch2, moveInStorageOrder2);
          }
        }
      };
      var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent3);
      if (res) {
        return res;
      }
      var nextCh = dir > 0 ? wrappedLineExtent3.end : mv(wrappedLineExtent3.begin, -1);
      if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
        if (res) {
          return res;
        }
      }
      return null;
    }
    var commands2 = {
      selectAll: selectAll2,
      singleSelection: function(cm) {
        return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll2);
      },
      killLine: function(cm) {
        return deleteNearSelection2(cm, function(range3) {
          if (range3.empty()) {
            var len = getLine2(cm.doc, range3.head.line).text.length;
            if (range3.head.ch == len && range3.head.line < cm.lastLine()) {
              return { from: range3.head, to: Pos2(range3.head.line + 1, 0) };
            } else {
              return { from: range3.head, to: Pos2(range3.head.line, len) };
            }
          } else {
            return { from: range3.from(), to: range3.to() };
          }
        });
      },
      deleteLine: function(cm) {
        return deleteNearSelection2(cm, function(range3) {
          return {
            from: Pos2(range3.from().line, 0),
            to: clipPos2(cm.doc, Pos2(range3.to().line + 1, 0))
          };
        });
      },
      delLineLeft: function(cm) {
        return deleteNearSelection2(cm, function(range3) {
          return {
            from: Pos2(range3.from().line, 0),
            to: range3.from()
          };
        });
      },
      delWrappedLineLeft: function(cm) {
        return deleteNearSelection2(cm, function(range3) {
          var top2 = cm.charCoords(range3.head, "div").top + 5;
          var leftPos = cm.coordsChar({ left: 0, top: top2 }, "div");
          return { from: leftPos, to: range3.from() };
        });
      },
      delWrappedLineRight: function(cm) {
        return deleteNearSelection2(cm, function(range3) {
          var top2 = cm.charCoords(range3.head, "div").top + 5;
          var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
          return { from: range3.from(), to: rightPos };
        });
      },
      undo: function(cm) {
        return cm.undo();
      },
      redo: function(cm) {
        return cm.redo();
      },
      undoSelection: function(cm) {
        return cm.undoSelection();
      },
      redoSelection: function(cm) {
        return cm.redoSelection();
      },
      goDocStart: function(cm) {
        return cm.extendSelection(Pos2(cm.firstLine(), 0));
      },
      goDocEnd: function(cm) {
        return cm.extendSelection(Pos2(cm.lastLine()));
      },
      goLineStart: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          return lineStart2(cm, range3.head.line);
        }, { origin: "+move", bias: 1 });
      },
      goLineStartSmart: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          return lineStartSmart2(cm, range3.head);
        }, { origin: "+move", bias: 1 });
      },
      goLineEnd: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          return lineEnd2(cm, range3.head.line);
        }, { origin: "+move", bias: -1 });
      },
      goLineRight: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          var top2 = cm.cursorCoords(range3.head, "div").top + 5;
          return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
        }, sel_move2);
      },
      goLineLeft: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          var top2 = cm.cursorCoords(range3.head, "div").top + 5;
          return cm.coordsChar({ left: 0, top: top2 }, "div");
        }, sel_move2);
      },
      goLineLeftSmart: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          var top2 = cm.cursorCoords(range3.head, "div").top + 5;
          var pos = cm.coordsChar({ left: 0, top: top2 }, "div");
          if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
            return lineStartSmart2(cm, range3.head);
          }
          return pos;
        }, sel_move2);
      },
      goLineUp: function(cm) {
        return cm.moveV(-1, "line");
      },
      goLineDown: function(cm) {
        return cm.moveV(1, "line");
      },
      goPageUp: function(cm) {
        return cm.moveV(-1, "page");
      },
      goPageDown: function(cm) {
        return cm.moveV(1, "page");
      },
      goCharLeft: function(cm) {
        return cm.moveH(-1, "char");
      },
      goCharRight: function(cm) {
        return cm.moveH(1, "char");
      },
      goColumnLeft: function(cm) {
        return cm.moveH(-1, "column");
      },
      goColumnRight: function(cm) {
        return cm.moveH(1, "column");
      },
      goWordLeft: function(cm) {
        return cm.moveH(-1, "word");
      },
      goGroupRight: function(cm) {
        return cm.moveH(1, "group");
      },
      goGroupLeft: function(cm) {
        return cm.moveH(-1, "group");
      },
      goWordRight: function(cm) {
        return cm.moveH(1, "word");
      },
      delCharBefore: function(cm) {
        return cm.deleteH(-1, "codepoint");
      },
      delCharAfter: function(cm) {
        return cm.deleteH(1, "char");
      },
      delWordBefore: function(cm) {
        return cm.deleteH(-1, "word");
      },
      delWordAfter: function(cm) {
        return cm.deleteH(1, "word");
      },
      delGroupBefore: function(cm) {
        return cm.deleteH(-1, "group");
      },
      delGroupAfter: function(cm) {
        return cm.deleteH(1, "group");
      },
      indentAuto: function(cm) {
        return cm.indentSelection("smart");
      },
      indentMore: function(cm) {
        return cm.indentSelection("add");
      },
      indentLess: function(cm) {
        return cm.indentSelection("subtract");
      },
      insertTab: function(cm) {
        return cm.replaceSelection("	");
      },
      insertSoftTab: function(cm) {
        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
        for (var i3 = 0; i3 < ranges.length; i3++) {
          var pos = ranges[i3].from();
          var col = countColumn2(cm.getLine(pos.line), pos.ch, tabSize);
          spaces.push(spaceStr2(tabSize - col % tabSize));
        }
        cm.replaceSelections(spaces);
      },
      defaultTab: function(cm) {
        if (cm.somethingSelected()) {
          cm.indentSelection("add");
        } else {
          cm.execCommand("insertTab");
        }
      },
      transposeChars: function(cm) {
        return runInOp2(cm, function() {
          var ranges = cm.listSelections(), newSel = [];
          for (var i3 = 0; i3 < ranges.length; i3++) {
            if (!ranges[i3].empty()) {
              continue;
            }
            var cur = ranges[i3].head, line = getLine2(cm.doc, cur.line).text;
            if (line) {
              if (cur.ch == line.length) {
                cur = new Pos2(cur.line, cur.ch - 1);
              }
              if (cur.ch > 0) {
                cur = new Pos2(cur.line, cur.ch + 1);
                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos2(cur.line, cur.ch - 2), cur, "+transpose");
              } else if (cur.line > cm.doc.first) {
                var prev = getLine2(cm.doc, cur.line - 1).text;
                if (prev) {
                  cur = new Pos2(cur.line, 1);
                  cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos2(cur.line - 1, prev.length - 1), cur, "+transpose");
                }
              }
            }
            newSel.push(new Range2(cur, cur));
          }
          cm.setSelections(newSel);
        });
      },
      newlineAndIndent: function(cm) {
        return runInOp2(cm, function() {
          var selection = cm.getOption("selection");
          if (selection) {
            var ranges = selection.ranges;
            if (ranges != null && ranges != [] && ranges.length != selection.primary) {
              var ofAnchorCh = cm.getRange(Pos2(0, 0), cm.getCursor()).length + 1 == ranges[selection.primary].anchor.ch;
              var ofHeadCh = 0;
              if (!ofAnchorCh) {
                ofHeadCh = cm.getRange(Pos2(0, 0), cm.getCursor()).length + 1 - ranges[selection.primary].anchor.ch;
              }
              cm.setSelection(Pos2(0, ranges[selection.primary].anchor.ch + ofHeadCh), Pos2(0, ranges[selection.primary].head.ch + ofHeadCh), { scroll: false });
              selection.primary++;
              return;
            } else if (ranges.length === selection.primary) {
              cm.setOption("selection", null);
              return cm.extendSelection(Pos2(cm.lastLine()));
            }
          } else {
            if (cm.getOption("isSupportReturn") == void 0 ? true : cm.getOption("isSupportReturn")) {
              var sels = cm.listSelections();
              for (var i3 = sels.length - 1; i3 >= 0; i3--) {
                cm.replaceRange(cm.doc.lineSeparator(), sels[i3].anchor, sels[i3].head, "+input");
              }
              sels = cm.listSelections();
              for (var i$12 = 0; i$12 < sels.length; i$12++) {
                cm.indentLine(sels[i$12].from().line, null, true);
              }
              ensureCursorVisible2(cm);
            }
          }
        });
      },
      openLine: function(cm) {
        return cm.replaceSelection("\n", "start");
      },
      toggleOverwrite: function(cm) {
        return cm.toggleOverwrite();
      }
    };
    function lineStart2(cm, lineN) {
      var line = getLine2(cm.doc, lineN);
      var visual = visualLine2(line);
      if (visual != line) {
        lineN = lineNo2(visual);
      }
      return endOfLine2(true, cm, visual, lineN, 1);
    }
    function lineEnd2(cm, lineN) {
      var line = getLine2(cm.doc, lineN);
      var visual = visualLineEnd2(line);
      if (visual != line) {
        lineN = lineNo2(visual);
      }
      return endOfLine2(true, cm, line, lineN, -1);
    }
    function lineStartSmart2(cm, pos) {
      var start2 = lineStart2(cm, pos.line);
      var line = getLine2(cm.doc, start2.line);
      var order2 = getOrder2(line, cm.doc.direction);
      if (!order2 || order2[0].level == 0) {
        var firstNonWS = Math.max(start2.ch, line.text.search(/\S/));
        var inWS = pos.line == start2.line && pos.ch <= firstNonWS && pos.ch;
        return Pos2(start2.line, inWS ? 0 : firstNonWS, start2.sticky);
      }
      return start2;
    }
    function doHandleBinding2(cm, bound, dropShift) {
      if (typeof bound == "string") {
        bound = commands2[bound];
        if (!bound) {
          return false;
        }
      }
      cm.display.input.ensurePolled();
      var prevShift = cm.display.shift, done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        if (dropShift) {
          cm.display.shift = false;
        }
        done = bound(cm) != Pass2;
      } finally {
        cm.display.shift = prevShift;
        cm.state.suppressEdits = false;
      }
      return done;
    }
    function lookupKeyForEditor2(cm, name2, handle) {
      for (var i3 = 0; i3 < cm.state.keyMaps.length; i3++) {
        var result = lookupKey2(name2, cm.state.keyMaps[i3], handle, cm);
        if (result) {
          return result;
        }
      }
      return cm.options.extraKeys && lookupKey2(name2, cm.options.extraKeys, handle, cm) || lookupKey2(name2, cm.options.keyMap, handle, cm);
    }
    var stopSeq2 = new Delayed2();
    function dispatchKey2(cm, name2, e, handle) {
      var seq = cm.state.keySeq;
      if (seq) {
        if (isModifierKey2(name2)) {
          return "handled";
        }
        if (/\'$/.test(name2)) {
          cm.state.keySeq = null;
        } else {
          stopSeq2.set(50, function() {
            if (cm.state.keySeq == seq) {
              cm.state.keySeq = null;
              cm.display.input.reset();
            }
          });
        }
        if (dispatchKeyInner2(cm, seq + " " + name2, e, handle)) {
          return true;
        }
      }
      return dispatchKeyInner2(cm, name2, e, handle);
    }
    function dispatchKeyInner2(cm, name2, e, handle) {
      var result = lookupKeyForEditor2(cm, name2, handle);
      if (result == "multi") {
        cm.state.keySeq = name2;
      }
      if (result == "handled") {
        signalLater2(cm, "keyHandled", cm, name2, e);
      }
      if (result == "handled" || result == "multi") {
        e_preventDefault2(e);
        restartBlink2(cm);
      }
      return !!result;
    }
    function handleKeyBinding2(cm, e) {
      var name2 = keyName2(e, true);
      if (!name2) {
        return false;
      }
      if (e.shiftKey && !cm.state.keySeq) {
        return dispatchKey2(cm, "Shift-" + name2, e, function(b) {
          return doHandleBinding2(cm, b, true);
        }) || dispatchKey2(cm, name2, e, function(b) {
          if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
            return doHandleBinding2(cm, b);
          }
        });
      } else {
        return dispatchKey2(cm, name2, e, function(b) {
          return doHandleBinding2(cm, b);
        });
      }
    }
    function handleCharBinding2(cm, e, ch) {
      return dispatchKey2(cm, "'" + ch + "'", e, function(b) {
        return doHandleBinding2(cm, b, true);
      });
    }
    var lastStoppedKey2 = null;
    function onKeyDown2(e) {
      var cm = this;
      if (e.target && e.target != cm.display.input.getField()) {
        return;
      }
      cm.curOp.focus = activeElt2();
      if (signalDOMEvent2(cm, e)) {
        return;
      }
      if (ie2 && ie_version2 < 11 && e.keyCode == 27) {
        e.returnValue = false;
      }
      var code = e.keyCode;
      cm.display.shift = code == 16 || e.shiftKey;
      var handled = handleKeyBinding2(cm, e);
      if (presto2) {
        lastStoppedKey2 = handled ? code : null;
        if (!handled && code == 88 && !hasCopyEvent2 && (mac2 ? e.metaKey : e.ctrlKey)) {
          cm.replaceSelection("", null, "cut");
        }
      }
      if (gecko2 && !mac2 && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
        document.execCommand("cut");
      }
      if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
        showCrossHair2(cm);
      }
    }
    function showCrossHair2(cm) {
      var lineDiv = cm.display.lineDiv;
      addClass2(lineDiv, "CodeMirror-crosshair");
      function up(e) {
        if (e.keyCode == 18 || !e.altKey) {
          rmClass2(lineDiv, "CodeMirror-crosshair");
          off2(document, "keyup", up);
          off2(document, "mouseover", up);
        }
      }
      on2(document, "keyup", up);
      on2(document, "mouseover", up);
    }
    function onKeyUp2(e) {
      if (e.keyCode == 16) {
        this.doc.sel.shift = false;
      }
      signalDOMEvent2(this, e);
    }
    function onKeyPress2(e) {
      var cm = this;
      if (e.target && e.target != cm.display.input.getField()) {
        return;
      }
      if (eventInWidget2(cm.display, e) || signalDOMEvent2(cm, e) || e.ctrlKey && !e.altKey || mac2 && e.metaKey) {
        return;
      }
      var keyCode = e.keyCode, charCode = e.charCode;
      if (presto2 && keyCode == lastStoppedKey2) {
        lastStoppedKey2 = null;
        e_preventDefault2(e);
        return;
      }
      if (presto2 && (!e.which || e.which < 10) && handleKeyBinding2(cm, e)) {
        return;
      }
      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
      if (ch == "\b") {
        return;
      }
      if (handleCharBinding2(cm, e, ch)) {
        return;
      }
      cm.display.input.onKeyPress(e);
    }
    var DOUBLECLICK_DELAY2 = 400;
    var PastClick2 = function(time, pos, button) {
      this.time = time;
      this.pos = pos;
      this.button = button;
    };
    PastClick2.prototype.compare = function(time, pos, button) {
      return this.time + DOUBLECLICK_DELAY2 > time && cmp2(pos, this.pos) == 0 && button == this.button;
    };
    var lastClick2, lastDoubleClick2;
    function clickRepeat2(pos, button) {
      var now2 = +new Date();
      if (lastDoubleClick2 && lastDoubleClick2.compare(now2, pos, button)) {
        lastClick2 = lastDoubleClick2 = null;
        return "triple";
      } else if (lastClick2 && lastClick2.compare(now2, pos, button)) {
        lastDoubleClick2 = new PastClick2(now2, pos, button);
        lastClick2 = null;
        return "double";
      } else {
        lastClick2 = new PastClick2(now2, pos, button);
        lastDoubleClick2 = null;
        return "single";
      }
    }
    function onMouseDown2(e) {
      var cm = this, display = cm.display;
      if (signalDOMEvent2(cm, e) || display.activeTouch && display.input.supportsTouch()) {
        return;
      }
      display.input.ensurePolled();
      display.shift = e.shiftKey;
      if (eventInWidget2(display, e)) {
        if (!webkit2) {
          display.scroller.draggable = false;
          setTimeout(function() {
            return display.scroller.draggable = true;
          }, 100);
        }
        return;
      }
      if (clickInGutter2(cm, e)) {
        return;
      }
      var pos = posFromMouse2(cm, e), button = e_button2(e), repeat2 = pos ? clickRepeat2(pos, button) : "single";
      window.focus();
      if (button == 1 && cm.state.selectingText) {
        cm.state.selectingText(e);
      }
      if (pos && handleMappedButton2(cm, button, pos, repeat2, e)) {
        return;
      }
      if (button == 1) {
        if (pos) {
          leftButtonDown2(cm, pos, repeat2, e);
        } else if (e_target2(e) == display.scroller) {
          e_preventDefault2(e);
        }
      } else if (button == 2) {
        if (pos) {
          extendSelection2(cm.doc, pos);
        }
        setTimeout(function() {
          return display.input.focus();
        }, 20);
      } else if (button == 3) {
        if (captureRightClick2) {
          cm.display.input.onContextMenu(e);
        } else {
          delayBlurEvent2(cm);
        }
      }
    }
    function handleMappedButton2(cm, button, pos, repeat2, event2) {
      var name2 = "Click";
      if (repeat2 == "double") {
        name2 = "Double" + name2;
      } else if (repeat2 == "triple") {
        name2 = "Triple" + name2;
      }
      name2 = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name2;
      return dispatchKey2(cm, addModifierNames2(name2, event2), event2, function(bound) {
        if (typeof bound == "string") {
          bound = commands2[bound];
        }
        if (!bound) {
          return false;
        }
        var done = false;
        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }
          done = bound(cm, pos) != Pass2;
        } finally {
          cm.state.suppressEdits = false;
        }
        return done;
      });
    }
    function configureMouse2(cm, repeat2, event2) {
      var option2 = cm.getOption("configureMouse");
      var value2 = option2 ? option2(cm, repeat2, event2) : {};
      if (value2.unit == null) {
        var rect = chromeOS2 ? event2.shiftKey && event2.metaKey : event2.altKey;
        value2.unit = rect ? "rectangle" : repeat2 == "single" ? "char" : repeat2 == "double" ? "word" : "line";
      }
      if (value2.extend == null || cm.doc.extend) {
        value2.extend = cm.doc.extend || event2.shiftKey;
      }
      if (value2.addNew == null) {
        value2.addNew = mac2 ? event2.metaKey : event2.ctrlKey;
      }
      if (value2.moveOnDrag == null) {
        value2.moveOnDrag = !(mac2 ? event2.altKey : event2.ctrlKey);
      }
      return value2;
    }
    function leftButtonDown2(cm, pos, repeat2, event2) {
      if (ie2) {
        setTimeout(bind3(ensureFocus2, cm), 0);
      } else {
        cm.curOp.focus = activeElt2();
      }
      var behavior = configureMouse2(cm, repeat2, event2);
      var sel = cm.doc.sel, contained;
      if (cm.options.dragDrop && dragAndDrop2 && !cm.isReadOnly() && repeat2 == "single" && (contained = sel.contains(pos)) > -1 && (cmp2((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp2(contained.to(), pos) > 0 || pos.xRel < 0)) {
        leftButtonStartDrag2(cm, event2, pos, behavior);
      } else {
        leftButtonSelect2(cm, event2, pos, behavior);
      }
    }
    function leftButtonStartDrag2(cm, event2, pos, behavior) {
      var display = cm.display, moved2 = false;
      var dragEnd = operation2(cm, function(e) {
        if (webkit2) {
          display.scroller.draggable = false;
        }
        cm.state.draggingText = false;
        if (cm.state.delayingBlurEvent) {
          if (cm.hasFocus()) {
            cm.state.delayingBlurEvent = false;
          } else {
            delayBlurEvent2(cm);
          }
        }
        off2(display.wrapper.ownerDocument, "mouseup", dragEnd);
        off2(display.wrapper.ownerDocument, "mousemove", mouseMove);
        off2(display.scroller, "dragstart", dragStart2);
        off2(display.scroller, "drop", dragEnd);
        if (!moved2) {
          e_preventDefault2(e);
          if (!behavior.addNew) {
            extendSelection2(cm.doc, pos, null, null, behavior.extend);
          }
          if (webkit2 && !safari2 || ie2 && ie_version2 == 9) {
            setTimeout(function() {
              display.wrapper.ownerDocument.body.focus({ preventScroll: true });
              display.input.focus();
            }, 20);
          } else {
            display.input.focus();
          }
        }
      });
      var mouseMove = function(e2) {
        moved2 = moved2 || Math.abs(event2.clientX - e2.clientX) + Math.abs(event2.clientY - e2.clientY) >= 10;
      };
      var dragStart2 = function() {
        return moved2 = true;
      };
      if (webkit2) {
        display.scroller.draggable = true;
      }
      cm.state.draggingText = dragEnd;
      dragEnd.copy = !behavior.moveOnDrag;
      on2(display.wrapper.ownerDocument, "mouseup", dragEnd);
      on2(display.wrapper.ownerDocument, "mousemove", mouseMove);
      on2(display.scroller, "dragstart", dragStart2);
      on2(display.scroller, "drop", dragEnd);
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        return display.input.focus();
      }, 20);
      if (display.scroller.dragDrop) {
        display.scroller.dragDrop();
      }
    }
    function rangeForUnit2(cm, pos, unit) {
      if (unit == "char") {
        return new Range2(pos, pos);
      }
      if (unit == "word") {
        return cm.findWordAt(pos);
      }
      if (unit == "line") {
        return new Range2(Pos2(pos.line, 0), clipPos2(cm.doc, Pos2(pos.line + 1, 0)));
      }
      var result = unit(cm, pos);
      return new Range2(result.from, result.to);
    }
    function leftButtonSelect2(cm, event2, start2, behavior) {
      if (ie2) {
        delayBlurEvent2(cm);
      }
      var display = cm.display, doc = cm.doc;
      e_preventDefault2(event2);
      var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
      if (behavior.addNew && !behavior.extend) {
        ourIndex = doc.sel.contains(start2);
        if (ourIndex > -1) {
          ourRange = ranges[ourIndex];
        } else {
          ourRange = new Range2(start2, start2);
        }
      } else {
        ourRange = doc.sel.primary();
        ourIndex = doc.sel.primIndex;
      }
      if (behavior.unit == "rectangle") {
        if (!behavior.addNew) {
          ourRange = new Range2(start2, start2);
        }
        start2 = posFromMouse2(cm, event2, true, true);
        ourIndex = -1;
      } else {
        var range3 = rangeForUnit2(cm, start2, behavior.unit);
        if (behavior.extend) {
          ourRange = extendRange2(ourRange, range3.anchor, range3.head, behavior.extend);
        } else {
          ourRange = range3;
        }
      }
      if (!behavior.addNew) {
        ourIndex = 0;
        setSelection2(doc, new Selection2([ourRange], 0), sel_mouse2);
        startSel = doc.sel;
      } else if (ourIndex == -1) {
        ourIndex = ranges.length;
        setSelection2(doc, normalizeSelection2(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
        setSelection2(doc, normalizeSelection2(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
        startSel = doc.sel;
      } else {
        replaceOneSelection2(doc, ourIndex, ourRange, sel_mouse2);
      }
      var lastPos = start2;
      function extendTo(pos) {
        if (cmp2(lastPos, pos) == 0) {
          return;
        }
        lastPos = pos;
        if (behavior.unit == "rectangle") {
          var ranges2 = [], tabSize = cm.options.tabSize;
          var startCol = countColumn2(getLine2(doc, start2.line).text, start2.ch, tabSize);
          var posCol = countColumn2(getLine2(doc, pos.line).text, pos.ch, tabSize);
          var left2 = Math.min(startCol, posCol), right2 = Math.max(startCol, posCol);
          for (var line = Math.min(start2.line, pos.line), end2 = Math.min(cm.lastLine(), Math.max(start2.line, pos.line)); line <= end2; line++) {
            var text = getLine2(doc, line).text, leftPos = findColumn2(text, left2, tabSize);
            if (left2 == right2) {
              ranges2.push(new Range2(Pos2(line, leftPos), Pos2(line, leftPos)));
            } else if (text.length > leftPos) {
              ranges2.push(new Range2(Pos2(line, leftPos), Pos2(line, findColumn2(text, right2, tabSize))));
            }
          }
          if (!ranges2.length) {
            ranges2.push(new Range2(start2, start2));
          }
          setSelection2(doc, normalizeSelection2(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
          cm.scrollIntoView(pos);
        } else {
          var oldRange = ourRange;
          var range4 = rangeForUnit2(cm, pos, behavior.unit);
          var anchor = oldRange.anchor, head;
          if (cmp2(range4.anchor, anchor) > 0) {
            head = range4.head;
            anchor = minPos2(oldRange.from(), range4.anchor);
          } else {
            head = range4.anchor;
            anchor = maxPos2(oldRange.to(), range4.head);
          }
          var ranges$1 = startSel.ranges.slice(0);
          ranges$1[ourIndex] = bidiSimplify2(cm, new Range2(clipPos2(doc, anchor), head));
          setSelection2(doc, normalizeSelection2(cm, ranges$1, ourIndex), sel_mouse2);
        }
      }
      var editorSize = display.wrapper.getBoundingClientRect();
      var counter = 0;
      function extend2(e) {
        var curCount = ++counter;
        var cur = posFromMouse2(cm, e, true, behavior.unit == "rectangle");
        if (!cur) {
          return;
        }
        if (cmp2(cur, lastPos) != 0) {
          cm.curOp.focus = activeElt2();
          extendTo(cur);
          var visible2 = visibleLines2(display, doc);
          if (cur.line >= visible2.to || cur.line < visible2.from) {
            setTimeout(operation2(cm, function() {
              if (counter == curCount) {
                extend2(e);
              }
            }), 150);
          }
        } else {
          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
          if (outside) {
            setTimeout(operation2(cm, function() {
              if (counter != curCount) {
                return;
              }
              display.scroller.scrollTop += outside;
              extend2(e);
            }), 50);
          }
        }
      }
      function done(e) {
        cm.state.selectingText = false;
        counter = Infinity;
        if (e) {
          e_preventDefault2(e);
          display.input.focus();
        }
        off2(display.wrapper.ownerDocument, "mousemove", move);
        off2(display.wrapper.ownerDocument, "mouseup", up);
        doc.history.lastSelOrigin = null;
      }
      var move = operation2(cm, function(e) {
        if (e.buttons === 0 || !e_button2(e)) {
          done(e);
        } else {
          extend2(e);
        }
      });
      var up = operation2(cm, done);
      cm.state.selectingText = up;
      on2(display.wrapper.ownerDocument, "mousemove", move);
      on2(display.wrapper.ownerDocument, "mouseup", up);
    }
    function bidiSimplify2(cm, range3) {
      var anchor = range3.anchor;
      var head = range3.head;
      var anchorLine = getLine2(cm.doc, anchor.line);
      if (cmp2(anchor, head) == 0 && anchor.sticky == head.sticky) {
        return range3;
      }
      var order2 = getOrder2(anchorLine);
      if (!order2) {
        return range3;
      }
      var index2 = getBidiPartAt2(order2, anchor.ch, anchor.sticky), part = order2[index2];
      if (part.from != anchor.ch && part.to != anchor.ch) {
        return range3;
      }
      var boundary = index2 + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
      if (boundary == 0 || boundary == order2.length) {
        return range3;
      }
      var leftSide;
      if (head.line != anchor.line) {
        leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
      } else {
        var headIndex = getBidiPartAt2(order2, head.ch, head.sticky);
        var dir = headIndex - index2 || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
        if (headIndex == boundary - 1 || headIndex == boundary) {
          leftSide = dir < 0;
        } else {
          leftSide = dir > 0;
        }
      }
      var usePart = order2[boundary + (leftSide ? -1 : 0)];
      var from = leftSide == (usePart.level == 1);
      var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
      return anchor.ch == ch && anchor.sticky == sticky ? range3 : new Range2(new Pos2(anchor.line, ch, sticky), head);
    }
    function gutterEvent2(cm, e, type2, prevent) {
      var mX, mY;
      if (e.touches) {
        mX = e.touches[0].clientX;
        mY = e.touches[0].clientY;
      } else {
        try {
          mX = e.clientX;
          mY = e.clientY;
        } catch (e$1) {
          return false;
        }
      }
      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
        return false;
      }
      if (prevent) {
        e_preventDefault2(e);
      }
      var display = cm.display;
      var lineBox = display.lineDiv.getBoundingClientRect();
      if (mY > lineBox.bottom || !hasHandler2(cm, type2)) {
        return e_defaultPrevented2(e);
      }
      mY -= lineBox.top - display.viewOffset;
      for (var i3 = 0; i3 < cm.display.gutterSpecs.length; ++i3) {
        var g = display.gutters.childNodes[i3];
        if (g && g.getBoundingClientRect().right >= mX) {
          var line = lineAtHeight2(cm.doc, mY);
          var gutter = cm.display.gutterSpecs[i3];
          signal2(cm, type2, cm, line, gutter.className, e);
          return e_defaultPrevented2(e);
        }
      }
    }
    function clickInGutter2(cm, e) {
      return gutterEvent2(cm, e, "gutterClick", true);
    }
    function onContextMenu2(cm, e) {
      if (eventInWidget2(cm.display, e) || contextMenuInGutter2(cm, e)) {
        return;
      }
      if (signalDOMEvent2(cm, e, "contextmenu")) {
        return;
      }
      if (!captureRightClick2) {
        cm.display.input.onContextMenu(e);
      }
    }
    function contextMenuInGutter2(cm, e) {
      if (!hasHandler2(cm, "gutterContextMenu")) {
        return false;
      }
      return gutterEvent2(cm, e, "gutterContextMenu", false);
    }
    function themeChanged2(cm) {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
      clearCaches2(cm);
    }
    var Init2 = { toString: function() {
      return "CodeMirror.Init";
    } };
    var defaults2 = {};
    var optionHandlers2 = {};
    function defineOptions2(CodeMirror3) {
      var optionHandlers3 = CodeMirror3.optionHandlers;
      function option2(name2, deflt, handle, notOnInit) {
        CodeMirror3.defaults[name2] = deflt;
        if (handle) {
          optionHandlers3[name2] = notOnInit ? function(cm, val, old) {
            if (old != Init2) {
              handle(cm, val, old);
            }
          } : handle;
        }
      }
      CodeMirror3.defineOption = option2;
      CodeMirror3.Init = Init2;
      option2("value", "", function(cm, val) {
        return cm.setValue(val);
      }, true);
      option2("mode", null, function(cm, val) {
        cm.doc.modeOption = val;
        loadMode2(cm);
      }, true);
      option2("indentUnit", 2, loadMode2, true);
      option2("indentWithTabs", false);
      option2("smartIndent", true);
      option2("tabSize", 4, function(cm) {
        resetModeState2(cm);
        clearCaches2(cm);
        regChange2(cm);
      }, true);
      option2("lineSeparator", null, function(cm, val) {
        cm.doc.lineSep = val;
        if (!val) {
          return;
        }
        var newBreaks = [], lineNo3 = cm.doc.first;
        cm.doc.iter(function(line) {
          for (var pos = 0; ; ) {
            var found = line.text.indexOf(val, pos);
            if (found == -1) {
              break;
            }
            pos = found + val.length;
            newBreaks.push(Pos2(lineNo3, found));
          }
          lineNo3++;
        });
        for (var i3 = newBreaks.length - 1; i3 >= 0; i3--) {
          replaceRange2(cm.doc, val, newBreaks[i3], Pos2(newBreaks[i3].line, newBreaks[i3].ch + val.length));
        }
      });
      option2("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
        cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
        if (old != Init2) {
          cm.refresh();
        }
      });
      option2("specialCharPlaceholder", defaultSpecialCharPlaceholder2, function(cm) {
        return cm.refresh();
      }, true);
      option2("electricChars", true);
      option2("inputStyle", mobile2 ? "contenteditable" : "textarea", function() {
        throw new Error("inputStyle can not (yet) be changed in a running editor");
      }, true);
      option2("spellcheck", false, function(cm, val) {
        return cm.getInputField().spellcheck = val;
      }, true);
      option2("autocorrect", false, function(cm, val) {
        return cm.getInputField().autocorrect = val;
      }, true);
      option2("autocapitalize", false, function(cm, val) {
        return cm.getInputField().autocapitalize = val;
      }, true);
      option2("rtlMoveVisually", !windows2);
      option2("wholeLineUpdateBefore", true);
      option2("theme", "default", function(cm) {
        themeChanged2(cm);
        updateGutters2(cm);
      }, true);
      option2("keyMap", "default", function(cm, val, old) {
        var next = getKeyMap2(val);
        var prev = old != Init2 && getKeyMap2(old);
        if (prev && prev.detach) {
          prev.detach(cm, next);
        }
        if (next.attach) {
          next.attach(cm, prev || null);
        }
      });
      option2("extraKeys", null);
      option2("configureMouse", null);
      option2("lineWrapping", false, wrappingChanged2, true);
      option2("gutters", [], function(cm, val) {
        cm.display.gutterSpecs = getGutters2(val, cm.options.lineNumbers);
        updateGutters2(cm);
      }, true);
      option2("fixedGutter", true, function(cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll2(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option2("coverGutterNextToScrollbar", false, function(cm) {
        return updateScrollbars2(cm);
      }, true);
      option2("scrollbarStyle", "native", function(cm) {
        initScrollbars2(cm);
        updateScrollbars2(cm);
        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
      }, true);
      option2("lineNumbers", false, function(cm, val) {
        cm.display.gutterSpecs = getGutters2(cm.options.gutters, val);
        updateGutters2(cm);
      }, true);
      option2("firstLineNumber", 1, updateGutters2, true);
      option2("lineNumberFormatter", function(integer3) {
        return integer3;
      }, updateGutters2, true);
      option2("showCursorWhenSelecting", false, updateSelection2, true);
      option2("resetSelectionOnContextMenu", true);
      option2("lineWiseCopyCut", true);
      option2("pasteLinesPerSelection", true);
      option2("selectionsMayTouch", false);
      option2("readOnly", false, function(cm, val) {
        if (val == "nocursor") {
          onBlur2(cm);
          cm.display.input.blur();
        }
        cm.display.input.readOnlyChanged(val);
      });
      option2("screenReaderLabel", null, function(cm, val) {
        val = val === "" ? null : val;
        cm.display.input.screenReaderLabelChanged(val);
      });
      option2("disableInput", false, function(cm, val) {
        if (!val) {
          cm.display.input.reset();
        }
      }, true);
      option2("dragDrop", true, dragDropChanged2);
      option2("allowDropFileTypes", null);
      option2("cursorBlinkRate", 530);
      option2("cursorScrollMargin", 0);
      option2("cursorHeight", 1, updateSelection2, true);
      option2("singleCursorHeightPerLine", true, updateSelection2, true);
      option2("workTime", 100);
      option2("workDelay", 100);
      option2("flattenSpans", true, resetModeState2, true);
      option2("addModeClass", false, resetModeState2, true);
      option2("pollInterval", 100);
      option2("undoDepth", 200, function(cm, val) {
        return cm.doc.history.undoDepth = val;
      });
      option2("historyEventDelay", 1250);
      option2("viewportMargin", 10, function(cm) {
        return cm.refresh();
      }, true);
      option2("maxHighlightLength", 1e4, resetModeState2, true);
      option2("moveInputWithCursor", true, function(cm, val) {
        if (!val) {
          cm.display.input.resetPosition();
        }
      });
      option2("tabindex", null, function(cm, val) {
        return cm.display.input.getField().tabIndex = val || "";
      });
      option2("autofocus", null);
      option2("direction", "ltr", function(cm, val) {
        return cm.doc.setDirection(val);
      }, true);
      option2("phrases", null);
    }
    function dragDropChanged2(cm, value2, old) {
      var wasOn = old && old != Init2;
      if (!value2 != !wasOn) {
        var funcs = cm.display.dragFunctions;
        var toggle = value2 ? on2 : off2;
        toggle(cm.display.scroller, "dragstart", funcs.start);
        toggle(cm.display.scroller, "dragenter", funcs.enter);
        toggle(cm.display.scroller, "dragover", funcs.over);
        toggle(cm.display.scroller, "dragleave", funcs.leave);
        toggle(cm.display.scroller, "drop", funcs.drop);
      }
    }
    function wrappingChanged2(cm) {
      if (cm.options.lineWrapping) {
        addClass2(cm.display.wrapper, "CodeMirror-wrap");
        cm.display.sizer.style.minWidth = "";
        cm.display.sizerWidth = null;
      } else {
        rmClass2(cm.display.wrapper, "CodeMirror-wrap");
        findMaxLine2(cm);
      }
      estimateLineHeights2(cm);
      regChange2(cm);
      clearCaches2(cm);
      setTimeout(function() {
        return updateScrollbars2(cm);
      }, 100);
    }
    function CodeMirror2(place, options2) {
      var this$1$1 = this;
      if (!(this instanceof CodeMirror2)) {
        return new CodeMirror2(place, options2);
      }
      this.options = options2 = options2 ? copyObj2(options2) : {};
      copyObj2(defaults2, options2, false);
      var doc = options2.value;
      if (typeof doc == "string") {
        doc = new Doc2(doc, options2.mode, null, options2.lineSeparator, options2.direction);
      } else if (options2.mode) {
        doc.modeOption = options2.mode;
      }
      this.doc = doc;
      var input2 = new CodeMirror2.inputStyles[options2.inputStyle](this);
      var display = this.display = new Display2(place, doc, input2, options2);
      display.wrapper.CodeMirror = this;
      themeChanged2(this);
      if (options2.lineWrapping) {
        this.display.wrapper.className += " CodeMirror-wrap";
      }
      initScrollbars2(this);
      this.state = {
        keyMaps: [],
        overlays: [],
        modeGen: 0,
        overwrite: false,
        delayingBlurEvent: false,
        focused: false,
        suppressEdits: false,
        pasteIncoming: -1,
        cutIncoming: -1,
        selectingText: false,
        draggingText: false,
        highlight: new Delayed2(),
        keySeq: null,
        specialChars: null
      };
      if (options2.autofocus && !mobile2) {
        display.input.focus();
      }
      if (ie2 && ie_version2 < 11) {
        setTimeout(function() {
          return this$1$1.display.input.reset(true);
        }, 20);
      }
      registerEventHandlers2(this);
      ensureGlobalHandlers2();
      startOperation2(this);
      this.curOp.forceUpdate = true;
      attachDoc2(this, doc);
      if (options2.autofocus && !mobile2 || this.hasFocus()) {
        setTimeout(function() {
          if (this$1$1.hasFocus() && !this$1$1.state.focused) {
            onFocus2(this$1$1);
          }
        }, 20);
      } else {
        onBlur2(this);
      }
      for (var opt in optionHandlers2) {
        if (optionHandlers2.hasOwnProperty(opt)) {
          optionHandlers2[opt](this, options2[opt], Init2);
        }
      }
      maybeUpdateLineNumberWidth2(this);
      if (options2.finishInit) {
        options2.finishInit(this);
      }
      for (var i3 = 0; i3 < initHooks2.length; ++i3) {
        initHooks2[i3](this);
      }
      endOperation2(this);
      if (webkit2 && options2.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
        display.lineDiv.style.textRendering = "auto";
      }
    }
    CodeMirror2.defaults = defaults2;
    CodeMirror2.optionHandlers = optionHandlers2;
    function registerEventHandlers2(cm) {
      var d = cm.display;
      on2(d.scroller, "mousedown", operation2(cm, onMouseDown2));
      if (ie2 && ie_version2 < 11) {
        on2(d.scroller, "dblclick", operation2(cm, function(e) {
          if (signalDOMEvent2(cm, e)) {
            return;
          }
          var pos = posFromMouse2(cm, e);
          if (!pos || clickInGutter2(cm, e) || eventInWidget2(cm.display, e)) {
            return;
          }
          e_preventDefault2(e);
          var word = cm.findWordAt(pos);
          extendSelection2(cm.doc, word.anchor, word.head);
        }));
      } else {
        on2(d.scroller, "dblclick", function(e) {
          return signalDOMEvent2(cm, e) || e_preventDefault2(e);
        });
      }
      on2(d.scroller, "contextmenu", function(e) {
        return onContextMenu2(cm, e);
      });
      on2(d.input.getField(), "contextmenu", function(e) {
        if (!d.scroller.contains(e.target)) {
          onContextMenu2(cm, e);
        }
      });
      var touchFinished, prevTouch = { end: 0 };
      function finishTouch() {
        if (d.activeTouch) {
          touchFinished = setTimeout(function() {
            return d.activeTouch = null;
          }, 1e3);
          prevTouch = d.activeTouch;
          prevTouch.end = +new Date();
        }
      }
      function isMouseLikeTouchEvent(e) {
        if (e.touches.length != 1) {
          return false;
        }
        var touch = e.touches[0];
        return touch.radiusX <= 1 && touch.radiusY <= 1;
      }
      function farAway(touch, other) {
        if (other.left == null) {
          return true;
        }
        var dx = other.left - touch.left, dy = other.top - touch.top;
        return dx * dx + dy * dy > 20 * 20;
      }
      on2(d.scroller, "touchstart", function(e) {
        if (!signalDOMEvent2(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter2(cm, e)) {
          d.input.ensurePolled();
          clearTimeout(touchFinished);
          var now2 = +new Date();
          d.activeTouch = {
            start: now2,
            moved: false,
            prev: now2 - prevTouch.end <= 300 ? prevTouch : null
          };
          if (e.touches.length == 1) {
            d.activeTouch.left = e.touches[0].pageX;
            d.activeTouch.top = e.touches[0].pageY;
          }
        }
      });
      on2(d.scroller, "touchmove", function() {
        if (d.activeTouch) {
          d.activeTouch.moved = true;
        }
      });
      on2(d.scroller, "touchend", function(e) {
        var touch = d.activeTouch;
        if (touch && !eventInWidget2(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
          var pos = cm.coordsChar(d.activeTouch, "page"), range3;
          if (!touch.prev || farAway(touch, touch.prev)) {
            range3 = new Range2(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
            range3 = cm.findWordAt(pos);
          } else {
            range3 = new Range2(Pos2(pos.line, 0), clipPos2(cm.doc, Pos2(pos.line + 1, 0)));
          }
          cm.setSelection(range3.anchor, range3.head);
          cm.focus();
          e_preventDefault2(e);
        }
        finishTouch();
      });
      on2(d.scroller, "touchcancel", finishTouch);
      on2(d.scroller, "scroll", function() {
        if (d.scroller.clientHeight) {
          updateScrollTop2(cm, d.scroller.scrollTop);
          setScrollLeft2(cm, d.scroller.scrollLeft, true);
          signal2(cm, "scroll", cm);
        }
      });
      on2(d.scroller, "mousewheel", function(e) {
        return onScrollWheel2(cm, e);
      });
      on2(d.scroller, "DOMMouseScroll", function(e) {
        return onScrollWheel2(cm, e);
      });
      on2(d.wrapper, "scroll", function() {
        return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
      });
      d.dragFunctions = {
        enter: function(e) {
          if (!signalDOMEvent2(cm, e)) {
            e_stop2(e);
          }
        },
        over: function(e) {
          if (!signalDOMEvent2(cm, e)) {
            onDragOver2(cm, e);
            e_stop2(e);
          }
        },
        start: function(e) {
          return onDragStart2(cm, e);
        },
        drop: operation2(cm, onDrop2),
        leave: function(e) {
          if (!signalDOMEvent2(cm, e)) {
            clearDragCursor2(cm);
          }
        }
      };
      var inp = d.input.getField();
      on2(inp, "keyup", function(e) {
        return onKeyUp2.call(cm, e);
      });
      on2(inp, "keydown", operation2(cm, onKeyDown2));
      on2(inp, "keypress", operation2(cm, onKeyPress2));
      on2(inp, "focus", function(e) {
        return onFocus2(cm, e);
      });
      on2(inp, "blur", function(e) {
        return onBlur2(cm, e);
      });
    }
    var initHooks2 = [];
    CodeMirror2.defineInitHook = function(f) {
      return initHooks2.push(f);
    };
    function indentLine2(cm, n, how, aggressive) {
      var doc = cm.doc, state;
      if (how == null) {
        how = "add";
      }
      if (how == "smart") {
        if (!doc.mode.indent) {
          how = "prev";
        } else {
          state = getContextBefore2(cm, n).state;
        }
      }
      var tabSize = cm.options.tabSize;
      var line = getLine2(doc, n), curSpace = countColumn2(line.text, null, tabSize);
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      var curSpaceString = line.text.match(/^\s*/)[0], indentation;
      if (!aggressive && !/\S/.test(line.text)) {
        indentation = 0;
        how = "not";
      } else if (how == "smart") {
        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
        if (indentation == Pass2 || indentation > 150) {
          if (!aggressive) {
            return;
          }
          how = "prev";
        }
      }
      if (how == "prev") {
        if (n > doc.first) {
          indentation = countColumn2(getLine2(doc, n - 1).text, null, tabSize);
        } else {
          indentation = 0;
        }
      } else if (how == "add") {
        indentation = curSpace + cm.options.indentUnit;
      } else if (how == "subtract") {
        indentation = curSpace - cm.options.indentUnit;
      } else if (typeof how == "number") {
        indentation = curSpace + how;
      }
      indentation = Math.max(0, indentation);
      var indentString = "", pos = 0;
      if (cm.options.indentWithTabs) {
        for (var i3 = Math.floor(indentation / tabSize); i3; --i3) {
          pos += tabSize;
          indentString += "	";
        }
      }
      if (pos < indentation) {
        indentString += spaceStr2(indentation - pos);
      }
      if (indentString != curSpaceString) {
        replaceRange2(doc, indentString, Pos2(n, 0), Pos2(n, curSpaceString.length), "+input");
        line.stateAfter = null;
        return true;
      } else {
        for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {
          var range3 = doc.sel.ranges[i$12];
          if (range3.head.line == n && range3.head.ch < curSpaceString.length) {
            var pos$1 = Pos2(n, curSpaceString.length);
            replaceOneSelection2(doc, i$12, new Range2(pos$1, pos$1));
            break;
          }
        }
      }
    }
    var lastCopied2 = null;
    function setLastCopied2(newLastCopied) {
      lastCopied2 = newLastCopied;
    }
    function applyTextInput2(cm, inserted, deleted, sel, origin) {
      var doc = cm.doc;
      cm.display.shift = false;
      if (!sel) {
        sel = doc.sel;
      }
      var recent = +new Date() - 200;
      var paste = origin == "paste" || cm.state.pasteIncoming > recent;
      var textLines = splitLinesAuto2(inserted), multiPaste = null;
      if (paste && sel.ranges.length > 1) {
        if (lastCopied2 && lastCopied2.text.join("\n") == inserted) {
          if (sel.ranges.length % lastCopied2.text.length == 0) {
            multiPaste = [];
            for (var i3 = 0; i3 < lastCopied2.text.length; i3++) {
              multiPaste.push(doc.splitLines(lastCopied2.text[i3]));
            }
          }
        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
          multiPaste = map2(textLines, function(l) {
            return [l];
          });
        }
      }
      var updateInput = cm.curOp.updateInput;
      for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
        var range3 = sel.ranges[i$12];
        var from = range3.from(), to = range3.to();
        if (range3.empty()) {
          if (deleted && deleted > 0) {
            from = Pos2(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste) {
            to = Pos2(to.line, Math.min(getLine2(doc, to.line).text.length, to.ch + lst2(textLines).length));
          } else if (paste && lastCopied2 && lastCopied2.lineWise && lastCopied2.text.join("\n") == textLines.join("\n")) {
            from = to = Pos2(from.line, 0);
          }
        }
        var changeEvent = {
          from,
          to,
          text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
          origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
        };
        makeChange2(cm.doc, changeEvent);
        signalLater2(cm, "inputRead", cm, changeEvent);
      }
      if (inserted && !paste) {
        triggerElectric2(cm, inserted);
      }
      ensureCursorVisible2(cm);
      if (cm.curOp.updateInput < 2) {
        cm.curOp.updateInput = updateInput;
      }
      cm.curOp.typing = true;
      cm.state.pasteIncoming = cm.state.cutIncoming = -1;
    }
    function handlePaste2(e, cm) {
      var pasted = e.clipboardData && e.clipboardData.getData("Text");
      if (pasted) {
        e.preventDefault();
        if (!cm.isReadOnly() && !cm.options.disableInput) {
          runInOp2(cm, function() {
            return applyTextInput2(cm, pasted, 0, null, "paste");
          });
        }
        return true;
      }
    }
    function triggerElectric2(cm, inserted) {
      if (!cm.options.electricChars || !cm.options.smartIndent) {
        return;
      }
      var sel = cm.doc.sel;
      for (var i3 = sel.ranges.length - 1; i3 >= 0; i3--) {
        var range3 = sel.ranges[i3];
        if (range3.head.ch > 100 || i3 && sel.ranges[i3 - 1].head.line == range3.head.line) {
          continue;
        }
        var mode = cm.getModeAt(range3.head);
        var indented = false;
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++) {
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indented = indentLine2(cm, range3.head.line, "smart");
              break;
            }
          }
        } else if (mode.electricInput) {
          if (mode.electricInput.test(getLine2(cm.doc, range3.head.line).text.slice(0, range3.head.ch))) {
            indented = indentLine2(cm, range3.head.line, "smart");
          }
        }
        if (indented) {
          signalLater2(cm, "electricInput", cm, range3.head.line);
        }
      }
    }
    function copyableRanges2(cm) {
      var text = [], ranges = [];
      for (var i3 = 0; i3 < cm.doc.sel.ranges.length; i3++) {
        var line = cm.doc.sel.ranges[i3].head.line;
        var lineRange = { anchor: Pos2(line, 0), head: Pos2(line + 1, 0) };
        ranges.push(lineRange);
        text.push(cm.getRange(lineRange.anchor, lineRange.head));
      }
      return { text, ranges };
    }
    function disableBrowserMagic2(field, spellcheck, autocorrect, autocapitalize) {
      field.setAttribute("autocorrect", autocorrect ? "" : "off");
      field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
      field.setAttribute("spellcheck", !!spellcheck);
    }
    function hiddenTextarea2() {
      var te = elt2("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
      var div = elt2("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
      if (webkit2) {
        te.style.width = "1000px";
      } else {
        te.setAttribute("wrap", "off");
      }
      if (ios2) {
        te.style.border = "1px solid black";
      }
      disableBrowserMagic2(te);
      return div;
    }
    function addEditorMethods2(CodeMirror3) {
      var optionHandlers3 = CodeMirror3.optionHandlers;
      var helpers = CodeMirror3.helpers = {};
      CodeMirror3.prototype = {
        constructor: CodeMirror3,
        focus: function() {
          window.focus();
          this.display.input.focus();
        },
        setOption: function(option2, value2) {
          var options2 = this.options, old = options2[option2];
          if (options2[option2] == value2 && option2 != "mode") {
            return;
          }
          options2[option2] = value2;
          if (optionHandlers3.hasOwnProperty(option2)) {
            operation2(this, optionHandlers3[option2])(this, value2, old);
          }
          signal2(this, "optionChange", this, option2);
        },
        getOption: function(option2) {
          return this.options[option2];
        },
        getDoc: function() {
          return this.doc;
        },
        addKeyMap: function(map3, bottom2) {
          this.state.keyMaps[bottom2 ? "push" : "unshift"](getKeyMap2(map3));
        },
        removeKeyMap: function(map3) {
          var maps = this.state.keyMaps;
          for (var i3 = 0; i3 < maps.length; ++i3) {
            if (maps[i3] == map3 || maps[i3].name == map3) {
              maps.splice(i3, 1);
              return true;
            }
          }
        },
        addOverlay: methodOp2(function(spec, options2) {
          var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
          if (mode.startState) {
            throw new Error("Overlays may not be stateful.");
          }
          insertSorted2(this.state.overlays, {
            mode,
            modeSpec: spec,
            opaque: options2 && options2.opaque,
            priority: options2 && options2.priority || 0
          }, function(overlay) {
            return overlay.priority;
          });
          this.state.modeGen++;
          regChange2(this);
        }),
        removeOverlay: methodOp2(function(spec) {
          var overlays = this.state.overlays;
          for (var i3 = 0; i3 < overlays.length; ++i3) {
            var cur = overlays[i3].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i3, 1);
              this.state.modeGen++;
              regChange2(this);
              return;
            }
          }
        }),
        indentLine: methodOp2(function(n, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null) {
              dir = this.options.smartIndent ? "smart" : "prev";
            } else {
              dir = dir ? "add" : "subtract";
            }
          }
          if (isLine2(this.doc, n)) {
            indentLine2(this, n, dir, aggressive);
          }
        }),
        indentSelection: methodOp2(function(how) {
          var ranges = this.doc.sel.ranges, end2 = -1;
          for (var i3 = 0; i3 < ranges.length; i3++) {
            var range3 = ranges[i3];
            if (!range3.empty()) {
              var from = range3.from(), to = range3.to();
              var start2 = Math.max(end2, from.line);
              end2 = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
              for (var j = start2; j < end2; ++j) {
                indentLine2(this, j, how);
              }
              var newRanges = this.doc.sel.ranges;
              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i3].from().ch > 0) {
                replaceOneSelection2(this.doc, i3, new Range2(from, newRanges[i3].to()), sel_dontScroll2);
              }
            } else if (range3.head.line > end2) {
              indentLine2(this, range3.head.line, how, true);
              end2 = range3.head.line;
              if (i3 == this.doc.sel.primIndex) {
                ensureCursorVisible2(this);
              }
            }
          }
        }),
        getTokenAt: function(pos, precise) {
          return takeToken2(this, pos, precise);
        },
        getLineTokens: function(line, precise) {
          return takeToken2(this, Pos2(line), precise, true);
        },
        getTokenTypeAt: function(pos) {
          pos = clipPos2(this.doc, pos);
          var styles = getLineStyles2(this, getLine2(this.doc, pos.line));
          var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
          var type2;
          if (ch == 0) {
            type2 = styles[2];
          } else {
            for (; ; ) {
              var mid = before + after >> 1;
              if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                after = mid;
              } else if (styles[mid * 2 + 1] < ch) {
                before = mid + 1;
              } else {
                type2 = styles[mid * 2 + 2];
                break;
              }
            }
          }
          var cut = type2 ? type2.indexOf("overlay ") : -1;
          return cut < 0 ? type2 : cut == 0 ? null : type2.slice(0, cut - 1);
        },
        getModeAt: function(pos) {
          var mode = this.doc.mode;
          if (!mode.innerMode) {
            return mode;
          }
          return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
        },
        getHelper: function(pos, type2) {
          return this.getHelpers(pos, type2)[0];
        },
        getHelpers: function(pos, type2) {
          var found = [];
          if (!helpers.hasOwnProperty(type2)) {
            return found;
          }
          var help = helpers[type2], mode = this.getModeAt(pos);
          if (typeof mode[type2] == "string") {
            if (help[mode[type2]]) {
              found.push(help[mode[type2]]);
            }
          } else if (mode[type2]) {
            for (var i3 = 0; i3 < mode[type2].length; i3++) {
              var val = help[mode[type2][i3]];
              if (val) {
                found.push(val);
              }
            }
          } else if (mode.helperType && help[mode.helperType]) {
            found.push(help[mode.helperType]);
          } else if (help[mode.name]) {
            found.push(help[mode.name]);
          }
          for (var i$12 = 0; i$12 < help._global.length; i$12++) {
            var cur = help._global[i$12];
            if (cur.pred(mode, this) && indexOf2(found, cur.val) == -1) {
              found.push(cur.val);
            }
          }
          return found;
        },
        getStateAfter: function(line, precise) {
          var doc = this.doc;
          line = clipLine2(doc, line == null ? doc.first + doc.size - 1 : line);
          return getContextBefore2(this, line + 1, precise).state;
        },
        cursorCoords: function(start2, mode) {
          var pos, range3 = this.doc.sel.primary();
          if (start2 == null) {
            pos = range3.head;
          } else if (typeof start2 == "object") {
            pos = clipPos2(this.doc, start2);
          } else {
            pos = start2 ? range3.from() : range3.to();
          }
          return cursorCoords2(this, pos, mode || "page");
        },
        charCoords: function(pos, mode) {
          return charCoords2(this, clipPos2(this.doc, pos), mode || "page");
        },
        coordsChar: function(coords, mode) {
          coords = fromCoordSystem2(this, coords, mode || "page");
          return coordsChar2(this, coords.left, coords.top);
        },
        lineAtHeight: function(height, mode) {
          height = fromCoordSystem2(this, { top: height, left: 0 }, mode || "page").top;
          return lineAtHeight2(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function(line, mode, includeWidgets) {
          var end2 = false, lineObj;
          if (typeof line == "number") {
            var last = this.doc.first + this.doc.size - 1;
            if (line < this.doc.first) {
              line = this.doc.first;
            } else if (line > last) {
              line = last;
              end2 = true;
            }
            lineObj = getLine2(this.doc, line);
          } else {
            lineObj = line;
          }
          return intoCoordSystem2(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end2).top + (end2 ? this.doc.height - heightAtLine2(lineObj) : 0);
        },
        defaultTextHeight: function() {
          return textHeight2(this.display);
        },
        defaultCharWidth: function() {
          return charWidth2(this.display);
        },
        getViewport: function() {
          return { from: this.display.viewFrom, to: this.display.viewTo };
        },
        addWidget: function(pos, node, scroll, vert, horiz) {
          var display = this.display;
          pos = cursorCoords2(this, clipPos2(this.doc, pos));
          var top2 = pos.bottom, left2 = pos.left;
          node.style.position = "absolute";
          node.setAttribute("cm-ignore-events", "true");
          this.display.input.setUneditable(node);
          display.sizer.appendChild(node);
          if (vert == "over") {
            top2 = pos.top;
          } else if (vert == "above" || vert == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
              top2 = pos.top - node.offsetHeight;
            } else if (pos.bottom + node.offsetHeight <= vspace) {
              top2 = pos.bottom;
            }
            if (left2 + node.offsetWidth > hspace) {
              left2 = hspace - node.offsetWidth;
            }
          }
          node.style.top = top2 + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left2 = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left") {
              left2 = 0;
            } else if (horiz == "middle") {
              left2 = (display.sizer.clientWidth - node.offsetWidth) / 2;
            }
            node.style.left = left2 + "px";
          }
          if (scroll) {
            scrollIntoView2(this, { left: left2, top: top2, right: left2 + node.offsetWidth, bottom: top2 + node.offsetHeight });
          }
        },
        triggerOnKeyDown: methodOp2(onKeyDown2),
        triggerOnKeyPress: methodOp2(onKeyPress2),
        triggerOnKeyUp: onKeyUp2,
        triggerOnMouseDown: methodOp2(onMouseDown2),
        execCommand: function(cmd) {
          if (commands2.hasOwnProperty(cmd)) {
            return commands2[cmd].call(null, this);
          }
        },
        triggerElectric: methodOp2(function(text) {
          triggerElectric2(this, text);
        }),
        findPosH: function(from, amount, unit, visually) {
          var dir = 1;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos2(this.doc, from);
          for (var i3 = 0; i3 < amount; ++i3) {
            cur = findPosH2(this.doc, cur, dir, unit, visually);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveH: methodOp2(function(dir, unit) {
          var this$1$1 = this;
          this.extendSelectionsBy(function(range3) {
            if (this$1$1.display.shift || this$1$1.doc.extend || range3.empty()) {
              return findPosH2(this$1$1.doc, range3.head, dir, unit, this$1$1.options.rtlMoveVisually);
            } else {
              return dir < 0 ? range3.from() : range3.to();
            }
          }, sel_move2);
        }),
        deleteH: methodOp2(function(dir, unit) {
          var sel = this.doc.sel, doc = this.doc;
          if (sel.somethingSelected()) {
            doc.replaceSelection("", null, "+delete");
          } else {
            deleteNearSelection2(this, function(range3) {
              var other = findPosH2(doc, range3.head, dir, unit, false);
              return dir < 0 ? { from: other, to: range3.head } : { from: range3.head, to: other };
            });
          }
        }),
        findPosV: function(from, amount, unit, goalColumn) {
          var dir = 1, x = goalColumn;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos2(this.doc, from);
          for (var i3 = 0; i3 < amount; ++i3) {
            var coords = cursorCoords2(this, cur, "div");
            if (x == null) {
              x = coords.left;
            } else {
              coords.left = x;
            }
            cur = findPosV2(this, coords, dir, unit);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveV: methodOp2(function(dir, unit) {
          var this$1$1 = this;
          var doc = this.doc, goals = [];
          var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
          doc.extendSelectionsBy(function(range3) {
            if (collapse) {
              return dir < 0 ? range3.from() : range3.to();
            }
            var headPos = cursorCoords2(this$1$1, range3.head, "div");
            if (range3.goalColumn != null) {
              headPos.left = range3.goalColumn;
            }
            goals.push(headPos.left);
            var pos = findPosV2(this$1$1, headPos, dir, unit);
            if (unit == "page" && range3 == doc.sel.primary()) {
              addToScrollTop2(this$1$1, charCoords2(this$1$1, pos, "div").top - headPos.top);
            }
            return pos;
          }, sel_move2);
          if (goals.length) {
            for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
              doc.sel.ranges[i3].goalColumn = goals[i3];
            }
          }
        }),
        findWordAt: function(pos) {
          var doc = this.doc, line = getLine2(doc, pos.line).text;
          var start2 = pos.ch, end2 = pos.ch;
          if (line) {
            var helper = this.getHelper(pos, "wordChars");
            if ((pos.sticky == "before" || end2 == line.length) && start2) {
              --start2;
            } else {
              ++end2;
            }
            var startChar = line.charAt(start2);
            var check = isWordChar2(startChar, helper) ? function(ch) {
              return isWordChar2(ch, helper);
            } : /\s/.test(startChar) ? function(ch) {
              return /\s/.test(ch);
            } : function(ch) {
              return !/\s/.test(ch) && !isWordChar2(ch);
            };
            while (start2 > 0 && check(line.charAt(start2 - 1))) {
              --start2;
            }
            while (end2 < line.length && check(line.charAt(end2))) {
              ++end2;
            }
          }
          return new Range2(Pos2(pos.line, start2), Pos2(pos.line, end2));
        },
        toggleOverwrite: function(value2) {
          if (value2 != null && value2 == this.state.overwrite) {
            return;
          }
          if (this.state.overwrite = !this.state.overwrite) {
            addClass2(this.display.cursorDiv, "CodeMirror-overwrite");
          } else {
            rmClass2(this.display.cursorDiv, "CodeMirror-overwrite");
          }
          signal2(this, "overwriteToggle", this, this.state.overwrite);
        },
        hasFocus: function() {
          return this.display.input.getField() == activeElt2();
        },
        isReadOnly: function() {
          return !!(this.options.readOnly || this.doc.cantEdit);
        },
        scrollTo: methodOp2(function(x, y) {
          scrollToCoords2(this, x, y);
        }),
        getScrollInfo: function() {
          var scroller = this.display.scroller;
          return {
            left: scroller.scrollLeft,
            top: scroller.scrollTop,
            height: scroller.scrollHeight - scrollGap2(this) - this.display.barHeight,
            width: scroller.scrollWidth - scrollGap2(this) - this.display.barWidth,
            clientHeight: displayHeight2(this),
            clientWidth: displayWidth2(this)
          };
        },
        scrollIntoView: methodOp2(function(range3, margin) {
          if (range3 == null) {
            range3 = { from: this.doc.sel.primary().head, to: null };
            if (margin == null) {
              margin = this.options.cursorScrollMargin;
            }
          } else if (typeof range3 == "number") {
            range3 = { from: Pos2(range3, 0), to: null };
          } else if (range3.from == null) {
            range3 = { from: range3, to: null };
          }
          if (!range3.to) {
            range3.to = range3.from;
          }
          range3.margin = margin || 0;
          if (range3.from.line != null) {
            scrollToRange2(this, range3);
          } else {
            scrollToCoordsRange2(this, range3.from, range3.to, range3.margin);
          }
        }),
        setSize: methodOp2(function(width2, height) {
          var this$1$1 = this;
          var interpret = function(val) {
            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
          };
          if (width2 != null) {
            this.display.wrapper.style.width = interpret(width2);
          }
          if (height != null) {
            this.display.wrapper.style.height = interpret(height);
          }
          if (this.options.lineWrapping) {
            clearLineMeasurementCache2(this);
          }
          var lineNo3 = this.display.viewFrom;
          this.doc.iter(lineNo3, this.display.viewTo, function(line) {
            if (line.widgets) {
              for (var i3 = 0; i3 < line.widgets.length; i3++) {
                if (line.widgets[i3].noHScroll) {
                  regLineChange2(this$1$1, lineNo3, "widget");
                  break;
                }
              }
            }
            ++lineNo3;
          });
          this.curOp.forceUpdate = true;
          signal2(this, "refresh", this);
        }),
        operation: function(f) {
          return runInOp2(this, f);
        },
        startOperation: function() {
          return startOperation2(this);
        },
        endOperation: function() {
          return endOperation2(this);
        },
        refresh: methodOp2(function() {
          var oldHeight = this.display.cachedTextHeight;
          regChange2(this);
          this.curOp.forceUpdate = true;
          clearCaches2(this);
          scrollToCoords2(this, this.doc.scrollLeft, this.doc.scrollTop);
          updateGutterSpace2(this.display);
          if (oldHeight == null || Math.abs(oldHeight - textHeight2(this.display)) > 0.5 || this.options.lineWrapping) {
            estimateLineHeights2(this);
          }
          signal2(this, "refresh", this);
        }),
        swapDoc: methodOp2(function(doc) {
          var old = this.doc;
          old.cm = null;
          if (this.state.selectingText) {
            this.state.selectingText();
          }
          attachDoc2(this, doc);
          clearCaches2(this);
          this.display.input.reset();
          scrollToCoords2(this, doc.scrollLeft, doc.scrollTop);
          this.curOp.forceScroll = true;
          signalLater2(this, "swapDoc", this, old);
          return old;
        }),
        phrase: function(phraseText) {
          var phrases = this.options.phrases;
          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
        },
        getInputField: function() {
          return this.display.input.getField();
        },
        getWrapperElement: function() {
          return this.display.wrapper;
        },
        getScrollerElement: function() {
          return this.display.scroller;
        },
        getGutterElement: function() {
          return this.display.gutters;
        }
      };
      eventMixin2(CodeMirror3);
      CodeMirror3.registerHelper = function(type2, name2, value2) {
        if (!helpers.hasOwnProperty(type2)) {
          helpers[type2] = CodeMirror3[type2] = { _global: [] };
        }
        helpers[type2][name2] = value2;
      };
      CodeMirror3.registerGlobalHelper = function(type2, name2, predicate, value2) {
        CodeMirror3.registerHelper(type2, name2, value2);
        helpers[type2]._global.push({ pred: predicate, val: value2 });
      };
    }
    function findPosH2(doc, pos, dir, unit, visually) {
      var oldPos = pos;
      var origDir = dir;
      var lineObj = getLine2(doc, pos.line);
      var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
      function findNextLine() {
        var l = pos.line + lineDir;
        if (l < doc.first || l >= doc.first + doc.size) {
          return false;
        }
        pos = new Pos2(l, pos.ch, pos.sticky);
        return lineObj = getLine2(doc, l);
      }
      function moveOnce(boundToLine) {
        var next;
        if (unit == "codepoint") {
          var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
          if (isNaN(ch)) {
            next = null;
          } else {
            var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
            next = new Pos2(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
          }
        } else if (visually) {
          next = moveVisually2(doc.cm, lineObj, pos, dir);
        } else {
          next = moveLogically2(lineObj, pos, dir);
        }
        if (next == null) {
          if (!boundToLine && findNextLine()) {
            pos = endOfLine2(visually, doc.cm, lineObj, pos.line, lineDir);
          } else {
            return false;
          }
        } else {
          pos = next;
        }
        return true;
      }
      if (unit == "char" || unit == "codepoint") {
        moveOnce();
      } else if (unit == "column") {
        moveOnce(true);
      } else if (unit == "word" || unit == "group") {
        var sawType = null, group = unit == "group";
        var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
        for (var first = true; ; first = false) {
          if (dir < 0 && !moveOnce(!first)) {
            break;
          }
          var cur = lineObj.text.charAt(pos.ch) || "\n";
          var type2 = isWordChar2(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
          if (group && !first && !type2) {
            type2 = "s";
          }
          if (sawType && sawType != type2) {
            if (dir < 0) {
              dir = 1;
              moveOnce();
              pos.sticky = "after";
            }
            break;
          }
          if (type2) {
            sawType = type2;
          }
          if (dir > 0 && !moveOnce(!first)) {
            break;
          }
        }
      }
      var result = skipAtomic2(doc, pos, oldPos, origDir, true);
      if (equalCursorPos2(oldPos, result)) {
        result.hitSide = true;
      }
      return result;
    }
    function findPosV2(cm, pos, dir, unit) {
      var doc = cm.doc, x = pos.left, y;
      if (unit == "page") {
        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
        var moveAmount = Math.max(pageSize - 0.5 * textHeight2(cm.display), 3);
        y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
      } else if (unit == "line") {
        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
      }
      var target;
      for (; ; ) {
        target = coordsChar2(cm, x, y);
        if (!target.outside) {
          break;
        }
        if (dir < 0 ? y <= 0 : y >= doc.height) {
          target.hitSide = true;
          break;
        }
        y += dir * 5;
      }
      return target;
    }
    var ContentEditableInput2 = function(cm) {
      this.cm = cm;
      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
      this.polling = new Delayed2();
      this.composing = null;
      this.gracePeriod = false;
      this.readDOMTimeout = null;
    };
    ContentEditableInput2.prototype.init = function(display) {
      var this$1$1 = this;
      var input2 = this, cm = input2.cm;
      var div = input2.div = display.lineDiv;
      div.contentEditable = true;
      disableBrowserMagic2(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
      function belongsToInput(e) {
        for (var t = e.target; t; t = t.parentNode) {
          if (t == div) {
            return true;
          }
          if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) {
            break;
          }
        }
        return false;
      }
      on2(div, "paste", function(e) {
        if (!belongsToInput(e) || signalDOMEvent2(cm, e) || handlePaste2(e, cm)) {
          return;
        }
        if (ie_version2 <= 11) {
          setTimeout(operation2(cm, function() {
            return this$1$1.updateFromDOM();
          }), 20);
        }
      });
      on2(div, "compositionstart", function(e) {
        this$1$1.composing = { data: e.data, done: false };
      });
      on2(div, "compositionupdate", function(e) {
        if (!this$1$1.composing) {
          this$1$1.composing = { data: e.data, done: false };
        }
      });
      on2(div, "compositionend", function(e) {
        if (this$1$1.composing) {
          if (e.data != this$1$1.composing.data) {
            this$1$1.readFromDOMSoon();
          }
          this$1$1.composing.done = true;
        }
      });
      on2(div, "touchstart", function() {
        return input2.forceCompositionEnd();
      });
      on2(div, "input", function() {
        if (!this$1$1.composing) {
          this$1$1.readFromDOMSoon();
        }
      });
      function onCopyCut(e) {
        if (!belongsToInput(e) || signalDOMEvent2(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied2({ lineWise: false, text: cm.getSelections() });
          if (e.type == "cut") {
            cm.replaceSelection("", null, "cut");
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges2(cm);
          setLastCopied2({ lineWise: true, text: ranges.text });
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll2);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        if (e.clipboardData) {
          e.clipboardData.clearData();
          var content = lastCopied2.text.join("\n");
          e.clipboardData.setData("Text", content);
          if (e.clipboardData.getData("Text") == content) {
            e.preventDefault();
            return;
          }
        }
        var kludge = hiddenTextarea2(), te = kludge.firstChild;
        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
        te.value = lastCopied2.text.join("\n");
        var hadFocus = activeElt2();
        selectInput2(te);
        setTimeout(function() {
          cm.display.lineSpace.removeChild(kludge);
          hadFocus.focus();
          if (hadFocus == div) {
            input2.showPrimarySelection();
          }
        }, 50);
      }
      on2(div, "copy", onCopyCut);
      on2(div, "cut", onCopyCut);
    };
    ContentEditableInput2.prototype.screenReaderLabelChanged = function(label) {
      if (label) {
        this.div.setAttribute("aria-label", label);
      } else {
        this.div.removeAttribute("aria-label");
      }
    };
    ContentEditableInput2.prototype.prepareSelection = function() {
      var result = prepareSelection2(this.cm, false);
      result.focus = activeElt2() == this.div;
      return result;
    };
    ContentEditableInput2.prototype.showSelection = function(info, takeFocus) {
      if (!info || !this.cm.display.view.length) {
        return;
      }
      if (info.focus || takeFocus) {
        this.showPrimarySelection();
      }
      this.showMultipleSelections(info);
    };
    ContentEditableInput2.prototype.getSelection = function() {
      return this.cm.display.wrapper.ownerDocument.getSelection();
    };
    ContentEditableInput2.prototype.showPrimarySelection = function() {
      var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
      var from = prim.from(), to = prim.to();
      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
        sel.removeAllRanges();
        return;
      }
      var curAnchor = domToPos2(cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos2(cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp2(minPos2(curAnchor, curFocus), from) == 0 && cmp2(maxPos2(curAnchor, curFocus), to) == 0) {
        return;
      }
      var view = cm.display.view;
      var start2 = from.line >= cm.display.viewFrom && posToDOM2(cm, from) || { node: view[0].measure.map[2], offset: 0 };
      var end2 = to.line < cm.display.viewTo && posToDOM2(cm, to);
      if (!end2) {
        var measure = view[view.length - 1].measure;
        var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end2 = { node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3] };
      }
      if (!start2 || !end2) {
        sel.removeAllRanges();
        return;
      }
      var old = sel.rangeCount && sel.getRangeAt(0), rng2;
      try {
        rng2 = range2(start2.node, start2.offset, end2.offset, end2.node);
      } catch (e) {
      }
      if (rng2) {
        if (!gecko2 && cm.state.focused) {
          sel.collapse(start2.node, start2.offset);
          if (!rng2.collapsed) {
            sel.removeAllRanges();
            sel.addRange(rng2);
          }
        } else {
          sel.removeAllRanges();
          sel.addRange(rng2);
        }
        if (old && sel.anchorNode == null) {
          sel.addRange(old);
        } else if (gecko2) {
          this.startGracePeriod();
        }
      }
      this.rememberSelection();
    };
    ContentEditableInput2.prototype.startGracePeriod = function() {
      var this$1$1 = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        this$1$1.gracePeriod = false;
        if (this$1$1.selectionChanged()) {
          this$1$1.cm.operation(function() {
            return this$1$1.cm.curOp.selectionChanged = true;
          });
        }
      }, 20);
    };
    ContentEditableInput2.prototype.showMultipleSelections = function(info) {
      removeChildrenAndAdd2(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd2(this.cm.display.selectionDiv, info.selection);
    };
    ContentEditableInput2.prototype.rememberSelection = function() {
      var sel = this.getSelection();
      this.lastAnchorNode = sel.anchorNode;
      this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode;
      this.lastFocusOffset = sel.focusOffset;
    };
    ContentEditableInput2.prototype.selectionInEditor = function() {
      var sel = this.getSelection();
      if (!sel.rangeCount) {
        return false;
      }
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains2(this.div, node);
    };
    ContentEditableInput2.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor") {
        if (!this.selectionInEditor() || activeElt2() != this.div) {
          this.showSelection(this.prepareSelection(), true);
        }
        this.div.focus();
      }
    };
    ContentEditableInput2.prototype.blur = function() {
      this.div.blur();
    };
    ContentEditableInput2.prototype.getField = function() {
      return this.div;
    };
    ContentEditableInput2.prototype.supportsTouch = function() {
      return true;
    };
    ContentEditableInput2.prototype.receivedFocus = function() {
      var this$1$1 = this;
      var input2 = this;
      if (this.selectionInEditor()) {
        setTimeout(function() {
          return this$1$1.pollSelection();
        }, 20);
      } else {
        runInOp2(this.cm, function() {
          return input2.cm.curOp.selectionChanged = true;
        });
      }
      function poll() {
        if (input2.cm.state.focused) {
          input2.pollSelection();
          input2.polling.set(input2.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    };
    ContentEditableInput2.prototype.selectionChanged = function() {
      var sel = this.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    };
    ContentEditableInput2.prototype.pollSelection = function() {
      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
        return;
      }
      var sel = this.getSelection(), cm = this.cm;
      if (android2 && chrome2 && this.cm.display.gutterSpecs.length && isInGutter2(sel.anchorNode)) {
        this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
        this.blur();
        this.focus();
        return;
      }
      if (this.composing) {
        return;
      }
      this.rememberSelection();
      var anchor = domToPos2(cm, sel.anchorNode, sel.anchorOffset);
      var head = domToPos2(cm, sel.focusNode, sel.focusOffset);
      if (anchor && head) {
        runInOp2(cm, function() {
          setSelection2(cm.doc, simpleSelection2(anchor, head), sel_dontScroll2);
          if (anchor.bad || head.bad) {
            cm.curOp.selectionChanged = true;
          }
        });
      }
    };
    ContentEditableInput2.prototype.pollContent = function() {
      if (this.readDOMTimeout != null) {
        clearTimeout(this.readDOMTimeout);
        this.readDOMTimeout = null;
      }
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.ch == 0 && from.line > cm.firstLine()) {
        from = Pos2(from.line - 1, getLine2(cm.doc, from.line - 1).length);
      }
      if (to.ch == getLine2(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
        to = Pos2(to.line + 1, 0);
      }
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
        return false;
      }
      var fromIndex, fromLine, fromNode;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex2(cm, from.line)) == 0) {
        fromLine = lineNo2(display.view[0].line);
        fromNode = display.view[0].node;
      } else {
        fromLine = lineNo2(display.view[fromIndex].line);
        fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex2(cm, to.line);
      var toLine, toNode;
      if (toIndex == display.view.length - 1) {
        toLine = display.viewTo - 1;
        toNode = display.lineDiv.lastChild;
      } else {
        toLine = lineNo2(display.view[toIndex + 1].line) - 1;
        toNode = display.view[toIndex + 1].node.previousSibling;
      }
      if (!fromNode) {
        return false;
      }
      var newText = cm.doc.splitLines(domTextBetween2(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween2(cm.doc, Pos2(fromLine, 0), Pos2(toLine, getLine2(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst2(newText) == lst2(oldText)) {
          newText.pop();
          oldText.pop();
          toLine--;
        } else if (newText[0] == oldText[0]) {
          newText.shift();
          oldText.shift();
          fromLine++;
        } else {
          break;
        }
      }
      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
        ++cutFront;
      }
      var newBot = lst2(newText), oldBot = lst2(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        ++cutEnd;
      }
      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          cutFront--;
          cutEnd++;
        }
      }
      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
      var chFrom = Pos2(fromLine, cutFront);
      var chTo = Pos2(toLine, oldText.length ? lst2(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp2(chFrom, chTo)) {
        replaceRange2(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    };
    ContentEditableInput2.prototype.ensurePolled = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput2.prototype.reset = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput2.prototype.forceCompositionEnd = function() {
      if (!this.composing) {
        return;
      }
      clearTimeout(this.readDOMTimeout);
      this.composing = null;
      this.updateFromDOM();
      this.div.blur();
      this.div.focus();
    };
    ContentEditableInput2.prototype.readFromDOMSoon = function() {
      var this$1$1 = this;
      if (this.readDOMTimeout != null) {
        return;
      }
      this.readDOMTimeout = setTimeout(function() {
        this$1$1.readDOMTimeout = null;
        if (this$1$1.composing) {
          if (this$1$1.composing.done) {
            this$1$1.composing = null;
          } else {
            return;
          }
        }
        this$1$1.updateFromDOM();
      }, 80);
    };
    ContentEditableInput2.prototype.updateFromDOM = function() {
      var this$1$1 = this;
      if (this.cm.isReadOnly() || !this.pollContent()) {
        runInOp2(this.cm, function() {
          return regChange2(this$1$1.cm);
        });
      }
    };
    ContentEditableInput2.prototype.setUneditable = function(node) {
      node.contentEditable = "false";
    };
    ContentEditableInput2.prototype.onKeyPress = function(e) {
      if (e.charCode == 0 || this.composing) {
        return;
      }
      e.preventDefault();
      if (!this.cm.isReadOnly()) {
        operation2(this.cm, applyTextInput2)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
      }
    };
    ContentEditableInput2.prototype.readOnlyChanged = function(val) {
      this.div.contentEditable = String(val != "nocursor");
    };
    ContentEditableInput2.prototype.onContextMenu = function() {
    };
    ContentEditableInput2.prototype.resetPosition = function() {
    };
    ContentEditableInput2.prototype.needsContentAttribute = true;
    function posToDOM2(cm, pos) {
      var view = findViewForLine2(cm, pos.line);
      if (!view || view.hidden) {
        return null;
      }
      var line = getLine2(cm.doc, pos.line);
      var info = mapFromLineView2(view, line, pos.line);
      var order2 = getOrder2(line, cm.doc.direction), side = "left";
      if (order2) {
        var partPos = getBidiPartAt2(order2, pos.ch);
        side = partPos % 2 ? "right" : "left";
      }
      var result = nodeAndOffsetInLineMap2(info.map, pos.ch, side);
      result.offset = result.collapse == "right" ? result.end : result.start;
      return result;
    }
    function isInGutter2(node) {
      for (var scan = node; scan; scan = scan.parentNode) {
        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
          return true;
        }
      }
      return false;
    }
    function badPos2(pos, bad) {
      if (bad) {
        pos.bad = true;
      }
      return pos;
    }
    function domTextBetween2(cm, from, to, fromLine, toLine) {
      var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
      function recognizeMarker(id2) {
        return function(marker) {
          return marker.id == id2;
        };
      }
      function close2() {
        if (closing) {
          text += lineSep;
          if (extraLinebreak) {
            text += lineSep;
          }
          closing = extraLinebreak = false;
        }
      }
      function addText(str) {
        if (str) {
          close2();
          text += str;
        }
      }
      function walk(node) {
        if (node.nodeType == 1) {
          var cmText = node.getAttribute("cm-text");
          if (cmText) {
            addText(cmText);
            return;
          }
          var markerID = node.getAttribute("cm-marker"), range3;
          if (markerID) {
            var found = cm.findMarks(Pos2(fromLine, 0), Pos2(toLine + 1, 0), recognizeMarker(+markerID));
            if (found.length && (range3 = found[0].find(0))) {
              addText(getBetween2(cm.doc, range3.from, range3.to).join(lineSep));
            }
            return;
          }
          if (node.getAttribute("contenteditable") == "false") {
            return;
          }
          var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
            return;
          }
          if (isBlock) {
            close2();
          }
          for (var i3 = 0; i3 < node.childNodes.length; i3++) {
            walk(node.childNodes[i3]);
          }
          if (/^(pre|p)$/i.test(node.nodeName)) {
            extraLinebreak = true;
          }
          if (isBlock) {
            closing = true;
          }
        } else if (node.nodeType == 3) {
          addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
        }
      }
      for (; ; ) {
        walk(from);
        if (from == to) {
          break;
        }
        from = from.nextSibling;
        extraLinebreak = false;
      }
      return text;
    }
    function domToPos2(cm, node, offset2) {
      var lineNode;
      if (node == cm.display.lineDiv) {
        lineNode = cm.display.lineDiv.childNodes[offset2];
        if (!lineNode) {
          return badPos2(cm.clipPos(Pos2(cm.display.viewTo - 1)), true);
        }
        node = null;
        offset2 = 0;
      } else {
        for (lineNode = node; ; lineNode = lineNode.parentNode) {
          if (!lineNode || lineNode == cm.display.lineDiv) {
            return null;
          }
          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
            break;
          }
        }
      }
      for (var i3 = 0; i3 < cm.display.view.length; i3++) {
        var lineView = cm.display.view[i3];
        if (lineView.node == lineNode) {
          return locateNodeInLineView2(lineView, node, offset2);
        }
      }
    }
    function locateNodeInLineView2(lineView, node, offset2) {
      var wrapper = lineView.text.firstChild, bad = false;
      if (!node || !contains2(wrapper, node)) {
        return badPos2(Pos2(lineNo2(lineView.line), 0), true);
      }
      if (node == wrapper) {
        bad = true;
        node = wrapper.childNodes[offset2];
        offset2 = 0;
        if (!node) {
          var line = lineView.rest ? lst2(lineView.rest) : lineView.line;
          return badPos2(Pos2(lineNo2(line), line.text.length), bad);
        }
      }
      var textNode = node.nodeType == 3 ? node : null, topNode = node;
      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
        textNode = node.firstChild;
        if (offset2) {
          offset2 = textNode.nodeValue.length;
        }
      }
      while (topNode.parentNode != wrapper) {
        topNode = topNode.parentNode;
      }
      var measure = lineView.measure, maps = measure.maps;
      function find2(textNode2, topNode2, offset3) {
        for (var i3 = -1; i3 < (maps ? maps.length : 0); i3++) {
          var map3 = i3 < 0 ? measure.map : maps[i3];
          for (var j = 0; j < map3.length; j += 3) {
            var curNode = map3[j + 2];
            if (curNode == textNode2 || curNode == topNode2) {
              var line2 = lineNo2(i3 < 0 ? lineView.line : lineView.rest[i3]);
              var ch = map3[j] + offset3;
              if (offset3 < 0 || curNode != textNode2) {
                ch = map3[j + (offset3 ? 1 : 0)];
              }
              return Pos2(line2, ch);
            }
          }
        }
      }
      var found = find2(textNode, topNode, offset2);
      if (found) {
        return badPos2(found, bad);
      }
      for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset2 : 0; after; after = after.nextSibling) {
        found = find2(after, after.firstChild, 0);
        if (found) {
          return badPos2(Pos2(found.line, found.ch - dist), bad);
        } else {
          dist += after.textContent.length;
        }
      }
      for (var before = topNode.previousSibling, dist$1 = offset2; before; before = before.previousSibling) {
        found = find2(before, before.firstChild, -1);
        if (found) {
          return badPos2(Pos2(found.line, found.ch + dist$1), bad);
        } else {
          dist$1 += before.textContent.length;
        }
      }
    }
    var TextareaInput2 = function(cm) {
      this.cm = cm;
      this.prevInput = "";
      this.pollingFast = false;
      this.polling = new Delayed2();
      this.hasSelection = false;
      this.composing = null;
    };
    TextareaInput2.prototype.init = function(display) {
      var this$1$1 = this;
      var input2 = this, cm = this.cm;
      this.createField(display);
      var te = this.textarea;
      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
      if (ios2) {
        te.style.width = "0px";
      }
      on2(te, "input", function() {
        if (ie2 && ie_version2 >= 9 && this$1$1.hasSelection) {
          this$1$1.hasSelection = null;
        }
        input2.poll();
      });
      on2(te, "paste", function(e) {
        if (signalDOMEvent2(cm, e) || handlePaste2(e, cm)) {
          return;
        }
        cm.state.pasteIncoming = +new Date();
        input2.fastPoll();
      });
      function prepareCopyCut(e) {
        if (signalDOMEvent2(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied2({ lineWise: false, text: cm.getSelections() });
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges2(cm);
          setLastCopied2({ lineWise: true, text: ranges.text });
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll2);
          } else {
            input2.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput2(te);
          }
        }
        if (e.type == "cut") {
          cm.state.cutIncoming = +new Date();
        }
      }
      on2(te, "cut", prepareCopyCut);
      on2(te, "copy", prepareCopyCut);
      on2(display.scroller, "paste", function(e) {
        if (eventInWidget2(display, e) || signalDOMEvent2(cm, e)) {
          return;
        }
        if (!te.dispatchEvent) {
          cm.state.pasteIncoming = +new Date();
          input2.focus();
          return;
        }
        var event2 = new Event("paste");
        event2.clipboardData = e.clipboardData;
        te.dispatchEvent(event2);
      });
      on2(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget2(display, e)) {
          e_preventDefault2(e);
        }
      });
      on2(te, "compositionstart", function() {
        var start2 = cm.getCursor("from");
        if (input2.composing) {
          input2.composing.range.clear();
        }
        input2.composing = {
          start: start2,
          range: cm.markText(start2, cm.getCursor("to"), { className: "CodeMirror-composing" })
        };
      });
      on2(te, "compositionend", function() {
        if (input2.composing) {
          input2.poll();
          input2.composing.range.clear();
          input2.composing = null;
        }
      });
    };
    TextareaInput2.prototype.createField = function(_display) {
      this.wrapper = hiddenTextarea2();
      this.textarea = this.wrapper.firstChild;
    };
    TextareaInput2.prototype.screenReaderLabelChanged = function(label) {
      if (label) {
        this.textarea.setAttribute("aria-label", label);
      } else {
        this.textarea.removeAttribute("aria-label");
      }
    };
    TextareaInput2.prototype.prepareSelection = function() {
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection2(cm);
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords2(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
      }
      return result;
    };
    TextareaInput2.prototype.showSelection = function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd2(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd2(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    };
    TextareaInput2.prototype.reset = function(typing) {
      if (this.contextMenuPending || this.composing) {
        return;
      }
      var cm = this.cm;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var content = cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) {
          selectInput2(this.textarea);
        }
        if (ie2 && ie_version2 >= 9) {
          this.hasSelection = content;
        }
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie2 && ie_version2 >= 9) {
          this.hasSelection = null;
        }
      }
    };
    TextareaInput2.prototype.getField = function() {
      return this.textarea;
    };
    TextareaInput2.prototype.supportsTouch = function() {
      return false;
    };
    TextareaInput2.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile2 || activeElt2() != this.textarea)) {
        try {
          this.textarea.focus();
        } catch (e) {
        }
      }
    };
    TextareaInput2.prototype.blur = function() {
      this.textarea.blur();
    };
    TextareaInput2.prototype.resetPosition = function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    };
    TextareaInput2.prototype.receivedFocus = function() {
      this.slowPoll();
    };
    TextareaInput2.prototype.slowPoll = function() {
      var this$1$1 = this;
      if (this.pollingFast) {
        return;
      }
      this.polling.set(this.cm.options.pollInterval, function() {
        this$1$1.poll();
        if (this$1$1.cm.state.focused) {
          this$1$1.slowPoll();
        }
      });
    };
    TextareaInput2.prototype.fastPoll = function() {
      var missed = false, input2 = this;
      input2.pollingFast = true;
      function p() {
        var changed = input2.poll();
        if (!changed && !missed) {
          missed = true;
          input2.polling.set(60, p);
        } else {
          input2.pollingFast = false;
          input2.slowPoll();
        }
      }
      input2.polling.set(20, p);
    };
    TextareaInput2.prototype.poll = function() {
      var this$1$1 = this;
      var cm = this.cm, input2 = this.textarea, prevInput = this.prevInput;
      if (this.contextMenuPending || !cm.state.focused || hasSelection2(input2) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
        return false;
      }
      var text = input2.value;
      if (text == prevInput && !cm.somethingSelected()) {
        return false;
      }
      if (ie2 && ie_version2 >= 9 && this.hasSelection === text || mac2 && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }
      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text.charCodeAt(0);
        if (first == 8203 && !prevInput) {
          prevInput = "\u200B";
        }
        if (first == 8666) {
          this.reset();
          return this.cm.execCommand("undo");
        }
      }
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
        ++same;
      }
      runInOp2(cm, function() {
        applyTextInput2(cm, text.slice(same), prevInput.length - same, null, this$1$1.composing ? "*compose" : null);
        if (text.length > 1e3 || text.indexOf("\n") > -1) {
          input2.value = this$1$1.prevInput = "";
        } else {
          this$1$1.prevInput = text;
        }
        if (this$1$1.composing) {
          this$1$1.composing.range.clear();
          this$1$1.composing.range = cm.markText(this$1$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
        }
      });
      return true;
    };
    TextareaInput2.prototype.ensurePolled = function() {
      if (this.pollingFast && this.poll()) {
        this.pollingFast = false;
      }
    };
    TextareaInput2.prototype.onKeyPress = function() {
      if (ie2 && ie_version2 >= 9) {
        this.hasSelection = null;
      }
      this.fastPoll();
    };
    TextareaInput2.prototype.onContextMenu = function(e) {
      var input2 = this, cm = input2.cm, display = cm.display, te = input2.textarea;
      if (input2.contextMenuPending) {
        input2.contextMenuPending();
      }
      var pos = posFromMouse2(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto2) {
        return;
      }
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1) {
        operation2(cm, setSelection2)(cm.doc, simpleSelection2(pos), sel_dontScroll2);
      }
      var oldCSS = te.style.cssText, oldWrapperCSS = input2.wrapper.style.cssText;
      var wrapperBox = input2.wrapper.offsetParent.getBoundingClientRect();
      input2.wrapper.style.cssText = "position: static";
      te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie2 ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      var oldScrollY;
      if (webkit2) {
        oldScrollY = window.scrollY;
      }
      display.input.focus();
      if (webkit2) {
        window.scrollTo(null, oldScrollY);
      }
      display.input.reset();
      if (!cm.somethingSelected()) {
        te.value = input2.prevInput = " ";
      }
      input2.contextMenuPending = rehide;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200B" + (selected ? te.value : "");
          te.value = "\u21DA";
          te.value = extval;
          input2.prevInput = selected ? "" : "\u200B";
          te.selectionStart = 1;
          te.selectionEnd = extval.length;
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        if (input2.contextMenuPending != rehide) {
          return;
        }
        input2.contextMenuPending = false;
        input2.wrapper.style.cssText = oldWrapperCSS;
        te.style.cssText = oldCSS;
        if (ie2 && ie_version2 < 9) {
          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
        }
        if (te.selectionStart != null) {
          if (!ie2 || ie2 && ie_version2 < 9) {
            prepareSelectAllHack();
          }
          var i3 = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input2.prevInput == "\u200B") {
              operation2(cm, selectAll2)(cm);
            } else if (i3++ < 10) {
              display.detectingSelectAll = setTimeout(poll, 500);
            } else {
              display.selForContextMenu = null;
              display.input.reset();
            }
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }
      if (ie2 && ie_version2 >= 9) {
        prepareSelectAllHack();
      }
      if (captureRightClick2) {
        e_stop2(e);
        var mouseup = function() {
          off2(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on2(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    };
    TextareaInput2.prototype.readOnlyChanged = function(val) {
      if (!val) {
        this.reset();
      }
      this.textarea.disabled = val == "nocursor";
      this.textarea.readOnly = !!val;
    };
    TextareaInput2.prototype.setUneditable = function() {
    };
    TextareaInput2.prototype.needsContentAttribute = false;
    function fromTextArea2(textarea, options2) {
      options2 = options2 ? copyObj2(options2) : {};
      options2.value = textarea.value;
      if (!options2.tabindex && textarea.tabIndex) {
        options2.tabindex = textarea.tabIndex;
      }
      if (!options2.placeholder && textarea.placeholder) {
        options2.placeholder = textarea.placeholder;
      }
      if (options2.autofocus == null) {
        var hasFocus = activeElt2();
        options2.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
      }
      function save2() {
        textarea.value = cm.getValue();
      }
      var realSubmit;
      if (textarea.form) {
        on2(textarea.form, "submit", save2);
        if (!options2.leaveSubmitMethodAlone) {
          var form = textarea.form;
          realSubmit = form.submit;
          try {
            var wrappedSubmit = form.submit = function() {
              save2();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
          } catch (e) {
          }
        }
      }
      options2.finishInit = function(cm2) {
        cm2.save = save2;
        cm2.getTextArea = function() {
          return textarea;
        };
        cm2.toTextArea = function() {
          cm2.toTextArea = isNaN;
          save2();
          textarea.parentNode.removeChild(cm2.getWrapperElement());
          textarea.style.display = "";
          if (textarea.form) {
            off2(textarea.form, "submit", save2);
            if (!options2.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
              textarea.form.submit = realSubmit;
            }
          }
        };
      };
      textarea.style.display = "none";
      var cm = CodeMirror2(function(node) {
        return textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options2);
      return cm;
    }
    function addLegacyProps2(CodeMirror3) {
      CodeMirror3.off = off2;
      CodeMirror3.on = on2;
      CodeMirror3.wheelEventPixels = wheelEventPixels2;
      CodeMirror3.Doc = Doc2;
      CodeMirror3.splitLines = splitLinesAuto2;
      CodeMirror3.countColumn = countColumn2;
      CodeMirror3.findColumn = findColumn2;
      CodeMirror3.isWordChar = isWordCharBasic2;
      CodeMirror3.Pass = Pass2;
      CodeMirror3.signal = signal2;
      CodeMirror3.Line = Line2;
      CodeMirror3.changeEnd = changeEnd2;
      CodeMirror3.scrollbarModel = scrollbarModel2;
      CodeMirror3.Pos = Pos2;
      CodeMirror3.cmpPos = cmp2;
      CodeMirror3.modes = modes2;
      CodeMirror3.mimeModes = mimeModes2;
      CodeMirror3.resolveMode = resolveMode2;
      CodeMirror3.getMode = getMode2;
      CodeMirror3.modeExtensions = modeExtensions2;
      CodeMirror3.extendMode = extendMode2;
      CodeMirror3.copyState = copyState2;
      CodeMirror3.startState = startState2;
      CodeMirror3.innerMode = innerMode2;
      CodeMirror3.commands = commands2;
      CodeMirror3.keyMap = keyMap2;
      CodeMirror3.keyName = keyName2;
      CodeMirror3.isModifierKey = isModifierKey2;
      CodeMirror3.lookupKey = lookupKey2;
      CodeMirror3.normalizeKeyMap = normalizeKeyMap2;
      CodeMirror3.StringStream = StringStream2;
      CodeMirror3.SharedTextMarker = SharedTextMarker2;
      CodeMirror3.TextMarker = TextMarker2;
      CodeMirror3.LineWidget = LineWidget2;
      CodeMirror3.e_preventDefault = e_preventDefault2;
      CodeMirror3.e_stopPropagation = e_stopPropagation2;
      CodeMirror3.e_stop = e_stop2;
      CodeMirror3.addClass = addClass2;
      CodeMirror3.contains = contains2;
      CodeMirror3.rmClass = rmClass2;
      CodeMirror3.keyNames = keyNames2;
    }
    defineOptions2(CodeMirror2);
    addEditorMethods2(CodeMirror2);
    var dontDelegate2 = "iter insert remove copy getEditor constructor".split(" ");
    for (var prop in Doc2.prototype) {
      if (Doc2.prototype.hasOwnProperty(prop) && indexOf2(dontDelegate2, prop) < 0) {
        CodeMirror2.prototype[prop] = function(method3) {
          return function() {
            return method3.apply(this.doc, arguments);
          };
        }(Doc2.prototype[prop]);
      }
    }
    eventMixin2(Doc2);
    CodeMirror2.inputStyles = { "textarea": TextareaInput2, "contenteditable": ContentEditableInput2 };
    CodeMirror2.defineMode = function(name2) {
      if (!CodeMirror2.defaults.mode && name2 != "null") {
        CodeMirror2.defaults.mode = name2;
      }
      defineMode2.apply(this, arguments);
    };
    CodeMirror2.defineMIME = defineMIME2;
    CodeMirror2.defineMode("null", function() {
      return { token: function(stream) {
        return stream.skipToEnd();
      } };
    });
    CodeMirror2.defineMIME("text/plain", "null");
    CodeMirror2.defineExtension = function(name2, func) {
      CodeMirror2.prototype[name2] = func;
    };
    CodeMirror2.defineDocExtension = function(name2, func) {
      Doc2.prototype[name2] = func;
    };
    CodeMirror2.fromTextArea = fromTextArea2;
    addLegacyProps2(CodeMirror2);
    CodeMirror2.version = "5.63.1";
    return CodeMirror2;
  });
})(codemirror);
(function(module, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineOption("fullScreen", false, function(cm, val, old) {
      if (old == CodeMirror2.Init)
        old = false;
      if (!old == !val)
        return;
      if (val)
        setFullscreen(cm);
      else
        setNormal(cm);
    });
    function setFullscreen(cm) {
      var wrap = cm.getWrapperElement();
      cm.state.fullScreenRestore = {
        scrollTop: window.pageYOffset,
        scrollLeft: window.pageXOffset,
        width: wrap.style.width,
        height: wrap.style.height
      };
      wrap.style.width = "";
      wrap.style.height = "auto";
      wrap.className += " CodeMirror-fullscreen";
      document.documentElement.style.overflow = "hidden";
      cm.refresh();
    }
    function setNormal(cm) {
      var wrap = cm.getWrapperElement();
      wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, "");
      document.documentElement.style.overflow = "";
      var info = cm.state.fullScreenRestore;
      wrap.style.width = info.width;
      wrap.style.height = info.height;
      window.scrollTo(info.scrollLeft, info.scrollTop);
      cm.refresh();
    }
  });
})();
(function(mod) {
  mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineMode("javascript", function(config2, parserConfig) {
    var indentUnit = config2.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonldMode = parserConfig.jsonld;
    var jsonMode = parserConfig.json || jsonldMode;
    var trackScope = parserConfig.trackScope !== false;
    var isTS = parserConfig.typescript;
    var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
    var keywords2 = function() {
      function kw(type3) {
        return { type: type3, style: "keyword" };
      }
      var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
      var operator = kw("operator"), atom = { type: "atom", style: "atom" };
      return {
        "if": kw("if"),
        "while": A,
        "with": A,
        "else": B,
        "do": B,
        "try": B,
        "finally": B,
        "return": D,
        "break": D,
        "continue": D,
        "new": kw("new"),
        "delete": C,
        "void": C,
        "throw": C,
        "debugger": kw("debugger"),
        "var": kw("var"),
        "const": kw("var"),
        "let": kw("var"),
        "function": kw("function"),
        "catch": kw("catch"),
        "for": kw("for"),
        "switch": kw("switch"),
        "case": kw("case"),
        "default": kw("default"),
        "in": operator,
        "typeof": operator,
        "instanceof": operator,
        "true": atom,
        "false": atom,
        "null": atom,
        "undefined": atom,
        "NaN": atom,
        "Infinity": atom,
        "this": kw("this"),
        "class": kw("class"),
        "super": kw("atom"),
        "yield": C,
        "export": kw("export"),
        "import": kw("import"),
        "extends": C,
        "await": C
      };
    }();
    var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
    function readRegexp(stream) {
      var escaped = false, next, inSet = false;
      while ((next = stream.next()) != null) {
        if (!escaped) {
          if (next == "/" && !inSet)
            return;
          if (next == "[")
            inSet = true;
          else if (inSet && next == "]")
            inSet = false;
        }
        escaped = !escaped && next == "\\";
      }
    }
    var type2, content;
    function ret(tp, style, cont2) {
      type2 = tp;
      content = cont2;
      return style;
    }
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
        return ret("number", "number");
      } else if (ch == "." && stream.match("..")) {
        return ret("spread", "meta");
      } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        return ret(ch);
      } else if (ch == "=" && stream.eat(">")) {
        return ret("=>", "operator");
      } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
        return ret("number", "number");
      } else if (/\d/.test(ch)) {
        stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
        return ret("number", "number");
      } else if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        } else if (stream.eat("/")) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (expressionAllowed(stream, state, 1)) {
          readRegexp(stream);
          stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
          return ret("regexp", "string-2");
        } else {
          stream.eat("=");
          return ret("operator", "operator", stream.current());
        }
      } else if (ch == "`") {
        state.tokenize = tokenQuasi;
        return tokenQuasi(stream, state);
      } else if (ch == "#" && stream.peek() == "!") {
        stream.skipToEnd();
        return ret("meta", "meta");
      } else if (ch == "#" && stream.eatWhile(wordRE)) {
        return ret("variable", "property");
      } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (isOperatorChar.test(ch)) {
        if (ch != ">" || !state.lexical || state.lexical.type != ">") {
          if (stream.eat("=")) {
            if (ch == "!" || ch == "=")
              stream.eat("=");
          } else if (/[<>*+\-|&?]/.test(ch)) {
            stream.eat(ch);
            if (ch == ">")
              stream.eat(ch);
          }
        }
        if (ch == "?" && stream.eat("."))
          return ret(".");
        return ret("operator", "operator", stream.current());
      } else if (wordRE.test(ch)) {
        stream.eatWhile(wordRE);
        var word = stream.current();
        if (state.lastType != ".") {
          if (keywords2.propertyIsEnumerable(word)) {
            var kw = keywords2[word];
            return ret(kw.type, kw.style, word);
          }
          if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
            return ret("async", "keyword", word);
        }
        return ret("variable", "variable", word);
      }
    }
    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next;
        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
          state.tokenize = tokenBase;
          return ret("jsonld-keyword", "meta");
        }
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped)
            break;
          escaped = !escaped && next == "\\";
        }
        if (!escaped)
          state.tokenize = tokenBase;
        return ret("string", "string");
      };
    }
    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = ch == "*";
      }
      return ret("comment", "comment");
    }
    function tokenQuasi(stream, state) {
      var escaped = false, next;
      while ((next = stream.next()) != null) {
        if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && next == "\\";
      }
      return ret("quasi", "string-2", stream.current());
    }
    var brackets2 = "([{}])";
    function findFatArrow(stream, state) {
      if (state.fatArrowAt)
        state.fatArrowAt = null;
      var arrow2 = stream.string.indexOf("=>", stream.start);
      if (arrow2 < 0)
        return;
      if (isTS) {
        var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow2));
        if (m)
          arrow2 = m.index;
      }
      var depth = 0, sawSomething = false;
      for (var pos = arrow2 - 1; pos >= 0; --pos) {
        var ch = stream.string.charAt(pos);
        var bracket = brackets2.indexOf(ch);
        if (bracket >= 0 && bracket < 3) {
          if (!depth) {
            ++pos;
            break;
          }
          if (--depth == 0) {
            if (ch == "(")
              sawSomething = true;
            break;
          }
        } else if (bracket >= 3 && bracket < 6) {
          ++depth;
        } else if (wordRE.test(ch)) {
          sawSomething = true;
        } else if (/["'\/`]/.test(ch)) {
          for (; ; --pos) {
            if (pos == 0)
              return;
            var next = stream.string.charAt(pos - 1);
            if (next == ch && stream.string.charAt(pos - 2) != "\\") {
              pos--;
              break;
            }
          }
        } else if (sawSomething && !depth) {
          ++pos;
          break;
        }
      }
      if (sawSomething && !depth)
        state.fatArrowAt = pos;
    }
    var atomicTypes = {
      "atom": true,
      "number": true,
      "variable": true,
      "string": true,
      "regexp": true,
      "this": true,
      "import": true,
      "jsonld-keyword": true
    };
    function JSLexical(indented, column, type3, align, prev, info) {
      this.indented = indented;
      this.column = column;
      this.type = type3;
      this.prev = prev;
      this.info = info;
      if (align != null)
        this.align = align;
    }
    function inScope(state, varname) {
      if (!trackScope)
        return false;
      for (var v = state.localVars; v; v = v.next)
        if (v.name == varname)
          return true;
      for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
        for (var v = cx2.vars; v; v = v.next)
          if (v.name == varname)
            return true;
      }
    }
    function parseJS(state, style, type3, content2, stream) {
      var cc = state.cc;
      cx.state = state;
      cx.stream = stream;
      cx.marked = null, cx.cc = cc;
      cx.style = style;
      if (!state.lexical.hasOwnProperty("align"))
        state.lexical.align = true;
      while (true) {
        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
        if (combinator(type3, content2)) {
          while (cc.length && cc[cc.length - 1].lex)
            cc.pop()();
          if (cx.marked)
            return cx.marked;
          if (type3 == "variable" && inScope(state, content2))
            return "variable-2";
          return style;
        }
      }
    }
    var cx = { state: null, column: null, marked: null, cc: null };
    function pass() {
      for (var i2 = arguments.length - 1; i2 >= 0; i2--)
        cx.cc.push(arguments[i2]);
    }
    function cont() {
      pass.apply(null, arguments);
      return true;
    }
    function inList(name2, list) {
      for (var v = list; v; v = v.next)
        if (v.name == name2)
          return true;
      return false;
    }
    function register2(varname) {
      var state = cx.state;
      cx.marked = "def";
      if (!trackScope)
        return;
      if (state.context) {
        if (state.lexical.info == "var" && state.context && state.context.block) {
          var newContext = registerVarScoped(varname, state.context);
          if (newContext != null) {
            state.context = newContext;
            return;
          }
        } else if (!inList(varname, state.localVars)) {
          state.localVars = new Var(varname, state.localVars);
          return;
        }
      }
      if (parserConfig.globalVars && !inList(varname, state.globalVars))
        state.globalVars = new Var(varname, state.globalVars);
    }
    function registerVarScoped(varname, context) {
      if (!context) {
        return null;
      } else if (context.block) {
        var inner = registerVarScoped(varname, context.prev);
        if (!inner)
          return null;
        if (inner == context.prev)
          return context;
        return new Context2(inner, context.vars, true);
      } else if (inList(varname, context.vars)) {
        return context;
      } else {
        return new Context2(context.prev, new Var(varname, context.vars), false);
      }
    }
    function isModifier(name2) {
      return name2 == "public" || name2 == "private" || name2 == "protected" || name2 == "abstract" || name2 == "readonly";
    }
    function Context2(prev, vars, block2) {
      this.prev = prev;
      this.vars = vars;
      this.block = block2;
    }
    function Var(name2, next) {
      this.name = name2;
      this.next = next;
    }
    var defaultVars = new Var("this", new Var("arguments", null));
    function pushcontext() {
      cx.state.context = new Context2(cx.state.context, cx.state.localVars, false);
      cx.state.localVars = defaultVars;
    }
    function pushblockcontext() {
      cx.state.context = new Context2(cx.state.context, cx.state.localVars, true);
      cx.state.localVars = null;
    }
    function popcontext() {
      cx.state.localVars = cx.state.context.vars;
      cx.state.context = cx.state.context.prev;
    }
    popcontext.lex = true;
    function pushlex(type3, info) {
      var result = function() {
        var state = cx.state, indent = state.indented;
        if (state.lexical.type == "stat")
          indent = state.lexical.indented;
        else
          for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
            indent = outer.indented;
        state.lexical = new JSLexical(indent, cx.stream.column(), type3, null, state.lexical, info);
      };
      result.lex = true;
      return result;
    }
    function poplex() {
      var state = cx.state;
      if (state.lexical.prev) {
        if (state.lexical.type == ")")
          state.indented = state.lexical.indented;
        state.lexical = state.lexical.prev;
      }
    }
    poplex.lex = true;
    function expect(wanted) {
      function exp(type3) {
        if (type3 == wanted)
          return cont();
        else if (wanted == ";" || type3 == "}" || type3 == ")" || type3 == "]")
          return pass();
        else
          return cont(exp);
      }
      return exp;
    }
    function statement(type3, value2) {
      if (type3 == "var")
        return cont(pushlex("vardef", value2), vardef, expect(";"), poplex);
      if (type3 == "keyword a")
        return cont(pushlex("form"), parenExpr, statement, poplex);
      if (type3 == "keyword b")
        return cont(pushlex("form"), statement, poplex);
      if (type3 == "keyword d")
        return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
      if (type3 == "debugger")
        return cont(expect(";"));
      if (type3 == "{")
        return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
      if (type3 == ";")
        return cont();
      if (type3 == "if") {
        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
          cx.state.cc.pop()();
        return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
      }
      if (type3 == "function")
        return cont(functiondef);
      if (type3 == "for")
        return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
      if (type3 == "class" || isTS && value2 == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form", type3 == "class" ? type3 : value2), className, poplex);
      }
      if (type3 == "variable") {
        if (isTS && value2 == "declare") {
          cx.marked = "keyword";
          return cont(statement);
        } else if (isTS && (value2 == "module" || value2 == "enum" || value2 == "type") && cx.stream.match(/^\s*\w/, false)) {
          cx.marked = "keyword";
          if (value2 == "enum")
            return cont(enumdef);
          else if (value2 == "type")
            return cont(typename, expect("operator"), typeexpr, expect(";"));
          else
            return cont(pushlex("form"), pattern2, expect("{"), pushlex("}"), block, poplex, poplex);
        } else if (isTS && value2 == "namespace") {
          cx.marked = "keyword";
          return cont(pushlex("form"), expression, statement, poplex);
        } else if (isTS && value2 == "abstract") {
          cx.marked = "keyword";
          return cont(statement);
        } else {
          return cont(pushlex("stat"), maybelabel);
        }
      }
      if (type3 == "switch")
        return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
      if (type3 == "case")
        return cont(expression, expect(":"));
      if (type3 == "default")
        return cont(expect(":"));
      if (type3 == "catch")
        return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
      if (type3 == "export")
        return cont(pushlex("stat"), afterExport, poplex);
      if (type3 == "import")
        return cont(pushlex("stat"), afterImport, poplex);
      if (type3 == "async")
        return cont(statement);
      if (value2 == "@")
        return cont(expression, statement);
      return pass(pushlex("stat"), expression, expect(";"), poplex);
    }
    function maybeCatchBinding(type3) {
      if (type3 == "(")
        return cont(funarg, expect(")"));
    }
    function expression(type3, value2) {
      return expressionInner(type3, value2, false);
    }
    function expressionNoComma(type3, value2) {
      return expressionInner(type3, value2, true);
    }
    function parenExpr(type3) {
      if (type3 != "(")
        return pass();
      return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
    }
    function expressionInner(type3, value2, noComma) {
      if (cx.state.fatArrowAt == cx.stream.start) {
        var body = noComma ? arrowBodyNoComma : arrowBody;
        if (type3 == "(")
          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
        else if (type3 == "variable")
          return pass(pushcontext, pattern2, expect("=>"), body, popcontext);
      }
      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
      if (atomicTypes.hasOwnProperty(type3))
        return cont(maybeop);
      if (type3 == "function")
        return cont(functiondef, maybeop);
      if (type3 == "class" || isTS && value2 == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form"), classExpression, poplex);
      }
      if (type3 == "keyword c" || type3 == "async")
        return cont(noComma ? expressionNoComma : expression);
      if (type3 == "(")
        return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
      if (type3 == "operator" || type3 == "spread")
        return cont(noComma ? expressionNoComma : expression);
      if (type3 == "[")
        return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
      if (type3 == "{")
        return contCommasep(objprop, "}", null, maybeop);
      if (type3 == "quasi")
        return pass(quasi, maybeop);
      if (type3 == "new")
        return cont(maybeTarget(noComma));
      return cont();
    }
    function maybeexpression(type3) {
      if (type3.match(/[;\}\)\],]/))
        return pass();
      return pass(expression);
    }
    function maybeoperatorComma(type3, value2) {
      if (type3 == ",")
        return cont(maybeexpression);
      return maybeoperatorNoComma(type3, value2, false);
    }
    function maybeoperatorNoComma(type3, value2, noComma) {
      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
      var expr = noComma == false ? expression : expressionNoComma;
      if (type3 == "=>")
        return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
      if (type3 == "operator") {
        if (/\+\+|--/.test(value2) || isTS && value2 == "!")
          return cont(me);
        if (isTS && value2 == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
        if (value2 == "?")
          return cont(expression, expect(":"), expr);
        return cont(expr);
      }
      if (type3 == "quasi") {
        return pass(quasi, me);
      }
      if (type3 == ";")
        return;
      if (type3 == "(")
        return contCommasep(expressionNoComma, ")", "call", me);
      if (type3 == ".")
        return cont(property, me);
      if (type3 == "[")
        return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      if (isTS && value2 == "as") {
        cx.marked = "keyword";
        return cont(typeexpr, me);
      }
      if (type3 == "regexp") {
        cx.state.lastType = cx.marked = "operator";
        cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
        return cont(expr);
      }
    }
    function quasi(type3, value2) {
      if (type3 != "quasi")
        return pass();
      if (value2.slice(value2.length - 2) != "${")
        return cont(quasi);
      return cont(maybeexpression, continueQuasi);
    }
    function continueQuasi(type3) {
      if (type3 == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasi);
      }
    }
    function arrowBody(type3) {
      findFatArrow(cx.stream, cx.state);
      return pass(type3 == "{" ? statement : expression);
    }
    function arrowBodyNoComma(type3) {
      findFatArrow(cx.stream, cx.state);
      return pass(type3 == "{" ? statement : expressionNoComma);
    }
    function maybeTarget(noComma) {
      return function(type3) {
        if (type3 == ".")
          return cont(noComma ? targetNoComma : target);
        else if (type3 == "variable" && isTS)
          return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
        else
          return pass(noComma ? expressionNoComma : expression);
      };
    }
    function target(_, value2) {
      if (value2 == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorComma);
      }
    }
    function targetNoComma(_, value2) {
      if (value2 == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorNoComma);
      }
    }
    function maybelabel(type3) {
      if (type3 == ":")
        return cont(poplex, statement);
      return pass(maybeoperatorComma, expect(";"), poplex);
    }
    function property(type3) {
      if (type3 == "variable") {
        cx.marked = "property";
        return cont();
      }
    }
    function objprop(type3, value2) {
      if (type3 == "async") {
        cx.marked = "property";
        return cont(objprop);
      } else if (type3 == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value2 == "get" || value2 == "set")
          return cont(getterSetter);
        var m;
        if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
          cx.state.fatArrowAt = cx.stream.pos + m[0].length;
        return cont(afterprop);
      } else if (type3 == "number" || type3 == "string") {
        cx.marked = jsonldMode ? "property" : cx.style + " property";
        return cont(afterprop);
      } else if (type3 == "jsonld-keyword") {
        return cont(afterprop);
      } else if (isTS && isModifier(value2)) {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type3 == "[") {
        return cont(expression, maybetype, expect("]"), afterprop);
      } else if (type3 == "spread") {
        return cont(expressionNoComma, afterprop);
      } else if (value2 == "*") {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type3 == ":") {
        return pass(afterprop);
      }
    }
    function getterSetter(type3) {
      if (type3 != "variable")
        return pass(afterprop);
      cx.marked = "property";
      return cont(functiondef);
    }
    function afterprop(type3) {
      if (type3 == ":")
        return cont(expressionNoComma);
      if (type3 == "(")
        return pass(functiondef);
    }
    function commasep(what, end2, sep) {
      function proceed(type3, value2) {
        if (sep ? sep.indexOf(type3) > -1 : type3 == ",") {
          var lex = cx.state.lexical;
          if (lex.info == "call")
            lex.pos = (lex.pos || 0) + 1;
          return cont(function(type4, value3) {
            if (type4 == end2 || value3 == end2)
              return pass();
            return pass(what);
          }, proceed);
        }
        if (type3 == end2 || value2 == end2)
          return cont();
        if (sep && sep.indexOf(";") > -1)
          return pass(what);
        return cont(expect(end2));
      }
      return function(type3, value2) {
        if (type3 == end2 || value2 == end2)
          return cont();
        return pass(what, proceed);
      };
    }
    function contCommasep(what, end2, info) {
      for (var i2 = 3; i2 < arguments.length; i2++)
        cx.cc.push(arguments[i2]);
      return cont(pushlex(end2, info), commasep(what, end2), poplex);
    }
    function block(type3) {
      if (type3 == "}")
        return cont();
      return pass(statement, block);
    }
    function maybetype(type3, value2) {
      if (isTS) {
        if (type3 == ":")
          return cont(typeexpr);
        if (value2 == "?")
          return cont(maybetype);
      }
    }
    function maybetypeOrIn(type3, value2) {
      if (isTS && (type3 == ":" || value2 == "in"))
        return cont(typeexpr);
    }
    function mayberettype(type3) {
      if (isTS && type3 == ":") {
        if (cx.stream.match(/^\s*\w+\s+is\b/, false))
          return cont(expression, isKW, typeexpr);
        else
          return cont(typeexpr);
      }
    }
    function isKW(_, value2) {
      if (value2 == "is") {
        cx.marked = "keyword";
        return cont();
      }
    }
    function typeexpr(type3, value2) {
      if (value2 == "keyof" || value2 == "typeof" || value2 == "infer" || value2 == "readonly") {
        cx.marked = "keyword";
        return cont(value2 == "typeof" ? expressionNoComma : typeexpr);
      }
      if (type3 == "variable" || value2 == "void") {
        cx.marked = "type";
        return cont(afterType);
      }
      if (value2 == "|" || value2 == "&")
        return cont(typeexpr);
      if (type3 == "string" || type3 == "number" || type3 == "atom")
        return cont(afterType);
      if (type3 == "[")
        return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
      if (type3 == "{")
        return cont(pushlex("}"), typeprops, poplex, afterType);
      if (type3 == "(")
        return cont(commasep(typearg, ")"), maybeReturnType, afterType);
      if (type3 == "<")
        return cont(commasep(typeexpr, ">"), typeexpr);
      if (type3 == "quasi") {
        return pass(quasiType, afterType);
      }
    }
    function maybeReturnType(type3) {
      if (type3 == "=>")
        return cont(typeexpr);
    }
    function typeprops(type3) {
      if (type3.match(/[\}\)\]]/))
        return cont();
      if (type3 == "," || type3 == ";")
        return cont(typeprops);
      return pass(typeprop, typeprops);
    }
    function typeprop(type3, value2) {
      if (type3 == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(typeprop);
      } else if (value2 == "?" || type3 == "number" || type3 == "string") {
        return cont(typeprop);
      } else if (type3 == ":") {
        return cont(typeexpr);
      } else if (type3 == "[") {
        return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
      } else if (type3 == "(") {
        return pass(functiondecl, typeprop);
      } else if (!type3.match(/[;\}\)\],]/)) {
        return cont();
      }
    }
    function quasiType(type3, value2) {
      if (type3 != "quasi")
        return pass();
      if (value2.slice(value2.length - 2) != "${")
        return cont(quasiType);
      return cont(typeexpr, continueQuasiType);
    }
    function continueQuasiType(type3) {
      if (type3 == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasiType);
      }
    }
    function typearg(type3, value2) {
      if (type3 == "variable" && cx.stream.match(/^\s*[?:]/, false) || value2 == "?")
        return cont(typearg);
      if (type3 == ":")
        return cont(typeexpr);
      if (type3 == "spread")
        return cont(typearg);
      return pass(typeexpr);
    }
    function afterType(type3, value2) {
      if (value2 == "<")
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
      if (value2 == "|" || type3 == "." || value2 == "&")
        return cont(typeexpr);
      if (type3 == "[")
        return cont(typeexpr, expect("]"), afterType);
      if (value2 == "extends" || value2 == "implements") {
        cx.marked = "keyword";
        return cont(typeexpr);
      }
      if (value2 == "?")
        return cont(typeexpr, expect(":"), typeexpr);
    }
    function maybeTypeArgs(_, value2) {
      if (value2 == "<")
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
    }
    function typeparam() {
      return pass(typeexpr, maybeTypeDefault);
    }
    function maybeTypeDefault(_, value2) {
      if (value2 == "=")
        return cont(typeexpr);
    }
    function vardef(_, value2) {
      if (value2 == "enum") {
        cx.marked = "keyword";
        return cont(enumdef);
      }
      return pass(pattern2, maybetype, maybeAssign, vardefCont);
    }
    function pattern2(type3, value2) {
      if (isTS && isModifier(value2)) {
        cx.marked = "keyword";
        return cont(pattern2);
      }
      if (type3 == "variable") {
        register2(value2);
        return cont();
      }
      if (type3 == "spread")
        return cont(pattern2);
      if (type3 == "[")
        return contCommasep(eltpattern, "]");
      if (type3 == "{")
        return contCommasep(proppattern, "}");
    }
    function proppattern(type3, value2) {
      if (type3 == "variable" && !cx.stream.match(/^\s*:/, false)) {
        register2(value2);
        return cont(maybeAssign);
      }
      if (type3 == "variable")
        cx.marked = "property";
      if (type3 == "spread")
        return cont(pattern2);
      if (type3 == "}")
        return pass();
      if (type3 == "[")
        return cont(expression, expect("]"), expect(":"), proppattern);
      return cont(expect(":"), pattern2, maybeAssign);
    }
    function eltpattern() {
      return pass(pattern2, maybeAssign);
    }
    function maybeAssign(_type, value2) {
      if (value2 == "=")
        return cont(expressionNoComma);
    }
    function vardefCont(type3) {
      if (type3 == ",")
        return cont(vardef);
    }
    function maybeelse(type3, value2) {
      if (type3 == "keyword b" && value2 == "else")
        return cont(pushlex("form", "else"), statement, poplex);
    }
    function forspec(type3, value2) {
      if (value2 == "await")
        return cont(forspec);
      if (type3 == "(")
        return cont(pushlex(")"), forspec1, poplex);
    }
    function forspec1(type3) {
      if (type3 == "var")
        return cont(vardef, forspec2);
      if (type3 == "variable")
        return cont(forspec2);
      return pass(forspec2);
    }
    function forspec2(type3, value2) {
      if (type3 == ")")
        return cont();
      if (type3 == ";")
        return cont(forspec2);
      if (value2 == "in" || value2 == "of") {
        cx.marked = "keyword";
        return cont(expression, forspec2);
      }
      return pass(expression, forspec2);
    }
    function functiondef(type3, value2) {
      if (value2 == "*") {
        cx.marked = "keyword";
        return cont(functiondef);
      }
      if (type3 == "variable") {
        register2(value2);
        return cont(functiondef);
      }
      if (type3 == "(")
        return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
      if (isTS && value2 == "<")
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
    }
    function functiondecl(type3, value2) {
      if (value2 == "*") {
        cx.marked = "keyword";
        return cont(functiondecl);
      }
      if (type3 == "variable") {
        register2(value2);
        return cont(functiondecl);
      }
      if (type3 == "(")
        return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
      if (isTS && value2 == "<")
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
    }
    function typename(type3, value2) {
      if (type3 == "keyword" || type3 == "variable") {
        cx.marked = "type";
        return cont(typename);
      } else if (value2 == "<") {
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
      }
    }
    function funarg(type3, value2) {
      if (value2 == "@")
        cont(expression, funarg);
      if (type3 == "spread")
        return cont(funarg);
      if (isTS && isModifier(value2)) {
        cx.marked = "keyword";
        return cont(funarg);
      }
      if (isTS && type3 == "this")
        return cont(maybetype, maybeAssign);
      return pass(pattern2, maybetype, maybeAssign);
    }
    function classExpression(type3, value2) {
      if (type3 == "variable")
        return className(type3, value2);
      return classNameAfter(type3, value2);
    }
    function className(type3, value2) {
      if (type3 == "variable") {
        register2(value2);
        return cont(classNameAfter);
      }
    }
    function classNameAfter(type3, value2) {
      if (value2 == "<")
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
      if (value2 == "extends" || value2 == "implements" || isTS && type3 == ",") {
        if (value2 == "implements")
          cx.marked = "keyword";
        return cont(isTS ? typeexpr : expression, classNameAfter);
      }
      if (type3 == "{")
        return cont(pushlex("}"), classBody, poplex);
    }
    function classBody(type3, value2) {
      if (type3 == "async" || type3 == "variable" && (value2 == "static" || value2 == "get" || value2 == "set" || isTS && isModifier(value2)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (type3 == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(classfield, classBody);
      }
      if (type3 == "number" || type3 == "string")
        return cont(classfield, classBody);
      if (type3 == "[")
        return cont(expression, maybetype, expect("]"), classfield, classBody);
      if (value2 == "*") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (isTS && type3 == "(")
        return pass(functiondecl, classBody);
      if (type3 == ";" || type3 == ",")
        return cont(classBody);
      if (type3 == "}")
        return cont();
      if (value2 == "@")
        return cont(expression, classBody);
    }
    function classfield(type3, value2) {
      if (value2 == "!")
        return cont(classfield);
      if (value2 == "?")
        return cont(classfield);
      if (type3 == ":")
        return cont(typeexpr, maybeAssign);
      if (value2 == "=")
        return cont(expressionNoComma);
      var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
      return pass(isInterface ? functiondecl : functiondef);
    }
    function afterExport(type3, value2) {
      if (value2 == "*") {
        cx.marked = "keyword";
        return cont(maybeFrom, expect(";"));
      }
      if (value2 == "default") {
        cx.marked = "keyword";
        return cont(expression, expect(";"));
      }
      if (type3 == "{")
        return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
      return pass(statement);
    }
    function exportField(type3, value2) {
      if (value2 == "as") {
        cx.marked = "keyword";
        return cont(expect("variable"));
      }
      if (type3 == "variable")
        return pass(expressionNoComma, exportField);
    }
    function afterImport(type3) {
      if (type3 == "string")
        return cont();
      if (type3 == "(")
        return pass(expression);
      if (type3 == ".")
        return pass(maybeoperatorComma);
      return pass(importSpec, maybeMoreImports, maybeFrom);
    }
    function importSpec(type3, value2) {
      if (type3 == "{")
        return contCommasep(importSpec, "}");
      if (type3 == "variable")
        register2(value2);
      if (value2 == "*")
        cx.marked = "keyword";
      return cont(maybeAs);
    }
    function maybeMoreImports(type3) {
      if (type3 == ",")
        return cont(importSpec, maybeMoreImports);
    }
    function maybeAs(_type, value2) {
      if (value2 == "as") {
        cx.marked = "keyword";
        return cont(importSpec);
      }
    }
    function maybeFrom(_type, value2) {
      if (value2 == "from") {
        cx.marked = "keyword";
        return cont(expression);
      }
    }
    function arrayLiteral(type3) {
      if (type3 == "]")
        return cont();
      return pass(commasep(expressionNoComma, "]"));
    }
    function enumdef() {
      return pass(pushlex("form"), pattern2, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
    }
    function enummember() {
      return pass(pattern2, maybeAssign);
    }
    function isContinuedStatement(state, textAfter) {
      return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
    }
    function expressionAllowed(stream, state, backUp) {
      return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
    }
    return {
      startState: function(basecolumn) {
        var state = {
          tokenize: tokenBase,
          lastType: "sof",
          cc: [],
          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
          localVars: parserConfig.localVars,
          context: parserConfig.localVars && new Context2(null, null, false),
          indented: basecolumn || 0
        };
        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
          state.globalVars = parserConfig.globalVars;
        return state;
      },
      token: function(stream, state) {
        if (stream.sol()) {
          if (!state.lexical.hasOwnProperty("align"))
            state.lexical.align = false;
          state.indented = stream.indentation();
          findFatArrow(stream, state);
        }
        if (state.tokenize != tokenComment && stream.eatSpace())
          return null;
        var style = state.tokenize(stream, state);
        if (type2 == "comment")
          return style;
        state.lastType = type2 == "operator" && (content == "++" || content == "--") ? "incdec" : type2;
        return parseJS(state, style, type2, content, stream);
      },
      indent: function(state, textAfter) {
        if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)
          return CodeMirror2.Pass;
        if (state.tokenize != tokenBase)
          return 0;
        var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top2;
        if (!/^\s*else\b/.test(textAfter))
          for (var i2 = state.cc.length - 1; i2 >= 0; --i2) {
            var c = state.cc[i2];
            if (c == poplex)
              lexical = lexical.prev;
            else if (c != maybeelse && c != popcontext)
              break;
          }
        while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top2 = state.cc[state.cc.length - 1]) && (top2 == maybeoperatorComma || top2 == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)))
          lexical = lexical.prev;
        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
          lexical = lexical.prev;
        var type3 = lexical.type, closing = firstChar == type3;
        if (type3 == "vardef")
          return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
        else if (type3 == "form" && firstChar == "{")
          return lexical.indented;
        else if (type3 == "form")
          return lexical.indented + indentUnit;
        else if (type3 == "stat")
          return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
        else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
          return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
        else if (lexical.align)
          return lexical.column + (closing ? 0 : 1);
        else
          return lexical.indented + (closing ? 0 : indentUnit);
      },
      electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
      blockCommentStart: jsonMode ? null : "/*",
      blockCommentEnd: jsonMode ? null : "*/",
      blockCommentContinue: jsonMode ? null : " * ",
      lineComment: jsonMode ? null : "//",
      fold: "brace",
      closeBrackets: "()[]{}''\"\"``",
      helperType: jsonMode ? "json" : "javascript",
      jsonldMode,
      jsonMode,
      expressionAllowed,
      skipExpression: function(state) {
        parseJS(state, "atom", "atom", "true", new CodeMirror2.StringStream("", 2, null));
      }
    };
  });
  CodeMirror2.registerHelper("wordChars", "javascript", /[\w$]/);
  CodeMirror2.defineMIME("text/javascript", "javascript");
  CodeMirror2.defineMIME("text/ecmascript", "javascript");
  CodeMirror2.defineMIME("application/javascript", "javascript");
  CodeMirror2.defineMIME("application/x-javascript", "javascript");
  CodeMirror2.defineMIME("application/ecmascript", "javascript");
  CodeMirror2.defineMIME("application/json", { name: "javascript", json: true });
  CodeMirror2.defineMIME("application/x-json", { name: "javascript", json: true });
  CodeMirror2.defineMIME("application/manifest+json", { name: "javascript", json: true });
  CodeMirror2.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
  CodeMirror2.defineMIME("text/typescript", { name: "javascript", typescript: true });
  CodeMirror2.defineMIME("application/typescript", { name: "javascript", typescript: true });
});
(function(mod) {
  mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineMode("css", function(config2, parserConfig) {
    var inline = parserConfig.inline;
    if (!parserConfig.propertyKeywords)
      parserConfig = CodeMirror2.resolveMode("text/css");
    var indentUnit = config2.indentUnit, tokenHooks = parserConfig.tokenHooks, documentTypes2 = parserConfig.documentTypes || {}, mediaTypes2 = parserConfig.mediaTypes || {}, mediaFeatures2 = parserConfig.mediaFeatures || {}, mediaValueKeywords2 = parserConfig.mediaValueKeywords || {}, propertyKeywords2 = parserConfig.propertyKeywords || {}, nonStandardPropertyKeywords2 = parserConfig.nonStandardPropertyKeywords || {}, fontProperties2 = parserConfig.fontProperties || {}, counterDescriptors2 = parserConfig.counterDescriptors || {}, colorKeywords2 = parserConfig.colorKeywords || {}, valueKeywords2 = parserConfig.valueKeywords || {}, allowNested = parserConfig.allowNested, lineComment = parserConfig.lineComment, supportsAtComponent = parserConfig.supportsAtComponent === true, highlightNonStandardPropertyKeywords = config2.highlightNonStandardPropertyKeywords !== false;
    var type2, override;
    function ret(style, tp) {
      type2 = tp;
      return style;
    }
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (tokenHooks[ch]) {
        var result = tokenHooks[ch](stream, state);
        if (result !== false)
          return result;
      }
      if (ch == "@") {
        stream.eatWhile(/[\w\\\-]/);
        return ret("def", stream.current());
      } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
        return ret(null, "compare");
      } else if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "#") {
        stream.eatWhile(/[\w\\\-]/);
        return ret("atom", "hash");
      } else if (ch == "!") {
        stream.match(/^\s*\w*/);
        return ret("keyword", "important");
      } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (ch === "-") {
        if (/[\d.]/.test(stream.peek())) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        } else if (stream.match(/^-[\w\\\-]*/)) {
          stream.eatWhile(/[\w\\\-]/);
          if (stream.match(/^\s*:/, false))
            return ret("variable-2", "variable-definition");
          return ret("variable-2", "variable");
        } else if (stream.match(/^\w+-/)) {
          return ret("meta", "meta");
        }
      } else if (/[,+>*\/]/.test(ch)) {
        return ret(null, "select-op");
      } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
        return ret("qualifier", "qualifier");
      } else if (/[:;{}\[\]\(\)]/.test(ch)) {
        return ret(null, ch);
      } else if (stream.match(/^[\w-.]+(?=\()/)) {
        if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {
          state.tokenize = tokenParenthesized;
        }
        return ret("variable callee", "variable");
      } else if (/[\w\\\-]/.test(ch)) {
        stream.eatWhile(/[\w\\\-]/);
        return ret("property", "word");
      } else {
        return ret(null, null);
      }
    }
    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, ch;
        while ((ch = stream.next()) != null) {
          if (ch == quote && !escaped) {
            if (quote == ")")
              stream.backUp(1);
            break;
          }
          escaped = !escaped && ch == "\\";
        }
        if (ch == quote || !escaped && quote != ")")
          state.tokenize = null;
        return ret("string", "string");
      };
    }
    function tokenParenthesized(stream, state) {
      stream.next();
      if (!stream.match(/^\s*[\"\')]/, false))
        state.tokenize = tokenString(")");
      else
        state.tokenize = null;
      return ret(null, "(");
    }
    function Context2(type3, indent, prev) {
      this.type = type3;
      this.indent = indent;
      this.prev = prev;
    }
    function pushContext(state, stream, type3, indent) {
      state.context = new Context2(type3, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
      return type3;
    }
    function popContext(state) {
      if (state.context.prev)
        state.context = state.context.prev;
      return state.context.type;
    }
    function pass(type3, stream, state) {
      return states[state.context.type](type3, stream, state);
    }
    function popAndPass(type3, stream, state, n) {
      for (var i2 = n || 1; i2 > 0; i2--)
        state.context = state.context.prev;
      return pass(type3, stream, state);
    }
    function wordAsValue(stream) {
      var word = stream.current().toLowerCase();
      if (valueKeywords2.hasOwnProperty(word))
        override = "atom";
      else if (colorKeywords2.hasOwnProperty(word))
        override = "keyword";
      else
        override = "variable";
    }
    var states = {};
    states.top = function(type3, stream, state) {
      if (type3 == "{") {
        return pushContext(state, stream, "block");
      } else if (type3 == "}" && state.context.prev) {
        return popContext(state);
      } else if (supportsAtComponent && /@component/i.test(type3)) {
        return pushContext(state, stream, "atComponentBlock");
      } else if (/^@(-moz-)?document$/i.test(type3)) {
        return pushContext(state, stream, "documentTypes");
      } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type3)) {
        return pushContext(state, stream, "atBlock");
      } else if (/^@(font-face|counter-style)/i.test(type3)) {
        state.stateArg = type3;
        return "restricted_atBlock_before";
      } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type3)) {
        return "keyframes";
      } else if (type3 && type3.charAt(0) == "@") {
        return pushContext(state, stream, "at");
      } else if (type3 == "hash") {
        override = "builtin";
      } else if (type3 == "word") {
        override = "tag";
      } else if (type3 == "variable-definition") {
        return "maybeprop";
      } else if (type3 == "interpolation") {
        return pushContext(state, stream, "interpolation");
      } else if (type3 == ":") {
        return "pseudo";
      } else if (allowNested && type3 == "(") {
        return pushContext(state, stream, "parens");
      }
      return state.context.type;
    };
    states.block = function(type3, stream, state) {
      if (type3 == "word") {
        var word = stream.current().toLowerCase();
        if (propertyKeywords2.hasOwnProperty(word)) {
          override = "property";
          return "maybeprop";
        } else if (nonStandardPropertyKeywords2.hasOwnProperty(word)) {
          override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
          return "maybeprop";
        } else if (allowNested) {
          override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
          return "block";
        } else {
          override += " error";
          return "maybeprop";
        }
      } else if (type3 == "meta") {
        return "block";
      } else if (!allowNested && (type3 == "hash" || type3 == "qualifier")) {
        override = "error";
        return "block";
      } else {
        return states.top(type3, stream, state);
      }
    };
    states.maybeprop = function(type3, stream, state) {
      if (type3 == ":")
        return pushContext(state, stream, "prop");
      return pass(type3, stream, state);
    };
    states.prop = function(type3, stream, state) {
      if (type3 == ";")
        return popContext(state);
      if (type3 == "{" && allowNested)
        return pushContext(state, stream, "propBlock");
      if (type3 == "}" || type3 == "{")
        return popAndPass(type3, stream, state);
      if (type3 == "(")
        return pushContext(state, stream, "parens");
      if (type3 == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
        override += " error";
      } else if (type3 == "word") {
        wordAsValue(stream);
      } else if (type3 == "interpolation") {
        return pushContext(state, stream, "interpolation");
      }
      return "prop";
    };
    states.propBlock = function(type3, _stream, state) {
      if (type3 == "}")
        return popContext(state);
      if (type3 == "word") {
        override = "property";
        return "maybeprop";
      }
      return state.context.type;
    };
    states.parens = function(type3, stream, state) {
      if (type3 == "{" || type3 == "}")
        return popAndPass(type3, stream, state);
      if (type3 == ")")
        return popContext(state);
      if (type3 == "(")
        return pushContext(state, stream, "parens");
      if (type3 == "interpolation")
        return pushContext(state, stream, "interpolation");
      if (type3 == "word")
        wordAsValue(stream);
      return "parens";
    };
    states.pseudo = function(type3, stream, state) {
      if (type3 == "meta")
        return "pseudo";
      if (type3 == "word") {
        override = "variable-3";
        return state.context.type;
      }
      return pass(type3, stream, state);
    };
    states.documentTypes = function(type3, stream, state) {
      if (type3 == "word" && documentTypes2.hasOwnProperty(stream.current())) {
        override = "tag";
        return state.context.type;
      } else {
        return states.atBlock(type3, stream, state);
      }
    };
    states.atBlock = function(type3, stream, state) {
      if (type3 == "(")
        return pushContext(state, stream, "atBlock_parens");
      if (type3 == "}" || type3 == ";")
        return popAndPass(type3, stream, state);
      if (type3 == "{")
        return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
      if (type3 == "interpolation")
        return pushContext(state, stream, "interpolation");
      if (type3 == "word") {
        var word = stream.current().toLowerCase();
        if (word == "only" || word == "not" || word == "and" || word == "or")
          override = "keyword";
        else if (mediaTypes2.hasOwnProperty(word))
          override = "attribute";
        else if (mediaFeatures2.hasOwnProperty(word))
          override = "property";
        else if (mediaValueKeywords2.hasOwnProperty(word))
          override = "keyword";
        else if (propertyKeywords2.hasOwnProperty(word))
          override = "property";
        else if (nonStandardPropertyKeywords2.hasOwnProperty(word))
          override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
        else if (valueKeywords2.hasOwnProperty(word))
          override = "atom";
        else if (colorKeywords2.hasOwnProperty(word))
          override = "keyword";
        else
          override = "error";
      }
      return state.context.type;
    };
    states.atComponentBlock = function(type3, stream, state) {
      if (type3 == "}")
        return popAndPass(type3, stream, state);
      if (type3 == "{")
        return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
      if (type3 == "word")
        override = "error";
      return state.context.type;
    };
    states.atBlock_parens = function(type3, stream, state) {
      if (type3 == ")")
        return popContext(state);
      if (type3 == "{" || type3 == "}")
        return popAndPass(type3, stream, state, 2);
      return states.atBlock(type3, stream, state);
    };
    states.restricted_atBlock_before = function(type3, stream, state) {
      if (type3 == "{")
        return pushContext(state, stream, "restricted_atBlock");
      if (type3 == "word" && state.stateArg == "@counter-style") {
        override = "variable";
        return "restricted_atBlock_before";
      }
      return pass(type3, stream, state);
    };
    states.restricted_atBlock = function(type3, stream, state) {
      if (type3 == "}") {
        state.stateArg = null;
        return popContext(state);
      }
      if (type3 == "word") {
        if (state.stateArg == "@font-face" && !fontProperties2.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors2.hasOwnProperty(stream.current().toLowerCase()))
          override = "error";
        else
          override = "property";
        return "maybeprop";
      }
      return "restricted_atBlock";
    };
    states.keyframes = function(type3, stream, state) {
      if (type3 == "word") {
        override = "variable";
        return "keyframes";
      }
      if (type3 == "{")
        return pushContext(state, stream, "top");
      return pass(type3, stream, state);
    };
    states.at = function(type3, stream, state) {
      if (type3 == ";")
        return popContext(state);
      if (type3 == "{" || type3 == "}")
        return popAndPass(type3, stream, state);
      if (type3 == "word")
        override = "tag";
      else if (type3 == "hash")
        override = "builtin";
      return "at";
    };
    states.interpolation = function(type3, stream, state) {
      if (type3 == "}")
        return popContext(state);
      if (type3 == "{" || type3 == ";")
        return popAndPass(type3, stream, state);
      if (type3 == "word")
        override = "variable";
      else if (type3 != "variable" && type3 != "(" && type3 != ")")
        override = "error";
      return "interpolation";
    };
    return {
      startState: function(base) {
        return {
          tokenize: null,
          state: inline ? "block" : "top",
          stateArg: null,
          context: new Context2(inline ? "block" : "top", base || 0, null)
        };
      },
      token: function(stream, state) {
        if (!state.tokenize && stream.eatSpace())
          return null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style && typeof style == "object") {
          type2 = style[1];
          style = style[0];
        }
        override = style;
        if (type2 != "comment")
          state.state = states[state.state](type2, stream, state);
        return override;
      },
      indent: function(state, textAfter) {
        var cx = state.context, ch = textAfter && textAfter.charAt(0);
        var indent = cx.indent;
        if (cx.type == "prop" && (ch == "}" || ch == ")"))
          cx = cx.prev;
        if (cx.prev) {
          if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
            cx = cx.prev;
            indent = cx.indent;
          } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
            indent = Math.max(0, cx.indent - indentUnit);
          }
        }
        return indent;
      },
      electricChars: "}",
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      blockCommentContinue: " * ",
      lineComment,
      fold: "brace"
    };
  });
  function keySet(array3) {
    var keys2 = {};
    for (var i2 = 0; i2 < array3.length; ++i2) {
      keys2[array3[i2].toLowerCase()] = true;
    }
    return keys2;
  }
  var documentTypes_ = [
    "domain",
    "regexp",
    "url",
    "url-prefix"
  ], documentTypes = keySet(documentTypes_);
  var mediaTypes_ = [
    "all",
    "aural",
    "braille",
    "handheld",
    "print",
    "projection",
    "screen",
    "tty",
    "tv",
    "embossed"
  ], mediaTypes = keySet(mediaTypes_);
  var mediaFeatures_ = [
    "width",
    "min-width",
    "max-width",
    "height",
    "min-height",
    "max-height",
    "device-width",
    "min-device-width",
    "max-device-width",
    "device-height",
    "min-device-height",
    "max-device-height",
    "aspect-ratio",
    "min-aspect-ratio",
    "max-aspect-ratio",
    "device-aspect-ratio",
    "min-device-aspect-ratio",
    "max-device-aspect-ratio",
    "color",
    "min-color",
    "max-color",
    "color-index",
    "min-color-index",
    "max-color-index",
    "monochrome",
    "min-monochrome",
    "max-monochrome",
    "resolution",
    "min-resolution",
    "max-resolution",
    "scan",
    "grid",
    "orientation",
    "device-pixel-ratio",
    "min-device-pixel-ratio",
    "max-device-pixel-ratio",
    "pointer",
    "any-pointer",
    "hover",
    "any-hover",
    "prefers-color-scheme"
  ], mediaFeatures = keySet(mediaFeatures_);
  var mediaValueKeywords_ = [
    "landscape",
    "portrait",
    "none",
    "coarse",
    "fine",
    "on-demand",
    "hover",
    "interlace",
    "progressive",
    "dark",
    "light"
  ], mediaValueKeywords = keySet(mediaValueKeywords_);
  var propertyKeywords_ = [
    "align-content",
    "align-items",
    "align-self",
    "alignment-adjust",
    "alignment-baseline",
    "all",
    "anchor-point",
    "animation",
    "animation-delay",
    "animation-direction",
    "animation-duration",
    "animation-fill-mode",
    "animation-iteration-count",
    "animation-name",
    "animation-play-state",
    "animation-timing-function",
    "appearance",
    "azimuth",
    "backdrop-filter",
    "backface-visibility",
    "background",
    "background-attachment",
    "background-blend-mode",
    "background-clip",
    "background-color",
    "background-image",
    "background-origin",
    "background-position",
    "background-position-x",
    "background-position-y",
    "background-repeat",
    "background-size",
    "baseline-shift",
    "binding",
    "bleed",
    "block-size",
    "bookmark-label",
    "bookmark-level",
    "bookmark-state",
    "bookmark-target",
    "border",
    "border-bottom",
    "border-bottom-color",
    "border-bottom-left-radius",
    "border-bottom-right-radius",
    "border-bottom-style",
    "border-bottom-width",
    "border-collapse",
    "border-color",
    "border-image",
    "border-image-outset",
    "border-image-repeat",
    "border-image-slice",
    "border-image-source",
    "border-image-width",
    "border-left",
    "border-left-color",
    "border-left-style",
    "border-left-width",
    "border-radius",
    "border-right",
    "border-right-color",
    "border-right-style",
    "border-right-width",
    "border-spacing",
    "border-style",
    "border-top",
    "border-top-color",
    "border-top-left-radius",
    "border-top-right-radius",
    "border-top-style",
    "border-top-width",
    "border-width",
    "bottom",
    "box-decoration-break",
    "box-shadow",
    "box-sizing",
    "break-after",
    "break-before",
    "break-inside",
    "caption-side",
    "caret-color",
    "clear",
    "clip",
    "color",
    "color-profile",
    "column-count",
    "column-fill",
    "column-gap",
    "column-rule",
    "column-rule-color",
    "column-rule-style",
    "column-rule-width",
    "column-span",
    "column-width",
    "columns",
    "contain",
    "content",
    "counter-increment",
    "counter-reset",
    "crop",
    "cue",
    "cue-after",
    "cue-before",
    "cursor",
    "direction",
    "display",
    "dominant-baseline",
    "drop-initial-after-adjust",
    "drop-initial-after-align",
    "drop-initial-before-adjust",
    "drop-initial-before-align",
    "drop-initial-size",
    "drop-initial-value",
    "elevation",
    "empty-cells",
    "fit",
    "fit-content",
    "fit-position",
    "flex",
    "flex-basis",
    "flex-direction",
    "flex-flow",
    "flex-grow",
    "flex-shrink",
    "flex-wrap",
    "float",
    "float-offset",
    "flow-from",
    "flow-into",
    "font",
    "font-family",
    "font-feature-settings",
    "font-kerning",
    "font-language-override",
    "font-optical-sizing",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-synthesis",
    "font-variant",
    "font-variant-alternates",
    "font-variant-caps",
    "font-variant-east-asian",
    "font-variant-ligatures",
    "font-variant-numeric",
    "font-variant-position",
    "font-variation-settings",
    "font-weight",
    "gap",
    "grid",
    "grid-area",
    "grid-auto-columns",
    "grid-auto-flow",
    "grid-auto-rows",
    "grid-column",
    "grid-column-end",
    "grid-column-gap",
    "grid-column-start",
    "grid-gap",
    "grid-row",
    "grid-row-end",
    "grid-row-gap",
    "grid-row-start",
    "grid-template",
    "grid-template-areas",
    "grid-template-columns",
    "grid-template-rows",
    "hanging-punctuation",
    "height",
    "hyphens",
    "icon",
    "image-orientation",
    "image-rendering",
    "image-resolution",
    "inline-box-align",
    "inset",
    "inset-block",
    "inset-block-end",
    "inset-block-start",
    "inset-inline",
    "inset-inline-end",
    "inset-inline-start",
    "isolation",
    "justify-content",
    "justify-items",
    "justify-self",
    "left",
    "letter-spacing",
    "line-break",
    "line-height",
    "line-height-step",
    "line-stacking",
    "line-stacking-ruby",
    "line-stacking-shift",
    "line-stacking-strategy",
    "list-style",
    "list-style-image",
    "list-style-position",
    "list-style-type",
    "margin",
    "margin-bottom",
    "margin-left",
    "margin-right",
    "margin-top",
    "marks",
    "marquee-direction",
    "marquee-loop",
    "marquee-play-count",
    "marquee-speed",
    "marquee-style",
    "mask-clip",
    "mask-composite",
    "mask-image",
    "mask-mode",
    "mask-origin",
    "mask-position",
    "mask-repeat",
    "mask-size",
    "mask-type",
    "max-block-size",
    "max-height",
    "max-inline-size",
    "max-width",
    "min-block-size",
    "min-height",
    "min-inline-size",
    "min-width",
    "mix-blend-mode",
    "move-to",
    "nav-down",
    "nav-index",
    "nav-left",
    "nav-right",
    "nav-up",
    "object-fit",
    "object-position",
    "offset",
    "offset-anchor",
    "offset-distance",
    "offset-path",
    "offset-position",
    "offset-rotate",
    "opacity",
    "order",
    "orphans",
    "outline",
    "outline-color",
    "outline-offset",
    "outline-style",
    "outline-width",
    "overflow",
    "overflow-style",
    "overflow-wrap",
    "overflow-x",
    "overflow-y",
    "padding",
    "padding-bottom",
    "padding-left",
    "padding-right",
    "padding-top",
    "page",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "page-policy",
    "pause",
    "pause-after",
    "pause-before",
    "perspective",
    "perspective-origin",
    "pitch",
    "pitch-range",
    "place-content",
    "place-items",
    "place-self",
    "play-during",
    "position",
    "presentation-level",
    "punctuation-trim",
    "quotes",
    "region-break-after",
    "region-break-before",
    "region-break-inside",
    "region-fragment",
    "rendering-intent",
    "resize",
    "rest",
    "rest-after",
    "rest-before",
    "richness",
    "right",
    "rotate",
    "rotation",
    "rotation-point",
    "row-gap",
    "ruby-align",
    "ruby-overhang",
    "ruby-position",
    "ruby-span",
    "scale",
    "scroll-behavior",
    "scroll-margin",
    "scroll-margin-block",
    "scroll-margin-block-end",
    "scroll-margin-block-start",
    "scroll-margin-bottom",
    "scroll-margin-inline",
    "scroll-margin-inline-end",
    "scroll-margin-inline-start",
    "scroll-margin-left",
    "scroll-margin-right",
    "scroll-margin-top",
    "scroll-padding",
    "scroll-padding-block",
    "scroll-padding-block-end",
    "scroll-padding-block-start",
    "scroll-padding-bottom",
    "scroll-padding-inline",
    "scroll-padding-inline-end",
    "scroll-padding-inline-start",
    "scroll-padding-left",
    "scroll-padding-right",
    "scroll-padding-top",
    "scroll-snap-align",
    "scroll-snap-type",
    "shape-image-threshold",
    "shape-inside",
    "shape-margin",
    "shape-outside",
    "size",
    "speak",
    "speak-as",
    "speak-header",
    "speak-numeral",
    "speak-punctuation",
    "speech-rate",
    "stress",
    "string-set",
    "tab-size",
    "table-layout",
    "target",
    "target-name",
    "target-new",
    "target-position",
    "text-align",
    "text-align-last",
    "text-combine-upright",
    "text-decoration",
    "text-decoration-color",
    "text-decoration-line",
    "text-decoration-skip",
    "text-decoration-skip-ink",
    "text-decoration-style",
    "text-emphasis",
    "text-emphasis-color",
    "text-emphasis-position",
    "text-emphasis-style",
    "text-height",
    "text-indent",
    "text-justify",
    "text-orientation",
    "text-outline",
    "text-overflow",
    "text-rendering",
    "text-shadow",
    "text-size-adjust",
    "text-space-collapse",
    "text-transform",
    "text-underline-position",
    "text-wrap",
    "top",
    "touch-action",
    "transform",
    "transform-origin",
    "transform-style",
    "transition",
    "transition-delay",
    "transition-duration",
    "transition-property",
    "transition-timing-function",
    "translate",
    "unicode-bidi",
    "user-select",
    "vertical-align",
    "visibility",
    "voice-balance",
    "voice-duration",
    "voice-family",
    "voice-pitch",
    "voice-range",
    "voice-rate",
    "voice-stress",
    "voice-volume",
    "volume",
    "white-space",
    "widows",
    "width",
    "will-change",
    "word-break",
    "word-spacing",
    "word-wrap",
    "writing-mode",
    "z-index",
    "clip-path",
    "clip-rule",
    "mask",
    "enable-background",
    "filter",
    "flood-color",
    "flood-opacity",
    "lighting-color",
    "stop-color",
    "stop-opacity",
    "pointer-events",
    "color-interpolation",
    "color-interpolation-filters",
    "color-rendering",
    "fill",
    "fill-opacity",
    "fill-rule",
    "image-rendering",
    "marker",
    "marker-end",
    "marker-mid",
    "marker-start",
    "paint-order",
    "shape-rendering",
    "stroke",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "text-rendering",
    "baseline-shift",
    "dominant-baseline",
    "glyph-orientation-horizontal",
    "glyph-orientation-vertical",
    "text-anchor",
    "writing-mode"
  ], propertyKeywords = keySet(propertyKeywords_);
  var nonStandardPropertyKeywords_ = [
    "accent-color",
    "aspect-ratio",
    "border-block",
    "border-block-color",
    "border-block-end",
    "border-block-end-color",
    "border-block-end-style",
    "border-block-end-width",
    "border-block-start",
    "border-block-start-color",
    "border-block-start-style",
    "border-block-start-width",
    "border-block-style",
    "border-block-width",
    "border-inline",
    "border-inline-color",
    "border-inline-end",
    "border-inline-end-color",
    "border-inline-end-style",
    "border-inline-end-width",
    "border-inline-start",
    "border-inline-start-color",
    "border-inline-start-style",
    "border-inline-start-width",
    "border-inline-style",
    "border-inline-width",
    "content-visibility",
    "margin-block",
    "margin-block-end",
    "margin-block-start",
    "margin-inline",
    "margin-inline-end",
    "margin-inline-start",
    "overflow-anchor",
    "overscroll-behavior",
    "padding-block",
    "padding-block-end",
    "padding-block-start",
    "padding-inline",
    "padding-inline-end",
    "padding-inline-start",
    "scroll-snap-stop",
    "scrollbar-3d-light-color",
    "scrollbar-arrow-color",
    "scrollbar-base-color",
    "scrollbar-dark-shadow-color",
    "scrollbar-face-color",
    "scrollbar-highlight-color",
    "scrollbar-shadow-color",
    "scrollbar-track-color",
    "searchfield-cancel-button",
    "searchfield-decoration",
    "searchfield-results-button",
    "searchfield-results-decoration",
    "shape-inside",
    "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);
  var fontProperties_ = [
    "font-display",
    "font-family",
    "src",
    "unicode-range",
    "font-variant",
    "font-feature-settings",
    "font-stretch",
    "font-weight",
    "font-style"
  ], fontProperties = keySet(fontProperties_);
  var counterDescriptors_ = [
    "additive-symbols",
    "fallback",
    "negative",
    "pad",
    "prefix",
    "range",
    "speak-as",
    "suffix",
    "symbols",
    "system"
  ], counterDescriptors = keySet(counterDescriptors_);
  var colorKeywords_ = [
    "aliceblue",
    "antiquewhite",
    "aqua",
    "aquamarine",
    "azure",
    "beige",
    "bisque",
    "black",
    "blanchedalmond",
    "blue",
    "blueviolet",
    "brown",
    "burlywood",
    "cadetblue",
    "chartreuse",
    "chocolate",
    "coral",
    "cornflowerblue",
    "cornsilk",
    "crimson",
    "cyan",
    "darkblue",
    "darkcyan",
    "darkgoldenrod",
    "darkgray",
    "darkgreen",
    "darkgrey",
    "darkkhaki",
    "darkmagenta",
    "darkolivegreen",
    "darkorange",
    "darkorchid",
    "darkred",
    "darksalmon",
    "darkseagreen",
    "darkslateblue",
    "darkslategray",
    "darkslategrey",
    "darkturquoise",
    "darkviolet",
    "deeppink",
    "deepskyblue",
    "dimgray",
    "dimgrey",
    "dodgerblue",
    "firebrick",
    "floralwhite",
    "forestgreen",
    "fuchsia",
    "gainsboro",
    "ghostwhite",
    "gold",
    "goldenrod",
    "gray",
    "grey",
    "green",
    "greenyellow",
    "honeydew",
    "hotpink",
    "indianred",
    "indigo",
    "ivory",
    "khaki",
    "lavender",
    "lavenderblush",
    "lawngreen",
    "lemonchiffon",
    "lightblue",
    "lightcoral",
    "lightcyan",
    "lightgoldenrodyellow",
    "lightgray",
    "lightgreen",
    "lightgrey",
    "lightpink",
    "lightsalmon",
    "lightseagreen",
    "lightskyblue",
    "lightslategray",
    "lightslategrey",
    "lightsteelblue",
    "lightyellow",
    "lime",
    "limegreen",
    "linen",
    "magenta",
    "maroon",
    "mediumaquamarine",
    "mediumblue",
    "mediumorchid",
    "mediumpurple",
    "mediumseagreen",
    "mediumslateblue",
    "mediumspringgreen",
    "mediumturquoise",
    "mediumvioletred",
    "midnightblue",
    "mintcream",
    "mistyrose",
    "moccasin",
    "navajowhite",
    "navy",
    "oldlace",
    "olive",
    "olivedrab",
    "orange",
    "orangered",
    "orchid",
    "palegoldenrod",
    "palegreen",
    "paleturquoise",
    "palevioletred",
    "papayawhip",
    "peachpuff",
    "peru",
    "pink",
    "plum",
    "powderblue",
    "purple",
    "rebeccapurple",
    "red",
    "rosybrown",
    "royalblue",
    "saddlebrown",
    "salmon",
    "sandybrown",
    "seagreen",
    "seashell",
    "sienna",
    "silver",
    "skyblue",
    "slateblue",
    "slategray",
    "slategrey",
    "snow",
    "springgreen",
    "steelblue",
    "tan",
    "teal",
    "thistle",
    "tomato",
    "turquoise",
    "violet",
    "wheat",
    "white",
    "whitesmoke",
    "yellow",
    "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);
  var valueKeywords_ = [
    "above",
    "absolute",
    "activeborder",
    "additive",
    "activecaption",
    "afar",
    "after-white-space",
    "ahead",
    "alias",
    "all",
    "all-scroll",
    "alphabetic",
    "alternate",
    "always",
    "amharic",
    "amharic-abegede",
    "antialiased",
    "appworkspace",
    "arabic-indic",
    "armenian",
    "asterisks",
    "attr",
    "auto",
    "auto-flow",
    "avoid",
    "avoid-column",
    "avoid-page",
    "avoid-region",
    "axis-pan",
    "background",
    "backwards",
    "baseline",
    "below",
    "bidi-override",
    "binary",
    "bengali",
    "blink",
    "block",
    "block-axis",
    "blur",
    "bold",
    "bolder",
    "border",
    "border-box",
    "both",
    "bottom",
    "break",
    "break-all",
    "break-word",
    "brightness",
    "bullets",
    "button",
    "button-bevel",
    "buttonface",
    "buttonhighlight",
    "buttonshadow",
    "buttontext",
    "calc",
    "cambodian",
    "capitalize",
    "caps-lock-indicator",
    "caption",
    "captiontext",
    "caret",
    "cell",
    "center",
    "checkbox",
    "circle",
    "cjk-decimal",
    "cjk-earthly-branch",
    "cjk-heavenly-stem",
    "cjk-ideographic",
    "clear",
    "clip",
    "close-quote",
    "col-resize",
    "collapse",
    "color",
    "color-burn",
    "color-dodge",
    "column",
    "column-reverse",
    "compact",
    "condensed",
    "contain",
    "content",
    "contents",
    "content-box",
    "context-menu",
    "continuous",
    "contrast",
    "copy",
    "counter",
    "counters",
    "cover",
    "crop",
    "cross",
    "crosshair",
    "cubic-bezier",
    "currentcolor",
    "cursive",
    "cyclic",
    "darken",
    "dashed",
    "decimal",
    "decimal-leading-zero",
    "default",
    "default-button",
    "dense",
    "destination-atop",
    "destination-in",
    "destination-out",
    "destination-over",
    "devanagari",
    "difference",
    "disc",
    "discard",
    "disclosure-closed",
    "disclosure-open",
    "document",
    "dot-dash",
    "dot-dot-dash",
    "dotted",
    "double",
    "down",
    "drop-shadow",
    "e-resize",
    "ease",
    "ease-in",
    "ease-in-out",
    "ease-out",
    "element",
    "ellipse",
    "ellipsis",
    "embed",
    "end",
    "ethiopic",
    "ethiopic-abegede",
    "ethiopic-abegede-am-et",
    "ethiopic-abegede-gez",
    "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et",
    "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et",
    "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez",
    "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et",
    "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er",
    "ethiopic-halehame-ti-et",
    "ethiopic-halehame-tig",
    "ethiopic-numeric",
    "ew-resize",
    "exclusion",
    "expanded",
    "extends",
    "extra-condensed",
    "extra-expanded",
    "fantasy",
    "fast",
    "fill",
    "fill-box",
    "fixed",
    "flat",
    "flex",
    "flex-end",
    "flex-start",
    "footnotes",
    "forwards",
    "from",
    "geometricPrecision",
    "georgian",
    "grayscale",
    "graytext",
    "grid",
    "groove",
    "gujarati",
    "gurmukhi",
    "hand",
    "hangul",
    "hangul-consonant",
    "hard-light",
    "hebrew",
    "help",
    "hidden",
    "hide",
    "higher",
    "highlight",
    "highlighttext",
    "hiragana",
    "hiragana-iroha",
    "horizontal",
    "hsl",
    "hsla",
    "hue",
    "hue-rotate",
    "icon",
    "ignore",
    "inactiveborder",
    "inactivecaption",
    "inactivecaptiontext",
    "infinite",
    "infobackground",
    "infotext",
    "inherit",
    "initial",
    "inline",
    "inline-axis",
    "inline-block",
    "inline-flex",
    "inline-grid",
    "inline-table",
    "inset",
    "inside",
    "intrinsic",
    "invert",
    "italic",
    "japanese-formal",
    "japanese-informal",
    "justify",
    "kannada",
    "katakana",
    "katakana-iroha",
    "keep-all",
    "khmer",
    "korean-hangul-formal",
    "korean-hanja-formal",
    "korean-hanja-informal",
    "landscape",
    "lao",
    "large",
    "larger",
    "left",
    "level",
    "lighter",
    "lighten",
    "line-through",
    "linear",
    "linear-gradient",
    "lines",
    "list-item",
    "listbox",
    "listitem",
    "local",
    "logical",
    "loud",
    "lower",
    "lower-alpha",
    "lower-armenian",
    "lower-greek",
    "lower-hexadecimal",
    "lower-latin",
    "lower-norwegian",
    "lower-roman",
    "lowercase",
    "ltr",
    "luminosity",
    "malayalam",
    "manipulation",
    "match",
    "matrix",
    "matrix3d",
    "media-controls-background",
    "media-current-time-display",
    "media-fullscreen-button",
    "media-mute-button",
    "media-play-button",
    "media-return-to-realtime-button",
    "media-rewind-button",
    "media-seek-back-button",
    "media-seek-forward-button",
    "media-slider",
    "media-sliderthumb",
    "media-time-remaining-display",
    "media-volume-slider",
    "media-volume-slider-container",
    "media-volume-sliderthumb",
    "medium",
    "menu",
    "menulist",
    "menulist-button",
    "menulist-text",
    "menulist-textfield",
    "menutext",
    "message-box",
    "middle",
    "min-intrinsic",
    "mix",
    "mongolian",
    "monospace",
    "move",
    "multiple",
    "multiple_mask_images",
    "multiply",
    "myanmar",
    "n-resize",
    "narrower",
    "ne-resize",
    "nesw-resize",
    "no-close-quote",
    "no-drop",
    "no-open-quote",
    "no-repeat",
    "none",
    "normal",
    "not-allowed",
    "nowrap",
    "ns-resize",
    "numbers",
    "numeric",
    "nw-resize",
    "nwse-resize",
    "oblique",
    "octal",
    "opacity",
    "open-quote",
    "optimizeLegibility",
    "optimizeSpeed",
    "oriya",
    "oromo",
    "outset",
    "outside",
    "outside-shape",
    "overlay",
    "overline",
    "padding",
    "padding-box",
    "painted",
    "page",
    "paused",
    "persian",
    "perspective",
    "pinch-zoom",
    "plus-darker",
    "plus-lighter",
    "pointer",
    "polygon",
    "portrait",
    "pre",
    "pre-line",
    "pre-wrap",
    "preserve-3d",
    "progress",
    "push-button",
    "radial-gradient",
    "radio",
    "read-only",
    "read-write",
    "read-write-plaintext-only",
    "rectangle",
    "region",
    "relative",
    "repeat",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "repeat-x",
    "repeat-y",
    "reset",
    "reverse",
    "rgb",
    "rgba",
    "ridge",
    "right",
    "rotate",
    "rotate3d",
    "rotateX",
    "rotateY",
    "rotateZ",
    "round",
    "row",
    "row-resize",
    "row-reverse",
    "rtl",
    "run-in",
    "running",
    "s-resize",
    "sans-serif",
    "saturate",
    "saturation",
    "scale",
    "scale3d",
    "scaleX",
    "scaleY",
    "scaleZ",
    "screen",
    "scroll",
    "scrollbar",
    "scroll-position",
    "se-resize",
    "searchfield",
    "searchfield-cancel-button",
    "searchfield-decoration",
    "searchfield-results-button",
    "searchfield-results-decoration",
    "self-start",
    "self-end",
    "semi-condensed",
    "semi-expanded",
    "separate",
    "sepia",
    "serif",
    "show",
    "sidama",
    "simp-chinese-formal",
    "simp-chinese-informal",
    "single",
    "skew",
    "skewX",
    "skewY",
    "skip-white-space",
    "slide",
    "slider-horizontal",
    "slider-vertical",
    "sliderthumb-horizontal",
    "sliderthumb-vertical",
    "slow",
    "small",
    "small-caps",
    "small-caption",
    "smaller",
    "soft-light",
    "solid",
    "somali",
    "source-atop",
    "source-in",
    "source-out",
    "source-over",
    "space",
    "space-around",
    "space-between",
    "space-evenly",
    "spell-out",
    "square",
    "square-button",
    "start",
    "static",
    "status-bar",
    "stretch",
    "stroke",
    "stroke-box",
    "sub",
    "subpixel-antialiased",
    "svg_masks",
    "super",
    "sw-resize",
    "symbolic",
    "symbols",
    "system-ui",
    "table",
    "table-caption",
    "table-cell",
    "table-column",
    "table-column-group",
    "table-footer-group",
    "table-header-group",
    "table-row",
    "table-row-group",
    "tamil",
    "telugu",
    "text",
    "text-bottom",
    "text-top",
    "textarea",
    "textfield",
    "thai",
    "thick",
    "thin",
    "threeddarkshadow",
    "threedface",
    "threedhighlight",
    "threedlightshadow",
    "threedshadow",
    "tibetan",
    "tigre",
    "tigrinya-er",
    "tigrinya-er-abegede",
    "tigrinya-et",
    "tigrinya-et-abegede",
    "to",
    "top",
    "trad-chinese-formal",
    "trad-chinese-informal",
    "transform",
    "translate",
    "translate3d",
    "translateX",
    "translateY",
    "translateZ",
    "transparent",
    "ultra-condensed",
    "ultra-expanded",
    "underline",
    "unidirectional-pan",
    "unset",
    "up",
    "upper-alpha",
    "upper-armenian",
    "upper-greek",
    "upper-hexadecimal",
    "upper-latin",
    "upper-norwegian",
    "upper-roman",
    "uppercase",
    "urdu",
    "url",
    "var",
    "vertical",
    "vertical-text",
    "view-box",
    "visible",
    "visibleFill",
    "visiblePainted",
    "visibleStroke",
    "visual",
    "w-resize",
    "wait",
    "wave",
    "wider",
    "window",
    "windowframe",
    "windowtext",
    "words",
    "wrap",
    "wrap-reverse",
    "x-large",
    "x-small",
    "xor",
    "xx-large",
    "xx-small"
  ], valueKeywords = keySet(valueKeywords_);
  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
  CodeMirror2.registerHelper("hintWords", "css", allWords);
  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = ch == "*";
    }
    return ["comment", "comment"];
  }
  CodeMirror2.defineMIME("text/css", {
    documentTypes,
    mediaTypes,
    mediaFeatures,
    mediaValueKeywords,
    propertyKeywords,
    nonStandardPropertyKeywords,
    fontProperties,
    counterDescriptors,
    colorKeywords,
    valueKeywords,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*"))
          return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });
  CodeMirror2.defineMIME("text/x-scss", {
    mediaTypes,
    mediaFeatures,
    mediaValueKeywords,
    propertyKeywords,
    nonStandardPropertyKeywords,
    colorKeywords,
    valueKeywords,
    fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/^\s*\{/, false))
          return [null, null];
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{"))
          return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });
  CodeMirror2.defineMIME("text/x-less", {
    mediaTypes,
    mediaFeatures,
    mediaValueKeywords,
    propertyKeywords,
    nonStandardPropertyKeywords,
    colorKeywords,
    valueKeywords,
    fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.eat("{"))
          return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false))
          return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });
  CodeMirror2.defineMIME("text/x-gss", {
    documentTypes,
    mediaTypes,
    mediaFeatures,
    propertyKeywords,
    nonStandardPropertyKeywords,
    fontProperties,
    counterDescriptors,
    colorKeywords,
    valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*"))
          return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });
});
AwsuiCodeHelper.install = (app) => {
  app.component(AwsuiCodeHelper.name, AwsuiCodeHelper);
};
let _common = {};
_common = {
  message,
  messageSuccess,
  messageWarning,
  messageError,
  msgbox,
  alert: alert$1,
  confirm,
  prompt,
  messageObject
};
var Message = _common;
function messageObject() {
  return {
    message: ElMessage,
    messageBox: ElMessageBox
  };
}
function message(options2) {
  return ElMessage(options2);
}
function messageSuccess(options2) {
  return ElMessage.success(options2);
}
function messageWarning(options2) {
  return ElMessage.warning(options2);
}
function messageError(options2) {
  return ElMessage.error(options2);
}
function msgbox(options2) {
  options2 = Object.assign({
    customClass: "awsui-message-box",
    confirmButtonClass: "awsui-button awsui-button--primary",
    cancelButtonClass: "awsui-button awsui-button--default"
  }, options2);
  return ElMessageBox(options2);
}
function alert$1(message2, title, options2) {
  options2 = Object.assign({
    customClass: "awsui-message-box",
    confirmButtonClass: "awsui-button awsui-button--primary",
    cancelButtonClass: "awsui-button awsui-button--default"
  }, options2);
  return ElMessageBox.alert(message2, title, options2);
}
function confirm(message2, title, options2) {
  options2 = Object.assign({
    customClass: "awsui-message-box",
    confirmButtonClass: "awsui-button awsui-button--primary",
    cancelButtonClass: "awsui-button awsui-button--default"
  }, options2);
  return ElMessageBox.confirm(message2, title, options2);
}
function prompt(message2, title, options2) {
  options2 = Object.assign({
    customClass: "awsui-message-box",
    confirmButtonClass: "awsui-button awsui-button--primary",
    cancelButtonClass: "awsui-button awsui-button--default"
  }, options2);
  return ElMessageBox.prompt(message2, title, options2);
}
const _sfc_main$1 = defineComponent({
  name: "UpgradeService",
  props: {
    upgradeService: {
      type: Boolean,
      default: false
    },
    upgradeServiceData: {
      type: String,
      default: ""
    },
    globalProperties: {
      type: Object
    }
  },
  components: {
    AwsuiDialog,
    AwsuiButton
  },
  setup(props2, ctx2) {
    const { proxy: proxy2 } = getCurrentInstance();
    const isShow = computed({
      get: () => {
        return props2.upgradeService;
      },
      set: (value2) => {
        ctx2.emit("update:upgrade-service", value2);
      }
    });
    watch(isShow, (nval, oval) => {
    });
    const upgradeBtnText = ref("\u8054\u7CFB\u7BA1\u7406\u5458");
    const context = ref("\u6743\u9650\u7EC4");
    const details = ref("\u8BE5\u529F\u80FD\u5E2E\u52A9\u7EC4\u7EC7\u5B9E\u73B0\u7CBE\u51C6\u7684\u6743\u9650\u63A7\u5236\uFF0C\u53EF\u9488\u5BF9\u6743\u9650\u3001\u5C97\u4F4D\u3001\u89D2\u8272\u3001\u7FA4\u7EC4\u8FDB\u884C\u6388\u6743");
    const upgradeServiceInfo = reactive([
      { id: "sec", "module": "\u6743\u9650\u7EC4", "msg": "\u8BE5\u529F\u80FD\u5E2E\u52A9\u7EC4\u7EC7\u5B9E\u73B0\u7CBE\u51C6\u7684\u6743\u9650\u63A7\u5236\uFF0C\u53EF\u9488\u5BF9\u6743\u9650\u3001\u5C97\u4F4D\u3001\u89D2\u8272\u3001\u7FA4\u7EC4\u8FDB\u884C\u6388\u6743" },
      { id: "table", "module": "\u5916\u90E8\u8868\u7ED3\u6784", "msg": "\u8BE5\u529F\u80FD\u5F00\u653E\u5916\u90E8\u8868\u7ED3\u6784" },
      { id: "service", "module": "\u670D\u52A1\u673A\u5668\u4EBA", "msg": "\u8BE5\u529F\u80FD\u63D0\u4F9B\u9AD8\u7EA7\u6D41\u7A0B\u8282\u70B9\u63A7\u4EF6\uFF1A\u7CFB\u7EDF\u4EFB\u52A1\u3001\u811A\u672C\u4EFB\u52A1\u53CA\u591A\u79CD\u673A\u5668\u4EBA\u670D\u52A1" },
      { id: "sql", "module": "\u9AD8\u7EA7\u6570\u636E", "msg": "\u8BE5\u529F\u80FD\u63D0\u4F9B\u9AD8\u7EA7\u6570\u636E\u7684\u8BFB\u5199\u80FD\u529B\uFF0C\u652F\u6301\u5BF9\u5185\u5916\u90E8\u6570\u636E\u6E90\u7684\u8BFB\u53D6\u3001\u5F15\u7528\u3001\u5206\u6790\u7B49\u64CD\u4F5C" },
      { id: "java", "module": "Java\u4E8B\u4EF6", "msg": "\u8BE5\u529F\u80FD\u63D0\u4F9B\u5F00\u653E\u7684\u4E8B\u4EF6\u6CE8\u518C\u5165\u53E3\uFF0C\u53EF\u8BFB\u53D6\u81EA\u5B9A\u4E49Java\u4E8B\u4EF6\u5217\u8868" },
      { id: "job", "module": "\u8C03\u5EA6\u670D\u52A1", "msg": "\u8BE5\u529F\u80FD\u63D0\u4F9BJavaJob\u3001SOAPJob\u3001HTTPJob\u3001SQLJob\u56DB\u79CD\u5B9A\u65F6\u5668\u7C7B\u578B\uFF0C\u4EE5\u6B64\u5B9E\u73B0\u4E1A\u52A1\u6D41\u7A0B\u81EA\u52A8\u5316\u573A\u666F" },
      { id: "cc", "module": "\u8FDE\u63A5\u670D\u52A1", "msg": "\u8BE5\u529F\u80FD\u63D0\u4F9B\u5341\u4F59\u7C7B\u6280\u672F\u9002\u914D\u5668\uFF0C\u6253\u901A\u7EC4\u7EC7\u4E1A\u52A1\u6570\u636E\u5B64\u5C9B" },
      { id: "limit", "module": "\u4EBA\u6570\u9650\u5236", "msg": "\u4F7F\u7528\u4EBA\u6570\u5DF2\u8D85\u8FC7\u7248\u672C\u914D\u989D\uFF0C\u8BF7\u5347\u7EA7\u670D\u52A1\u89C4\u683C\u6216\u8C03\u6574\u6388\u6743\u8303\u56F4" },
      { id: "relation", "module": "\u5173\u7CFB\u56FE", "msg": "\u8BE5\u529F\u80FD\u67E5\u770B\u5E94\u7528\u95F4\u4F9D\u8D56\u548C\u5173\u8054\u5173\u7CFB" }
    ]);
    onMounted(() => {
      console.log(props2.globalProperties, ">>>>>");
      for (var i2 = 0; i2 < upgradeServiceInfo.length; i2++) {
        if (upgradeServiceInfo[i2].id == props2.upgradeServiceData || upgradeServiceInfo[i2].module == props2.upgradeServiceData) {
          context.value = upgradeServiceInfo[i2].module;
          details.value = upgradeServiceInfo[i2].msg;
        }
      }
      if (proxy2.AWSPageContext && proxy2.AWSPageContext.settingParam.isDingDingAdmin || window.isDingDingAdmin) {
        upgradeBtnText.value = "\u53BB\u5347\u7EA7";
      }
    });
    watch(() => props2.upgradeServiceData, (value2) => {
      if (value2) {
        for (var i2 = 0; i2 < upgradeServiceInfo.length; i2++) {
          if (upgradeServiceInfo[i2].id == props2.upgradeServiceData || upgradeServiceInfo[i2].module == value2) {
            context.value = upgradeServiceInfo[i2].module;
            details.value = upgradeServiceInfo[i2].msg;
          }
        }
      }
    }, {
      deep: true,
      immediate: true
    });
    const methods = {
      isShowTab() {
        isShow.value = true;
      },
      diaConfirm() {
        const instance = proxy2.awsuiaxios == null ? props2.globalProperties : proxy2;
        if (instance.AWSPageContext.settingParam.isDingDingAdmin || window.isDingDingAdmin) {
          let url2 = "https://h5.dingtalk.com/open-market/skuDetail.html?dd_share=false&showmenu=false&bizCode=isv&goodsCode=DD_GOODS-101001048203&funnelsource=dingdingda&ddtab=true";
          try {
            top.window.location.href = url2;
            return;
          } catch (e) {
          }
          try {
            window.location.href = url2;
            return;
          } catch (e) {
          }
        } else {
          instance.awsuiaxios.post({
            url: "./jd",
            data: {
              cmd: "CLIENT_M_BIZMODE_DINGDINGDA_SEND_MSG"
            }
          }).then(function(responseObject) {
            instance.$message({
              type: "success",
              message: "\u53D1\u9001\u6210\u529F"
            });
          });
        }
      },
      diaCancel() {
        isShow.value = false;
        proxy2.$emit("diaCancel", false);
      }
    };
    return __spreadValues2({
      isShow,
      context,
      upgradeBtnText,
      details,
      upgradeServiceInfo
    }, methods);
  }
});
const _withScopeId$1 = (n) => (pushScopeId("data-v-412973ba"), n = n(), popScopeId(), n);
const _hoisted_1$1 = { class: "upgradeService" };
const _hoisted_2$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("div", { class: "icon-warp" }, [
  /* @__PURE__ */ createCommentVNode("        #CECECE"),
  /* @__PURE__ */ createElementVNode("i", { class: "awsui-iconfont" }, "\uE9D7"),
  /* @__PURE__ */ createElementVNode("div", null, "400-609-6909")
], -1));
const _hoisted_3$1 = { class: "warp" };
const _hoisted_4$1 = {
  key: 0,
  class: "warp-top"
};
const _hoisted_5$1 = /* @__PURE__ */ createTextVNode("\u5F53\u524D\u7248\u672C\u4E0D\u652F\u6301\u3010 ");
const _hoisted_6$1 = /* @__PURE__ */ createTextVNode(" \u3011\uFF0C\u5347\u7EA7\u670D\u52A1\u53EF\u89E3\u9501 ");
const _hoisted_7$1 = { class: "warp-bottom" };
const _hoisted_8$1 = { class: "button-warp" };
const _hoisted_9$1 = /* @__PURE__ */ createTextVNode(" \u4E0B\u6B21\u518D\u8BF4 ");
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_awsui_button = resolveComponent("awsui-button");
  const _component_awsui_dialog = resolveComponent("awsui-dialog");
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    createVNode(_component_awsui_dialog, {
      modelValue: _ctx.isShow,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.isShow = $event),
      modal: true,
      "close-on-click-modal": false
    }, {
      footer: withCtx(() => [
        createElementVNode("div", _hoisted_8$1, [
          createVNode(_component_awsui_button, {
            type: "primary",
            onClick: _ctx.diaConfirm
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.upgradeBtnText), 1)
            ]),
            _: 1
          }, 8, ["onClick"]),
          createVNode(_component_awsui_button, {
            class: "quit",
            onClick: _ctx.diaCancel
          }, {
            default: withCtx(() => [
              _hoisted_9$1
            ]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      default: withCtx(() => [
        _hoisted_2$1,
        createElementVNode("div", _hoisted_3$1, [
          _ctx.context !== "\u4EBA\u6570\u9650\u5236" ? (openBlock(), createElementBlock("div", _hoisted_4$1, [
            _hoisted_5$1,
            createElementVNode("span", null, toDisplayString(_ctx.context), 1),
            _hoisted_6$1
          ])) : createCommentVNode("v-if", true),
          createElementVNode("div", _hoisted_7$1, toDisplayString(_ctx.details), 1)
        ])
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var upgradeService = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-412973ba"]]);
const _sfc_main = defineComponent({
  name: "ac-address",
  components: {
    ElScrollbar,
    AwsuiCheckbox,
    AwsuiButton,
    ElTree,
    ElSelect,
    ElOption: ElOption$2,
    AwsuiDialog,
    upgradeService
  },
  props: {
    globalProperties: Object,
    dialogVisible: {
      type: Boolean,
      default: false
    },
    setting: {
      type: Object,
      default: () => {
        return {};
      }
    }
  },
  setup(props2, ctx2) {
    const { proxy: $this } = getCurrentInstance();
    const setting = props2.setting;
    const isUpgradeService = ref(false);
    const iconJSON = {
      permission: "&#xe60e;",
      company: "&#xe6ff;",
      department: "&#59318;",
      user: "&#58939;",
      role: "&#59048;",
      team: "&#xe6f9;"
    };
    const treeKey = ref("");
    const setRef = (el) => {
      treeKey.value = el;
    };
    const isShow = computed({
      get: () => {
        return props2.dialogVisible;
      },
      set: (value2) => {
        ctx2.emit("update:dialogVisible", value2);
      }
    });
    const options2 = ref([]);
    const companyId = ref("");
    const invoke = ref("");
    const showPosition = ref(false);
    const values = ref([]);
    const list = ref([]);
    const loading = ref(false);
    const states = ref([]);
    const idx = ref(0);
    const titleType = ref("");
    const currentNodeKey = ref("");
    ref(false);
    const isChecked = ref(true);
    const isSearch = ref(false);
    const isShowCheck = ref(false);
    const isShowBottom = ref(true);
    const isShowDetail = ref(false);
    const isPermission = ref(false);
    const isAdd = ref(true);
    const checked = false;
    const checkedList = ref([]);
    const defaultExpandKeys = ref();
    const isValue = ref();
    let navList = [];
    const urlAxios = axios;
    let treeList = ref([]);
    let treeAll = ref([]);
    const acTypeList = ref([]);
    let newArr = reactive([]);
    let addList = reactive([]);
    const id2 = ref("");
    const type2 = ref("");
    const acList = reactive([]);
    const permissions = ref("");
    const roleType = ref();
    const acLists = ref([]);
    const arrsss = ref([]);
    const str = ref(" ");
    const upgradeServiceData = ref("\u6743\u9650\u7EC4");
    const permissionAcTypeName = ref("");
    const permissionChecked = ref(false);
    const checkedNodes = ref(-1);
    const imgUrl = "../commons/js/jquery/themes/default/ui/images/noResult.png";
    const searchArr = reactive([]);
    const defaultProps2 = {
      label: "name",
      isLeaf: "users"
    };
    const ids = ref("");
    const isButton = ref(true);
    watch(checkedList, (nval, oval) => {
      if (nval.length < oval.length) {
        isAdd.value = false;
      } else {
        isAdd.value = true;
      }
    });
    const getTreelist = (show) => {
      let isDingDingDaRuntime = window.isDingDingDaRuntime;
      let assignmentTypes = setting.assignmentTypes;
      var arr = assignmentTypes == null ? void 0 : assignmentTypes.split(",");
      let arrs = [];
      let isPermission2 = false;
      for (var s = 0; s < arr.length; s++) {
        if (arr[s] == "permission") {
          isPermission2 = true;
          continue;
        }
        if (arr[s] == "department" || arr[s] == "user" || arr[s] == "company") {
          arrs.push(arr[s]);
        } else {
          arrs.push(arr[s]);
        }
      }
      if (isPermission2) {
        arrs.push("permission");
      }
      let assignmentDatas = arrs.join(",");
      let groupType = "";
      arrs.forEach((items, index2) => {
        if (items == "department" || items == "user" || items == "company") {
          groupType = "org";
        }
      });
      urlAxios.post({
        url: "jd",
        data: {
          sid: setting.sid,
          cmd: "CLIENT_COMMON_AC_JSON",
          resourceId: setting.resourceId,
          resourceType: setting.resourceType,
          assignmentTypes: isDingDingDaRuntime ? assignmentDatas : setting.assignmentTypes,
          groupType: isDingDingDaRuntime ? groupType : setting.groupType,
          permissionType: setting.permissionType,
          accessModeScope: setting.accessModeScope,
          isRestrict: setting.isRestrict ? setting.isRestrict : false
        }
      }).then(function(r) {
        if (r.result == "ok") {
          checkedNodes.value = r.data.limitUserCount;
          permissionAcTypeName.value = r.data.permissionAcTypeName;
          if (permissionChecked.value) {
            isButton.value = false;
          }
          treeAll.value = r.data.acList;
          treeList.value = r.data.treeList;
          if (treeList.value.length > 0) {
            defaultExpandKeys.value = [treeList.value[0] ? treeList.value[0].id : ""];
          }
          let treeListLength = treeList.value.length;
          for (let i22 = 0; i22 < treeListLength; i22++) {
            if (treeList.value[i22].pid) {
              treeList.value.splice(i22, 1);
              i22--;
              treeListLength--;
            }
            if (treeList.value[i22].nocheck) {
              treeList.value[i22].disabled = true;
            }
          }
          companyId.value = r.data.companyId;
          invoke.value = r.data.invoke;
          showPosition.value = r.data.showPosition;
          if (show) {
            acTypeList.value = r.data.acTypeList;
            if (r.data.acList.length > 0) {
              isShowCheck.value = false;
              isShowBottom.value = false;
              isShowDetail.value = true;
              acLists.value = r.data.acList;
            }
            if (setting.callback) {
              setting.callback(acLists.value);
            }
            let tabArray = {
              "permission": "\u6743\u9650",
              "org": "\u7EC4\u7EC7",
              "position": "\u5C97\u4F4D",
              "role": "\u89D2\u8272",
              "team": "\u7FA4\u7EC4"
            };
            let isPermission3 = false;
            let tempList = r.data.assignmentTypesList;
            for (var k = 0; k < tempList.length; k++) {
              if (tempList[k] == "permission" && isDingDingDaRuntime) {
                isPermission3 = true;
                continue;
              }
              if (tempList[k] == "department" || tempList[k] == "user" || tempList[k] == "company") {
                navList.push({
                  id: "org",
                  label: tabArray["org"]
                });
              } else {
                navList.push({
                  id: tempList[k],
                  label: tabArray[tempList[k]]
                });
              }
            }
            if (isPermission3) {
              navList.push({
                id: "permission",
                label: tabArray["permission"]
              });
            }
            let nameMap = {};
            for (var i2 = 0; i2 < navList.length; i2++) {
              if (!nameMap[navList[i2].label]) {
                newArr.push(navList[i2]);
                nameMap[navList[i2].label] = true;
              }
            }
            for (var j = 0; j < newArr.length; j++) {
              if (JSON.stringify(newArr[j]) == "{}") {
                newArr.splice(j, 1);
              }
            }
          }
          titleType.value = newArr[0].id;
          if (newArr[0].label == "\u5C97\u4F4D") {
            roleType.value = 1;
          } else {
            roleType.value = 0;
          }
        }
      });
    };
    const remoteMethod = (query) => {
      if (query !== "") {
        ids.value = "search";
        loading.value = false;
        urlAxios.post({
          url: "jd",
          data: {
            sid: setting.sid,
            cmd: "CLIENT_COMMON_AC_SEARCH",
            companyId: companyId.value,
            type: titleType.value,
            keyWord: query,
            page: 1,
            limit: 12,
            resourceType: setting.resourceType,
            invoke: invoke.value,
            showPosition: showPosition.value ? "0" : "1"
          }
        }).then(function(r) {
          if (r.data.list.length > 0) {
            list.value = r.data.list.map((item) => {
              return { value: { item }, label: `${item.text}`, text: `${item.showtextsuffix}` };
            });
            options2.value = list.value.filter((item) => {
              return item.label.toLowerCase().indexOf(query.toLowerCase()) > -1 || item.text.toLowerCase().indexOf(query.toLowerCase()) > -1;
            });
            if (permissionChecked.value || r.data.list[0].type == "permission") {
              permissionChecked.value = true;
              acLists.value.forEach((group) => {
                group.acList.forEach((item) => {
                  options2.value.forEach((target, index2) => {
                    if (item.permissionId == target.value.item.id) {
                      options2.value.splice(index2, 1);
                    }
                  });
                });
              });
            }
          }
        });
      } else {
        options2.value = [];
      }
    };
    const checkTab = (checkedNodesParam, checkedKeysany) => {
      if (acTypeList.value.length == 1) {
        checkedList.value[0] = acTypeList.value[0].label;
        isAdd.value = true;
        changetab(acTypeList.value[0]);
      }
      if (isPermission.value) {
        permissionChecked.value = true;
      }
      let personNum = 0;
      acLists.value.forEach((item) => {
        personNum += item.acList.length;
      });
      checkedKeysany.checkedNodes.forEach((item) => {
        if (item.type == "user") {
          personNum++;
        }
      });
      if (personNum > checkedNodes.value && checkedNodes.value > 0) {
        let index2 = checkedKeysany.checkedKeys.indexOf(checkedNodesParam.id);
        if (index2 > -1) {
          let treeCheckList = checkedKeysany.checkedKeys;
          treeCheckList.splice(index2, 1);
          treeKey.value.setCheckedKeys(treeCheckList);
          if (treeCheckList.length <= 0) {
            isShowCheck.value = false;
            isPermission.value = false;
            if (acLists.value.length > 0) {
              isShowBottom.value = false;
              isShowDetail.value = true;
            }
          }
        }
        upgradeServiceData.value = "limit";
        isUpgradeService.value = true;
        return;
      }
      if (checkedKeysany.checkedNodes.length <= 0) {
        isShowCheck.value = false;
        isPermission.value = false;
        if (acLists.value.length > 0) {
          isShowBottom.value = false;
          isShowDetail.value = true;
        }
      }
    };
    const tabClick = (name2, indexs) => {
      isButton.value = false;
      acList.length = 0;
      if (name2.id == "permission") {
        permissionChecked.value = true;
      } else {
        permissionChecked.value = false;
      }
      if (permissionChecked.value) {
        isButton.value = false;
      } else {
        isButton.value = true;
      }
      if (name2.id !== "org" && window.isDingDingDaRuntime) {
        upgradeServiceData.value = "sec";
        isUpgradeService.value = true;
        return;
      }
      if (name2.label == "\u5C97\u4F4D") {
        roleType.value = 1;
      } else {
        roleType.value = 0;
      }
      isPermission.value = false;
      isShowCheck.value = false;
      if (acLists.value.length > 0) {
        isShowDetail.value = true;
      } else {
        isShowBottom.value = true;
      }
      idx.value = indexs;
      titleType.value = name2.id;
      urlAxios.post({
        url: "jd",
        data: {
          sid: setting.sid,
          cmd: "CLIENT_COMMON_AC_GROUP",
          groupType: name2.id,
          resourceType: setting.resourceType,
          assignmentTypes: setting.assignmentTypes,
          companyId: companyId.value,
          invoke: invoke.value
        }
      }).then(function(r) {
        treeList.value = r;
        for (let i2 = 0; i2 < treeList.value.length; i2++) {
          if (treeList.value[i2].pid) {
            treeList.value.splice(i2, 1);
            i2--;
          }
          if (treeList.value[i2].nocheck) {
            treeList.value[i2].disabled = true;
          }
        }
        let permissionId = "";
        treeAll.value.forEach((item) => {
          item.acList.forEach((item1) => {
            permissionId = item1.permissionId;
            if (treeList.value.childrens) {
              treeList.value.childrens.forEach((treenode, index2) => {
                if (treenode.nocheck) {
                  treeList.value.childrens[index2].disabled = true;
                }
                if (permissionId && permissionId == treenode.id) {
                  treeList.value.childrens[index2].disabled = true;
                }
              });
            }
          });
        });
        defaultExpandKeys.value = treeList.value.length > 0 ? [treeList.value[0].id] : [];
      });
    };
    const checkChange = (data, checkeds) => {
      if (data.type == "permission") {
        ids.value = "permission";
      } else {
        ids.value = "tree";
      }
      if (checkeds) {
        id2.value = data.id;
        type2.value = data.type;
        acList.push({
          assignmentId: id2.value,
          assignmentType: type2.value,
          checked: checkeds
        });
      } else {
        acList.forEach((item, index2) => {
          if (item.assignmentId == data.id) {
            acList.splice(index2, 1);
          }
        });
      }
      if (checkeds) {
        isShowCheck.value = true;
        isShowBottom.value = false;
        isShowDetail.value = true;
        isPermission.value = false;
      }
      if (checkeds && type2.value == "permission") {
        isShowCheck.value = false;
        isPermission.value = true;
        isShowBottom.value = false;
        isShowDetail.value = true;
      }
      if (!checkeds) {
        isShowBottom.value = false;
        isShowDetail.value = false;
      }
      if (!checkeds && type2.value == "permission") {
        isShowBottom.value = false;
        isShowDetail.value = true;
      }
      if (acLists.value.length > 0) {
        isShowBottom.value = false;
        isShowDetail.value = true;
      }
    };
    const changetab = (data) => {
      if (checkedList.value.length > 0 || permissionChecked.value) {
        isButton.value = false;
      } else {
        isButton.value = true;
      }
      isValue.value = data.value;
      if (checkedList.value.length > 0) {
        addList.push({
          value: data.value,
          checkeds: isAdd.value
        });
      }
    };
    if (values.value.length > 0) {
      isShowCheck.value = true;
    }
    const treeAaa = () => {
      var v = acList.find((value2) => {
        if (!value2.checked) {
          return value2;
        }
      });
      acList.forEach((item, index2) => {
        if (v && v.assignmentId == item.assignmentId) {
          acList.splice(index2, 1);
        }
      });
      var arrs = JSON.parse(JSON.stringify(acList));
      arrs.forEach((item, index2) => {
        if (!item.checked) {
          arrs.splice(index2, 1);
        }
      });
      return arrs;
    };
    const searchAdd = () => {
      var arrs = [];
      searchArr.length = 0;
      arrsss.value = [];
      for (var r = 0; r < values.value.length; r++) {
        arrs = list.value.filter((item) => {
          return item.value.item.id == values.value[r];
        });
      }
      arrsss.value = arrsss.value.concat(arrs);
      arrsss.value.forEach((item) => {
        searchArr.push({
          assignmentId: item.value.item.id,
          assignmentType: item.value.item.type
        });
      });
    };
    const checkAdd = () => {
      var w = addList.find((value2) => {
        if (!value2.checkeds) {
          return value2;
        }
      });
      addList.forEach((item, index2) => {
        if (w && w.value == item.value) {
          addList.splice(index2, 1);
        }
      });
      var arrAdd = JSON.parse(JSON.stringify(addList));
      arrAdd.forEach((item, index2) => {
        if (!item.checkeds) {
          arrAdd.splice(index2, 1);
          index2--;
        }
      });
      return arrAdd;
    };
    const getTreeItem = (treeItem, targetData) => {
      if (treeItem.id && treeItem.id == targetData) {
        treeItem["disabled"] = true;
        return true;
      } else if (treeItem.childrens || treeItem.childrens > 0) {
        treeItem.childrens.forEach((child) => {
          getTreeItem(child, targetData);
        });
      }
    };
    const permissionAdd = () => {
      if (values.value.length > 0) {
        for (let r = 0; r < values.value.length; r++) {
          treeList.value.forEach((li) => {
            if (getTreeItem(li, values.value[r]))
              return;
          });
        }
      }
      let str2 = treeKey.value.getCheckedKeys().length > 0 ? treeKey.value.getCheckedKeys().join(" ") : values.value.join(" ");
      var aa = treeKey.value.getCheckedNodes();
      for (var i2 = 0; i2 < aa.length; i2++) {
        aa[i2].disabled = true;
      }
      let obj = {
        resourceId: setting.resourceId,
        resourceType: setting.resourceType
      };
      urlAxios.post({
        url: "jd",
        data: {
          sid: setting.sid,
          cmd: "CLIENT_M_COMMON_SECURITYGROUP_SAVE",
          id: setting.resourceId,
          pid: "{}",
          securityList: str2,
          permissionType: setting.permissionType,
          params: JSON.stringify(obj)
        }
      }).then(function(r) {
        acLists.value = r.data.acList;
        if (acLists.value && acLists.value.length > 0) {
          isShowBottom.value = false;
        }
        treeAll.value = r.data.acList;
      });
    };
    const buttonTab = () => {
      if (isPermission.value) {
        isButton.value = false;
      } else {
        isButton.value = true;
      }
      if (ids.value == "permission" || titleType.value == "permission") {
        permissionAdd();
      } else {
        searchAdd();
        var arrs = treeAaa();
        if (checkedList.value.length <= 0) {
          ElMessage.warning({
            message: "\u8BF7\u9009\u62E9\u6388\u6743\u7C7B\u578B",
            type: "warning"
          });
        }
      }
      isShowCheck.value = false;
      isPermission.value = false;
      nextTick(() => {
        treeKey.value.setCheckedKeys([]);
        checkedList.value = [];
      });
      var arrAdd = checkAdd();
      let listss = [];
      if (ids.value == "tree") {
        for (let i2 = 0; i2 < arrs.length; i2++) {
          let tmp = arrs[i2];
          for (let j = 0; j < arrAdd.length; j++) {
            let obj = {};
            obj.assignmentId = tmp.assignmentId;
            obj.assignmentType = tmp.assignmentType;
            var opt = arrAdd[j];
            obj.acTypeNameOpt = opt.value;
            listss.push(obj);
          }
        }
      } else if (ids.value == "search") {
        for (let i2 = 0; i2 < searchArr.length; i2++) {
          let tmp1 = searchArr[i2];
          for (let j = 0; j < arrAdd.length; j++) {
            let obj1 = {};
            obj1.assignmentId = tmp1.assignmentId;
            obj1.assignmentType = tmp1.assignmentType;
            var opt1 = arrAdd[j];
            if (!opt1.checkeds) {
              continue;
            }
            obj1.acTypeNameOpt = opt1.value;
            listss.push(obj1);
          }
        }
      }
      urlAxios.post({
        url: "jd",
        data: {
          sid: setting.sid,
          cmd: "CLIENT_COMMON_AC_ADD",
          resourceType: setting.resourceType,
          resourceId: setting.resourceId,
          accessMode: 0,
          acList: JSON.stringify(listss),
          permissionType: setting.permissionType
        }
      }).then(function(r) {
        addList = [];
        acList.splice(0, acList.length);
        str.value = " ";
        permissions.value = "";
        isShowDetail.value = true;
        acLists.value = r.data.acListJson;
        values.value = [];
        if (acLists.value && acLists.value.length > 0) {
          isShowBottom.value = false;
        }
      });
    };
    const loadNode = (node, resolve, data) => {
      if (node.level >= 1) {
        const pid = node.data.id;
        const type22 = node.data.type;
        const name2 = node.data.name;
        urlAxios.post({
          url: "jd",
          data: {
            sid: setting.sid,
            type: type22,
            pid,
            invoke: invoke.value,
            assignmentType: 0,
            assignmentTypes: setting.assignmentTypes,
            resourceType: setting.resourceType,
            nodeid: name2,
            roleType: roleType.value,
            cmd: "CLIENT_COMMON_AC_SUBDATA"
          }
        }).then((r) => {
          r.forEach((item) => {
            if (item.type == "user" || item.type == "permission" || item.type == "role" || item.type == "position") {
              item.users = true;
            } else {
              item.users = false;
            }
            if (item.nocheck) {
              item.disabled = true;
            }
          });
          node.data.childrens = r;
          resolve(r);
          treeAll.value.forEach((item, index2) => {
            item.acList.forEach((item1, index1) => {
              node.data.childrens.forEach((treenode, indexnode) => {
                if (treenode.nocheck) {
                  node.data.childrens[indexnode].disabled = true;
                }
                if (item1.permissionId && item1.permissionId == treenode.id) {
                  node.data.childrens[indexnode].disabled = true;
                }
              });
            });
          });
        });
      }
    };
    watch(isShow, (nval, oval) => {
      if (nval) {
        getTreelist(true);
      } else {
        if (setting.callback) {
          setting.callback(acLists.value);
        }
        idx.value = 0;
        treeList.value = [];
        acLists.value = [];
        navList.length = 0;
        newArr.length = 0;
        isShowCheck.value = false;
        isPermission.value = false;
        isShowDetail.value = false;
        isSearch.value = false;
        acTypeList.value = [];
        options2.value = [];
        checkedList.value = [];
        permissionChecked.value = false;
      }
    });
    const getItem = (treeItem, targetData) => {
      if (treeItem.id && treeItem.id == targetData.permissionId) {
        treeItem["disabled"] = false;
        return true;
      } else if (treeItem.childrens || treeItem.childrens > 0) {
        treeItem.childrens.forEach((child) => {
          getItem(child, targetData);
        });
      }
    };
    const delTab = (items) => {
      Message.confirm("\u786E\u5B9A\u8981\u5220\u9664\u8FD9\u4E2A\u6743\u9650\u5417?", "\u63D0\u793A", {
        confirmButtonText: "\u786E\u5B9A",
        cancelButtonText: "\u53D6\u6D88",
        type: "warning"
      }).then(() => {
        if (items.permissionId) {
          urlAxios.post({
            url: "jd",
            data: {
              cmd: "CLIENT_M_COMMON_SECURITYGROUP_REMOVE",
              id: setting.resourceId,
              securityList: items.permissionId,
              permissionType: setting.permissionType
            }
          }).then(function(r) {
            if (r.result == "ok") {
              Message.message({
                message: "\u5220\u9664\u6210\u529F",
                type: "success"
              });
              acLists.value.forEach((item) => {
                item.acList.forEach((item1, index1) => {
                  if (item1.id == items.id) {
                    item.acList.splice(index1, 1);
                    item1.disabled = false;
                  }
                  if (items.id == item1.id) {
                    item1.disabled = false;
                  }
                });
              });
              if (treeList.value.length > 0) {
                treeList.value.forEach((li) => {
                  if (getItem(li, items))
                    return;
                });
              }
              showBottom();
            }
          });
        } else {
          urlAxios.post({
            url: "jd",
            data: {
              cmd: "CLIENT_COMMON_AC_REMOVE",
              accessMode: 0,
              invoke: invoke.value,
              acId: items.id,
              sid: setting.sid
            }
          }).then(function(r) {
            if (r.result == "ok") {
              Message.message({
                message: "\u5220\u9664\u6210\u529F",
                type: "success"
              });
              acLists.value.forEach((item, index2) => {
                item.acList.forEach((item1, index1) => {
                  if (item1.id == items.id) {
                    item.acList.splice(index1, 1);
                  }
                });
              });
              showBottom();
            }
          });
        }
      }).catch(() => {
      });
    };
    const showBottom = () => {
      let isShow2 = false;
      acLists.value.forEach((item) => {
        if (item.acList.length > 0) {
          isShow2 = true;
          return;
        }
      });
      if (!isShow2) {
        isShowBottom.value = true;
      }
    };
    const searchTab = () => {
      isSearch.value = true;
      $this.$refs.selector.focus();
    };
    const searchBack = () => {
      values.value.length = 0;
      isSearch.value = false;
      options2.value = [];
      if (treeKey.value.getCheckedKeys().length == 0) {
        isShowCheck.value = false;
        isPermission.value = false;
      }
    };
    const closeTab = () => {
      isShow.value = false;
      isPermission.value = false;
      isShowCheck.value = false;
      values.value.length = 0;
      options2.value.length = 0;
    };
    const blurTab = (status) => {
      if (!status) {
        options2.value = [];
      }
    };
    const selectChange = () => {
      if (permissionChecked.value) {
        if (acTypeList.value.length == 1) {
          isPermission.value = true;
        }
      } else {
        isShowCheck.value = true;
      }
      if (acTypeList.value.length == 1) {
        checkedList.value[0] = acTypeList.value[0].label;
        isAdd.value = true;
        changetab(acTypeList.value[0]);
      }
      if (values.value.length <= 0) {
        isShowCheck.value = false;
        isPermission.value = false;
      }
    };
    const removeTag = () => {
      if (values.value.length <= 0) {
        isShowCheck.value = false;
      }
    };
    const diaCancel = (show) => {
      isUpgradeService.value = show;
    };
    const handleClose = () => {
      closeTab();
    };
    return {
      isButton,
      treeList,
      isUpgradeService,
      newArr,
      isShow,
      urlAxios,
      defaultProps: defaultProps2,
      checked,
      acTypeList,
      isShowCheck,
      isShowDetail,
      isPermission,
      isShowBottom,
      checkedList,
      acLists,
      idx,
      options: options2,
      values,
      list,
      loading,
      states,
      isSearch,
      defaultExpandKeys,
      currentNodeKey,
      iconJSON,
      isChecked,
      upgradeServiceData,
      permissionAcTypeName,
      permissionChecked,
      imgUrl,
      setRef,
      getTreelist,
      checkChange,
      checkTab,
      tabClick,
      changetab,
      buttonTab,
      loadNode,
      searchTab,
      searchBack,
      remoteMethod,
      closeTab,
      blurTab,
      selectChange,
      removeTag,
      delTab,
      diaCancel,
      handleClose
    };
  }
});
const _withScopeId = (n) => (pushScopeId("data-v-f8c79174"), n = n(), popScopeId(), n);
const _hoisted_1 = { id: "awsui-dialog" };
const _hoisted_2 = { class: "mainDiv" };
const _hoisted_3 = { class: "selectWarp" };
const _hoisted_4 = ["innerHTML"];
const _hoisted_5 = { class: "option-label" };
const _hoisted_6 = { class: "nav_tab" };
const _hoisted_7 = { class: "nav_tab_left" };
const _hoisted_8 = ["onClick"];
const _hoisted_9 = { class: "main_content" };
const _hoisted_10 = { class: "detailData" };
const _hoisted_11 = ["innerHTML"];
const _hoisted_12 = { class: "detailData-item" };
const _hoisted_13 = { class: "desc" };
const _hoisted_14 = { class: "rangeDiv" };
const _hoisted_15 = {
  key: 0,
  class: "nav_tab-two"
};
const _hoisted_16 = {
  key: 1,
  class: "nav_tab-two"
};
const _hoisted_17 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("i", { class: "awsui-iconfont" }, "\uE8B4", -1));
const _hoisted_18 = /* @__PURE__ */ createTextVNode(" \u6DFB\u52A0\u5DE6\u4FA7\u9009\u4E2D\u7684\u8303\u56F4 ");
const _hoisted_19 = [
  _hoisted_17,
  _hoisted_18
];
const _hoisted_20 = {
  key: 2,
  class: "nav_tab-two"
};
const _hoisted_21 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("i", { class: "awsui-iconfont" }, "\uE8B4", -1));
const _hoisted_22 = /* @__PURE__ */ createTextVNode(" \u6388\u6743\u5DE6\u4FA7\u9009\u4E2D\u7684\u6743\u9650\u7EC4 ");
const _hoisted_23 = [
  _hoisted_21,
  _hoisted_22
];
const _hoisted_24 = {
  key: 3,
  class: "awsui-dialog-right"
};
const _hoisted_25 = { class: "dialog-right-item" };
const _hoisted_26 = { class: "button-tip" };
const _hoisted_27 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", null, "\u8BF7\u52FE\u9009\u4E0A\u9762\u7684\u6743\u9650", -1));
const _hoisted_28 = /* @__PURE__ */ createTextVNode(" \u6DFB\u52A0 ");
const _hoisted_29 = /* @__PURE__ */ createTextVNode(" \u6DFB\u52A0 ");
const _hoisted_30 = {
  key: 4,
  class: "awsui-dialog-right"
};
const _hoisted_31 = { class: "dialog-right-item" };
const _hoisted_32 = { class: "button-tip" };
const _hoisted_33 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", null, "\u8BF7\u52FE\u9009\u4E0A\u9762\u7684\u6743\u9650", -1));
const _hoisted_34 = /* @__PURE__ */ createTextVNode(" \u6DFB\u52A0 ");
const _hoisted_35 = /* @__PURE__ */ createTextVNode(" \u6DFB\u52A0 ");
const _hoisted_36 = {
  key: 5,
  class: "rangeBottom"
};
const _hoisted_37 = { class: "emptyAC" };
const _hoisted_38 = ["src"];
const _hoisted_39 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("p", null, "\u8FD8\u6CA1\u6709\u8BBE\u7F6E\u8BBF\u95EE\u8303\u56F4", -1));
const _hoisted_40 = { class: "rangeDetail" };
const _hoisted_41 = { key: 0 };
const _hoisted_42 = { class: "detailMain" };
const _hoisted_43 = ["innerHTML"];
const _hoisted_44 = ["innerHTML"];
const _hoisted_45 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("i", { class: "awsui-iconfont hover" }, " \uE626 ", -1));
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = resolveComponent("el-option");
  const _component_el_select = resolveComponent("el-select");
  const _component_el_tree = resolveComponent("el-tree");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_awsui_checkbox = resolveComponent("awsui-checkbox");
  const _component_awsui_button = resolveComponent("awsui-button");
  const _component_awsui_dialog = resolveComponent("awsui-dialog");
  const _component_upgrade_service = resolveComponent("upgrade-service");
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createCommentVNode('    :modal="true"'),
    createCommentVNode('    :close-on-click-modal="false"'),
    createCommentVNode(`    :height="setting.height+'px'"`),
    createVNode(_component_awsui_dialog, {
      modelValue: _ctx.isShow,
      "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.isShow = $event),
      width: _ctx.setting.width + "px",
      modal: true,
      title: _ctx.setting.title,
      height: "80%",
      class: "ac-address-dialog",
      "before-close": _ctx.handleClose
    }, {
      default: withCtx(() => [
        createCommentVNode('      :close-on-click-modal="false"'),
        createCommentVNode('      <h2 class="dlg-title">{{ setting.title }}</h2>'),
        createElementVNode("div", {
          class: "dlg-warp",
          style: normalizeStyle({ "min-width": _ctx.setting.width ? _ctx.setting.width - 60 + "px" : "1240px" })
        }, [
          createElementVNode("div", _hoisted_2, [
            withDirectives(createElementVNode("div", _hoisted_3, [
              createVNode(_component_el_select, {
                modelValue: _ctx.values,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.values = $event),
                multiple: "",
                filterable: true,
                remote: true,
                "reserve-keyword": false,
                "popper-append-to-body": false,
                "default-first-option": true,
                "remote-method": _ctx.remoteMethod,
                loading: _ctx.loading,
                "no-match-text": "\u6682\u65E0\u6570\u636E",
                "no-data-text": "\u6682\u65E0\u6570\u636E",
                onVisibleChange: _ctx.blurTab,
                onChange: _ctx.selectChange,
                onRemoveTag: _ctx.removeTag,
                placeholder: "\u8BF7\u8F93\u5165\u67E5\u8BE2\u6761\u4EF6",
                ref: "selector"
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (item) => {
                    return openBlock(), createBlock(_component_el_option, {
                      key: item.value.item.id,
                      label: item.label,
                      value: item.value.item.id
                    }, {
                      default: withCtx(() => [
                        createElementVNode("i", {
                          class: "awsui-iconfont hover",
                          innerHTML: _ctx.iconJSON[item.value.item.type],
                          style: normalizeStyle(item.value.item.type === "role" && item.value.item.roleType === 1 ? "color:#008ed5;" : "")
                        }, null, 12, _hoisted_4),
                        createCommentVNode('                <span slot="empty"></span>'),
                        createElementVNode("span", {
                          class: "option-data",
                          style: normalizeStyle({ "max-width": _ctx.setting.width ? (_ctx.setting.width - 60) * 0.6 - 100 + "px" : "694px" })
                        }, [
                          createElementVNode("span", {
                            ref: "option-item",
                            class: "option-item"
                          }, toDisplayString(item.label), 513),
                          createElementVNode("span", _hoisted_5, toDisplayString(item.text), 1)
                        ], 4)
                      ]),
                      _: 2
                    }, 1032, ["label", "value"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "remote-method", "loading", "onVisibleChange", "onChange", "onRemoveTag"]),
              createElementVNode("i", {
                class: "awsui-iconfont hover",
                onClick: _cache[1] || (_cache[1] = (...args) => _ctx.searchBack && _ctx.searchBack(...args))
              }, "\uE6FA")
            ], 512), [
              [vShow, _ctx.isSearch]
            ]),
            createElementVNode("div", _hoisted_6, [
              createElementVNode("div", _hoisted_7, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.newArr, (item, index2) => {
                  return openBlock(), createElementBlock("p", {
                    class: normalizeClass(_ctx.idx == index2 ? "active" : ""),
                    onClick: ($event) => _ctx.tabClick(item, index2),
                    key: index2
                  }, toDisplayString(item.label), 11, _hoisted_8);
                }), 128))
              ]),
              createElementVNode("i", {
                class: "awsui-iconfont hover",
                onClick: _cache[2] || (_cache[2] = (...args) => _ctx.searchTab && _ctx.searchTab(...args))
              }, "\uE6E9")
            ]),
            createVNode(_component_el_scrollbar, null, {
              default: withCtx(() => [
                createElementVNode("div", _hoisted_9, [
                  createVNode(_component_el_tree, {
                    data: _ctx.treeList,
                    ref: _ctx.setRef,
                    "show-checkbox": true,
                    "node-key": "id",
                    props: _ctx.defaultProps,
                    "check-strictly": true,
                    "check-on-click-node": true,
                    "current-node-key": _ctx.currentNodeKey,
                    load: _ctx.loadNode,
                    "empty-text": "\u6682\u65E0\u6570\u636E",
                    lazy: "",
                    "default-expanded-keys": _ctx.defaultExpandKeys,
                    onCheckChange: _ctx.checkChange,
                    onCheck: _ctx.checkTab
                  }, {
                    default: withCtx(({ data }) => [
                      createElementVNode("span", _hoisted_10, [
                        createElementVNode("i", {
                          class: "awsui-iconfont hover",
                          innerHTML: data.iconFont.code ? data.iconFont.code : data.iconFont,
                          style: normalizeStyle({ color: data.type == "role" ? data.iconFont.color : "" })
                        }, null, 12, _hoisted_11),
                        createElementVNode("span", _hoisted_12, [
                          createTextVNode(toDisplayString(data.name) + " ", 1),
                          createElementVNode("span", _hoisted_13, toDisplayString(data.desc), 1)
                        ])
                      ])
                    ]),
                    _: 1
                  }, 8, ["data", "props", "current-node-key", "load", "default-expanded-keys", "onCheckChange", "onCheck"]),
                  createCommentVNode("            <awsui-tree"),
                  createCommentVNode('                :data="treeList"'),
                  createCommentVNode("                show-checkbox"),
                  createCommentVNode('                node-key="id"'),
                  createCommentVNode('                :props="defaultProps"'),
                  createCommentVNode('                :check-strictly="true"'),
                  createCommentVNode('                :load="loadNode"'),
                  createCommentVNode("                lazy"),
                  createCommentVNode('                @check-change="checkChange"'),
                  createCommentVNode('                node-click="nodeClick"'),
                  createCommentVNode("            >"),
                  createCommentVNode("            </awsui-tree>")
                ])
              ]),
              _: 1
            })
          ]),
          createElementVNode("div", _hoisted_14, [
            !_ctx.isShowCheck && !_ctx.isPermission ? (openBlock(), createElementBlock("div", _hoisted_15, " \u8BBF\u95EE\u8303\u56F4 ")) : createCommentVNode("v-if", true),
            _ctx.isShowCheck ? (openBlock(), createElementBlock("div", _hoisted_16, _hoisted_19)) : createCommentVNode("v-if", true),
            _ctx.isPermission ? (openBlock(), createElementBlock("div", _hoisted_20, _hoisted_23)) : createCommentVNode("v-if", true),
            _ctx.isShowCheck ? (openBlock(), createElementBlock("div", _hoisted_24, [
              createElementVNode("div", _hoisted_25, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.acTypeList, (item, index2) => {
                  return openBlock(), createBlock(_component_awsui_checkbox, {
                    modelValue: _ctx.checkedList,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.checkedList = $event),
                    onChange: ($event) => _ctx.changetab(item),
                    label: item.label,
                    key: index2
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.setting.permissionType == "dw" ? _ctx.permissionAcTypeName : item.label), 1)
                    ]),
                    _: 2
                  }, 1032, ["modelValue", "onChange", "label"]);
                }), 128))
              ]),
              createElementVNode("div", _hoisted_26, [
                _hoisted_27,
                createElementVNode("span", null, [
                  _ctx.checkedList.length > 0 ? (openBlock(), createBlock(_component_awsui_button, {
                    key: 0,
                    type: "primary",
                    onClick: _ctx.buttonTab
                  }, {
                    default: withCtx(() => [
                      _hoisted_28
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : (openBlock(), createBlock(_component_awsui_button, {
                    key: 1,
                    disabled: ""
                  }, {
                    default: withCtx(() => [
                      _hoisted_29
                    ]),
                    _: 1
                  }))
                ])
              ])
            ])) : createCommentVNode("v-if", true),
            _ctx.isPermission ? (openBlock(), createElementBlock("div", _hoisted_30, [
              createElementVNode("div", _hoisted_31, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.acTypeList, (item, index2) => {
                  return openBlock(), createBlock(_component_awsui_checkbox, {
                    modelValue: _ctx.permissionChecked,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.permissionChecked = $event),
                    disabled: _ctx.permissionChecked,
                    onChange: ($event) => _ctx.changetab(item),
                    label: item.label,
                    key: index2
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.permissionAcTypeName), 1)
                    ]),
                    _: 2
                  }, 1032, ["modelValue", "disabled", "onChange", "label"]);
                }), 128))
              ]),
              createElementVNode("div", _hoisted_32, [
                _hoisted_33,
                createElementVNode("span", null, [
                  _ctx.permissionChecked ? (openBlock(), createBlock(_component_awsui_button, {
                    key: 0,
                    type: "primary",
                    onClick: _ctx.buttonTab
                  }, {
                    default: withCtx(() => [
                      _hoisted_34
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : (openBlock(), createBlock(_component_awsui_button, {
                    key: 1,
                    disabled: ""
                  }, {
                    default: withCtx(() => [
                      _hoisted_35
                    ]),
                    _: 1
                  }))
                ])
              ])
            ])) : createCommentVNode("v-if", true),
            _ctx.isShowBottom ? (openBlock(), createElementBlock("div", _hoisted_36, [
              createElementVNode("div", _hoisted_37, [
                createElementVNode("img", { src: _ctx.imgUrl }, null, 8, _hoisted_38),
                _hoisted_39
              ])
            ])) : createCommentVNode("v-if", true),
            createVNode(_component_el_scrollbar, null, {
              default: withCtx(() => [
                createElementVNode("div", _hoisted_40, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.acLists, (item, index2) => {
                    return openBlock(), createElementBlock("div", {
                      class: "detailWarp",
                      key: index2
                    }, [
                      item.acList.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_41, toDisplayString(_ctx.setting.permissionType == "dw" ? _ctx.permissionAcTypeName : item.acTypeName), 1)) : createCommentVNode("v-if", true),
                      createElementVNode("ul", _hoisted_42, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(item.acList, (item1, index1) => {
                          return openBlock(), createElementBlock("li", { key: index1 }, [
                            createElementVNode("i", {
                              class: "awsui-iconfont hover",
                              innerHTML: item1.icon,
                              style: normalizeStyle("color:" + item1.color)
                            }, null, 12, _hoisted_43),
                            createElementVNode("span", {
                              class: "detail-center",
                              innerHTML: item1.label
                            }, null, 8, _hoisted_44),
                            createVNode(_component_awsui_button, {
                              type: "text",
                              onClick: ($event) => _ctx.delTab(item1, index1)
                            }, {
                              default: withCtx(() => [
                                _hoisted_45
                              ]),
                              _: 2
                            }, 1032, ["onClick"])
                          ]);
                        }), 128))
                      ])
                    ]);
                  }), 128))
                ])
              ]),
              _: 1
            })
          ])
        ], 4),
        createCommentVNode("      <template #footer>"),
        createCommentVNode('&lt;!&ndash;        <div class="dlg-button">&ndash;&gt;'),
        createCommentVNode("          &lt;!&ndash;        <button>\u5173\u95ED</button>&ndash;&gt;"),
        createCommentVNode('          <awsui-button @click="closeTab">\u5173\u95ED</awsui-button>'),
        createCommentVNode("&lt;!&ndash;        </div>&ndash;&gt;"),
        createCommentVNode("      </template>")
      ]),
      _: 1
    }, 8, ["modelValue", "width", "title", "before-close"]),
    createVNode(_component_upgrade_service, {
      upgradeService: _ctx.isUpgradeService,
      globalProperties: _ctx.globalProperties,
      upgradeServiceData: _ctx.upgradeServiceData,
      onDiaCancel: _ctx.diaCancel
    }, null, 8, ["upgradeService", "globalProperties", "upgradeServiceData", "onDiaCancel"])
  ]);
}
var acAddress = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-f8c79174"]]);
const vmObj = {
  vm: null
};
const visible = ref(false);
const propsOptions = reactive({
  sid: "",
  width: 700,
  resourceId: "",
  resourceType: "",
  title: "",
  permissionType: "",
  groupType: "",
  accessModeScope: "",
  isRestrict: false,
  callback: (acList) => {
    console.log(22);
  }
});
let globalProperties = null;
const openAc = (options2) => {
  var _a;
  console.log(globalProperties);
  if (vmObj.vm == null) {
    const renderTest = defineComponent({
      render() {
        return h(acAddress, {
          setting: propsOptions,
          dialogVisible: visible.value,
          globalProperties,
          "onUpdate:dialogVisible": (value2) => {
            visible.value = value2;
          }
        });
      },
      setup(props2, context) {
        visible.value = false;
        return {
          visible
        };
      }
    });
    vmObj.vm = createVNode(renderTest);
    render$Z(vmObj.vm, document.createElement("div"));
    document.getElementsByTagName("body")[0].appendChild((_a = vmObj.vm) == null ? void 0 : _a.el);
  }
  Object.assign(propsOptions, options2);
  visible.value = true;
};
const closeAc = () => {
  if (visible.value) {
    visible.value = false;
  }
};
var AcAddress = {
  install: (app) => {
    globalProperties = app.config.globalProperties;
    app.config.globalProperties.AWSUI = {
      openAc,
      closeAc
    };
  },
  openAc,
  closeAc,
  acAddress
};
upgradeService.install = (app) => {
  app.component(upgradeService.name, upgradeService);
};
const defaultInstallOpt = {
  size: "mini",
  zIndex: 2e3
};
const CodeMirror$1 = window.CodeMirror || CodeMirror$3;
const AWSPageContext = {
  isDingDingDaRuntime: tools$1.tools.getConstByName("isDingDingDaRuntime", false),
  devUserInfo: tools$1.tools.getConstByName("devUserInfo", null),
  formulaLabelMap: tools$1.tools.getConstByName("formulaLabelMap", {}),
  settingParam: tools$1.tools.getConstByName("settingParam", {}),
  axiosBaseUrl: tools$1.tools.getConstByName("axiosBaseUrl", "./"),
  production: tools$1.tools.getConstByName("production", true),
  iconfontMap: tools$1.tools.getConstByName("iconfontMap", {})
};
axios.config(AWSPageContext);
const components = [
  HelloWorld,
  deploy,
  AwsuiCodemirror,
  Form,
  iframe,
  AwsuiCascader,
  AwsuiFormItem,
  AwsuiLayout,
  AwsuiFooter,
  AwsuiHeader,
  AwsuiMain,
  AwsuiAside,
  AwsuiCol,
  AwsuiRow,
  AwsuiSwitch,
  input,
  PopListDom,
  richMenu,
  tabMenu,
  CustomMenu,
  itemMenu,
  scrollBar,
  AwsuiSelect$1,
  AwsuiButton,
  AwsuiButtonGroup,
  AwsuiSelect,
  AwsuiDialog,
  sidebar,
  AwsuiUploadImage,
  AwsuiCheckbox,
  AwsuiPopover,
  AwsuiIconPicker,
  AwsuiTree,
  AwsuiDownSelectItem,
  AwsuiDownSelect,
  AwsAppInfo,
  AwsAppSelect,
  AwsuiCodeHelper,
  AwsuiFormula,
  AwsuiAddress,
  upgradeService
];
const install = (app, opt) => {
  const option2 = Object.assign(defaultInstallOpt, opt);
  app.config.globalProperties.$ELEMENT = option2;
  setConfig(option2);
  app.use(ElementUI);
  components.forEach((component2) => {
    app.component(component2.name, component2);
  });
  app.use(AcAddress);
  tools$1.install(app);
  if (typeof window != "undefined") {
    window.CodeMirror = CodeMirror$1;
  }
  app.config.globalProperties.awsuiaxios = axios;
  app.config.globalProperties.AWSPageContext = AWSPageContext;
  app.config.globalProperties.$message = Message.message;
  app.config.globalProperties.$message.success = Message.messageSuccess;
  app.config.globalProperties.$message.warning = Message.messageWarning;
  app.config.globalProperties.$message.error = Message.messageError;
  app.config.globalProperties.$messageObject = Message.messageObject;
  app.config.globalProperties.$msgbox = Message.msgbox;
  app.config.globalProperties.$alert = Message.alert;
  app.config.globalProperties.$confirm = Message.confirm;
  app.config.globalProperties.$prompt = Message.prompt;
};
var index = {
  HelloWorld,
  CodeMirror: CodeMirror$1,
  AwsuiCodemirror,
  install,
  ElementUI,
  tools: tools$1,
  getSid,
  axios
};
export { AwsuiCodemirror, formulaData as AwsuiFormulaDialog, CodeMirror$1 as CodeMirror, ElementUI, axios, index as default, getSid, install, tools$1 as tools };
